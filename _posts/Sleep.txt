자, 이제 이어서 이번 시간에는 락을 구현할 때 두번째 방법이라고 하긴 뭐하고 대기를 하는 두번째 방법인 소위 랜덤 메타에 대해서 알아보도록 할 건데요 사실은 지난 시간에 우리가 거의 대부분의 기능을 구현했기 때문에 오늘 할 것은 굉장히 단순합니다 그냥 슬립 계열의 함수 하나만 뿅 호출하면 , 사실, 그게 끝이긴 해요 , 자, 그런데 이 슬립을 한다는 것 자체가 이제 운영체제의 스케줄링이랑 또 밀접한 관련이 있기 때문에 이거에 대해서만 몇 가지만 , 일단은, 언급을 해야 될 것 같아 가지고 다시 ppt로 돌아왔습니다 , 자, 그래서 이제 두 번째 상황 같은 경우에는 화장실에 누군가가 있다고 가정을 할 때 거기 앞에서 계속 서성이면서 무한으로 대기를 하는 게 아니라 일단 자리로 돌아온 다음에 일정 시간을 기다렸다가 다시 이제 화장실로 가는 그런 케이스를 얘기를 하고 있는 거죠 정말로 운빨에 모든 걸 맡기고 있는 겁니다 내가 만약에 자리로 되돌아가는 순간에 하필이면 안에 화장실에 있던 사람이 나오고 또 다른 사람이 화장실을 점유한다고 하면은 굉장히 슬픈 얘기지만 간발의 차이로 내가 화장실을 소유할 수 있는 그 기회를 이제 놓치게 된다고 보시면 되겠어요 , 자, 그런데 이제 요 부분에 대해서 , 사실, 조금만 좀 더 언급을 드릴 것이 있는데 어 이건 , 사실, 이제 운영체제를 공부를 하면 계속 나오는 얘기이긴 합니다 이제 스케줄링 이라는 개념이 들어가게 되는데요 , 자, 제가 뭐 이건 몇 번 반복해서 언급을 드리고 있지만 결국에는 우리가 식당을 운영할 때 이런 직원들이 있고 직원을 움직이기 위해서는 이 영원이 빙이 해가지고 그 직원을 움직인다고 했었죠 사실상 이게 우리가 CPU 코어라고 했었고 이게 하나의 스레드라고 했습니다 , 자, 그리고 여기서 또 굉장히 흥미로운 사실은 만약에 우리가 코어가 하나밖에 없었다고 가정을 해볼게요 그러면 지금 , 이렇게, 프로그램이 지금 3개가 실행이 되고 있고 스레드는 지금 4개가 , 이렇게, 켜져 있는 상태인데 그런데 여기 위에 부분이 이제 유저 레벨이라고 하고 아랫부분이 커널 영역이라고 우리가 얘기를 합니다 커널 영역이라 하면 운영체제를 돌리기 위해서 필요한 그 중요한 일단 코드들이 다 들어가 있다고 보시면 되겠어요 말 그대로 윈도우즈 핵심적인 그런 프로그램들을 실행하기 위해서 요 커널 모드로 , 일단은, 돌아와야 된다고 보시면 되겠습니다 얘기지 어떻게 보면은 관리자 모드라고 볼 수가 있는 거죠 그런데 결국에는 어떤 코드가 실행이 된다는 것은 그 실행하는 주체가 CPU가 되겠죠 CPU가 해당 코드를 실행해서 그 코드가 돌아가야 되는데 여기 있는 아래 있는 커널 레벨에 있는 그런 코드들도 마찬가지로 이 CPU가 결국에는 빙의를 해가지고 그 스레드를 돌리는 것과 마찬가지로 , 이렇게, 유저 레벨에 있는 다른 스레드에 빙의해서 돌리는 것과 마찬가지로 결국엔 이 커널 모드에 있는 이 코드도 CPU가 전류를 해서 돌려야 된다는 얘기가 되겠습니다 , 자, 이 얘기가 왜 나오냐면은 , 사실, 오늘 계속 얘기하고 있는 이 슬립을 한다는 것 자체가 어떤 의미를 갖고 있는지를 이제 부연 설명을 드리고자 하는 건데요 커널이 하고 있는 굉장히 중요한 그런 기능들은 굉장히 많지만 그 중에서 운영체제가 또 중요하게 생각해야 될 것이 스케줄링이라는 개념이 있습니다 그게 뭐 하는 거냐면은 지금 여기 유저 모드에서 실행되고 있는 프로그램이 여러 개가 있겠죠 그러니까 이 중에서 다음에 누구를 실행해야 될지를 얘가 어떤 알고리즘을 통해 가지고 골라줘야 됩니다 물론 이제 고르는 그 기준은 운영체제마다 그리고 정책마다 다르겠죠 이 프로그램의 중요도에 따라 가지고 어떤 특정 프로그램에 우선순위를 줄 수도 있을 것이고 그리고 지난번에 얘가 언제 최종적으로 실행이 되었는지도 이제 고려를 해가지고 어느 정도 공평하게 시간을 배분을 할 필요가 있을 겁니다 , 자, 그리고 만약에 여기 있는 어떤 직원의 빙의를 해가지고 여기 있는 직원이 지금 움직인다고 가정을 하면은 그러면 그 상황 자체에서는 커널코드가 지금 돌아가고 있지 않는 상태가 되겠죠 그렇다는 것은 결국에는 이 커널 모드에서 다음에 실행돼야 될 애를 골라주기 위해서는 여기 있는 실행권 자체를 다시 커널 쪽으로 넘겨줘야지만 그 코드가 실행이 되어서 다음은 누구누구가 실행이 되어야겠구나라는 걸 판단할 수가 있는 겁니다. , 자, 그래가지고 결론적으로 말씀을 드리면 일단 스케줄러가 , 이렇게, 어떤 프로그램을 딱 실행을 할 때 무한적으로 평생 실행하기도 된다는 그런 허락을 주는 게 아니라 타임 슬라이스라고 해가지고 너가 몇 초 동안 실행될 수 있어라는 어떻게 보면 실행권 같은 걸 , 이렇게, 준다고 보시면 되겠어요 일종의 쿠폰이죠 너는 이제 1초 동안 실행할 수 있어라는 걸 딱 시간을 정해 가지고 얘를 실행을 시킬 거고 얘는 그러면 얘가 정해준 그 타임 슬레이스라는 그 유효한 시간 내에서는 실행권을 , 일단은, 어느 정도 보장을 받는다고 보시면 되겠습니다 만약에 1초를 보장을 받았으면 1초 동안 얘가 뭔 짓거리를 하건 자기 마음이 되는 거고 그 1초를 최종적으로 다 소진했으면 자발적으로 다시 실행 소유권을 커널한테 넘겨주게 됩니다. 그래야지만 이어가지고 커널 코드가 실행이 되면서 커널이 다른 애들을 골라가지고 실행하는 그런 일련의 부분들이 실행이 되겠죠. 물론 여기 있는 타임 슬라이스를 무조건 100% 다 소진을 해야 하는 것도 아닙니다. 얘가 어떤 특정 상황에 따라 가지고 나는 더 이상 내가 받은 그 실행권을 다 쓸 필요가 없다고 하면은 알아서 스스로 포기해 가지고 반환을 하는 경우도 있을 것이고요 또 그게 아니라고 한다면 온갖 시스템콜을 많이 호출했을 때도 자발적으로 얘가 자기의 실행권을 일단 1차적으로 반환하는 셈이 됩니다 시스템콜이라는 용어가 이제 또 등장을 했는데 이 그림을 보시면 굉장히 잘 설명하고 있습니다 구글에서 몇 가지 이미지를 긁어왔는데 결국에는 여기가 유저 모드고 여기 아래가 커널 모드라고 가정을 하고 여기 이제 스레드들이 막 실행이 되다가 우리가 뭐 see out과 같은 콘솔에다가 뭔가 출력을 해주세요 라는 걸 만약에 우리가 실행을 한다고 하면은 지난번에도 말씀을 드린 적이 있지만 이건 유저 레벨에서 하드웨어를 제어하고 이런 개념이 아니기 때문에 무조건 커널 모드에다가 그걸 요청을 해야 됩니다 그래서 시스템 콜이라고 해서 커널에 요청을 보내는 함수들을 실행하면 커널 모드로 돌아와서 요청받은 것을 실행한 다음에 다시 스레드를 재생하는 형태로 동작을 하게 될 거에요. 그래서 이런 식으로 어떤 특정 API를 호출할 때 자발적으로 자신의 실행 소유권을 중도 포기하고 , 이렇게, 커널 모드로 돌아오는 경우도 있을 것이고 그게 아니라고 하면 우리가 명시적으로 sleep과 같은 일련의 계열들의 함수를 호출해도 이런 식으로 자기 실행권을 알아서 포기를 하게 됩니다. 결국에는 이 상황에서 결국에는 딱 봤을 때 이미 락을 다른 애가 잡고 있기 때문에 나는 여기서 별다르게 할 수 있는 것이 없다는 게 판별이 된다고 하면 맨 처음 경우처럼 스피드 락을 해가지고 계속 무한 루프를 돌면서 근성 있게 시도하는 방법도 괜찮겠지만 경우에 따라 가지고는 깔끔하게 한 번에 포기하는 것도 나쁘지 않겠죠 이 안에 있는 애가 진짜 안 나오겠다라는 생각이 들면 그냥 일단 내 자리로 돌아갔다가 나중에 다시 돌아오는 것도 합리적이기 때문에 이럴 때 자기가 처음에 받은 타임 슬라이스를 그냥 한 번에 쿨하게 포기를 하고 커널 모드로 일단 돌아가는 것도 방법이 될 겁니다 그 상황을 지금 얘기하고 있는 거예요 그리고 참고삼아서 오른쪽 그림도 한번 보면 도움이 될 것 같은데 이것도 굉장히 그림을 잘 만들어 놓으셨더라구요 어떤 분이 , 일단은, 여기 신규랑 종료는 무시하셔도 되고 어떤 프로그램이 실행이 될 때 즉 프로그램을 실행하는 단위가 쓰레드니까 쓰레드라고 생각하시면 되는건데 여기서 준비상태, 실행상태, 그리고 대기상태 , 이렇게, 3가지 상태가 있습니다 약간 삼각형 모양이죠 레디, 러닝, 그리고 블록킹 상태가 있는데 말그대로 실행하는 상태는 , 이렇게, CPU가 빙의해 가지고 요 스레드를 지금 움직이고 있는 요 실행 상태를 얘기를 하고 있는 거고 경우에 따라 가지고 내가 타임 슬라이스를 다 소진했다 내가 처음에 보장받은 내 모든 소유권을 다시 실행했다고 하면은 자발적으로 요렇게 컨택 스위칭을 일어나게 해 가지고 준비 상태로 , 일단은, 돌아올 수가 있습니다 그러면 나중에 CPU가 스케줄러를 보고 자기가 정한 알고리즘에 따라가지고 뭐 다른 애를 실행시킨건 아니면은 지금 현재 아예를 다시 실행시킨건 어찌 됐건 요렇게 이중에서 하나를 골라가지고 스레드를 실행을 해주게 될 거에요 그게 이제 준비해서 실행 상태로 넘어가는 요런 상태라고 보시면 되겠습니다 이게 어떻게 보면 신호등이라고 생각하시면 되겠어요 얘가 이제 노란불 얘가 파란불 그리고 얘가 빨간불이라고 보시면 되겠습니다 그 다음에 역시나 자발적으로 슬립을 한다거나 아니면 시스템 콜 같은 걸 호출하면은 , 이렇게, 대기 모드로 돌아왔다가 해당 요청이 끝나면은 다시 준비 상태가 되어 가지고 스케줄링에 의해 가지고 다시 이런 식으로 돌아올 수 있다는 얘기가 드는 거죠 그래서 이런 식으로 결국 프로그램이 실행 상태에서 대기상태와 준비상태로 왔다갔다갔다 하면서 내가 이제 진짜로 실행될 준비가 되었는지 안 되었는지를 판별해가지고 그걸 따라가지고 스케줄러가 정해준 다음에 이런 식으로 실행 소유권을 다시 , 이렇게, 줘가지고 쿠폰을 줘가지고 너는 이제 1초 동안 실행할 수 있어라는 걸 준다는 얘기가 되는 거죠 그래서 최종적으로 , 사실, 우리가 오늘 하는 거는 그냥 간단하게 슬립 계열의 그런 함수 하나만 뿅 호출하면 되는 거지만 그게 사실상 , 이렇게, 생각보다 복잡한 그런 근본적인 부분들이 , 사실, 개입을 하고 있다는 걸 이제 반드시 기억을 해주셔야 되겠습니다. , 사실, 서버 프로그래머는 다른 분야와는 다르게 , 이렇게, 운영체제라거나 다른 분야랑도 굉장히 엮여있는 부분이 많아가지고 그래가지고 실제로 서버 프로그램 면접을 볼 때는 이런식으로 컴퓨터 전공에 대해서 좀 더 많이 물어보는 편이라고 보시면 되겠어요 , 자, 그건 그렇고 결국에는 이제 실습을 다시 해보러 코드로 돌아갈 것인데 굉장히 허무할 정도로 굉장히 단순하긴 합니다 그래서 요 부분은 참고 삼아서 기억을 해주시고 실행 소유권을 포기한다라는 걸 이제 기억을 해주시면 되겠어요 , 자, 그래서 다시 , 일단은, 코드로 돌아왔구요. 지난 시간에 만든 코드에서 조금만 뭐 한 줄만 더 추가를 할 것인데 어 지난 시간에 만든 스피락을 유심히 살펴보면은 여기서 락을 하는 순간에 compareAndSwap 함수를 호출을 하고 있구요. 만약에 실패했을 때 이제 어떤 일을 할 것인지가 굉장히 중요한 건데 여기서는 실패를 했으면 그냥 무한 루프를 돌면서 계속 다시 시도를 하고 있습니다. 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 재차, 다 소진을 하는 그런 상태가 된다고 보시면 되겠습니다 그게 스핀 락의 특징이라고 볼 수 있는 거죠 물론 다른 애가 없어가지고 여기가 무한 루프로 하는 게 아니라 바로 성공했다면 좀 얘기가 다르죠 그럼 이제 굉장히 아름다운 상황인데 최악의 경우에는 굉장히 쓸데없이 이 무한 루프를 돌면서 CPU를 낭비할 수 있다는 게 스핀 락의 개념이었습니다 그럼 이제 오늘 추가할 거는 무엇이냐면 여기다가 사실상 한 줄만 더 추가를 하면 되는데요 이것도 옛날에는 이런식으로 슬립과 같이 운영체제에 따라가지고 이런 api 들이 몇 개가 있었습니다 근데 이것도 마찬가지로 C++11에서 여기 스레드가 추가가 되면서 이 라이브리가 추가가 되면서 얘네들도 이제 같이 공용된 C++코드로 관리할 수 있게 되었어요 어지간해서는 그 방법들을 똑같이 사용하는게 좋겠죠 이걸 어떻게 사용하면 되냐면은 디스 스레드라고 , 일단은, 친 다음에 여기서 뭐 일련의 함수들이 , 이렇게, 있는데요 슬립4 그리고 일드 , 이렇게, 두개를 , 일단은, 종종 사용합니다 어 슬립4는 말 그대로 언제까지 자라는 얘기가 되는 거니까 여기다가 일단 시간을 넣어 줘 가지고 그 시간 동안 얘가 실질적으로 다시 재스케줄링이 되지 않고 대기를 타다가 그 해당 시간이 끝나면은 어 이제 다시 스케줄링 대상이 되어 가지고 이 스레드가 다시 실행이 될 수 있다는 얘기가 되는 겁니다. 그래서 여기다가 이제 시간을 넣어주면 되는데 예를 들면은 sdchrono.ms 라고 해가지고 이런 식으로 시간을 넣어줄 수가 있어요. 예를 들면 100ms 동안 잠 잔 다음에 다시 깨어나가지고 이어서 실행을 해라 라고 한다면 뭐 이런 식으로 , 일단은, 작성을 할 수가 있다는 얘기가 되는 거죠. , 자, 그 다음에 똑같은 방법인데 이걸 , 이렇게, 입력을 하지 않고 이런식으로 MS를 이용해서 표현을 해도 됩니다 이게 좀 신기하죠? 얘를 타고가서 보면은 Operator로 , 이렇게, 정의가 되어가지고 아까랑 똑같은 표현을 , 이렇게, 할 수 있다는 걸 , 일단은, 알 수가 있습니다 , 이렇게, 하나 , 이렇게, 하나 , 일단은, 선택이 여부구요 , 자, 그 다음에 뭐 마찬가지로 디스 스레드에서 yield라는 함수기인데 yield가 이제 양보한다는 의미가 되는거죠 얘도 말그대로 자기가 어.. 받은 그 타임 슬라이스를 쿨하게 양보를 한 다음에 일단 커널 모드로 돌아가가지고 이제 알아서 스케줄링 해라라고 떠넘기는 셈이 되겠습니다 사실상 이 yield를 한다는 것은 이 슬립4를 호출할 때 0ms로 하는거랑 , 사실, 뭐 개념적으로 똑같다고 보시면 되겠어요 그니까 이 슬립4는 몇 초 동안 여기서 이제 입력한 이 일정 시간 동안 다시 재스케줄링이 되지 않는다라는 상황을 얘기를 하고 있는 거고 얘는 언제든지 다시 스케줄링이 될 수 있지만 기본적으로 현재는 필요 없기 때문에 현재 타임슬레이스는 필요 없기 때문에 일단 1차적으로 반환을 해주겠다라는 의미가 되는 겁니다 이 두 가지 중에 일단 하나를 골라서 사용을 해주시면 되겠어요 그리고 뭐 , 사실, 이게 정말 끝입니다 이런식으로 슬리프홀을 해가지고 중간에 끼워놓게 되면은 이제 엄밀히 말하면 스피락이라고 볼 수는 없는게 얘가 무한으로 와일루프를 돌면서 이제 유저 레벨에서 계속 뺑뺑이를 도는게 아니라 , 이렇게, 하다가 어 실패했네 라고 하면은 일단 커널 모드로 돌아가 가지고 자기가 실행받은 그 타임슬레스를 지금 포기하고 있다는 걸 알 수가 있는 겁니다 , 이렇게, 해가지고 , 일단은, 락을 구현을 할 때 스피드 락이 아니라 지금 기다리기 싫으면 일단 제자리로 돌아가 가지고 다시 오는 방법은 일단 , 이렇게, 구현을 할 수가 있는 거죠 사실상 지난번에도 얘기한 바와 같이 제가 얘기한 그 락에서 누군가가 있을 때 채택할 수 있는 세 가지 정책이라는 것 자체가 정말로 셋 중 하나만 선택해야 된다는 얘기가 아니고 이런 식으로 스피락을 몇 번씩 돌아 보다가 지금은 , 사실, 한 번만 돌고 바로 슬립을 하고 있지만 예를 들면 정책을 정해 가지고 5,000번 정도는 스피락처럼 계속 뺑뺑이를 돌면서 시도를 하다가 진짜 답이 없네 라고 싶으면 그제서야 이런 식으로 슬립을 해 가지고 잠시 자기가 받은 타임슬레이스를 반환하고 이런 식으로 일단 구현할 수 있다는 얘기가 되는 거죠 , 자, 이렇게, 해가지고 뭐 여기까지 , 사실, 별다른 의미는 없지만 똑같이 실행을 해보면은 뭐 마찬가지로 얘가 0이 나온다는 걸 볼 수가 있습니다 , 자, 이렇게, 0이 나오구요 그래서 , 사실, 요 방법 자체가 뭐 그렇게 어마어마하게 중요한 개념을 갖고 있다라는 건 아니지만 그럼에도 불구하고 이걸 실습한 이유는 이런 식으로 어 커널 모드로 돌아가는 것 자체가 어떻게 보면 컨택 스위칭을 유발을 하고 그리고 유저 모드에서 커널 레벨로 왔다 갔다 하는 그런 부분들이 들어간다고 일단 보시면 되는 것이기 때문에 나중에 혹시라도 컨텐츠 코드에서 로그를 찍는다 치고 막 이런 식으로 씨하우스를 남발하거나 하면 이게 똑같은 이유로 느려질 수 있다는 얘기가 되는 거죠 그래가지고 이제 앞으로 코드에서 굉장히 빠르게 동작해야 되는 그런 부분들에 대해서는 최대한 이런 식으로 시스템콜을 하는 부분들 즉 운영체제한테 뭔가를 요청하는 부분들은 최대한 자제를 해야 된다는 뭐 그런 얘기가 되겠습니다 이러면서 조금 차츰차츰 기본 지식을 늘려간다고 보시면 되겠어요 , 자, 이렇게, 해가지고 첫번째 방법에 이어가지고 두번째 방법도 간단하게 실습을 해봤고 그 다음에 이제 다음 시간에 마지막으로 이벤트를 사용하는 그런 방법에 대해서도 실습을 해보게 될 겁니다.