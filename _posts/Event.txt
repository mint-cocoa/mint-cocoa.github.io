이번 시간에는 이어서 이벤트를 이용한 동기화 방법에 대해서 알아보도록 할 건데요 지난 시간에 이제 계속 락을 구현을 할 때 사용하는 다양한 방법들에 대해서 알아보면서 겸사겸사 이벤트에 대해서 알아볼 것인데 , 사실, 이벤트라는 것 자체가 꼭 , 이렇게, 락에서만 뭔가 응용해 가지고 활용한다 이런 개념은 아니고 굉장히 이제 사용 범위가 넓다고 보시면 되겠습니다. 락과 더불어서 이벤트를 이용해 가지고 쓰레드를 동기화하는 그런 방법이 이제 종종 활용이 되기 때문에 어느 정도 중요성이 꽤 높은 그런 부분이라고 일단 보시면 되겠습니다 , 자, 근데 일단 이벤트가 나온 이유 자체가 우리가 지금 이 강의를 진행하면서 진행하다가 나온 이유가 결국에는 소위 갑질 메타라고 제가 한 직원한테 뭔가 부탁을 해가지고 직원이 우리를 중재를 해주는 그런 방식으로 이제 동작을 한다고 보시면 되겠어요 근데 여기서 말하는 직원이란 애가 , 사실, 지나가는 직원이 아니라 엄밀히 말하면 커널에 해당하는 겁니다 즉 관리자를 얘기하고 있는 거예요 그래서 우리가 유저 레벨에서 쓰레드끼리의 순서 보장에 대한 그런 결론이 나지 않다 보니까 이거를 그냥 관리자한테 쪼르르 가가지고 관리자가 우리 대신 뭔가 어... 순서 보장을 해달라고 , 사실, 요청을 하는 거라고 , 일단은, 볼 수가 있겠습니다 그래가지고 결국에는 관리자가 어떻게 보면 심판의 역할을 맡게 되는 건데 자세한 그런 내용은 이제 코드를 구현해 보면서 살펴보긴 할 건데 , 일단은, 이벤트를 만들... 이벤트라는 걸 사용하고 만들 때 C샵 기준으로는 우리가 이걸 알아봤을 때 오토 리셋 이벤트랑 매뉴얼 리셋 이벤트라고 두 가지의 클래스로 구분이 되어 있었는데 우리가 오늘 살펴볼 C++ 윈도우즈 API에서는 이 이벤트를 만들 때 인자를 어떻게 주냐에 따라서 이게 오토 리셋 이벤트가 될 수도 있고 매뉴얼 리셋 이벤트가 될 수가 있습니다 그래서 이벤트는 뭐 쉽게 말해 가지고 그냥 boolean 값이라고 생각을 하면 됩니다. 그냥 어떤 true, false 이 두가지 상태를 갖고 있는 그런 굉장히 단순한 그런 객체라고 일단 개념적으로 , 일단은, 생각을 할 수가 있겠어요. 그래가지고 문이 잠긴다 그리고 문이 열린다 이 두가지 상태를 갖고 있는 있는데 이거에 따라 가지고 이 상태에 따라 가지고 어떤 애가 계속 진행할 수 있는지 없는지를 이제 판별해 주게 될 겁니다 , 이렇게, 말로 하니까 조금 아리달성한데 코드를 보면 굉장히 단순한 기념이에요 , 자, 일단 그림으로 다시 한번 살펴보면 결국에는 이제 위에 있는 애들이 지금 뭔가 , 이렇게, 서로 순서를 정해야 되는 상황입니다 정확히 말하면은 여기 안에 이미 어떤 애가 있고 밖에 있는 애가 기다려야 되는 뭐 그런 상황이긴 한데 이 안에 있는 애가 언제 나올지 모르니까 얘가 계속 고지 곧대로 문 밖에서 기다리기도 뭐하고 해서 중재를 요청하는 거죠 그래가지고 식당 관리자한테 어 나는 , 일단은, 에라 모르겠고 내 자리로 돌아갈 테니까 진짜로 이 화장실이 비면은 깨워줘 라고 얘 입장에서 부탁을 하는 그런 상황이라고 보시면 되겠어요 그래가지고 지금 여기서 이벤트라는 걸 , 이렇게, 만들어 주는데 이벤트가 상태가 두가지 상태가 있습니다 하나는 여기서 마치 그 파란불 빨간불로 표현한 것 마냥 어 이 시그널이 꺼져 있는 상태 그리고 시그널이 켜져 있는 상태 , 이렇게, 두 가지 상태가 있어요 , 자, 그래서 이거를 이제 어떻게 응용할 것이냐면은 , 자, 일단은, 처음에 이벤트를 하나 만들고 시작을 할 겁니다 처음에 상태는 시그널이 꺼져 있는 상태에요 마치 이제 빨간불이 딱 켜져 있는 그런 상태라고 보시면 되겠습니다 요 상태에서 결국 이 오른쪽에 대기를 해야되는 직원이 그니까 직원이 아니라 대기를 해야되는 그 아이가 어 요 이벤트를 참고해가지고 나는 이제 이걸 이 상태를 봐가지고 이 상태가 파란불로 켜지면 나를 깨워달라고 부탁을 하면서 얘는 이제 잠들게 되는거죠 그럼 이제 식당 관리자가 어 요 이벤트를 관리를 하고 있으니까 얘가 이제 파란불로 뿅 켜지면 쪼로로 달려가서 요 아이를 이제 깨워주면 되겠습니다 굉장히 단순하죠 근데 이거를 이제 파란불로 키는거는 결국엔 누가 해주는 것이냐 이 왼쪽에 있는 애가 해주는 것이죠 왼쪽에 있던 애가 화장실을 빠져나가면서 자물쇠를 딱 풀어주는 그런 상황이 될 건데 이제는 결국에는 얘가 볼일을 다 봤다고 하면은 여기 있는 얘도 이제 똑같이 이벤트에 접근해가지고 요 애를 이제 시그널 상태로 바꿔주게 될 겁니다 그러면 이제는 얘가 파란불로 켜져가지고 얘가 파란불로 켜졌다고 하면 결국에는 , 이렇게, 이제 오른쪽에 대기타고 있던 애를 깨워가지고 다시 실행할 수 있게끔 만들어줄 수 있다는 얘기가 되는 겁니다 대충 이런 흐름이에요 다시 요약을 해보자면 결국에는 이 위에 있는 애들끼리 서로 중재가 안되다 보니까 그거를 아래 있는 관리자한테까지 요구를 해가지고 아래 있는 관리자가 이제 관리를 하게 되는 것이다 라는 것이고 얘가 이제 빨간불로 딱 꺼져 있을 때는 오른쪽에 있는 애는 더 이상 실행을 하지 않고 얘는 계속 잠들어 있는 상태라고 볼 수가 있는 거죠 결국에는 우리가 뭐 컨택스위칭에 대해서 얘기를 하면서 이 영혼이 주입이 돼서 빙의를 해야지만 얘가 이제 움직일 수 있다는 표현을 제가 썼는데 만약에 지금 이 이벤트가 , 이렇게, 빨간불로 딱 꺼져 있는 상태로 하면은 얘는 다시 실행이 되지 않고 계속 대기를 하는 상태가 될 겁니다 말 그대로 잠든 상태가 되는 거고 블록킹 상태가 되는 거고 나중에 이제 이벤트가 딱 , 이렇게, 시그널 상태로 바뀌어 가지고 파란 불 켜져 있을 때만 다시 얘를 깨워 가지고 움직이는 이런 상황이라고 보시면 되겠습니다 다시 뭐 생각을 해보면 장점이 뭐가 있는지 생각을 해보면 이 문 앞에서 그냥 하염없이 대기를 하면은 얘가 이제 굉장히 헛속으로 하면서 쓸데없는 에너지를 낭비할 수 있겠지만 이런식으로 제3자한테 요청을 해가지고 정말로 꼭 필요할 때만 자기를 깨워달라고 요청을 하면은 이제 그나마 쓸데없는 행동 없이 서로 효율적으로 이제 움직일 수 있게 되긴 하겠죠 하지만 단점이라고 한다면 결국에는 이 제3자인 이제 커널 모드로 돌아와 가지고 이런 추가적인 리소스가 들어가기 때문에 이거를 또 고지고때로 항상 남발할 수는 없을 것이고 , 이렇게, 어느 정도 대기를 해야 되는 상황이 확실하다고 할 때 이제 이 이벤트를 사용하면 굉장히 유용하다고 , 일단은, 볼 수가 있겠습니다 그래서 이거를 다시 코드로 돌아가 가지고 연구를 해보면서 진행을 다시 한번 해보도록 할게요 , 자, 이렇게, 해서 다시 일단 코드로 돌아왔구요 오늘 할 이벤트 실습은 일단 기존에 구현한 락을 대상으로 실습하는게 아니라 조금 더 일반적인 상황에서 실습을 해보고자 합니다 실제로 이벤트라는 것이 굉장히 다양한 상황에서 응용을 할 수가 있다고 했었죠. 그리고 결국에는 오늘 목적은 이벤트를 활용하고 뭐 연습하고 하는 것도 중요하긴 하지만 이 이벤트가 그냥 일반적인 스피락 같이 계속 무한정 트라이하는 방법에 비해서 어떠한 장점이 있는지를 확실히 숙지를 하는 게 조금 더 중요하다고 일단 보시면 되겠어요. 그래서 , 일단은, 오늘 테스트하기 위해서 윈도우즈 헤더를 , 일단은, 추가해 줄 겁니다. 이벤트를 사용하기 위해서 윈도우에서 자체적으로 제공하는 그런 api 들을 이용해서 테스트를 해볼 것이구요. , 자, 일단 상황은 요렇습니다. , 일단은, 뮤텍스를 하나를 요렇게 만들어 줄 것이고 그 다음에 뭐 공용 데이터를 관리하는 그런 큐를 하나를 만들어 주도록 할게요. , 자, 그 다음에 이거 프로... 한쪽 스레드에서는 뭔가 데이터를 계속 만들어줄 것이고 반대쪽 스레드에서는 얘가 밀어넣어준 데이터를 꺼내가지고 소모하는 그런 역할을 만들게 될 겁니다. 요런 상황이 이제 비일비재하게 등장하게 되겠죠. 한쪽에서는 예를 들면 클라이언트 쪽 데이터를 수신받아가지고 그걸 큐에다가 밀어넣고 다른 쪽 예를 들면 게임 컨텐츠를 관리하는 스레드에서 해당 패킷과 관련된 내용들을 추출해가지고 진행을 한다거나 하는 상황이 빈번하니까 그런 걸 가정하는 거죠. , 자, 그래서 무한 루프를 , 일단은, 돌 것이구요 그 다음에 뭐 어찌됐건 얘도 이제 공용으로 사용하는 큐를 건드리고 있는 거니까 여기다가 유닛 락을 이용해 가지고 류텍스를 락가드를 걸어 주도록 할게요 이런식으로 그 다음에 요런 느낌으로 데이터를 , 일단은, 아무 값이나 집어 넣도록 하겠습니다 , 자, 그 다음에 여기서 뭐 예를 들면은 슬리퍼 같은 걸 이용해 가지고 뭐 일정 시간 잠들 수도 있고 아닐 수도 있고 여기서 이제 좀 케바케로 달라지게 되겠죠 그래서 간단하게 이제 계속 데이터를 밀어 넣는 그런 작업을 하고 있는 거고 반대쪽에서는 그 데이터를 꺼내 쓸 겁니다 그래서 얘도 이제 무한 루프를 돌 것인데 얘도 어찌됐건 락가드를 걸어가주고 공용으로 사용하는 데이터를 건드릴 것이니까 락을 걸어주고 만약에 데이터가 있다 엠티가 false라고 한다면 뭔가 데이터를 잠시 꺼내가지고 여기서 뭔가를 해주게 되겠죠? 뭐 예를 들면 그냥 간단하게 테스트 해보기 위해서 뭐 , 이렇게, 씨하우스를 해주도록 하겠습니다 물론 락을 잡고 이런식으로 콘솔 출력을 하는게 뭐 좋은 습관은 아니지만 일단 간단하게 테스트를 하기 위해서 , 이렇게, 일단은, 만들어 보도록 할게요 , 자, 그러면 이제 메인에서는 어 스레드를 두개를 만들어 줄 것인데 하나는 말그대로 프로듀서의 역할을 맡게 될 것이고 그 다음에 컨트롤 D 복붙한 다음에 또 하나는 이제 컨슈머의 역할을 맡게 될 겁니다 소모하고 만들어주고 그 다음에 양쪽 스리드가 끝날 때까지 , 이렇게, 조인을 해가지고 그냥 기다려 주도록 할게요 , 자, 코드는 아직까지는 못하기 어려운 부분은 없구요 그 다음에 여기서 F5를 눌러 가지고 이제 실행을 해보면 , 자, 이런식으로 백백백백백이 0.1초마다 잘 실행이 되는 걸 볼 수가 있습니다 여기까지 뭐 딱히 문제가 있는 건 아닌데 , 자, 여기서 이제 한가지 아쉬운 점이 한가지가 있습니다 뭐냐면은 여기서 지금 데이터를 밀어넣는 애가 0.1초마다 규칙적으로 하고 있기는 하지만 만약에 그게 아니라 진짜 어쩌다가 한 번씩 데이터가 추가되는 상황이라고 가정해볼게요 얘가 이제 100ms가 아니라 진짜로 막 어마어마하게 큰 숫자가 될 수 있겠죠? 그러다 보면 얘는 뭐 거의 하루에 한 번씩 정말 가끔 가다가 데이터를 밀어넣는 작업을 하게 되겠지만 그걸 반대쪽 스레드에서는 그 개념을 지금 모르고 있기 때문에 결국에는 얘는 , 이렇게, 와일문을 계속 무한 루프를 돌면서 계속 체크를 해줄 수밖에 없습니다 게다가 심지어 여기 있는 부분 자체가 공용 데이터이기 때문에 여기서 락을 잡고 , 이렇게, 접근을 하고 있는 것까지도 조금 아쉽죠 그래가지고 만약에 결국에는 이 위에 있는 스레드에서 데이터를 실질적으로 안 넣어준다고 하면은 사실상 이 두 번째 스레드에서 하고 있는 여기 뺑뺑이를 돌면서 데이터가 있는지 없는지 체크하는 요 작업은 , 사실, 굳이 할 필요도 없는 인이어 작업이 된다는 얘기가 되겠습니다 그래가지고 실질적으로 이 부분에서 만약에 우리가 진짜로 데이터를 밀어넣는게 아니라 어마어마하게 늦게 데이터를 이런식으로 밀어넣는 상황이 있다고 가정을 하고 다시 실행을 해보면 , 사실, 코드가 버그가 일어난다고는 하는건 아니지만 실질적으로 여기 오른쪽에 진단도구에서 CPU 사용률을 보면 얘가 0은 아니고 꽤 그래도 뭐 여기 지금 8%로 잡히고 있는데 어찌됐건 뭔가 , 이렇게, CPU 점유율을 계속 차지하고 있다는 걸 알 수가 있습니다. CPU 점유율을 차지하고 있는 애는 바로 이 컨슈머 쪽 스레드에서 계속 루프를 돌면서 락을 잡고 얘를 이제 체크를 하기 때문이죠. 그러면 결국에는 아까 우리가 얘기한 그 화장실 상황에서도 마찬가지였지만 이런 식으로 안에 있는 사람이 진짜 뭘 어떻게 할지 모르는 상황에서 , 이렇게, 무작정 계속 트라이를 하는 이 근성 있는 방법이 가끔 가다가는 조금 안 좋을 수도 있다는 얘기가 되는 거죠 만약에 진짜로 여기 위에 있는 프로듀서가 진짜 어쩌다가 한 번씩 데이터를 밀어넣는다고 하면은 , 이렇게, 매번 체크하는 것보다는 뭔가 진짜로 데이터가 있을 때만 알려주세요 라는 방법을 채택하는 게 조금 더 좋을 수 있다는 얘기가 되는 거죠 , 자, 그래가지고 뭐 이거를 오늘 테스트하기 위해서 , 일단은, 어... 이벤트라는 걸 , 일단은, 간략하게 활용을 해볼 겁니다. 이제 이벤트가 어떻게 보면 요런 일련의 방식들에 가장 기초가 되는 그런 기법이라고 보시면 되겠어요. , 자, 그래서 , 일단은, createEvent라고 해가지고 이제 윈도우 API를 사용할 것인데 얘가 받아주는 인자가 , 일단은, 4개가 들어가 있습니다. 네 4개가 들어가 있는데 , 사실, 여기서 두번째랑 세 번째가 중요합니다. 특히나 이 두 번째가 가장 중요해요. 일단 첫 번째 갑 같은 경우에는 뭔가 보안 속성이랑 관련이 있는 건데 얘는 뭐 딱히 지금 단계에서 신경 쓸 필요는 없으니까 그냥 널로 넣어 줄 것이고 , 자, 매뉴얼 리셋 이라고 해가지고 이제 분류형 값을 , 이렇게, 받아주는데 이걸 우리가 수동으로 리셋을 해줄 것이냐 아니면 자동으로 리셋이 되게 만들어 줄 것이냐를 지금 얘기하고 있는 겁니다 만약에 매뉴얼 리셋을 우리가 트롤로 놓는다고 하면은 매뉴얼이라는게 수동이라는 의미니까 수동으로 리셋이 된다는 얘기가 되는 거고 그게 아니라 일반적인 상황에서 false를 놓는다고 하면은 이제 오토 리셋 방식의 이벤트로 동작을 하게 될 겁니다 그래서 이거는 Manual Reset 같은 경우에는 조금 있다가 얘를 바꿔보면서 실습을 하면 정확한 의미를 알게 될 것이고 그 다음에 여기서 Initial State라고 해가지고 이 이벤트의 초기 상태를 받아주게 됩니다. 얘가 true나 false 상태로 설정을 하면 signal 상태 혹은 non-signaled 그러니까 아까 얘기한 빨간불, 파란불 둘 중 하나로 , 일단은, 세팅을 해줄 수가 있는데 기본적으로 불을 꺼놓도록 하겠습니다. be initial state였고 마지막으로는 이름을 정해줄 수 있는데 얘는 필수적인 건 아니어서 그냥 이름 없이 null로 밀어주도록 할게요. 그럼 여기서 이제 createEvent라는 걸 호출을 하면은 얘는 어디까지나 여기 컨텐츠 단에서 유저 레벨에서 마음대로 얘를 처리할 수 있는 건 아니고 이 이벤트라는 것 자체가 커널 쪽에 가가지고 커널에서 만들어주는 그런 아이이기 때문에 실질적으로 이 이벤트를 커널 오브젝트라고도 표현을 합니다 그래서 얘가 이제 뱉어주는 걸 보면은 핸들이라는 걸 , 이렇게, 얘가 createEvent라는 함수가 뱉어주게 되는데 요 핸들은 실질적으로 그냥 우리가 사용하는 인트랑 마찬가지로 그냥 정수에 불과합니다 뭐 10, 20, 30 같은 그냥 숫자가 들어가 있는데 근데 그게 아무런 의미가 없는 그런 숫자는 아니고 일종의 번호표라고 생각하시면 되겠어요 얘가 10번이라는 그런 정수가 있는데 그거를 나중에 우리가 커널단에 뭔가 이 이벤트를 이용해 가지고 뭔가 작업을 하고 싶다고 할 때 그 10번 핸들에 해당하는 이벤트를 대상으로 무엇을 해주세요 라고 요 핸들을 같이 넘겨주게 될 거예요 그러니까 이제 이벤트가 꼭 하나만 있다는 보정은 없으니까 그 많은 이벤트 중에서 우리가 어떤 애를 의미를 하고 있는 건지를 요런 식으로 전달해주는 그런 구별하는 식별자라고 , 일단은, 부를 수가 있는 거죠 그래가지고 얘를 , 일단은, 요렇게 전역으로 핸들을 일단 전역으로 관리해가지고 여기 프로듀스랑 컨슈머 양쪽에서 활용할 수 있게끔 일단 요렇게 만들어 주도록 하겠습니다 그리고 뭐 일반적으로 이제 프로그램이 다 종료되었으면은 우리가 일반적으로 이제 New를 했던 그런 메모리를 Delete하는 것과 마찬가지로 얘도 짝을 맞춰가지고 Close Handle이라는 걸 호출해가지고 이 핸들을 이제 닫아주는 게 일단 좋습니다. 이게 좋은 습관이죠. , 이렇게, 뭐 그건 그렇고 결국에는 이제 여기서 이벤트가 딱 만들어졌는데 이벤트는 제가 이제 Kernel Object라는 표현을 사용했습니다. Kernel Object. Kernel Object는 커널에서 사용하는 오브젝트다 이거 말이 좀 말장난 같긴 한데 정말 정말 그게 다에요 그래서 이제 뭐 이런 이벤트뿐만 아니라 우리가 뭐 프로세스를 만들 때도 그렇고 어 아니면은 뭐 이제 다양한 커널에서 관리하는 그런 객체를 만들어 줄 때 커널 오브젝트라는게 생성이 되는데 그냥 커널에서 관리하는 그런 오브젝트다 커널에서 이 커널 오브젝트라는 걸 관리하기 위해서 뭔가 할당되는 일련의 메모리가 있는데 그거를 커널 오브젝트로 일단 생각하시면 되겠습니다. 그래서 기본적으로 커널 오브젝트에서 공통적으로 갖고 있는 속성이 여러 가지가 있는데 뭐 usageCount라고 해가지고 이 오브젝트를 몇 명이 사용하고 있는지 등등을 관리할 수 있을 것이고 그 다음에 signal이랑 일단 non-signal , 이렇게, 두 가지 상태를 갖고 있습니다. 얘가 이제 우리가 얘기한 빨간불이 될 것이고 얘가 우리가 얘기한 파란불이라고 일단 보시면 되겠어요 그래서 얘도 , 일단은, 그냥 관리하기 위해서 내부적으로 그냥 불리한 변수 하나를 둬가지고 얘가 꺼져있으면 빨간불, 켜져있으면 파란불로 , 이렇게, 두가지 상태를 , 일단은, 갖고 있다고 보시면 되겠어요 요 두가지 같은 경우는 일단 커널 옵젝트가 모두 공통적으로 갖고 있는 속성이고 거기다가 추가적으로 우리가 지금 이벤트를 사용하고 있으니까 여기서 자동모드인지 아니면 수동으로 다시 꺼지는 모드인지에 따라가지고 얘도 이런 식으로 추가적인 정보가 , 이렇게, 들어가 있겠죠 , 사실, 커널 옵젝트 중에서 이 이벤트는 굉장히 가벼운 편에 속하기 때문에 좀 부담 없이 , 일단은, 사용할 수 있다고 보시면 되겠습니다 물론 다른 애들에 비해서 상대적으로 가볍다는 얘기죠 , 자, 그래가지고 뭐 여기까지 일단 요런 정보를 갖고 있는데 우리가 어찌됐건 여기서 처음에 초기 상태를 false로 꺼놨으니까 non-signal 상태로 , 일단은, 꺼진 상태구요 그 다음에 이제 그러면 kernel 단계에서 어떻게 보면 일종의 오브젝트가 하나가 만들어져 가지고 상태를 관리하는 오브젝트가 있는데 그걸 이용해 가지고 우리가 동기화를 맞춰 주는 거죠 그러면은 위에 단계에서 예를 들면은 요게 지금 프로듀서 쪽에서 원래는 기존에는 요기다가 데이터를 밀어넣고 그냥 아무것도 안하고 있었지만 이제는 그게 아니라 요기다가 위에다가 setEvent라는 요런 함수를 호출해가지고 요기다가 핸들을 , 이렇게, 건네주도록 하겠습니다 그럼 얘가 뭘 하는 거냐면은 말 그대로 요 커널 오브젝트의 시그널 상태를 시그널 상태로 바꿔주세요 이 상태를 시그널 상태로 바꿔주세요 라고 하는 의미가 되는 겁니다 그러니까 이게 일종의 분류형 값이라고 했으면 그 분류형 값에 true를 대입하는 뭐 그런 느낌이라고 보시면 되겠어요 그래서 얘를 일단 딱 호출하는 순간 이제 이 해당 이벤트의 상태가 시그널 상태로 바꿔치기 된다라고 일단 보시면 되겠어요 그 다음에 그럼 컨슈머 쪽에서는 거꾸로 원래 우리가 하던 방식에서는 매번 마다 무한록도를 돌면서 계속 의미 없이 , 이렇게, 락을 걸면서 체크를 하고 있었는데 그게 아니라 얘도 마찬가지로 이런 식으로 waitForSingleObject라는 함수를 이용해가지고 , 일단은, 핸들을 넣어줄 것이고 대기시간을 여기다가 넣어줄 수 있는데 그냥 무한정 대기를 할 거면 infinite라는 이 키워드를 이용해가지고 , 사실, 얘가 마이너스 3죠 무한 대기를 하게끔 유도를 해줄겁니다 그럼 이제 뭐가 달라졌냐면은 원래는 여기서 무한 뺑뺑이를 돌면서 계속 체크하던 것이 여기서 일단 wait for single object가 딱 들어가는 순간 이제 요 핸들을 이용해가지고 지금 얘를 건네줬으니까 요기는 kernel object의 signal 상태를 봐가지고 걔가 signal 상태면 이제 계속 진행을 할 것이고 만약에 빨간불 non-signal 상태라고 하면은 애당초 요 스레드가 일어나지 않고 그냥 잠시 수면 상태에 빠져가지고 잠들게 될겁니다 그래서 요런 아랫부분이 이제 무한정 실행 되는 게 아니라 여기서 일단 대기를 해가지고 쿨쿨 잠든 상태가 되는 거죠 그러니까 아까 기내 화장실 얘기로 들면은 자리에 가가지고 난 한숨 눈 좀 붙이고 올 테니까 만약에 여기 진짜 이 이벤트가 발생해가지고 시그널 상태가 파란 불로 바꿔치게 되면은 나를 알아서 깨워줘 라고 우리가 커널한테 지금 부탁을 하고 있는 거죠 완전히 갑질을 하는 거죠 한마디로 그렇게 해서 , 이렇게, 바꿔치기를 하면 , 사실, 코드가 엄청 많이 추가되지는 않았지만 이제 완전히 동작 방식이 달라진다고 볼 수 있겠습니다. 제3자의 개입을 통해 가지고 우리가 무의미한 대기를 어떻게든 방지하게끔 유도를 해줬다고 보시면 되겠어요. 그 다음에 여기서 이제 메뉴 리셋이라는 거 자체를 만약에 우리가 false로 해가지고 예당초 상태가 자동으로 리셋되는 상태로 만약에 우리가 만들어놨다고 하면은 지금 흐름이 어떻게 되냐면은 여기 wait for single object에서 얘가 원래 잠들다가 어 시그널 상태가 딱 파란 블루 켜지자마자 커널이 다시 요쪽 스레드를 복원시켜가지고 얘가 계속 일을 할 수 있게끔 깨워주게 될 건데 그 순간 우리가 여기 있는 auto 리셋 상태를 true로 해줬기 때문에 여기서 사실상 다시 non-signal 상태로 어... 바뀌게 됩니다 한마디로 파란불이 되어서 깨워놨으니까 날 깨웠으니까 이제 자동으로 다시 non-single 상태로 , 이렇게, 바꿔치기를 해준다는 얘기가 되는거고 만약에 얘를 우리가 처음에 성적을 할 때 manual reset를 true로 했으면 기본적으로 얘가 자동으로 다시 상태가 바뀌지 않기 때문에 여기다가 추가적으로 우리가 reset event라는 요 함수를 호출해가지고 얘를 강제로 다시 불을 꺼줘야 됩니다 네 그래서 뭐 여기에 살짝 달라지는 부분인데 기본적으로 우리는 자동으로 다시 초기화 되는 상태로 , 일단은, 실습을 해보도록 할게요 , 자, 이렇게, 해가지고 뭐 결국에는 크게 어려운 내용은 없었는데 얘를 다시 이제 빌드 해가지고 이제 똑같이 실행을 해보면 결과물 자체가 딱히 달라지는 그런 건 아닙니다 얘도 똑같이 잘 출력이 되고 있는 걸 볼 수 있는 건데 근데 실질적으로 CPU 점유율이 아까는 원래 8%까지 올라갔던 게 이젠 0%에서 올라가지 않는다는 걸 볼 수가 있는 겁니다 한마디로 진짜로 뭔가 얘가 일감을 밀어넣은 다음에 이 이벤트를 이용해가지고 통지를 해주기 전까지는 요 스레드는 계속 여기서 대기를 하면서 잠든 상태가 되는 거죠 실행조차 되지 않고 그냥 쿨쿨 잠들면서 스케줄링 상태로 돌아갈 수가 없고 이제 운영체제가 나중에 요 아이가 Set Event를 통해 가지고 여기 있는 이벤트의 시그널 상태를 바꿔 줄 때 에서야 얘를 다시 깨워서 진행을 한다가 일단 오늘 핵심적인 내용이라고 보시면 되겠어요 그래가지고 뭐 이거를 전 처음에 공부했을 때 어 제가 약간 삼국지를 좋아하는데 삼국지에서 그 봉화대가 생각이 나더라구요 봉화대라고 해가지고 예전에는 통신기구가 없었으니까 뭔가 봉화대라는 그런 탑같은 데다가 불을 붙여가지고 거기 있는 연기를 통해 가지고 서로 소통을 했었는데 약간 그런 느낌이라고 볼 수가 있는 거죠 이 이벤트라는 거 자체는 이 두 아이 곁에 있는 건 아니고 저 멀리 커널 어딘가에서 관리하고 있는 그런 옵젝트이긴 하지만 어찌됐건 거기다가 , 이렇게, 불을 붙여가지고 상태를 이제 뭐 바꿔치기를 해준 다음에 그 다음에 다른 애가 계속 그 신호를 보고 이어서 진행할 수 있게끔 뭔가 유도를 해주는 그런 느낌이라고 일단 보시면 되겠습니다 그리고 이제 이 이벤트 자체도 종종 사용이 되기는 하지만 이런 아이의 기본적인 형태에다가 이제 변종이 되어 가지고 나중에 컨디션 Variable 이라거나 하는 다양한 방법들이 또 존재하는데 그거에 대해서도 이제 나중에 알아보게 될 겁니다 그래서 오늘 여기서 이제 굉장히 중요했던 내용은 , 사실, 딱 하나인데 이 각각의 함수가 무엇이고 하는 것 자체는 언제든지 구글에 찾아보면 되니까 딱히 중요하지는 않고 그냥 여기서 무한 루프를 돌면서 계속 뺑뺑이를 도는 게 아니라 여기서 , 일단은, 대기를 타가지고 더 이상 무의미하게 실행이 되는 걸 예방할 수 있다는 걸 이제 꼭 반드시 숙지를 해주셔야 되겠습니다 그 다음에 겸사겸사 커널 오브젝트라는 용어도 등장을 했는데 얘는 말 그대로 커널에서 관리를 하고 있는 그런 객체이기 때문에 이런 이벤트나 다른 커널 객체를 이용하게 되면은 어떠한 장점이 있냐면은 나중에 우리가 지금은 하나의 프로그램 내부에서만 서로 동기화 작업을 하고 있는데 그게 아니라 다른 프로그램끼리도 뭔가 동기화 작업을 할 때 이런 kernel object를 활용하면은 프로세스끼리도 서로 뭔가 동기화가 필요할 때 이런 방법을 이용할 수 있습니다. 근데 물론 MMO 서버 기준으로 봤을 때는 그렇게 다른 프로그램이랑 뭔가 동기화를 하고 이런 상황은 일단 없긴 할 테지만 참고 삼아서 알아주시면 되겠어요. 그래서 우리가 기존에 만들던 스피락 같은 경우에는 결국에는 모든 게 다 유저 레벨에서 일어나는 그런 동기화 기법이었다고 한다면 이런 식으로 커널 단계까지 개입을 해가지고 하는 방법들은 유저 모드 동기화가 아니라 커널 모드까지 개입을 해가지고 한 거니까 훨씬 더 활용성이 높기는 하지만 단점이라고 한다면 어찌되건 제3자까지 개입을 해가지고 그러니까 , 이렇게, 간단하게 유저 레벨에서 그냥 간단하게 처리할 수 있었으면 좋았을 테지만 그게 아니라 저 멀리 있는 커널까지 개입을 해가지고 우리가 추가적인 비용을 들여가지고 뭔가를 해주고 있는 것이기 때문에 너무 빈번하게 일어나는 일이라고 한다면 오히려 이런 식으로 이벤트를 활용하거나 커널 오브젝트를 활용하는 방법이 악수가 될 수도 있다는 얘기가 되는 거죠 항상 프로그램에서는 거의 대부분의 경우에 양면성을 띄고 있습니다 항상 어떤 방법이 제일 좋고 그런 게 아니라 상황에 따라가지고 어떤 방법이 좋을 수도 있고 다른 상황에서는 어떤 다른 방법이 좋을 수도 있고 한다는 걸 반드시 기억을 해주시면 되겠어요 하지만 기본적으로 , 이렇게, 굉장히 오랜 기간 기다렸다가 어쩌다가 한 번씩 실행하는 일이라고 한다면 매번마다 체크를 하기보다는 이런 식으로 중간에 이벤트나 뭐 다른 도구를 둬가지고 서로 통신을 하는 것도 굉장히 좋은 방법이라고 볼 수가 있는 거죠 , 자, 이렇게, 해가지고 , 일단은, 이벤트에 대한 내용을 맞춰 보도록 할게요.