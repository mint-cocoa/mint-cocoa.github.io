안녕하세요 여러분 제가 이제 강의를 좀 한참 만든 다음에 미래에서 다시 돌아와 가지고 좀 보충 설명 한 가지를 드릴 게 있는데요 제가 이제 강의 소스를 올릴 때 , 이렇게, 압축 파일로 다 웬만해서는 올려 드리고 있고 그 다음에 강의 제목이랑 맞춰 가지고 파일을 , 이렇게, 올려 놨는데요 나중에 이제 뒤에 돌아가가지고 테스트를 하다보니까 이게 살짝 문제가 있는 경우가 있더라구요 그게 뭐냐면은 이제 오늘부터 진행할 부분에서 우리가 이제 이벤트를 걸어줘가지고 어 빌 패키지 자동화 빌드 자동화와 관련된 부분들을 이제 넣어주게 되는데 여기 안에서 파일 경로를 이제 읽어가지고 뭔가를 해주는 그런게 있어요 근데 여기서 이제 한국어가 들어가면 살짝 문제가 됩니다 그래서 이 상태에서 만약에 솔루션을 키면은 어 빌드가 되지 않는 문제가 일어날 수 있으니까 무조건 압축을 푼 다음에 이거를 그냥 용문으로 아무거나 바꿔주신 다음에 얘를 다시 켜주시면 되겠습니다. 그러면 이제 아무런 문제 없이 잘 실행이 될 거예요. , 자, 그래서 혹시라도 이 부분에서 낚이셔가지고 고민을 하실까봐 그리고 이게 한 번 한국어 때문에 꼬이기 시작을 하면은 어 전체 그 아까 떴던 그 .vs 파일을 삭제하고 뭐 다시 만들고 온간 난리를 쳐야 되더라구요 그래서 이게 생각보다 잡기 어려운 버그여가지고 요 부분만 , 이렇게, 따로 보충 설명을 하고 이제 넘어가도록 할게요 , 자, 이제 다시 강의로 돌아가 주시면 되겠습니다 우리가 지난 시간까지 굉장히 성공적으로 프로토퍼프를 이식하는 데까지는 성공을 해서 프로토퍼프 기반으로 패킷을 만들고 전송하고 그리고 수신해서 사용하는 그런 실습까지는 해봤습니다 근데 지금 딱 이 상태로 콘텐츠를 만들자니 아직까지는 그래도 굉장히 반복적이고 귀찮은 작업이 아직 많이 남아 있다는 걸 알 수가 있고 이제 이런 부분들을 조금씩 개선해 나가면서 최대한 콘텐츠 단위에서는 편하게 그리고 쉴 수 없이 작업할 수 있는 환경을 마련하는 쪽으로 이제 한번 작업을 해볼 겁니다 근데 , 일단은, 지금 이 코드를 보면은 무엇을 자동화해야 될 것인가? 무엇이 지금 굉장히 귀찮을 것인가를 먼저 생각을 해봐야 되겠죠? 우선 프로톡 버프 파일을 만든 다음에 배치 파일을 실행하는 것조차도 귀찮긴 하구요. 그 다음에 실행된 거를 여기 긁어와가지고 우리 프로젝트에다가 옮겨오는 것도 당연히 귀찮은 작업이 될 것이고 그 두가지가 일단 있고 그 다음에 이 서머패킷 핸들러를 유심히 보면은 여기다가 우리가 프로토버프에서 만든 그 프로토콜 스트럭트마다 그 메시지마다 이런식으로 하나의 아이디를 부여한 다음에 그거랑 일대일로 대응시켜가지고 이런식으로 우리가 직접적으로 연결을 해줬습니다. Make Sand Buffer 요 S-Test라는 요 패킷은 이제 이 S-Test라는 아이디를 부여할 것이다 라는 식으로 연동을 해줬죠. 이런 부분도 굉장히 불편한 부분이고 그리고 마지막으로 실질적으로 핸들 패킷에 와가지고 이 버퍼가 왔을 때 패킷 헤더를 참고해가지고 아이디까지는 알았는데 이 부분을 우리가 스위치 케이스로 나눠가지고 지금 뭐 아이디가 몇 번이면 뭘 실행하라 이런 식으로 지금 구분을 하고 있습니다 , 자, 클라이언트가 지금 딱 이런 식으로 했었죠 근데 실제로 제가 이런 프로젝트 중에서 진짜 , 이렇게, 스위치 케이스 노가다를 하는 팀이 있었어요 근데 그게 나중에 이제 100개가 넘어가니까 작업하기도 굉장히 힘들고 실수의 여지도 많아지고 하다보니까 나중에 가서 이제 고친 뭐 그런 경험이 있습니다 그래서 뭐 요런 부분들을 , 일단은, 오늘 수정을 해보면서 , 일단은, 작업을 해볼 건데 이제 자동화하기 전에 먼저 코드를 한번 수동으로 , 일단은, 만들어 본 다음에 무엇을 자동화 할지를 생각하는게 굉장히 중요합니다 그 스텝을 , 일단은, 거쳐야 돼요 , 자, 그런데 , 일단은, 구조 정리부터 몇가지 해보자면 , 자, 이게 일단 제 폴더 구조에요 여기서 지금 우리가 여기까지 , 일단은, 작업을 해놨구요 근데 요게 좀 정리를 하자면 여기 프로토C 모시기 윈도우라고 되어있는 이 폴더를 어디서 관리할까 고민하다가 그냥 새 폴더를 만들어가지고 커먼이라고 해가지고 그냥 공용으로 사용할 그런 모든 기능들, 라이브러리 등등을 여기다가 일단 좀 밀어 넣어주도록 할게요 그래서 이 프로토C 모시기도 일단 여기 드래그 드롭 해가지고 커먼 안쪽에다가 요렇게 일단 넣어줄 것이고 그 다음에 이름이 너무 지저분하니까 그냥 프로토 버프라고 이름을 수정을 해보도록 하겠습니다 그 다음에 다시 가서 , 사실, 이 빈 나머지는 삭제해도 되지만 , 일단은, 그냥 오늘은 냅두도록 할 것이고 지금 프로토 파일이 , 이렇게, 하나가 들어가 있습니다 잠시 , 이렇게, 꺼내서 한번 살펴볼까요 여기까지 일단 작업을 해놨는데 여기 딱 보면은 이 s 테스트라는 아이는 , 사실, 우리가 패킷 용도로 활용할 것이지만 버프 데이터라는 애는 어떻게 보면 그냥 일반적인 클래스로 우리가 활용하고 있었죠 물론 이게 딸려서 지금 , 이렇게, 넘어가고 있기는 하긴 하지만 그리고 나중에 가면 이제 인원급 같은 것도 생기게 될 텐데 그 모든 애들을 다 이런 한 프로토 파일에 관리하는 거는 좀 바람직하지 않습니다 최대한 사용 용도에 따라가지고 프로토 파일을 구분한 다음에 만드는게 이제 훨씬 좋아요 그리고 나중에 심지어 이 프로토 파일이 너무 거대해지면은 이거 하나를 수정함으로써 우리의 전체 프로토 헤더... 헤더 파일? 요 .cc랑 .header 파일이 다 고치... 그니까 바뀌게 되면은 빌드하는데도 굉장히 오래 걸릴 수도 있기 때문에 컨텐츠 별로 뭐 예를 들면은 전투 아이템 이런식으로 용도별로 이런 패킷을 좀 구분하는 것도 괜찮습니다 근데 그건 뭐 나중에 일이니까 지금 당장 하지 않을 거고 오늘은 , 일단은, 여기 프로토 파일을 두 개를 더 복사해가지고 스트럭트랑 이넘이라는 값으로 , 이렇게, 만들어가지고 구조체 전용 그리고 이넘값 전용으로 하나씩 만들어 보도록 할게요 , 자, 이렇게, 삼총사를 먼저 만들어 놨구요 얘네들을 하나 둘 셋 긁어가지고 어 이제 프로젝트에다가 우리가 프로젝트 내부에서 관리를 해주게 될 건데 프로토콜이라는 이 폴더에다가 얘네들을 다 , 일단은, 요렇게 안 해줬으면 , 일단은, 밀어 넣어주시면 되겠습니다. 마찬가지로 위쪽에서도 똑같이 , 이렇게, 긁어주도록 할 거에요. 그래서 , 일단은, 여기서 잠시 작업을 해볼건데, 어, 이넘 같은 경우에는 이제 말그대로 여기서 이런 값 말고 이너메레이션을 사용하는 그런 용도로 활용할 겁니다. 예를 들어보자면 제가 샘플을 한번 찾아와서 똑같이 한번 만들어보자면 여기서 얘네들을 삭제를 해주고 예를들면 플레어 타입이 있다고 가정해봅시다 우리가 뭐 늘상 작업하던 타입 그러면은 플레어 타입 none 이라는게 있을 것이고 참고로 요 규칙상 프로토에서는 항상 0번이 꼭 있어야 된다는 규칙이 있어가지고 , 이렇게, 없음을 항상 0으로 하는걸 추천을 드리고요 그 다음에 뭐 플레어 타입 night 1번 그 다음에 뭐 플레어 타입의 Knight, Mage, Archer 순으로 할게요 뭐 이런식으로 이너미레이션을 각각 하나씩 정리를 해주도록 하겠습니다 요렇게 , 자, 그리고 struct 같은 경우에는 얘는 뭐하는 애냐면은 말 그대로 요렇게 전송하는 패킷이 아닌 그냥 일반적인 struct 용도로 활용할 요런 데이터들을 여기다가 , 일단은, 배치를 해주도록 하겠습니다 그리고 또 하나 이제 말씀을 드리자면 요런 부분에서 프로토 파일끼리도 서로 참조할 수도 있습니다. 이게 무슨 말이냐면 여기다가 위에다가 이제 혹시라도 여기 안에서 이 인원값을 사용할 수도 있으니까 이런 식으로 임포트를 한 다음에 import inum.proto를 , 이렇게, 찍어주면 여기 있는 내용도 꺼내가지고 얘가 이제 활용할 수가 있게 됩니다. 여기 , 이렇게, 닫아줘야 되고요. , 자, 그 다음에 마지막으로 그러면 프로토 파일은 얘가 이제 실질적으로 패킷을 내부적으로 관리하는 그런 아인데 얘도 마찬가지로 import inum.proto를 넣어주고 import struct.proto도 , 이렇게, 넣어주고 얘를 이제 , 이렇게, 관리를 해보도록 하겠습니다. , 자, 그 다음에 잠시 여기 상위 폴더를 열어가지고 배치 파일 같은 경우에도 좀 편하게 작업을 할 수 있도록 , 일단은, 드라이크 드롭을 해가지고 이쪽에다가 , 일단은, 넣어놓고 작업을 하도록 할게요. 마찬가지로 양쪽에다 다 넣어놔서 어차피 동일한 파일이다 보니까 하나를 고치면 다른 애도 일단 고쳐지게 될 겁니다. , 자, , 이렇게, 해서 배치 파일을 먼저 , 이렇게, 열어보고 그 다음에 배치 파일을 살펴보면 지금은 이 프로토만 지금 , 이렇게, 고치고 있는데 두개를 더 복사해가지고 이제는 뭐 스트럭트랑 그리고 이넘도 같이 빌드를 해주도록 하겠습니다. 요런 느낌으로 , 자, 그리고 실패하면 포즈를 하고 , 자, 그 다음에 배치 파일을 우리가 만약에 지금 딱 실행하면은 지금 요런... 한번 실행해볼까요? 이런저런 파일들이 막 생기게 되죠? struct, protocol, 그리고 innum 근데 이제 걔네들을 우리가 항상 지금까지는 , 이렇게, 복부술을 해서 질적 긁어왔어요 그래가지고 이제 방금 생성된 이넘이랑 스트럭트 2개의 세트, 그러니까 총 4개의 파일을 , 일단은, 게임 서버 코드가 있는 이쪽에다가 일단 복붙을 한 다음에 얘네들을 여기 프로토콜에다가 꺼내가지고 , 이렇게, 추가를 해줄 것이고 마찬가지로 서버에서 더미 클라이언트 쪽에도 똑같이 여기다가 복붙을 해준 다음에 똑같이 그냥 , 이렇게, 꺼내가지고 이쪽에다가 , 일단은, 배치를 시켜놓도록 하겠습니다 근데 뭐 당연한 얘기지만 이 작업을 우리가 패킷을 바꿀 때마다 매버마다 하는 거는 당연히 말이 안 될 겁니다. 그래가지고 이 작업을 여기에 배치 파일이 실행될 때끔 하게 유도를 해줄 것인데 배치 파일 문법은 그냥 구글링을 해서 뭐 어떤 파일 복사하는 거 이런 거 찾아보면 다 나옵니다. 여기 안에 있는 파일을 엑스 카피를 해서 딴 데로 이제 복사를 할 것인데 slashy를 대문자로 해주면은 덮어쓰기라는 의미입니다. 만약에 파일이 있으면은 덮어쓴다. 에러처리를 하지 않고 덮어쓴다는 의미고 pb.h라는 파일을 1칸, 2칸, 3칸 뒤로 간 다음에 게임서버라는 폴더에다가 넣어주세요 라는 의미가 되는 겁니다. 여기 점점 슬래시 점점 슬래시가 3번 있는 것은 여기 기준으로 지금 배치 파일이 여기 이 경로에 있는데 한 칸, 두 칸, 세 칸을 뒤로 간 다음에 그 다음에 게임 서버에 넣어달라 라는 의미이기 때문에 , 이렇게, 되는 거에요. 그 다음에 하나를 더 복사해가지고 cc, innum.pb.cc라는 파일도 똑같이 , 이렇게, 한 다음에 innum이 되었으니까 두 개를 더 만들어가지고 struct도 해주고 protocol도 , 이렇게, 해주면 되겠습니다. 그리고 마찬가지로 xcopy를 한 번 더 해줘가지고 얘네들을 이제 뭐 더미 클라이언트도 맞춰주면 되겠죠 나중에 가면은 우리가 꼭 C++로 모든걸 통일해서 한다는 보장이 없으니까 이런식으로 만들어가지고 상대방에서 관리하는 프로젝트에다가 얘를 일단 복사해서 넣어주는게 일단 속 편합니다 그래서 일단 , 이렇게, 관리를 해주고 있는 거구요 그리고 이 배치 파일 자체가 지금 여기서 만약에 우리가 이 배치파일을 실행하면은 이 proto.exe라는게 지금 같은 경로에 있다 보니까 얘를 찾아가지고 실행할 수 있지만 만약에 우리가 다른 경로에서 뭐 이런 데서 원격으로 커맨드를 이용해가지고 이 배치파일을 실행하면은 이 경로를 지금 경로를 인지해가지고 이 proto.exe를 찾지 못하는 경우가 생길 수가 있어요 그래서 , 일단은, 미리 pushd 한 다음에 달러표시 물결 dp0 라고 해가지고 현재 이 젠 프로토콜이 실행, 젠 패키스 실행되고 있는 경로 자체를 우리가 설정을 해주도록 하겠습니다. 디렉토리를 , 이렇게, 다시 맞춰주는 거죠. 네, 요 부분은 오차를 내시면 안되고요. 잘 보시면 되겠고 그래서 얘가 , 일단은, 빵 실행이 되면은 이제는 여기다가 뭐 파일들이 정상적으로 다 복사가 될 겁니다. 진짜로 되는지 보려면 이걸 한번 삭제해본 다음에 내용을 한번 날려보고 정상적으로 젠피켓을 눌러서 짜잔 복사되는지를 확인하면 되겠죠. 그리고 잘 되고 있습니다. 근데 지금 이 상태에서 빌드하면 아마도 에러가 날 것인데 우리가 매번 해주던 게 있었죠. 속성에 가가지고 여기 cc 파일에 대해서 미리 컴파일된 컴파일 헤더 사용 안함, PCH 사용 안함으로 바꿔줘야 되고요. struct도 똑같이 사용 안함으로 바꿔치기를 해주면 되겠습니다. 오케이. 그 다음에 위에서도 인험도 사용 안함으로 일단 바꿔주셔야 되고요 그리고 struct도 마찬가지로 속성 미리 컴파일된 헤더 사용 안함으로 바꿔주시기 한 다음에 일단 빌드를 다시 한번 해보도록 할게요 별다른 문제가 없으면 , 일단은, 통과가 될 겁니다 , 자, 그런데 여기서 또 이제 굉장히 아쉬운 점은 뭐 설령 우리가 여기다가 좀 끌고 와 가지고 작업을 한다고 해도 어 지금 이제 작업을 하려면은 여기 있는 프로토 파일을 막 고친 다음에 그 다음에 매번마다 이 배치 파일을 다시 실행해 줘야 되는데 그것도 너무 귀찮은 일이 될 거예요 그러면 이 배치 파일을 좀 알아서 눈치껏 알아서 해주면 되지 않을까 라는 생각이 드는데 실질적으로 우리가 빌드를 할 때 이벤트를 걸어 줄 수가 있습니다 예를 들면 지금 게임 서버 우클릭 속성에 가 가지고 살펴보면요 여기 사용자 지정 빌드 단계라는 게 있습니다. 아, 이게 아니라 위에 빌드 이벤트라는 게 있습니다. 요 부분에서 말 그대로 시점에 따라가지고 우리가 이벤트를 호출해줄 수 있는데 빌드 전 이벤트, 뭐 , 사실, 어디에도 상관없긴 한데 여기다가 , 일단은, 추가를 해보도록 할게요. 화살표 편집을 누른 다음에 여기다가 일단 명령어를 직접 입력을 할 건데 콜! , 자, 호출해달라. 달러 솔루션 디렉토리 네, 솔루션 디렉토리 기준으로 평가값이 지금 , 이렇게, 잡혔죠? 거기 안에다가 common이라는 폴더 안에 protobuf라는 파일 안에 빈에 안에다가 genpackets.batch파일을 호출해주세요 라고 이걸 실행해줄건데 , 일단은, 얘를 전체를 복붙해서 저장한 다음에 ok를 일단 눌러주도록 하겠습니다. ok 마찬가지로 더미클라이트 쪽에서도 똑같이 한번 해주도록 할게요. , 자, , 이렇게, 오케이. 그러면 이제는 굉장히 재미있게도 빌드를 실질적으로 , 이렇게, 할 때 여기 지금 파일이 복사되었습니다. 로고가 뜬다는 걸 볼 수가 있습니다. 이런 식으로 지금 자동으로 복사가 되고 있다는 것도 이제 알 수가 있는 거예요. 그래서 굳이 배치 파일을 막 실행할 필요 없이 이제는 , 이렇게, 빌드만 해주면 된다라는 굉장히 아름다운 상황이 있기는 한데 근데 이 빌드 이벤트가 좀 단점이라고 하긴 뭐한데 함정은 실질적으로 소스 코드가 아무런 변화가 없었다고 하면 빌드 이벤트가 실행이 되지 않습니다. 근데 지금 우리가 추적되고 있는 파일들, 이 헤더랑 cpp 파일들에 한해서만 지금 그런 것이고 굉장히 아쉽게도 이 프로토 파일들은 지금 뭐 추적 대상이 아니다 보니까 그냥 우리가 관리하기 위해서 얘를 그냥 참조로 , 이렇게, 넣어줬죠? 여기 사실상 멀리 원격에서 지금 커먼 프로토 버프 빈 안에 있는 그냥 파일을 그냥 우리가 사실상 문서 편집기 용도로 활용하는 것이지 얘를 뭐 딱히 뭐 빌드에다가 뭔가를 해달라고 요청을 한 적은 없습니다. 그러니까 여기서 만약에 우리가 뭐 하나를 추가한다거나 하나를 삭제한다거나 하면은 예를 들면은 지금 s 테스트에다가 플레어 타입을 뭐 , 이렇게, 추가한다고 값을 해봅시다. 5번으로 근데 , 이렇게, 설명하더라도 게임 서버가 그거를 인지해서 빌드를 해주지 않습니다 어 그러면은 뭐 강제로 코드를 살짝 수정 사항이 있게끔 뭔가 , 이렇게, 해줘야 되는가 막 그런데 그건 좀 너무 귀찮죠 그래가지고 이거를 어떻게 처리할 수 있냐면은 구글링을 해보면 굉장히 재밌는 방법이 나오는데 , 일단은, 어 그냥 상위 폴더 열기에서 요 파일을 일단 열어줘야 됩니다 프로젝트 파일을 , 자, 이 파일을 , 일단은, 열어줘야 돼요 근데 일단 비쥬얼 스튜디오를 끈 상태에서 이거를 수정을 해보도록 하겠습니다 , 자, 일단은, 지금 이거를 다시 켜가지고 요 파일을 우클릭 뭐 아무 메모장이나 뭐 어떤 프로그램은 상관없는데 저는 또 스펫뿔뿔이라는걸 이용해가지고 작업을 할거에요 , 자, 이거를 이용해가지고 이제 , 이렇게, 켜진 상태에서 여기 보면은 아이템 그룹이라고 해가지고 뭐 see include라고 , 이렇게, 되어있는 부분이 있습니다. , 자, 이거를 한번 유심히 보면은 아 이 부분이죠. Inon Proto, Protocol Proto, Struct Proto 즉 우리가 문서 편집기처럼 드래그 드롭 해가지고 사용할 때 이게 자동으로 추가 됐는데 얘를 , 일단은, 한 번 더 복사를 해서 아래다가 한 번 더 복붙을 한 다음에 그 다음에 Gem Picket은 일단 잠시 없애주고 여기 None이라고 되어있는 부분을 up to date check input 이거 아마 대소문자 구별할겁니다 , 이렇게, 일단 바꿔주시면 되겠습니다 얘는 뭐하는거냐면 이제는 요 파일들을 내가 추적해가지고 요 파일드 자체에서 뭔가 변화가 있었다고 하면은 진짜로 우리 코드와 마찬가지로 뭔가 변화가 있었다라고 인지해가지고 그래서 다시 이벤트를 실행시켜주게 될겁니다 굉장히 편리하죠 그래서 요 코드를 , 일단은, 사용하면 되구요 Ctrl C 마찬가지로 여기 말고 더미 클라이언트 쪽에서도 그냥 똑같이 한번 해주도록 할게요 요 파일이죠 프로젝트 파일 우클릭 이거 압축이 아니라 압축이 아니라 Edit Notepad로 한 다음에 여기서도 마찬가지로 아까 넣어준 코드를 그대로 다시 넣어주시면 되겠습니다. 뭐 한 대칭성 있게 이쯤에다가 넣어주도록 할게요. Up to date check input이 다 들어갔죠? , 자, 그러면 이제 이거를 닫아준 다음에 다시 서버를 , 이렇게, 띄워주시면 되겠습니다. 다시 이제 솔루션을 열어가지고 들어가보면은 아까 우리를 좀 괴롭혔던 문제 자동으로 인지하지 못하던 문제를 이제 해결해줄거에요 그래서 테스트를 해보자면 게임 서버를 잠시 빌드를 해봤는데 , 자, 지금은 복사를 하고 있죠? 잘 하고 있습니다 그런데 요 상태에서 만약에 여기서 지금 에러를 처리해 줬네요. 여기 에러 처리가 됐는데 여기서 만약에 우리가 이걸 지운 상태에서 다시 저장하고 또다시 한번 진행을 하면 이 파일 자체가 바뀌었다는 걸 인지를 해가지고 알아서 수정을 해주게 될 겁니다. 알아서 지금 다시 한번 , 이렇게, 빌드를 해 준 걸 볼 수가 있습니다. 이런 식으로 , 일단은, 응용을 할 수가 있어요. 굉장히 재밌게도. 그래서 여기까지 처리하면 어지간해서 크게 추천할 부분이 없겠죠? 프로토, 스트럭트, 이넘 이런 거 막 작업을 하다가 얘를 빌드하면 알아서 여기 있는 헤더, cpp 파일들이 다 생성이 된다는 걸 일단 알 수가 있고 그렇게 되면 우리가 컨텐츠 쪽에서 작업을 할 때 굉장히 편리하게 작업을 할 수가 있게 된다는 걸 알 수가 있습니다 , 이렇게, 해가지고 아까 배치 파일을 매번 실행하는 문제 등등은 해결이 되었고 그 다음에 생각해볼 문제는 뭐냐면은 다시 한번 서버 패킷 핸들러를 켜가지고 살펴보자면 요 부분이 이제 굉장히 지저분합니다 근데 이거는 딱히 뭐 그렇게 어마어마하게 좋은 방법이 없어요 그러니까 프로토 콜 문법을 보면은 지금 프로토 버프 파일이 지금 요 파일인데 어 사실상 지금 우리가 원하는 건 뭐냐면 이 패킷을 우리가 설계를 할 때 여기다가 뭔가 번호를 지정할 수 있으면 굉장히 아름다울 것 같죠 그러니까 우리가 이제 클래스 설계를 할 때 예를 들면 스태틱, 인트, 패킷 아이디라고 한 다음에 그냥 고정값으로 얘는 1이라는 값을 갖는다거나 하는 식으로 뭔가를 넣어주면 굉장히 아름다울 텐데 딱히 프로토3 문법에서는 그런 걸 할 수 있는 방법이 없습니다 유일하게 그나마 좀 비슷하게 할 수 있는 건 뭐냐면 여기 안에서 인원값을 넣어준 다음에 예를 들면 Packet ID라는 인원값을 넣어 줘 가지고 Packet ID는 1번 뭐 이런 식으로 정의하는 게 , 일단은, 가능은 해요 근데 지난번에 얘기한 대로 이넘 값에서는 항상 0이라는 값으로 시작을 해야 된다고 했었죠? 그래서 그냥 쓰레기 값으로 넌이라고 0번을 일단 입력을 해주도록 할게요 그러면 나중에 패킷이 늘어나더라도 예를 들면 메시지가 하나가 늘어나가지고 얘는 slogin 패킷이라고 만약에 예를 들면 여기서도 마찬가지로 이 똑같은 이넘을 만들어 준 다음에 넌은 0번 패킷 아이디는 2번 이런 식으로 늘려주면 됩니다 흠 그러면은 이 이넘값 자체가 공용으로 이넘에 빠져있는게 아니고 각 메시지 안에 들어가 있는 거기 때문에 얘네들이 동일한 아이로 인식되지 않고 에스트 테스트 안에 패킷 아이디로 구분이 됩니다 그래서 예를 들면 지금 이걸 잠시 한번 빌드를 해보도록 할게요 빌드를 해본 다음에 이걸 C++에서 어떻게 그러면 활용할 수 있냐 여기 서버 패킷 매니저에서 보면은 이 패킷을 기준으로 여기서 만약에 우리가 뭔가를 사용한다 즉, 이 stest라는 걸 여기서 , 이렇게, 강제로 이넘으로 우리가 하드코딩하는게 아니라 얘를 이제 이용해서 만약에 한다고 치면은 이제 , 이렇게, 이용할 수 있게 됩니다 프로토콜에 stest의 Packet ID라는 걸 꺼내 써서 얘를 넣어줄 수 있게 된다는 얘기가 되는 거죠 그리고 마찬가지로 만약에 우리가 템플릿 코드를 이용한다고 하면 이 템플릿으로도 비슷하게 맞춰줄 수가 있을 겁니다 템플릿에 Packet ID 이런 식으로 꺼내 쓸 수 있기는 하죠 그래서 , 이렇게, 진행을 해도 되기는 하는데 근데 , 이렇게, 하면 문제가 되는 부분은 뭐냐면 물론 좀 더럽죠? , 이렇게, 일단 추가를 하는 것 자체가 마음에 안 들 뿐더러 진짜 문제는 이걸 실수해 가지고 만약에 겹친다고 가정을 하면은 이런 체크를 안 해주다 보니까 여기서 이제 코드가 꼬일 확률이 생기게 됩니다. 이거는 어거지로 우리가 좀 패킷 아이디라는 그 값 자체를 여기 메시지 안에다가 넣어주기 위해서 진짜 어거지로 넣어준 거지만 이게 뭐 그렇게 깔끔한 방법은 아니라는 걸 알 수가 있는 거죠. 그리고 또 하나 , 이렇게, 고정해서 만들게 되면은 잔점이 뭐냐면은 나중에 우리가 이제 해킹을 방비할 때 어 공격자들이 굉장히 많이 하는 짓거리 중 하나가 패킷 조작입니다 패킷을 그냥 이것저것 막 건드려 보는 거죠 그래서 패킷 아이디가 몇 번 몇 번이 이제 어떤 의미를 갖는지를 보기 위해서 여러가지 방법이 있겠지만 리버싱을 해가지고 코드를 다 분석하는 건 진짜 완전 고수입니다. 근데 그 정도까지 근성 있는 사람은 거의 두물어요. 대부분 어떤 방식으로 하냐면 그냥 이것저것 그냥 실시간으로 테스트를 해보는 겁니다. 이제 패킷 자체를 전송되는 거, 서버 쪽에 전송되는 거를 캡쳐해가지고 계속 살펴보다가 내가 뭐 움직일 때는 패킷 아이디가 몇 번으로 간다라는 걸 이제 계속 분석을 하면서 진행을 하는 거죠. 그래가지고 주기적으로 패킷 아이디를 섞어주는게 굉장히 유효한데 지금까지 열심히 분석해가지고 로그인 패킷은 1번이다 2번이다 라는걸 깨달았는데 이걸 우리가 다음 패치 때 섞어가지고 아예 바꿔주면은 뭐 은근히 보안 효과가 나을 수도 있겠죠 그래서 그런 경우에도 굉장히 이 패킷 아이디를 교체해주는 게 유용한데 이런 식으로 우리가 만약에 인원값으로 하드코닝해서 관리하면 그런 부분도 굉장히 아쉽게 됩니다 그래도 개인적으로는 이 방법은 그렇게 추천을 드리지 않아요 결론적으로는 이거는 별로 추천드리지 않고 그러면 이거를 만약에 , 이렇게, 하지 않으면 그럼 어떻게 해야 되는 것이냐 결국에는 자동화 툴이 필요하다는 거죠 그래서 자동화해서 처리를 해서 이런 부분들을 좀 깔끔하게 좀 알아서 처리하게끔 유도를 해주는 게 , 일단은, 다음 시간의 목표이고요. 오늘은 그 다음 시간에 자동화할 것이 무엇인지를 먼저 생각을 해보기 위해서 여기 서버 패킷 핸들러 쪽을 좀 수정을 해보도록 할게요. 일단 버퍼리더, 버퍼라이터는 필요 없으니까 얘네들은 날려줄 것이고 이제 이 파일들이 굉장히 중요합니다. 이거를 기반으로 우리가 진짜로 만들어 줄 것이기 때문에 이걸 굉장히 깔끔하게 작업을 하는 게 중요해요. , 자, 그러면 뭐 예를들면 여기서는 유인트 16까지니까 , 이렇게, 일단 패킷 아이디를 설계하는 부분을 요렇게 넣어주도록 합시다 예를들면 패킷 s 테스트 , 자, 이제 이 파일을 보고 이 파일을 쭉 파싱해가지고 여기 있는 내용들을 이제 자동화해서 우리가 만들어볼 거예요. 그래서 얘네들도 to do 자동화라고 하면 되는 거죠. 예를 들면 지금 Packet s 테스트라는 걸 얘를 인지해가지고 여기다가 1번을 할당해 줄 것이고 어, 로그인이라는 애도 있네라고 하면은 Packet s 로그인을 2번으로 한다던가 , 이렇게, 자체적으로 Packet 번호를 늘려주면 되겠습니다. 물론 꼭 1번부터 해야 된다는 규칙은 없고요. 이걸 대역폭을 정해가지고 대역대를 정해서 1000번부터 3000번은 클라이언트랑 서버 통신할 때 쓰는 패킷 이런 식으로 정해주는 것도 굉장히 많은 도움이 되겠죠? 그런 식으로 일단 활용할 수 있겠습니다. 그 다음에 일단 보내는 부분이랑 받는 부분 양쪽을 처리해줘야 되는데 보내는 부분 같은 거는 그래도 요 부분이 이제 뭐 그럴싸하게 , 일단은, 되어있습니다 , 자, 그래가지고 , 일단은, 메이크 샌드 버퍼를 요 부분을 지금 간단하게 한번 만들어 보자면 요렇게 만들어줄 수가 있을 거예요 얘를 일단 삭제를 하고 왼쪽에서 메이크 샌드 버퍼를 호출한 다음에 패킷에다가 그 다음에 위에서 만들어준 PKT ST 테스트 이걸 나중에 자동화해가지고 처리를 해주면 되겠죠 그러니까 요 부분도 2도 자동화 처리를 해주는 부분이 있겠습니다 이 로그인 패킷도 똑같이 이런 식으로 쫙 늘려주면 되겠죠. 근데 여기 지금 템플릿 자체를 스태틱으로 만들어가지고 일단 안에다가 같이 넣어주도록 할게요. 프라이벳 영역에다가 얘를 같이 딱 넣어주도록 하겠습니다. 이런 식으로. 그리고 그냥 이 앞에 짝대기는 그냥 없애고 그냥 컨벤션에 맞춰가지고 똑같이 일단 , 이렇게, 다시 한번 고쳐보도록 할게요. 그리고 여기 스태틱을 붙여주면 되겠죠 스태틱, 맥스앤드, 버퍼 그래서 이 부분 나중에 수정 사항이 있으면 고치면 될 건데 일단 기본적으로는 이 부분 이 정도만 만족할 것 같고 나중에 가면 패킷 개수에 따라가지고 이 부분이 쫙 늘어나게 될 거라는 것도 일단 예상할 수가 있습니다 보내는 거는 일단 그렇게 보내면 될 것이고 받는 부분도 마찬가지로 , 이렇게, 지금 스위치 케이스로 구분해가지고 한 땀 한 땀 넘겨주는 게 굉장히 마음에 안 들죠 이걸 여러 가지 방법으로 처리할 수 있지만 맵으로 들고 있어도 되고 아니면 그냥 배열을 하나 크게 만들어 가지고 메모리 좀 손해를 보더라도 최대한 빠르게 처리해 주는 것도 괜찮습니다 네 그래서 일단 핸들패킷 , 이렇게, 만들진 않을 것이니까 얘는 잠시 삭제를 할 것이고 , 자, 위에서 , 일단은, 만들어 보도록 할게요 처음에는 이런식으로 usingPacketHandlerFunction을 우리가 정의를 해줄것인데 이 타입은 std function 함수를 받아줄것인데 boolean을 return하고 packetSessionRef를 인자로 받아주고 byte로 두번째 인자로 세번째 인자로는 int32를 받아준다고 가정해봅시다. 이거 자체를 함수라고 일단 정의를 해볼게요. 그러니까 이 타입이죠. 그래서 이런 타입들이 굉장히 많이 존재할텐데 이거를 뭐 맵에다가 저장을 해도 되지만 g-packet-handler 가지고 그냥 uint64-max만큼 6535개 만큼의 배열을 일단 만들어서 바로 이걸로 그냥 호출을 해주도록 할게요 만약에 패킷을 다 사용하지 않을 거라면 메모리 낭비가 있을 수도 있지만 그건 , 사실, 그 정도 이 정도는 크게 상관이 없습니다 패킷을 우리가 받아 가지고 호출하는 부분은 굉장히 자주 일어날 테니까 차라리 메모리 성능을 좀 손해를 보더라도 조금이라도 CPU 성능을 향상시킬 수 있으면 이것도 괜찮은 방법이라는 거죠 그래서 제가 진짜로 이랬던 프로젝트에서 진짜로 , 이렇게, 배열로 통으로 관리하던 곳도 있었어요 그래서 이거를 , 일단은, 이렇게, 크게 만들어가지고 , 일단은, 활용할 것이다 라고 볼 수 있는 거고 이거에 따라가지고 나머지 함수들도 만들어 줄 겁니다 , 자, 이거 코드가 이제 어떻게 만들어질 거냐면요 먼저 여기 Make Sand Buffer 위에다가 얘가 이제 보내는 역할을 하는 핵심적인 함수였다고 하면은 거꾸로 받는 역할을 하는 핵심적인 함수를 만들어 볼건데 , 자, 타임네임 패킷 타입을 받아주고 그 다음에 프로세스 펑션을 일단 템플릿으로 2개를 받아줄겁니다. 스태틱 불 핸들 패킷 이라는 이름으로 만들어 줄 것이고 프로세스 펑션은 무엇인지를 먼저 받아주고 그 다음에 패킷 세션 레퍼런스 여기 참조값을 붙인 이유는 뭐 굳이 안 붙여도 되긴 하는데 레퍼런스 카운트가 괜히 1 증가했다 줄어들 필요 없으니까 성능 향상을 조금 더 얻기 위해서 그냥 참조값으로 , 일단은, 받아준 겁니다 이거는 별다른 의미는 아니고 그 다음에 Byte, Buffer, Int, Length를 각각 받아줄 것인데 얘가 먼저 해야 되는 건 뭐냐면 패킷 타입으로 , 일단은, 패킷을 만들어 준 다음에 우리가 사용하던 pathFromArray라는 게 있었죠? 그러니까 지금 클라이언트에서 받아줄 때 얘를 잠시 오른쪽으로 , 이렇게, 나와보자면 , 이렇게, 받아주고 있었는데 이 코드를 자동화해서 만들기 위한 준비를 하고 있는 겁니다. 그래가지고 어떤 팩킷을 넣어주게 되면은 그 팩킷을 PassFromArray를 이용해가지고 받아줄 것이고 이 코드를 좀 복사해볼게요 여기서 끝까지 이런 식으로 요런 느낌으로 만들어주면 되겠죠 , 자, 3개 닫아주고 만약에 실패했으면은 return false 그래서 요 팩킷 타입에 대해가지고 PassFromArray를 호출해주는 굉장히 단순한 함수고 그게 아니라 성공했다고 하면은 우리가 나중에 넘겨줄 process func 라는 애로 진행을 시켜 주도록 할 거에요. session.packet. packet을 만들어 줘 가지고 그니까 여기 deserialize 해가지고 여기 있는 정보로 packet을 만들어 준 다음에 그 handle 함수로 이제 전달을 해준다라는 의미가 되는 거죠. 그래서 사실상 뭐 , 이렇게, 일단은, 만들어주는 게 일단 가장 핵심적인 함수구요. 그 다음에 실질적으로 핸들 패킷은 이제 어떻게 만들 것이냐 얘는 어... , 자, 일단 앞에다가 패킷 세션이라는 인자를 하나를 받아 주도록 하겠습니다 아이고, 바이트 , 자, 이제 인자 하나가 추가되는 이유는 뭐냐면은 뭐 지금까지는 우리 그냥 간단하게 테스트를 하기 위해서 뭐 , 이렇게, 핸들 테스트에다가 바이트 버퍼랑 렌스만 받아가지고 처리했지만 나중에 가면은 어떤 클라가 나한테 이 정보를 보내는지가 굉장히 중요해집니다. 그래서 걔한테 뭔가 답장을 보내고 싶다거나 할 때 반드시 패킷 세션, 누군가가 누가 나한테 보내는지를 , 이렇게, 첫 인자로 받아가지고 답변을 해줘야 되는 등등의 상황이기 때문에 이제 인자가 하나가 추가되었어요. 그래서 , 이렇게, 핸들 패킷에 앞에다가 패킷 세션 레프를 받아주도록 할 것이고 그 다음에 먼저 헤더를 까보도록 합시다. 헤더를 까봤더니만 reinterpret 캐스트를 해서 Packet Header Type으로 캐스팅을 해서 얘를 까봤더니만 헤더 아이디를 이용해가지고 우리가 몇 번째 패킷인지를 우리가 테스트할 수 있을 거예요. 그러면 얘를 그냥 그대로 호출해줄 겁니다. 얘를 일단 호출해줘서 이 함수를 호출함과 동시에 Session과 Buffer Length를 그대로 전달을 해주도록 할 거예요. 그리고 이왕이면은 뭐 실패여부도 그냥 다시 뱉어주도록 할게요. 불면으로 만들어가지고 이 턴을 , 이렇게, 때려주도록 하겠습니다. 그럼 이제 남은 일은 초기화를 할 때 우리가 여기 지금 전역으로 할당된 6535개 만큼에다가 각각의 정보를 우리가 다 넣어주면 되겠죠 몇 번은 어떤 함수를 호출해 몇 번은 어떤 함수를 호출해 등등을 만들어주면 되겠습니다 그래서 초기함수를 만들어줄건데 요 부분도 나중에 자동화 처리를 해줘야 되는 대상이죠 자동화 아 초기화가 아니라 자동화 초기화 함수이긴 한데 자동화를 처리해야 된다 요렇게 만들어주면 될거에요 그래서 예를 들면은 이제 뭐 어떻게 만들어줄 수 있냐면은 , 자, 여기서도 여기 위에서 이제 커스텀 핸들러를 우리가 등록을 해줄건데 지금은 좀 헷갈릴 수가 있어요 나중에 동작하는 걸 큰 그림으로 봐야 이해하기가 좀 쉬운데 , 일단은, 그냥 작업을 하시면 되겠습니다 먼저 두 개를 만들어 줄 건데 예제로 Packet, Session, Wrap를 받아주고 Session을 받아주고 Byte, Buffer, Int, Length를 받아주는 함수를 하나 만들어 줄 겁니다 이게 지금 딱 이 모습으로 되어 있는 함수라는 걸 볼 수 있습니다 그러면 이제 이 함수를 여기다가 등록을 할 수 있는 거죠 예를 들면 이런 느낌으로 0번 함수 같은 0번 패킷 아이디가 오면은 이 함수를 호출해줘라라고 우리가 연동을 시켜주는 겁니다. 근데 일단 이 invalid 패킷은 아직 등록되지 않은 그런 패킷 아이디로 올 때 처리를 해주기 위해서 만들어준 거기 때문에 , 일단은, 초기화를 , 이렇게, 해줄 거예요. 모든 애들을 다 하나씩 돌면서 uint64 max까지 하나씩 하나씩 돌면서 다 , 일단은, 초기화를 invalid로 , 일단은, 밀어줄 겁니다. 그래서 잘못된 번호의 패킷으로 오더라도 일단 요 함수가 호출이 될 거다라는 걸 일단 알 수가 있는 거죠 그 다음에 이제 이어가지고 지금 예제를 돌아보자면은 이 패킷 s 테스트라는 게 정의되었을 텐데 얘도 자동화 코드에 의해 가지고 이런 식으로 만들어지게 될 겁니다 s 테스트라는 패킷이 만들어지게 될 것이고 근데 얘는 조금 특이하게 버퍼랑 이 버퍼랑 렌스를 뱉어주기 보다는 프로토콜의 stest 참조를 , 이렇게, 뱉어주도록 할게요 그래야지만 사용하는 쪽에서 편하게 작업할 수 있으니까 굳이 컨텐츠 작업자가 이 버퍼 렌스에다가 이 패킷을 꺼내 쓰는 그런 코드까지 작업할 수 없으니까 이제 이런 식으로 편하게 작업할 수 있도록 만들어 주도록 할 겁니다 그래서 이제 등록을 해줄 것인데 예를 들면 자동화 코드에서 어떻게 만들어 줄 것이냐면은 stest라는 게 들어오면은 이제 이쪽으로 전달해줘야 되는데 근데 원래 우리가 요 함수 자체가 받아주는 packing handler function이 byte 배열이랑 int32를 받아주고 있었으니까 이거를 익명함수 lambda를 이용해 가지고 한번 더 , 이렇게, 전달해 주도록 할 거예요 session buffer length를 만약에 들어왔다고 하면은 return 이거를 만들어 줘 가지고 이제 패킷을 만들어 준 다음에 호출해줘라 라는 의미로 여기 있는 핸들 패킷 이라는 것을 호출해줄 겁니다. 그래서 프로토콜의 s 테스트로 이제 호출하면 되고 그 다음에 이제 프로세스 펑크 요 아이를 넣어줘야 되는데 걔를 이 핸들 테스트로 요렇게 건네주도록 할 거에요. 그 다음 나머지 인자는 Session, Buffer, Length로 그대로 , 이렇게, 전달을 해주시면 되겠습니다. 요렇게 , 일단은, 코드가 만들어지게 될 겁니다. , 자, 요렇게 만들어주면 되구요 어... , 자, 지금 에러가 나는거는 뭔가 짝이 안맞는거 같은데 어디가 안맞을까요? 아 마지막에 아 마지막에 이게 빼서 들었네요 , 자, 요렇게 , 일단은, 만들어주면 되겠습니다 그래서 Lambda로 , 일단은, 익명함수를 만들어줘서 결국에는 이 PKTS 테스트, 즉 지금 1번이죠? 1번으로 만약에 패킷 아이디가 왔다고 하면은 얘 함수를 이제 호출해줄 것이고 이 Lambda 함수를 호출해줄 것이고 얘가 호출이 되면은 Session Buffer Length를 받아가지고 그거를 지금 요렇게 요 함수한테 또 떠넘기고 있죠? 핸들 패킷으로 다시 떠넘기고 있는데 S 테스트랑 핸들 S 테스트를 넣어줬기 때문에 걔가 다시 핸들 패킷 아래로 타고 가면은 이제 요 아이로 이 첫번째 템플릿이 s 테스트로 만들어질 거니까 이 패킷 테스트가 s 테스트라는 패킷을 만든 다음에 그거를 pass from array를 이용해가지고 채워줄 것이고 그 다음에 만들어진 애를 이제 handle function으로 func로 전달해 주게 될 겁니다. 우리는 지금 handle s 테스트라는 애로 넘겨주도록 유도를 해줬죠. 요 아이로 이제 넘겨줘라라고 우리가 부탁을 해준 셈이 되는 겁니다. 그리고 참고로 요런 애들 같은 경우에는 구현부를 자동화하지 않고 이제 이거는 컨텐츠 작업자가 직접 만들어야 됩니다 무슨 얘기냐면은 임플레멘테이션을 나중에 이런 식으로 만들어주게 될 것인데 요 부분은 자동화 영역이 아니라 직접 컨텐츠 작업자가 적는 영역이라는 거죠 이제 어떻게 처리할 것인지를 근데 이거는 왜 자동화하지 않느냐 그건 당연한 얘기지만 이제 컨텐츠에서 무엇을 할지는 당연히 툴에서 알 수가 없죠 여기서 이제 뭐 로그인을 하건 처리를 하건 아니면은 뭐 게임에 접속을 해가지고 뭘 하건 이런 식으로 이제 컨텐츠 코드가 여기 안에 들어가기 때문에 이런 부분들은 자동화를 할 수 없고 이제 알아서 만들어줘야 된다는 얘기가 드는 거죠 근데 이 이름 컨베이션은 지켜주도록 할 겁니다 즉 에스트 테스트라는 패키지 있다고 하면은 뭐 이런 식으로 핸들 에스트 테스트라거나 이런 함수 이름은 그대로 컨베이션을 지켜가지고 결국에는 이 왼쪽에 있는 요 전체 부분은 우리가 툴을 이용해가지고 생성을 해줄 것이고 이 오른쪽 부분만 우리가 직접 만들어주면 된다라는 얘기 되는 거죠 그래서 결과적으로 프로토 파일을 작업을 한 다음에 빌드를 해가지고 요 파일이 자동 생성되면 유일하게 그 다음에 해야 되는 거는 요 핸들 부분 요 부분만 일단 만들어가지고 채워주면 된다라고 보시면 되는 거고 뭐 이전에 C샵 서버 강의를 보신 분은 알겠지만 거의 뭐 비슷한 느낌으로 만들었었죠 그냥 패킷을 만든 다음에 배치 파일을 돌리면 요런 핸들러가 핸들러가 호출이 될 것이고 이런 함수들만 우리가 직접 만들어서 사용을 했으면 됐습니다. 뭐 그런 똑같은 느낌으로 , 일단은, 만들어 보게 될 거에요. , 자, 그래가지고 뭐 지금 코드가 대충 요런 느낌으로 , 일단은, 만들어질 것이다 라는 걸 일단 알 수 있었구요. 자동화해야 되는 코드들이 몇가지가 보이죠? 지금 요 부분 요 부분 쫙 늘려주는 부분 자동화 처리 해줘야 되구요. 그 다음에 요 부분도 자동화 처리 해줘야 되고 그 다음에 요 부분도 자동화 처리 해줘야 되고 얘도 역시나 자동화 처리를 해서 여기 선화나는 부분까지는 자동화 처리를 나중에 해줘야 될 겁니다. 그래서 , 이렇게, 크게 4가지 부분이 있을텐데 나머지 부분은 딱히 건드릴 필요가 없을 것 같네요. , 자, 이렇게, 일단은, 구현을 해서 다시 한번 빌드를 해서 별다른 문제가 없는지 , 일단은, 확인을 해보도록 하겠습니다. 딱히 문제가 없다고 하면 될건데 지금 문제가 일어나고 있는거는 아 요 부분 게임 세션에서 이제 우리가 함수 어 호출을 살짝 바, 바꿔야 되겠죠? 예를 들면은 패킷 세션 래프를 자기 자신의 누구인지를 건네줘야 되니까 패킷 세션 래프로 요렇게 받아가지고 얘를 이런 식으로 건네주는 식으로 만들어주면 되겠습니다 그리고 , 사실, 여기서도 한번 더 헤더를 체크해가지고 나중에 가게 되면은 우리가 지금은 간단하게 하고 있으니까 더미 클라이언트랑 서버랑 1대1로 통신하고 있지만 나중에 가면 굉장히 다양하게 물릴 수가 있어요 서버가 하나만 있는 게 아니라 얘는 이제 게임 전투와 관련된 그런 기능을 하는 서버고 db 저장과 관련된 부분은 딴 서버에서 처리하고 이런 식으로 분산해서 처리할 수 있기 때문에 그럴 경우에 라고 한다면 이제 이 패킨 헤더를 참고해 가지고 요 id 대역대를 봐 가지고 이 대역대로 가면은 이 서버 팩킷과 관련된 부분이구나 라고 해서 넘겨주면 되고 이거는 어 클라이언트가 보내준 거네 라고 하면은 클라이언트 쪽 핸들러로 넘겨주면 되고 이런 식으로 분리를 해줄 필요가 있습니다 이거 지난번에도 제가 말씀을 드린 적이 있지만 팩킷 설계할 때 은근히 중요한 게 뭐냐면은 우리가 만약에 직접적으로 관리하고 있는 DB 서버랑 게임 서버랑 통신을 하고 있는데 둘 사이에서만 사용할 거라고 예측해가지고 팩킷을 만들어놨는데 나중에 클라이언트 쪽에서 해킹해가지고 팩킷 조작으로 그 팩킷으로 만약에 조작해가지고 건네주게 되면은 그런 부분들도 거를 수가 있어야 됩니다 그래서 얘가 만약 클라이언트가 보낸 쪽이라고 하면은 정말로 클라이언트랑 관련된 패킷만 실행이 될 수 있도록 유도를 해줘야 된다는 얘기가 드는 거죠 그래서 나중에는 여기서도 뭔가 뭐 패킷 아이디 대역 체크 등등이 이제 들어가야 된다라고 일단 볼 수가 있겠어요 네 뭐 지금 그건 당장 하지 않을 것이고 아까 레퍼런스로 패킷 세션 레프에 넘긴 게 여기서 보면은 얘를 일단 세션으로 추출하면서 레퍼런스 카운트 1 증가시켰는데 얘가 소멸이 되지 않는 한 어차피 레퍼런스 카운트는 0이 되지 않을 거니까 그 다음부터는 넘길 때 잠시 레퍼런스 카운트 증가하지 않고 그냥 , 이렇게, 넘긴 겁니다 어차피 요 부분에서 당장 레퍼런스 카운트를 1 증가하건 안하건 실질적으로 소멸에는 영향을 주지 않기 때문에 얘를 레퍼런스로 지금 넘기고 있다 그래야지 성능이 조금 더 좋아지니까 요렇게 일단 만들어 줬다 하고 보시면 되겠어요 , 자, 그래서 , 이렇게, 만들어 보고 뭐 나중에 가면은 이제 결국에는 이쪽은 우리가 작업을 안 했지만 아까 우리가 만들어 준 이 서버 패킹 핸들러랑 완전히 똑같이 대칭적으로 얘가 이제 만들어져야 된다는 얘기가 되는 거죠 아 그리고 지금은 우리가 테스트하기 위해서 모든 애들을 다 이쪽에다 넣어 놨지만 실제적으로 나중에 작업할 때는 s 테스트는 서버가 클라한테 보내는 용도였으니까 어 보내는 용도로만 사용할 거니까 Make Sand Buffer는 만들어지는 게 맞지만 여기 핸들러 등록하는 거는 반대쪽 클라이언트 쪽에 클라이언트 패킷 핸들러 쪽에 , 사실, 등록이 돼야 되는 부분입니다. 크게 모양만 일단 만들어 본 거예요. , 자, 그래가지고 뭐 , 이렇게, 코드가 만들어지는데 지금 , 이렇게, 만든 코드 상에서는 이제 이걸 사용할 때 초기화를 일단 한 번 해가지고 여기 패킷 핸들러를 누군가가 채워주긴 해야 되는데 뭐 그 부분은 , 일단은, 그냥 여기서 처음에 게임서버가 실행이 될때 먼저 서버패킷 핸들러를 초기화를 , 이렇게, 해주면 되겠죠. 이거는 뭐 큰 문제는 아니고 얘네들을 빵 채워준 다음에 이제 진행을 하면 된다라고 , 일단은, 보시면 되겠습니다. , 자, 이렇게, 해가지고 , 일단은, 모양을 한번 잡아봤는데 요 부분이 이제 뭐 좀 어렵게 느껴지실 수도 있겠지만 이게 완성이 한번 되면은 굉장히 편하게 작업을 할 수가 있게 됩니다. 딱 요 부분만 우리가 이제 건드리면서 작업하면 된다는 거죠. 그리고 얘는 이제 invalid라고 해가지고 뭔가 잘못된 패킷이 왔을 때는 대부분 뭐 , 이렇게, 처리해주게 되겠죠. 패킷 헤더를 까봐가지고 interpret, cast를 해서 패킷 헤더를 살펴본 다음에 로그는 찍어주는 게 좋긴 할 겁니다 대부분 이런 식으로 얘가 어떤 패킷을 보냈는데 뭔가 이상해 라고 로그를 찍은 다음에 return false로 실패했다라고 일단 찍어주면 될 것이고 얘는 이제 진짜로 콘텐츠 작업을 여기서 해주면 된다는 얘기가 되는 거죠 그래서 , 이렇게, 작업을 할 것이다 라고 결론을 내릴 수가 있고 이제 다음 시간에 아까 얘기한 이 왼쪽 부분을 자동화 처리를 하는 툴을 만들어보는 내용에 대해서 , 일단은, 실습을 해볼 거예요 이것도 이제 굉장히 재미있는 부분인데 이건 다음 시간에 , 일단은, 이어서 해보도록 하겠습니다.