자, 이렇게, 해서 우리가 지난 시간까지 요렇게 간단하게 메모리 풀을 한번 만들어 봤습니다 그리고 , 사실, 이걸 실전에서 쓴다고 해도 크게 문제가 없을 정도로 괜찮은 방법이기는 해요 , 이렇게, 메모리 풀을 사용하는 게 근데 여기서 굳이 굳이 개선할 점 그리고 좀 아쉬운 점을 일단 꼽아 보자면 이제 앞으로 메모리 활동은 굉장히 자주 일어날 일이 되겠죠 여기서 조금이라도 뭔가를 향상시킬 수 있으면 그게 의외로 뭔가 나비 효과처럼 크게 영향을 줄 수가 있는 부분입니다 , 자, 그런데 굳이 여기서 좀 아쉬운 점을 꼽아보자면 , 일단은, 이렇게, 락을 걸어 가지고 접근을 하는 부분이 있겠죠 그래서 만약에 이제 우리가 스레드가 몇십 개씩 동작을 해가지고 동시에 메모리를 바나나 한다거나 팝을 한다거나 할 때 이런 식으로 잠시나마 서로 경험을 해가지고 락을 걸어 가지고 꺼내 온다라는 게 조금 아쉬운 점이고요 그리고 두 번째로는 이제 우리가 , 이렇게, 여분으로 임시로 저장해주는 그런 메모리들을 , 이렇게, 큐에다가 조정을 하고 있습니다 그래서 이게 약간 두 가지의 개선점이라고 할 수 있긴 한데 물론 이거 자체로도 나쁘진 않아요 근데 이제 큐라는 것 자체가 혹은 이걸 이제 벡터라거나 스택으로 만들었을 때 마찬가지겠지만 내부적인 구현 자체가 뭔가 동적 배열 방식으로 되어 있습니다 그래가지고 결국에는 우리가 어떤 데이터를 넣어주기 위해서 그 데이터를 할당하기 위한 공간도 같이 , 이렇게, 만들어지게 되겠죠 그래서 이제 그런 부분을 이제 어떻게 개선할지 한번 생각을 해보겠습니다 , 자, 근데 이거는 그냥 말로 하기보다 코드로 보여드리는 게 나을 것 같아 가지고 , 일단은, 오늘 잠시 뭔가 테스트 코드를 만들 lock-free-stack 이라는 걸 한번 만들어 보도록 할게요 , 자, 이제 오랜만에 lock-free-stack 이라는 게 다시 등장을 했는데 제가 락프리 큐랑 락프리 스택에 대한 내용을 쭉 다뤘고 저는 굉장히 싫어한다고 했지만 그럼에도 불구하고 , 사실, 제가 모든 내용을 다 다룬건 아닙니다 좀 다른 방법이 있어요 , 자, 그래가지고 우리가 이전 시간에 만들었던 그 스택 방식을 곰곰이 복귀를 해보면 요렇게 노드라는 거를 개입시켜가지고 노드 안에 데이터를 넣어주고 그 다음에 해당 노드에서는 다음 노드를 가리키는 이런 방식으로 우리가 , 일단은, 만들어봤습니다 그런데 이 방식의 단점이라고 한다면 우리는 , 사실, 이 데이터를 만들어주고 싶은 건데 얘를 만들어주기 위해서 이 노드를 동적으로 할당해 가지고 그 데이터를 안에다가 넣어 줬었죠. 사실상 데이터 하나를 관리하기 위해서 노드를 만들어 주고 그 다음에 데이터를 넣어주고 , 이렇게, 두 가지 부분으로 이게 나뉘어 있다는 게 조금 마음에 안 듭니다. 그래가지고 우리가 결국에는 이 락프리 스택을 만들어 준다고 했을 때, 어차피 락프리 방식 자체가 뭔가 어마어마하게 큰 동적 배열을 이용해서 만든 건 아니었고 , 이렇게, 노드 기반으로 만든 다음에 이거를 컴퓨언 앤드 스왑 연산을 막 해가지고 우리가 이리저리 스택을 구현했었던 거를 이제 기억을 할 수가 있는데 , 사실, 이거보다 조금 더 좋은 방법이 하나가 더 있어요 그게 뭐냐면은 , 이렇게, 노드를 동적으로 만드는 비용까지 아끼기 위해서 데이터 안에다가 , 사실, 이렇게, 노드와 관련된 부분을 낑겨 넣는 거죠 , 자, 그래가지고 어 이게 뭐 일반적으로 그 리스트를 만들 때도 똑같은 얘기인데 , 이렇게, 노드 단위로 만들어 가지고 다음 데이터를 가리키게 만들어도 되지만 , 자, 이런 식으로 오늘 테스트 할 것은 일단 s-list-entry라는 이름으로 간략한 struct를 하나를 만들어 보도록 하겠습니다 그래서 얘가 , 일단은, 기본적으로 다음 이라는 어 그런 변수를 , 이렇게, 들고 있을 거예요 한마디로 요 노드에서 이 넥스트 노드를 가리키는 게 , 사실, 요 부분이라고 말할 수가 있는 거고 이제 우리가 실질적으로 데이터를 만들어 줄 때 어떤 데이터를 만약에 우리가 사용한다고 가정해 볼게요 그러면 이거를 s-list를 상속을 받거나 아니면은 여기다가 첫번째 멤버 변수를 무조건 이 s-list 엔트리로 요렇게 낑겨 넣어주는 겁니다 두가지 옵션이 있는데 뭐 , 일단은, 이 멤버 변수로 들고 있는걸 예로 들어 보도록 할게요 그 다음에 여기 안에다가 이제 뭐 필요한 데이터 뭐 hp 라거나 아니면은 뭐 np 라거나 하는 등등의 추가 정보를 요렇게 만약에 우리가 넣어주고 관리를 한다고 하면은 어 사실상 우리가 사용하던 이 node라는 것 자체가 이 전체 데이터에 낑겨 넣어 가지고 이제 한 번에 관리가 될 수 있다는 얘기가 되는 거죠 물론 요 방법의 단점이라고 하면 한다면은 위에서 사용했던 요 방식처럼 그냥 아무 데이터나 여기다가 낑겨 넣어가지고 만들어주는 건 아니고 우리가 애당초 데이터를 설계할 때 이 S-list 엔트리를 같이 포함해줘야 되기 때문에 뭔가 외부 라이브러리에서 이미 잘 설계된 클론 클래스 같은 경우에는 이 방식을 사용할 수 없겠지만 그게 아니라 메모리 풀처럼 우리가 정말 미세하게 이 데이터 자체를 지금 우리가 관리하고 있는 상태라고 한다면 이런 방법도 일단 충분히 사용할 수 있다는 얘기가 되는 거죠 그래서 이 방식에 대해서 , 일단은, 조금 깊이 고민을 해볼 예정입니다 , 자, 그런데 어쨌든 이게 락프리 방식이다 보니까 생각보다 좀 난이도가 있습니다. 그래가지고 여러가지 단계에 걸쳐가지고 이걸 한번 보여드릴까 하는데 제가 늘 하는 , 일단은, 1차 시도라고 뭔가 , 이렇게, 주석을 걸어가지고 영역을 일단 표시를 해보도록 하겠습니다. 그래서 , 일단은, 이런 기본적인 방식으로 , 일단은, 한번 다시 락프리 스택을 구현을 해보겠다라는 얘기를 하고 있는 거고요. , 자, 그리고 오늘 공부할 내용이 이어서 다음 시간에 알아볼 내용이랑 조금 영어성이 있어가지고 이 락 프리스택을 그냥 클래스로 만들지 않고 조금 특이하게 만들어 보도록 하겠습니다 , 일단은, s-list header라고 header를 , 이렇게, 또 만들어 줄 거예요 SlistEntry, Next는 NullPtr 요렇게 , 일단은, 헤더라는 애를 들고 있도록 하겠습니다 그래가지고 어찌됐건 데이터가 표시될때는 어떤 헤더라는 개념이 있어가지고 요 헤더가 첫번째 데이터를 , 일단은, 가리키고 있는 상태가 될겁니다 즉 요 아이가 무조건 첫번째 데이터를 가리킬 것이고 첫번째 데이터는 그 다음 데이터를 가리키고 이런 식으로 막 이어져 있는 거죠 근데 실질적으로 우리는 이 S-List 포인터로만 관리를 할 거지만 실질적으로 그 데이터는 S-List보다는 더 클 수가 있다는 얘기가 되는 거죠 여기 나머지 데이터들도 낑겨있을 거니까 그래가지고 , 사실, 일부만을 이용해가지고 그 노드를 표현하고 있지만 데이터는 같이 그 다음 부분에 낑겨있는 그런 상태라고 , 일단은, 이해를 해주시면 되겠습니다 근데 이게 일반적으로 리스트를 만들 때 그런 동적 배열을 이용하지 않고 , 이렇게, 노드 기반으로 만약에 우리가 한다고 했을 때 이런 방식으로 만드는 것도 굉장히 잘 알려진 방법이죠. , 자, 그 다음에 이제 의사 코드를 하나씩 만들어 볼 건데 우리가 결국에는 오늘 해볼 거는 stack을 만들어 보고 싶은 거예요 그래가지고 stack 같은 경우에 , 일단은, q 보다는 훨씬 더 간단하게 만들 수 있다는 걸 우리가 살펴봤는데 , 일단은, 초기화하는 코드 initialize header 라고 해가지고 이 header를 초기화하는 부분을 일단 만들어 줄 거고요 , 자, header 그 다음에 두 번째로 push-entry-as-list 라고 해가지고 이 스택에다가 데이터를 밀어넣는 작업을 정의해 주도록 하겠습니다. 어떤 헤더에다가 우리가 추가하고 싶은 데이터를 이 엔트리를 밀어 넣어주겠다라는게 일단 두번째 함수구요 마지막으로 pop 우리가 이제 데이터를 꺼내가지고 사용하고 싶을때를 pop-entry-as-list란 이름으로 , 자, 요렇게 만들어 보도록 하겠습니다 그 다음 얘는 , 일단은, 헤더를 요렇게 받아줘가지고 데이터를 리턴해줄거고 한마디로 우리가 사용하고 있는 그 스택 이 스택이라는거 자체가 이 헤더만 알고 있으면은 거기서 데이터를 넣어주고 꺼내주고 하는 작업을 한다고 , 일단은, 볼 수가 있겠습니다 , 자, 요걸 , 일단은, 만들어 볼 건데 일단 초기 상태는 이 헤더가 아무것도 가리키고 있지 않는 상태다 보니까 그냥 뭐 , 이렇게, 일단은, 밀어 줄 수가 있고 그 다음에 이 헤더가 이제 첫 번째 데이터를 뭔가 가리키게끔 어떤 데이터를 이 헤더에다가 이제 밀어 넣는 작업을 , 일단은, 만들어 보도록 할게요 근데 , 일단은, 늘 하듯 멀티스레드 환경을 무시하고 이게 싱글스레드라고 가정을 하고 만약에 만들어 준다고 하면은 , 자, 이전에 헤더라는 애가 비어있을 수도 있고 아니면 어떤 데이터를 가리킬 수도 있겠지만 무조건 이 첫 번째 데이터를 지금 가리키고 있는 상태가 될 겁니다 그러다 보니까 여기다가 데이터를 밀어넣는다 하면 결국 지금 이 상황인 거죠 여기서 새로운 데이터를 만들어 가지고 여기다가 지금 , 이렇게, 밀어 넣고 원래 헤더였던 애를 이 다음 애로 , 이렇게, 연결시켜주는 작업을 해야 되기 때문에 엔트리의 넥스트를 원래 기존에 헤더가 가리키고 있던 I를 , 이렇게, 가리켜 줄 겁니다 헤더의 Next가 지금 이 포인터예요 얘가 지금 , 이렇게, 되어있다가 보는 게 좀 낫겠네요 얘가 Next 포인터가 있는데 걔가 실질적으로 어떤 데이터를 가리키고 있다고 일단 생각해 주면 되겠습니다 , 자, 그 다음에 그래서 요 지금 데이터를 원래 가리키고 있던 원래 대장을 지금 , 이렇게, 바꿔치기 해준 다음에 그 다음에 이제 새로운 대장을 헤더의 넥스트를 엔트리로 , 이렇게, 바꿔치기를 해주면 새로운 데이터가 , 이렇게, 추가가 되는 걸 우리가 만들어 줄 수가 있겠죠 이걸 이제 스택의 푸쉬라고 , 일단은, 생각해 줄 수가 있을 거고 팝은 반대로 이 헤더가, 이 헤더 넥스트라는 애가 가리키고 있던 애를 뽑아가지고 얘를 이제 밖으로 배출해주면 되겠습니다. 뭐 굉장히 단순하죠? 그러다보니 이것도 뭐 만들어보자면 엔트리를 First라고 할까요? 첫번째 데이터를 , 일단은, 꺼내가지고 어..무슨 얘를 이제 반환하긴 할건데 만약에 null이 아니다 라고 하면은 null이 아니라고 하면은 여기다가 header의 next, 이제 header를 first의 next로 바꿔치기를 하시도록 하겠습니다. 즉, 얘가 만약에 null이 아니었다고 하면 데이터가 있다는 거니까 이 다음 아이를 어... 이제 새로운 리더로 인정해주가지고 이 넥스트가 얘를 가리키게 만들어 준다는 얘기가 되는 거죠 물론 만약에 데이터가 한 개밖에 없었다고 해도 상관없는 게 얘는 빠져나오고 얘가 가리키고 있거나 다음 데이터가 널 포인터일 테니까 얘가 이제 널 포인터를 가리키게 만들어줘서 그냥 빈 상태가 , 이렇게, 될 겁니다 그 어떤 경우든 요렇게 , 일단은, 만들어 주면 된다는 얘기가 되는 거죠 , 자, 이렇게, 해가지고 뭐 간단하게 이 , 사실, 노드와 비슷한 느낌인데 실질적으로 이 넥스트 포인터 자체가 이제 데이터에 추가된 형태로 우리가 뭔가를 만들어 봤어요 실질적으로 얘를 사용할 때는 뭐 어떻게 하면 되냐면은 , 일단은, 이 애슬리스트 헤더라는 거를 먼저 만들어 준 다음에 그 다음에 데이터를 만들어 줘 가지고 거기다가 밀어 넣어주면 되겠죠 그러니까 이거를 뭐 잠시 한번 예를 들어보자면 약간 이런 느낌으로 사용하면 되겠습니다 , 자, 일단은, 여기다가 락 프리 스택을 추가해준 다음에 요 내용을 일단 좀 삭제를 해보도록 할게요. 더 이상 필요 없으니까 쭉 삭제를 해주고 굳이 이제 한번 사용을 해보자면 우리가 어떤 데이터를 이제 만들어 줄 때 요런 식으로 만들어 줄 거고 그 다음에 처음에 시작을 할 때는 헤더를 하나를 만들어 줄 것이고 요기다 만들어 줄거야 그냥 헤더 헤더를 처음에 이니셜라이즈를 해줘가지고 이니셜라이즈 헤드를 호출해줘가지고 , 자, 요렇게 헤더를 넣어줘가지고 사실상 우리 스택을 초기화를 해준 다음에 데이터를 밀어넣고 싶으면은 그 다음에는 요 푸쉬함수를 호출해가지고 요게다가 헤더와 그 다음에 새로 만들어준 데이터를 밀어넣어주면 되는거죠 만약에 우리가 요 데이터를 만들어줬다 얘는 뭐 이쪽에다 일단 끄집어보도록 할게요 그렇다고 한다면 요게다가 뭐 예를 들면은 뉴 데이터를 한 다음에 이 데이터를 만들어 줬을 때 첫 멤버 변수가 S 엔트리다 보니까 얘를 캐스팅을 그대로 S 엔트리 로 해줘도 상관이 없겠죠 그러다 보니까 예를 들면은 S 리스트 엔트리 로 얘를 바꿔치기 해 줘 가지고 얘를 그대로 속여서 넣어주게 되면은 애당초 메모리 구조상 데이터도 결국에는 일부분은 s-list를 포함하고 있기 때문에 이 포인터를 치환해서 넣어줘도 어차피 나머지는 신경 쓸 필요 없기 때문에 이 부분만 , 일단은, 이렇게, 잘 넘겨받아 가지고 작동을 하게 될 겁니다 그리고 마찬가지로 데이터를 만약에 우리가 꺼내 쓴다라고 하면 pop-entry-list를 해가지고 마찬가지로 header에서 데이터라고 할까요? 뭐 이런식으로 얘를 꺼낼 수 있다는 얘기가 되는거죠 여기서는 거꾸로 애슬리슨 엔트리를 받아주니까 이거를 거꾸로 , 자, 일단 데이터로 , 이렇게, 캐스팅을 해주면 되겠습니다 저 1번 시그네는 캐스팅이 굉장히 많이 등장하니까 그리고 이거를 이제 뭐 장기간 동안 이걸 계속 사용할 건 아니다보니까 , 이렇게, 간단하게 C스타일의 캐스팅을 일단 했고요 뭐 , 이렇게, 해줄 수가 있겠죠 그래서 여기서 만약에 뭐 HP가 10이었고 그 다음에 NP가 뭐 20이었다라고 하면은 이제 얘를 똑같이 실행해보면 이제 그대로 그 데이터가 튀어나오게 될 겁니다 아 지금 발생하는 요 뭐 컴파일 문제는 우리가 구현부까지 다 헤더에다가 넣어 놔 가지고 그런 거니까 얘를 잠시 , 이렇게, 구현부를 cpp 로 옮겨 놓고 이쪽에다가는 그냥 선언만 , 이렇게, 해주고 다시 빌드를 해주면 되겠습니다 , 자, 그러면은 결국에는 다시 게임서버 들어와서 이걸 살펴보면은 데이터를 처음에 밀어 넣어준 다음에 그 다음에 데이터를 그냥 고지곳대로 다시 꺼내 가지고 , 이렇게, 10이랑 20이라는 값이 정상적으로 들어가 있다는 것도 알 수가 있는 겁니다 그래서 , 이렇게, 가지고 우리가 이제 스택을 사용할 것인데 근데 이제 여기서 좀 아쉬운 문제는 , 사실, 이거 자체가 우리가 그냥 간단하게 만들어 본거고 싱글스레드 환경이라고 하면은 뭐 잘 동작할 수 있겠지만 멀티스레드 환경에서는 당연히 뭐 , 이렇게, 하면은 온갖 문제가 일어나죠 우리가 계속 알아본 바와 같이 이 정도로는 불충분합니다 , 자, 그래가지고 어 이제 이어가지고 이거를 멀티스레드 환경으로 바꿔보는 작업을 할 건데 이거에 대해서도 할 얘기가 굉장히 많아요. 이 부분은 이제 제가 주석으로 , 일단은, 남겨놓고 여러분 혹시 코드를 보실 수도 있으니까 주석으로 하고 이제 이걸 복붙해 가지고 이어서 작업을 해보도록 하겠습니다. , 자, 여기서 여기까지는 잠시 , 이렇게, 주석을 처리를 하도록 하고 이제 이어가지고 이거를 2차 시도라고 해가지고 멀티셋 환경에서도 잘 동작을 하게 한번 유도를 해 보도록 할게요 , 자, 그런데 뭐 모든걸 다 복붙하진 않을 거고 , 일단은, 기본적으로 요 부분 그리고 요 부분은 다시 살려 가지고 여기다가 추가적으로 코드를 뭔가를 넣어 주도록 하겠습니다 , 이렇게, 자, 그래서 2차 시도에서는 이거를 결국에는 Compare and Swap 방식으로 바꿔야 된다라는 얘기가 되는 거고요 그러면은 얘랑 얘는 일단 살려둔 상태로 이 오른쪽에 가지고 얘를 어떤 식으로 Compare and Swap을 사용할 수 있는지를 한번 고민을 해봅시다 , 일단은, 당연한 얘기지만 뭐 이니셜라이트 헤드는 초교하는 부분이니까 얘는 그냥 싱글스레드 방식에서 한다고 가정을 하고 여기부터 푸쉬랑 팝이 다중스레드 환경에서 뭔가 동작할 수 있지 않을까라고 생각을 할 수가 있는데 , 자, 일단은, 푸쉬 같은 경우에는 우리가 컴퓨터 핸드스톱 연산에 대해서 쭉 알아봤었죠? 그러니까 사실은 여기서 얘를 헤더를 이용해가지고 꺼내준 다음에 그 다음에 이 엔트리를 헤더에다가 다시 , 이렇게, 넣어주는 이 단계가 중간에 누군가가 끼어들 수 있어가지고 문제가 되는 거였죠 근데 우리가 계속 알아봤던 그런 Interlocked 계열을 사용하면은 뭐 우리가 아토믹으로 만들어 줬지만 얘가 Interlock Compare Exchange라는 요런 함수도 똑같이 존재를 하니까 이걸 일단 사용해 보도록 할게요 그래서 여기 64는 64 비트를 지원한다는 얘기가 되는 거고 이게 128까지도 있습니다. 여러 가지 크기에 따라서 우리가 선택을 할 수 있고요. 그 다음에 여기다가 넣어주는 것은 , 일단은, 어떤 정수를 넣어줄 건데 우리 같은 경우에는 header의 next에 있는 이 주소값을 넣어줘서 이 주소값에 있는 것을 , 일단은, 넣어볼 것인데 그 다음에 원래 우리가 atomic 계열의 함수를 만들 때는 expected랑 desired라는 게 있었는데 얘는 이제 순서가 뒤바뀌어 있습니다 여기다가 desired를 넣어주고 그 다음에 expected를 넣어주면 되는데 그렇다는 것은 우리가 최종적으로 튀어나오기를 원하는 값은 entry일 것이고 그 다음에 비교하고 싶은 대상은 entry의 next를 , 이렇게, 넣어주면 되겠죠 즉 next랑 이 entry next를 비교해가지고 둘이 같으면은 이 값이 1로 들어오게 될 것이고 실패하면 0을 리턴하는 뭐 그런 방식으로 동작을 하게 될 겁니다 그래서 이걸 , 이렇게, 만들어 주면 결국 아까 하던 요 부분이 1 플러스 원으로 낑겨 가지고 동작을 하게 된다는 걸 우리가 여러 차례 일단 실습을 해 봤습니다 그래서 얘가 이제 실패를 할 동안 계속 뺑뺑이를 돌아라 라고 해 가지고 요렇게 , 일단은, 만들어 주면 될 것 같다는 생각이 들고 그 다음에 이어서 팝 엔트리 리스트 같은 경우에도 지금 이 부분이 문제가 되고 있죠? 얘가 , 이렇게, 꺼내온 다음에 얘를 호출하는 순간에 또 누군가가 끼어들 수 있으니까 이것도 우리가 대충 어떤 느낌으로 만들어놨으냐면 이걸 일단 expected라는 이름으로 바꿔줄게요. 그 다음에 expected null 체크를 한 다음에 얘가 null이 아니라고 하면 역시나 interact compare exchange64를 호출해가지고 얘도 , 일단은, 주소를 넣어줄 것인데 헤더에 next라는 요 아이가 그 다음에 여기다가 비교할.. 그니까 넣어줄 애는 expected를 넣어줄 것이고 어.. 그 다음에 아 이건 expected next를 넣어줄 것이고 그 다음에 얘를 요렇게 만들어주면 되겠죠 이거 좀 길어지긴 하는데 얘가 0이면은 실패했다는 얘기니까 계속 호출해라라고 , 이렇게, 일단은, 만들어주면 되겠습니다. 뭐 일단 한 줄에도 크게 상관없으니까 , 이렇게, 보여드리려고 할게요. 그러면은 결국에는 얘도 어.. 요 넥스트에 있는 요 값이 얘랑 우리가 예상한 값이랑 같은지를 체크해가지고 만약에 둘이 같으면은 이제 요 값을 두번째 값이 들어가게 될 겁니다. , 자, 그런데 만약에 빠져나왔다 가면 그냥 얘를 return 하면 되는데 근데 여기서 이제 문제가 되는 거는 뭐냐면은 우리가 이전에도 알아봤지만 여기서 삭제할 수 있는 경우가 생긴다는 얘기가 있었죠 그래가지고 내가 여기서 이 header의 next를 꺼내가지고 이제 만약에 얘가 null이 아니어서 우리가 그 다음 애를 꺼내 쓰려고 하는 상황이 있다고 가정해볼게요 그러니까 다시 요 그림으로 복습을 해보자면은 여기서 데이터가 뭐 , 이렇게, 3개가 있었는데 지금 이 상황인 거죠 header의 next를 꺼내 가지고 즉 요 아이를 우리가 꺼내 오고 싶은 건데 얘를 꺼내 오기 위해서 이 compound exchange를 막 하려고 하고 있는데 그 사이에 찰나에 누군가가 얘를 꺼낸 다음에 삭제를 했다고 하면은 사실상 여기 expected의 next를 우리가 꺼내 가지고 사용하려는 순간에 벌써 여기서 크래시가 나게 될 겁니다 뭐 요런 문제가 있기는 합니다 그런데 그 중간에 누군가가 삭제하는 문제는 , 사실, 우리가 락 프리 스택이랑 락 프리 스택 큐에 대해서 다뤄보면서 이전 시간에 신나게 알아봤었죠 그래서 그때 이걸 해결하기 위해서 여기다가 레퍼런스 카운팅을 하거나 팝을 하고 있는 애들의 카운팅을 해가지고 정말로 누군가가 여기서 건드리고 있으면 그 해당 메모리를 날리지 않는 등등의 방법을 사용했었어요 물론 지금은 상황이 조금 더 복잡해진 이유는 우리가 그렇게 관리할 수 있었던 이유는 애당초 노드라는 개념이 들어가서 그 노드 객체를 우리가 락 프리스택 안에서 관리했었기 때문인데 지금은 애당초 그 노드라는 것 자체가 어떻게 보면 데이터에 포함이 되어 있어서 걔를 뱉어주기 때문에 조금 더 상황이 복잡합니다 그런데 정말 운 좋게 밖에 있는 애가 이 데이터를 당장 딜리트를 하지 않고 뭔가 살려둔다고 가정을 해봅시다 , 일단은, 다른 문제를 지금 논할 거여서 그렇다고 하면 , 일단은, 여기서 이미 날린 포인터를 참조하는 문제는 해결이 될 테니까 그 문제는 , 일단은, 없다고 가정을 해보는데 , 자, 그러면은 거꾸로 얘기해서 그 문제가 없으면 지금 요 코드가 안전한가에 대해서 이제 논해 보도록 할게요 근데 사실은 요런 코드가 또 다른 문제가 하나가 더 있는데 이게 지난번에 우리가 lock-free-queue랑 lock-free-stack을 다룰 때는 제가 굳이 언급을 하지 않았어요 왜냐면은 굉장히 복잡한 내용인데 정작 우리가 사용했던 방법에서는 발생하지 않는 문제여 가지고 말씀을 안 드렸는데 이런걸 이제 aba-problem이라고 합니다 aba 문제 굉장히 용어가 재밌죠? 전 처음에 뭔 압박문제라고 했나 했는데 이게 ABA라고 읽어주시면 되는거고 요 문제 자체는 , 사실, 단어에 해답이 있어요 이게 뭘 얘기하는 거냐면은 A라는 상태에서 B라는 상태가 됐다가 다시 A라는 상태로 된 상황이라는 거죠 근데 우리가 compare and swap을 할 때 유심히 보면은 지금 비교하는 그 방식을 보면은 요 우리가 지금 바꿔주려고 하는 요 헤더의 상태가 우리가 예상한 값이면은 그 다음에는 얘가 같다고 하면은 그 다음에는 신경쓰지 않고 무조건 다음 코드가 실행이 되죠 우리가 여기다가 desired를 넣어준 요 코드가 여기 안으로 들어가게끔 이제 코드가 만들어져 있어요 그럼 이제 이게 어떤 문제가 발생할 수 있냐면은 어.. 예를 들면 , 자, 요런 상황이 있다고 가정해봅시다 물론 헤더가 있고 데이터가 3개가 있는데 대충 5,000번 6,000번 7,000번 주소에 해당하는 그런 데이터들이 각각 할당되어 있다고 가정을 해봅시다. 그리고 이 헤더는 지금 5,000번을 가리키고 있는 거고 우리가 여기서 인터랙트 컴페어를 할 때 결국 이 주소값을 이용해가지고 그냥 어떻게 보면 정수를 비교해가지고 그 정소가 같으면 고 아니면 실패를 하고 있는 겁니다. 즉 여기서 우리가 예측하는 상황은 데이터를 꺼내 오려고 할 때 이 헤더에 지금 헤더에 들어가 있는 그 다음 값이 첫 번째 값이 결국에는 5,000번이라고 하면은 그러면은 헤더를 6000번으로 바꿔주고 그리고 5000번은 이제 뽑아오겠다라고 일단 얘기하고 있는 겁니다 즉 이걸 진짜 의사코드로 표현하면은 만약에 헤더가 5000이라면 헤더에다 6000을 넣고 넣어줘 라는 거고 만약에 요 앞 조건이 성공이라고 한다면 이게 트루라고 한다면 뒤에 조건은 무조건 실행이 된다고 볼 수가 있는 거죠 , 자, 이게 뜬금없이 왜 자꾸만 이런 얘기를 하는 거냐 , 자, 여기서 이걸 생각을 해야 됩니다 이 코드가 지금 여기까지 지금 실행을 해보고 있다고 가정해 볼게요 지금 이제 이거를 실행하려고 딱 하고 있는 겁니다 요 로직을 만약에 헤더가 5천이라면 그 다음 값인 6천을 헤더에다가 넣어줘라는 걸 여기서 실행하려고 하고 있는 그 찰나 다른 애들이 또 이 동일한 데이터를 접근해가지고 꺼내고 넣을 수가 있겠죠 그래가지고 정말 절묘하게 이 상황에서 다른 애가 이 데이터 두 개를 예를 들면 팝팝 해가지고 지금 5,000번이랑 6,000번이 날라갔다고 가정을 해볼게요 그 다음에 정말로 또 공교롭게도 다른 스레드가 또 푸쉬를 해가지고 데이터를 집어 넣는데 어쩌다 보니까 5,000번 데이터를 집어 넣었다고 가정을 해봅시다 , 자, 여기서 5000이라는 값 자체가 우리로 치면 이 포인터 주소이다 보니까 우리가 어떤 주소를 할당을 한 다음에 해제를 하고 다시 할당을 할 때 방금 해제한 그 주소를 다시 할당받을 수 있느냐라고 한다면 , 사실, 멀루 오프리나 뉴 딜리트를 할 때 그럴 확률은 거의 없을 거라고 , 일단은, 생각을 할 수 있겠는데 거의 없다고 해서 뭐 꼭 그렇게 절대로 일어나지 않아야 된다고 뭐 보증은 할 수 없겠죠 마찬가지로 우리가 만약에 메모리 풀링을 해가지고 가장 마지막으로 삭제된 메모리 영역을 똑같이 다시 재활당해서 풀에서 꺼내서 사용한다고 하면 똑같은 주소값이 다시 들어오는 것도 충분히 발생할 수 있을 겁니다. 그러면 이제 상황이 굉장히 묘해지는 게 뭐냐면 우리가 처음에 예를 들었던 이 코드가 실행될 때는 이 상황을 착각 찍어서 이게 A라는 상황, 즉 헤더가 5000번을 가리키면 헤더에다가 6000을 넣어줘라는 코드를 실행하려고 얘가 요청을 하고 있었는데 절묘하게도 뭔가 상황이 바뀌면서 데이터가 사라지고 다시 넣어지고 하다보니까 이 상태로 바뀌었음에도 불구하고 지금 이 로직 자체는 무조건 헤더가 5000이면 무조건 6000을 넣어줘라고 , 일단은, 바로 고를 했기 때문에 얘가 만약에 정확히 이 상태에서 이제 계속 잘기차리고 와가지고 실행을 하다보면은 이 상황에 따라가지고 어... 지금 그니까 이 상황을 보고 요 로직을 실행시킬 수 있다는 얘기가 되는거죠 그럼 얘는 이제 어떻게 되냐면은 5천을 꺼내 쓴 다음에 헤더에다가는 6천을 넣어달라고 했었죠? 그러니까 헤더는 이제 6천을 가리키고 있게 됩니다 뭔가 엄한 상황이 된다는거죠 해가지고 결국에는 요렇게 스택이랑 팝을 우리가 락프리 구조로 , 이렇게, 컴패닛 수업으로 만들 때 , 사실, 요런 문제도 굉장히 신경을 써야 됩니다 동일한 값을, 즉 동일한 포인터가 결국엔 정수다 보니까 동일한 정수 값이 , 이렇게, 공교롭게 등장하게 되면은 상태가 실제로 변했음에도 그거를 인지하지 못하고 그냥 로직이 자연스럽게 진행을 할 수가 있다는 얘기가 되는 거죠 물론 그렇게 진행하게 되면은 아주 난리가 나게 됩니다 , 자, 그래서 요런 ABA 문제를 그럼 이제 어떻게 해결해야 되는지에 대해서 이제 이어가지고 고민을 해볼 건데 사실은 해결하는 방법은 뭐 여러가지 얘기했지만 대표적으로는 여기 주소값만 이용해가지고 즉 이 정수값만 이용해가지고 비교를 하는게 아니라 여기다가 별도의 값을 하나를 더 줘가지고 두개를 동시에 비교를 하는 겁니다 예를 들면은 이 5천, 6천, 7천과 마찬가지로 여기에다가 추가적으로 카운터를 둬가지고 1,2,3,4,5,6,7,8,9 같은 그런 랜덤한 값 랜덤하긴 뭐하고 일단 증가하는 그런 랜덤 증가하는 카운터를 둬가지고 그 값을 이용해가지고 매번마다 푸쉬랑 팝을 할 때마다 어떻게 보면 이런 티켓을 발급받는 느낌으로 이 번호표를 받아가지고 두 개의 숫자를 합해가지고 걔를 하나의 숫자로 인식해가지고 컴퓨어 수업을 때리면은 적어도 아까와 마찬가지로 상태가 변했을 때 그거를 이제 인지할 수가 있게 될 겁니다 뭐 그런 상황을 우리가 해결하기 위해서라도 결국에는 요렇게 단일 포인터만을 Compound 수업을 할 수 없다는 얘기가 되는 거죠 그래가지고 제가 , 사실, 이 강의를 굳이 , 이렇게, 열심히 하는 이유도 결국 이 ABA 프로그램과 관련된 문제에 대해서 좀 논하고 싶어가지고 이걸 준비한 거예요 요런 상황은 , 사실, 종종 발생할 수 있는데 우리가 예전에 락 프리 스택을 만들 때는 , 사실, 굳이 ABA 프로그램에 말씀을 안 드린 이유는 그런 문제가 애장초에 발생하지 않았습니다 왜냐면 우리가 하던 방식은 노드 기반으로 노드라는 어떻게 보면 객체가 객체 자체를 우리 lock-free-q나 lock-free-stack에서 내부적으로 관리하고 있었고 누군가가 팝을 하고 있는데 다른 애가 동시에 팝을 해가지고 그 같은 데이터를 바라보고 있다고 하면 그 데이터를 애당초 그 노드를 날리지 않게끔 우리가 붙잡고 있었기 때문에 애당초 ABF 러블럼이 발생하지 않았어요 근데 요런 방식으로 우리가 만약 코드를 고친다고 하면 이제 ABA Problem이 발생할 수도 있다는 얘기가 되는 겁니다 , 자, 그래서 이어가지고 살펴볼 거는 , 자, 여기도 한번 제가 쭉 치고 이제 이어가지고 그러면 이걸 어떻게 해결할 것이냐에 대한 3차 시도에 대해서 한번 논해 보도록 할게요 , 자, 그래서 여기까지도 혹시 또 코드를 보고 싶을 수도 있으니까 여기까지 , 일단은, 주석을 처리하고 그 다음에 이제 최종 버전으로 한번 얘기를 해보도록 합시다 여기까지는 다시 살려주도록 할게요 얘가 2차, 여기부터가 3차입니다 , 자, 그래서 이제 최종적으로 그러면 얘를 어떻게 고칠 것이냐 음... 말씀드린대로 이제 카운터를 하나를 더 두게 될 거에요 , 자, 그리고 이거는 이제 우리가 다음 시간에 살펴볼 , 사실, 마소에서 직접 구현해준 그 애슬리스트 엔트리랑 비슷하게 만들어 볼 것이기 때문에 어 , 일단은, 여기다가 dcl-spec-align 이라고 해가지고 16바이트 정렬을 , 일단은, 무조건 해주도록 하겠습니다. 이 이유는 곧이어서 나오는데 무조건 얘를 추가를 해주시고요. 얘를 살펴보면 Declare Spec Align이라고 해가지고 그냥 , 이렇게, 디파인이 되어 있습니다. 이걸 그냥 그대로 사용하는 거예요. 물론 이 버전으로 그냥 직접 넣어줘도 상관없습니다. 무조건 메모리가 16바이트 정렬이 되게끔 해달라라고 컴파일러한테 지금 힌트를 주고 있는 거고요 그 다음에 요 부분을 조금 바꿔볼 건데 , 자, 유니언을 넣어 줘 가지고 유니언 그 다음에 스트럭트 두 개를 넣어 줄 것인데 , 일단은, 유인트 두 개를 넣어 주도록 할 거예요 첫 번째는 알라인먼트 그 다음에 리전이라는 이름으로 만들어 줄 것이고 첫번째는 dummy struct name 이라고 대문자로 , 이렇게, 만들어줄건데 얘도 역시나 타고 들어가서 살펴보면은 여기에 , 일단은, 이렇게, define 되어있습니다. define이 되어있는데 얘는 아무것도 안하게 되어있죠? 그러니까 한마디로 얘는 넣으나 안 넣으나 똑같은 아무런 쓸데없는 의미, 이름이라는 의미가 되는거구요. 그 다음에 두번째로 union을 해줘가지고 , 자, 요렇게 depth를 만들어줄건데 요런 애들 각각 만들어 줄 건데 여기다가 우리가 비트를 세부적으로 정해 주도록 할 거에요 reserved는 4 next는 60 그리고 얘는 header x64라고 일단 이름을 붙여 주도록 할게요 , 자, union 문법 자체는 무엇이냐면 결국에는 이 데이터나 이 데이터나 두 가지 시각으로 동일한 데이터를 우리가 이름을 접근할 수 있다는 얘기가 되는 거고 실질적으로는 요 struct 자체가 uint64가 2개가 들어가 있습니다 즉 128 비트 짜리라는 얘기가 되는 거죠 그런데 걔를 접근할 때 , 이렇게, uint64, uint64 두 개로 , 일단은, 구분해 가지고 접근을 해도 되고 아니면 더 세부적으로 얘는 16, 48 즉 이 두 개가 합해 가지고 알라인먼트가 되는 거고 4bit랑 60bit가 합해 가지고 reserved랑 next가 합해 가지고 이 region이라는 게 될 겁니다 즉 얘를 세부적으로 접근할 것이냐 아니면 크게 접근할 것이냐 여러가지 옵션을 두는 그런 문법이라고 생각하시면 되겠어요 , 이렇게, 만들어 줄 것이고 그 다음에 얘가 초기화 될 때는 그냥 alignment를 0으로 밀고 region도 그냥 0으로 밀어 두고 할게요 얘네 둘을 0으로 밀어주면 어차피 얘네들도 000으로 다 밀립니다 , 자, 이렇게, 해가지고 얘는 uint64라고 해서 진짜 uint64짜리가 아니라 이걸 이제 비트 단위로 우리가 쪼개 쓰고 있는 그런 개념이라고 생각하시면 되겠습니다 그래서 얘를 합하면 똑같이 128이 나오죠 60, 60이다 보니까 64, 64이다 보니까 똑같이 128이 나오는 걸 확인할 수가 있습니다. 그래서 좀 얘기가 길어지는데 그 다음에 여기는 똑같이 Initialize, Push, Pop , 이렇게, 3가지 함수가 있는 거는 뭐 일단 똑같이 만들어 보도록 할게요. , 자, 이제 이어서 3차 시도로 넘어가 보도록 하겠습니다. , 자, 그러면은 , 일단은, initialize 를 할 때는 이제는 이 header 의 alignment 를 0 으로 밀어 줄 것이고 header 의 region 도 , 일단은, 0 으로 밀고 시작을 해 보도록 할게요 , 자, 이 header 가 이 정보를 들고 있고 s list entry 는 그냥 next만 들고 있고 이 상태라고 일단 볼 수가 있는 거고요 그 다음에 이제 이어서 push 부터 살펴볼 건데 푸쉬를 할 때는 , 자, 코드를 음 이 코드를 날리고 그냥 처음부터 진행을 해보도록 하겠습니다 우선은 어떻게 할 거냐면은 이 애틀리스트 헤더라는 거를 expected랑 desired 버전을 하나씩 만들어 주도록 할게요 짜잔 , 이렇게, 두 개를 만들어 줄 것이고 , 자, 그 다음에 요 주소라는 거 자체가 우리가 항상 16바이트 정렬을 해줄 거예요 16바이트 정렬을 해줬다는 거는 얘를 사실상 어 이 주소를 볼 때 16바이트 정렬이 돼 있으면 최하위 4비트는 무조건 000이 될 겁니다. 그래야지만 16바이트 정렬이 됩니다. 이게 이해가 안 가시면 제가 계산기를 한번 켜가지고 여기서 살펴보자면 프로그래머용 계산기를 본 다음에 여기서 아무 값이나 , 이렇게, 봐가지고 보면은 어떤 값이 있다고 했을 때 얘가 16바이트 정렬로 딱 떨어진다고 하는 것 자체가 여기 있는 값이 000이라는 얘기가 되는 거죠. 만약에 여기라도 하나가 0이 아니면 16바이트가 딱 떨어지지가 않습니다. 그래서 결국 어떤 주소가 16바이트 정렬이라면 여기 하위 4 비트가 00이라는 걸 우리가 확실히 알 수가 있는 거죠 그래가지고 어떤 주소를 저장을 할 때 얘를 풀로 저장하진 않을 것이고 , 자, 이렇게, 해당 주소에다가 걔를 그냥 64 비트짜리 정수로 인식을 한 다음에 걔를 요렇게 4 비트를 비트 쉬프트 해가지고 오른쪽으로 땡겨가지고 여기다가 저장을 해주게 될 겁니다 desired. 헤더64.next에 이 값을 저장을 해줄 거예요 우리가 next라고 표현한 헤더64의 next가 60비트짜리로 우리가 만들어 줬었죠 그래서 실질적으로 어떤 주소를 굳이 64비트로 표현하지 않고 60비트로도 우리가 표현할 수 있다는 얘기가 되는 겁니다 왜 굳이 이걸 쓸데없이 , 이렇게, 하느냐 이거는 그냥 실제로 구현 자체가 , 이렇게, 이 구조로 되어있기 때문에 똑같이 해보는 거고 경우에 따라 가지고 어 이제 , 이렇게, 만들어 주게 되면은 이 여분의 4 비트를 우리가 추가적인 정보를 넣어 줘 가지고 비교를 하는데 사용할 수 있지 있다는 얘기가 되는 거죠 요런 식으로 일단 응용을 해줄 수가 있습니다 물론 이걸 더 줄여서 실제로 운영체제에서는 주소를 64비트 체계를 활용하지만 실질적으로 48비트만을 활용해도 주소 범위에서 우리가 충분히 유의미하게 구분을 할 수 있기 때문에 그런 경우라면 주소를 아예 48비트로 활용한다고 예를 들면 방법입니다 그건 운영체제마다 다르긴 한데 일단 기본적으로 우리가 사용할 환경에서는 이게 60이랑 4로 되어있으니까 이걸 똑같이 지금 모작을 해보고 있는 거예요 그래서 어찌됐건 이 주소 자체를 넥스트에다가 넣어줄 수 있다라는 걸 우리가 살펴보고 있는 거죠. 물론 , 사실, 지금 단계에선 얘가 뭐 큰 의미가 없기는 합니다. 그래서 , 이렇게, 일단은, 16바이트 정렬이 되어 있다고 하면은 , 이렇게, 코드를 사용할 수 있다. 그래서 나중에 실질적으로 우리가 코드를 만들 때도 이 s-list라는 걸 나중에 마소에서 구현한 걸 사용할 때도 주소는 항상 16바이트 정렬을 해야 된다라는 이유가 이런 데서 오는 거라고 생각을 하시면 되겠습니다. 그 다음에 여기다가 컴퓨어 수업 연산을 계속 할 건데 일단 expected를 사용할 건데 header 값을 싸들이다 expected에 , 일단은, 복사를 해올 거에요 , 자, 여기서 다시 보면은 s-list header라는 애가 결국에는 이 region이라는 부분이 애당초 이 포인터, 데이터의 포인터를 지금 사실상 의미를 하는 거고 여기에다가 Depth랑 Sequence로 되어 있는 이 두 가지가 일종의 카운터가 되겠습니다 이 Depth 자체가 실질적으로 데이터가 들어가 있는 개수에 따라가지고 얘는 계속 1씩 늘어나게 될 거고 이 Sequence도 마찬가지로 우리가 팝을 할 때마다 1을 증가시키고 그 다음 푸쉬를 할 때마다 1 증가시키고 팝을 할 때마다 1을 줄여가지고 뭔가 데이터가 계속 바뀌게끔 유도를 해줄 거에요. 그럼 결과적으로는 이 두 개의 인트 64짜리 정수가 매번 마다 계속 다른 숫자를 갖게 된다는 얘기가 되는 거죠. 그 숫자를 이용해가지고 이 숫자랑 이 포인터랑 완전히 동일해야지만 그거를 하나의 상태로 우리가 인지를 해가지고 그거를 대상으로 compare and swap을 한다고 보시면 되겠습니다. 그래가지고 결국에는 이 사이에 뭔가 데이터가 변경될 수 있다는 걸 우리가 충분히 염두에 두고 이제 작업을 하는 거죠. , 자, 그래가지고 여기서 엔트리의 next 즉 우리가 넣으려고 하는 데이터에 next는 , 일단은, 무엇으로 넣어주고 싶냐면은 s-list 엔트리에 포인터로 캐스팅을 한 다음에 int64로 , 일단은, expected header64에 next를 캐스팅을 한 다음에 그거를 요렇게 넥칸을 다시 왼쪽으로 당겨주도록 할게요 우리가 애당초 데이터를 저장할 때 이 넥스트가 60비트 짜리로 되어 있는데 실제로 그거를 포인터로 보관하기 위해서 반대쪽으로 지금 , 이렇게, 4비트를 밀어 넣어주고 있다고 보시면 되겠습니다 이 코드가 헷갈릴 수 있으니까 여기다 한번 더 , 이렇게, 잡아주도록 할게요 그래서 이 부분은 원래 우리가 4비트를 날려가지고 관리했던 거를 다시 복원을 시켜주는 그런 코드라고 볼 수가 있는 거고 그거를 여기다가 , 일단은, Next에다가 다시 복원을 시켜준 다음에 그 다음에 desired 값을 채우고 있어요 이제 우리가 원하는 값은 무엇이냐 Depth 같은 경우에는 우리가 처음에 expected로 받아준 그러니까 여기 복사해가지고 이 상태에서 Depth에다가 1을 더한 값을 우리가 원하고 있고 그 다음에 Sequence 같은 경우에는 원래의 Sequence에서 또 1을 더한 값을 새로운 Sequence로 받아주고 싶다고 하는 겁니다 즉 얘도 1 늘려주고 얘도 1 늘려주겠다라는 코드를 실행하고 있는 거죠 이게 어떻게 보면 은행에서 티켓을 발급받아가지고 내 순번을 기다리는 약간 그런 거라고 보시면 되겠어요 이 사이에 누군가가 팝을 했다고 하면은 요 번호가 실질적으로 바뀌게 될 겁니다 요 헤더에 있는 값이 바뀌게 될 것이기 때문에 Interlock Compare Exchange를 빵 때리면은 이제 실패가 뜨게 된다는 얘기가 되는 거죠 그걸 이용해가지고 요 상태에서 누군가가 건드리고 있냐를 체크해가지고 A, B의 상태를 이제 우회한다고 보시면 되겠습니다 A, B의 문제를 그래서 Interlock Compare Exchange를 쓸 건데 Interlock Compare Locked, Compare, Exchange 여기 128 비트 짜리 버전이 하나 더 있어요 이걸 64 비트 두 개로 나눠서 해도 되는데 요즘 칩에서는 다 , 이렇게, 128 비트를 한 번에 체크를 할 수, compare and swap을 할 수 있게끔 연산을 지원하기 때문에 이 버전을 이용해 볼 거고 얘도 처음에는 대상 포인터를 넣어주게 됩니다 우리가 대상으로 하고 있는 거는 이 헤더를 얘기하고 있는 거고 그 다음에 여기에다가 Exchange 값 두 개를 넣어주고 Compare End를 넣어주죠 그래서 여기다가는 desire.region 그 다음에 desire.alignment를 넣어줄 것이고 마지막에는 우리가 처음에 예측한 그 값은 얼마인지를 또 포인터로 넣어주게 되는데 얘도 int64로 캐스팅을 해 줘 가지고 이 expected의 주소를 넣어 주도록 할게요 그 다음에 얘가 성공했으면 이제 1을 리턴하게 될 건데 1을 리턴했다는 건 성공했다는 거니까 그냥 여기서 빠져나가도 됩니다 그러니까 브레이크를 바로 때려 주도록 하겠습니다 요렇게 된다고 보시면 되겠어요 그래서 아까랑 굉장히 비슷한데 이제 달라진 점은 여기다가 뭔가 카운팅을 해가지고 티켓을 발급받아가지고 나만 유효한 요런 숫자가 이제 발급되게끔 유도를 해줬다라는 차이가 생기게 된거죠 네 그래가지고 이 상황에서 누군가가 팝을 했다고 하면은 이 숫자가 바뀔테니까 그걸로 인제가지고 얘가 실패해서 다음 턴에 다시 어 바뀐 값을 이용해가지고 체크를 해야 된다라는 로직이 실행이 된다고 볼 수가 있는거고 그 다음에 마찬가지로 팝 엔트리 리스트도 비슷하게 만들어 볼게요. , 자, 이 두개는 똑같이 , 이렇게, 갖고 오도록 하고 이제는 값을 추출해야 되니까 얘를 엔트리 라고 해가지고 얘를 이제 추출한 다음에 최종적으로 얘를 이제 뱉어주는 형태로 작업을 해보도록 하겠습니다. 얘도 마찬가지로 , 이렇게, 무한 루프를 돌건데 우선은 우리가 예측하던 어... 엑스펙티드는 이 헤더 값을 그대로 복사해가지고 , 일단은, 체크를 해보도록 하겠습니다. , 자, 그 다음에 요 코드는 그대로 복사를 해가지고 엔트리는 요 코드를 요렇게 갖고 오도록 할게요. 결국에는 요 헤더가 가리키고 있던 맨 첫번째 값이 우리가 인지하고 있는 헤더 값인데 걔를 우리가 꺼내 가지고 밖으로 추출하려고 하고 있는게 사실상 팝의 의도라고 볼 수 있는 거죠 근데 만약에 엔트리가 널이다 라고 하면은 데이터가 없단 얘기니까 그냥 바로 브레이크를 때려 보도록 할 거고 그게 아니라 여기 안으로 들어왔다고 하면은 이제는 디자인들을 하나씩 채워 주도록 하겠습니다 desired의 header64 같은 경우에는 어... 얘 같은 경우에는 무엇이냐 , 자, 요렇게 엔트리의 next에다가 4를 땡겨가지고 주소 자체를 64비트 주소를 60비트 안에 들어가게끔 요렇게 낑겨가지고 만든 요 아이를 여기다가 넣어줄 것이고 그 다음에 desired의 depth 같은 경우에는 이제 얘 같은 경우에는 팝을 해가지고 데이터를 하나 줄여 올 테니까 expected에 header64에 depth에다가 1을 , 이렇게, 꺼내 오도록 할게요 1을 줄여 주도록 하겠습니다 마지막으로 이 sequence 같은 경우에는 실질적으로 그냥 계속 무조건 증가하는 형태로 우리가 만들어 줄 것이기 때문에 이전 sequence에서 무조건 1을 증가시켜 주도록 하겠습니다 그럼 이제 거꾸로 여쭤보신다면 아니 그럼에도 불구하고 이 코드가 실행이 되다 보면은 이 Sequence Depth가 , 이렇게, 계속 늘어나고 줄어나고 하다가 Depth랑 Sequence가 정확하게 일치하는 값으로 또 떨어지는 게 충분히 가능하지 않느냐라고 여쭤보실 수 있겠지만 그렇게 하기 위해서는 이 비트가 한 바퀴를 다 돌아야 되겠죠? 이 Int64라는 어마무시하게 큰 값이 정확하게 일치를 하는 거는 사실상 우리가 이 전 우주에서 모래알을 찾는 거랑 거의 똑같은 확률이라고 생각하시면 됩니다 이게 거의 발생할 수가 없습니다 현실적으로 우리 인생에서 뭐 한 번씩 발생할 수 있는 그런 상황도 아니라고 보시면 되겠어요. 그러니까 사실상 얘는 겹치지 않는다고 일단 충분히 가정할 수 있다는 얘기가 드는 거죠. 그래서 ABA의 문제가 그래가지고 결국에는 오해를 할 수 있는 겁니다. 그 다음에 결국에는 여기서 interlocked 똑같이 compare exchange 128 compare exchange 128을 해가지고 여기서도 마찬가지로 int64 header를 넣어준 다음에 desired region, desired, desired then alignment를 넣어주고 그 다음에 마지막으로 우리가 예측한 expected 값을 최종적으로 여기다가 넣어주면 됩니다. 여기까지는 똑같아요. int64 expected 그리고 얘가 만약에 성공했다고 하면 얘도 역시나 그냥 빠져나오면 되겠죠. 만약에 아까와는 다르게 이 상태에서 누군가가 데이터를 꺼내쓰고 다시 넣어가지고 동일한 주소의 포인터가 딱 그 상태로 즉 5000번이 똑같이 헤더를 가리키는 아까의 그 상태를 다시 한번 예로 들면은 6000, 7000 누군가가 이 두 개의 데이트를 꺼냈다가 다시 뭔가 반납을 해가지고 이런 상황이 됐다고 하면 애당초 여기 있는 Depth랑 Sequence 값이 이미 바뀌고도 충분히 남았기 때문에 실질적으로 이 전체를 지금 Int64 두 개를 합해가지고 지금 한 번에 , 이렇게, 비교를 하고 있는 거죠. 그러다 보니까 결국에는 틀린 값으로 인지를 해가지고 성공을 하지 못할 겁니다. 그래가지고 이제 A, B의 문제가 해결이 된다고 보시면 되겠어요. , 자, 여기까지 그래서 요 부분에서 제가 이제 뭐 언급을 드리고 싶었던 건 뭐냐면은 우리가 이전 시간에 락 프리 스택에서 언급하지 않았던 이 ABA 문제를 해결하기 위해서 결국에는 포인터뿐만 아니라 거기다가 추가적으로 뭔가 , 이렇게, 더러운 카운터를 둬가지고 둘을 합해가지고 한 번에 컴페어 앤드 스왑을 한다라는 부분을 이제 설명을 드리고 싶었던 거예요 그래서 이제 요 코드를 만약에 우리가 다시 뭐 테스트를 해보고 싶다라고 한다면 뭐 대략적으로 이쪽에 돌아와 가지고 뭐 테스트를 해볼 수가 있겠죠 여기다가 애슬리스트 엔트리를 넣어준 다음에 이 부분을 예를 들면은 뭐 랜덤 값을 넣어주도록 할게요 랜드에다가 뭐 대충 1000으로 나눠준 요런 값으로 넣어주고 그 다음에 요 값이 반드시 declare-spec-align 16을 붙여가지고 16바이트 정렬이 되게끔 항상 유도를 해줄 것이고 그 다음에 이제 얘를 활용하기 위해서는 멀티셰도 환경에서 한번 테스트를 해보고 싶은데 대략적으로 뭐 , 이렇게, 만들어 봅시다 g-header 라는 거를 , 이렇게, 넓직하게 만들어 주고요 그 다음에 이 G 헤더를 New SList 헤더로 할당을 해준 다음에 혹시 모르니까 얘가 16바이트 정열인지를 체크를 해보도록 합시다. uint64 gheader 얘가 16으로 나눠가지고 정확하게 떨어져야지만 이제 , 사실, 요 코드가 우리가 만든 코드가 정상적으로 동작할 거니까 , 이렇게, 만들어 주고 그 다음에 여기다가 gheader를 , 이렇게, 넣어 주도록 할게요 초기화가 된 다음에 그 다음부터는 이제 데이터들을 여러 스레드에서 얘를 테스트할 수 있는 거니까 뭐 이런 식으로 포문을 돌면서 대충 스레드 3개가 데이터를 밀어넣는 작업을 해줄겁니다. 런치를 해가지고 , 이렇게, 일단은, 만들어 보도록 할게요. while true 계속 무한 루프를 돌면서 우리가 만든 데이터라고 했나요? 그러니까 데이터를 동적할당을 해주도록 할겁니다. new data 그 다음에 혹시 모르니까 여기도 16바이트 정렬이 되어있는지를 또 체크를 하도록 하고 이 코드를 복사하도록 할게요. 귀찮아서 복붙 하도록 할 것이고 참고로 나중에 가면 뉴 딜리트를 하지 않고 이거를 얼라인 멀록이라고 해가지고 16바이트 정렬을 지켜가지고 할당해주는 그런 방법도 있습니다. 뭐 그건 그렇고 그래가지고 , 이렇게, 해가지고 얘는 푸쉬 엔트리 리스트를 해줄거고 G 헤더랑 그 다음에 S 리스트 엔트리로 캐스팅해가지고 이 데이터를 그대로 밀어넣어 줄 것이고 그 다음에 너무 자주 하면 메모리가 터질 것 같으니까 대충 한 10ms마다 데이터를 밀어 넣어줄 것입니다. 그리고 반대쪽에서는 두 개 정도로 해가지고 얘는 거꾸로 데이터를 추출해가지고 사용하는 역할을 맡게 될 거예요. 그래서 , 사실, 이 부분은 필요 없을 것 같고 대략적으로 데이터 팝, 팝을 할 데이터니까 이름을 팝이라고 이름을 지어보도록 할게요. 그러면 여기다가 데이터 타입으로 캐스팅해가지고 팝 엔트리 애슬리스트를 호출해서 이 헤더에서 얘를 추출해가지고 만약에 얘가 팝이 널이 아니라고 하면은 뭐 그냥 간단하게 요 랜덤 값이 무엇이었는지를 그냥 추출한 다음에 딜리틀해서 노드를 삭제를 해주도록 할게요. 그 다음에 데이터가 없으면 뭐 뭐라고 할까요 넌 데이터 없다 라고 , 이렇게, 표시를 한 다음에 최종적으로 얘를 조인을 해가지고 기다려 주도록 합시다 , 이렇게, 코드를 한번 실행해 보도록 할게요 그러면은 , 일단은, 이게 잘 실행이 될까가 일단 궁금한데 의외로 얘를 실행을 해보면 별다른 문제 없이 코드가 쭉 잘 실행이 된다는 걸 볼 수가 있습니다 그러면 이 코드가 정말 멀티리스 환경에서 완전히 안전하냐라고 한다면 , 사실, 그거는 아니에요 이게 A, B의 문제는 해결이 되었지만 아까 처음에 얘기한 문제는 아직까지는 해결이 되지 않았습니다 그래가지고 만약에 내가 절묘하게 여기서 이 엔트리로 캐스팅을 해가지고 얘를 캐스팅한 다음에 이 넥스트를 추출하려는 이 순간에 누군가가 그 데이터를 꺼내 가지고 만약에 정확히 내가 참조하려고 했던 그 데이터를 만약에 이 데이터를 날렸다고 하면 사실상 여기서 use after fee 문제는 여전히 일어날 수 있다는 얘기가 되는 거죠. 근데 만약에 팝을 하는 스레드가 하나밖에 없다고 하면은 , 사실, 완벽하게 안전한데 그게 아니라고 한다면은 , 사실, 요 코드는 요 부분을 이제 해결해야 됩니다 뭐 이제 여러가지 방법이 있겠지만 그건 너무 또 내용이 복잡해지니까 거기서 거기까지 다루지 않을 거고 대략적으로 , 이렇게, ABA의 문제를 해결하기 위해서 카운터를 뒀다가 오늘의 핵심 내용이라고 , 일단은, 볼 수가 있겠어요 그래서 음 만약에 뭐 여러 스레드에서 팝을 한다고 하면 지금 이 코드가 약간 문제가 될 수 있다는 건 염두에 두셔야 되고 그래서 제가 늘 말씀을 드리는 거는 이런 락프리 계열의 코드는 직접 만들어서 사용하는 거는 진짜 어지간해서는 추천드리지 않습니다 이게 진짜로 잘 동작할 것 같음에도 불구하고 어딘가가 놓친 부분이 있다고 하면 그게 자주는 터지지 않고 정말 한 한 달에 한 번씩 터지는 버그가 일어날 수도 있어요 근데 그렇게 되면 진짜 버그를 잡을 수가 없습니다 그러다 보니까 최대한 리스크를 줄이는 차원에서라도 , 이렇게, 직접 만들어서 사용하는 것은 정말 비추 드리지만 그럼에도 불구하고 제가 이 강의를 열심히 진행한 이유는 여기서 이제 공부할 방법 공부할 것이 굉장히 많았다는 얘기가 되는 거죠 우리가 다음 시간에 알아볼 , 사실, 이런 비슷한 애를 이제 마소에서 직접 만들어 줘 가지고 우리가 사용하는 어 그런 이제 아토믹한 스택 이라는 게 하나가 있는데 그걸 사용해 볼 건데 거의 비슷하게 진짜 딱 요런 형태로 되어 있습니다 그리고 거기서 계속 문제를 보면은 16바이트 정렬을 맞추지 않으면 큰일 난다고 계속 겁을 주는데 진짜로 그게 문제가 일어나기 때문에 그렇게 말을 하는 거예요 그럼 만약에 거꾸로 얘기해 가지고 16바이트 정렬을 하지 않으면 어떤 문제가 발생할지를 곰곰이 생각을 해보면 , 자, 예를 들면은 여기서 우리가 , 이렇게, 4 비트로 당길 수 있었던 이유는 맨 하위 4 비트가 000이라는 걸 확신할 수 있었고 16바이트 정렬이 되었기 때문에 이 주소가 000으로 끝났다는 걸 알 수 있으니까 얘를 , 이렇게, 날릴 수가 있던 겁니다. 그리고 거꾸로 얘도 다시 사용할 때는 어차피 마지막 값은 000이니까 얘를 다시 복원시켜줘서 사용했었는데 만약에 16바이트 정렬이 아니었다고 하면은 애당초 우리가 이 주소를 , 이렇게, 당김과 동시에 실질적으로 잘못된 주소로 얘를 바꿔치기 하고 있다는 얘기가 되는 거죠. 그러다 보니까 얘를 복원해봤자 결국에는 엉뚱한 주소로 복원해가지고 사실상 약간 댕글링 포인터처럼 엉뚱한 주소를 가리켜가지고 코드가 실행이 되다 보니까 그렇게 되면 이제 앞으로 어떤 코드가 실행될지는 예측할 수 있는 범위가 아니가 이상한 코드가 실행이 될 확률이 높아진다고 보시면 되겠습니다. 그래서 반드시 다음 시간에도 이 16바이트 정렬을 지켜야 된다라는 얘기는 여기서 일단 맞다고 볼 수가 있는 거고요 그 다음에 이 ABI 문제를 해결하기 위해서 카운터를 두는 방법도 이제 꼭 기억을 해주시면 되겠습니다 ABI 같은 거는 진짜 면접에서도 가끔 나오는 주제니까 이것도 기억을 해주시면 되겠고 어찌됐건 , 사실, 이 코드는 이제 다음 시간에 지울 것이고 삭제를 해서 더 이상 사용하지 않을 것이고 우리는 이제 마수에서 만들어주는 걸 사용할 것이지만 그럼에도 불구하고 이 코드를 한번 읽어보면서 뭐 개선할 점이라거나 아니면 뭐 걱정되는 부분이 있는지 등등을 한번 연구를 해보시면 좋을 것 같아요 그리고 뭐 늘 그렇지만 여기서 디버그도 해보면서 요 헤더가 어떻게 변하는지 이제 뭐 스레드를 좀 줄여가지고 얘가 늘어날 때마다 요 카운팅이 어떻게 변하는지 등등도 추적을 해보면 충분한 가치가 있을 것 같습니다 , 자, 이렇게, 가지고 좀 잡다한 내용이 많아졌는데 , 이렇게, 해가지고 메모리 개선을 하기 위한 일단 중간 지식에 대해서 일단 쭉 알아봤습니다.