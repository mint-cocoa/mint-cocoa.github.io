자, 이제 이번 시간부터 드디어 또 새로운 단원으로 넘어와 가지고 이제 본격적으로 데이터베이스 연동을 실습을 해볼 겁니다 데이터베이스 자체에 관련된 내용은 예전에 C샵 시리즈에서 파트 5로 꽤 오랜 시간 다뤘기 때문에 DB란 무엇이고 SQL은 퀄이나 어떻게 작성하고 이런 거는 다 생략을 할 것이지만 C++에서 우리가 DB 연동 자체를 어떻게 해 가지고 데이터를 저장하고 꺼내올지에 대해서 이제 다루는 강의라고 생각하시면 되겠습니다. 즉 SQL Query 자체에 대한 기본적인 이해도는 일단 갖고 계셔야지 이제 수월하게 진행을 할 수가 있다고 보시면 되겠습니다. , 자, 그런데 DB 제품군이 , 사실, 굉장히 다양하게 존재하죠. 뭐 마이크로소프트에서 만든 SQL 서버 소위 MS SQL도 있고 MySQL도 있고 뭐 Oracle도 있고 굉장히 종류가 다양합니다. 그런데 실무에서 어떤 DB를 사용하느냐 보통 윈도우즈 서버 기반으로 간다고 치면 MS SQL 즉 SQL 서버를 많이 사용하는 편이긴 하고요 다만 새로운 프로젝트라고 하면 MySQL이나 다른 제품군을 사용하더라도 크게 무리는 없습니다 제가 본 프로젝트에서는 대부분 아직까지는 SQL 서버를 사용하고 있었어요 네 그건 그렇고 근데 만약에 이제 그 다양한 제품군 마다 연동하는 방법이 다르다고 치면은 굉장히 힘든 일이 될 겁니다 그런데 우리가 이전 파트 2에서 DX12에 대해서 공부를 할 때도 그랬지만 그래픽 카드도 굉장히 제품군이 다양하게 있지만 그 제품마다 연동하는 방법이 다른 게 아니라 DirectX라는 어떻게 보면 공용 라이브러리를 이용해서 코드를 만들고 각 그래픽카드랑 연동하는 작업은 마소와 마이크로소프트와 각 제조사들이 담당해서 처리를 했었죠. 그래서 우리는 딱히 내부 구현은 어떻게 되는지 신경쓰지 않고 그냥 DX12로만 우리가 코딩을 했었는데 지금도 마찬가지로 DB 연동을 할 때 그렇게 세부적인 DB의 스펙이나 이런 거에 대해서는 신경 쓸 필요 없고 우리는 이제 ODBC라는 걸 활용해 가지고 작업을 하게 될 겁니다 그래서 이제 ODBC를 통해 가지고 우리는 DB를 접근해서 데이터를 쓰기도 하고 읽기도 하고 할 것이고 그 세부적인 연동 자체에 대한 내용은 이제 각 제조사들이 DB 제조사들이 맡게 된다는 얘기가 드는 거죠 , 자, 그리고 , 일단은, 오늘 그냥 코드를 만들면서 설명하는 게 조금 나을 것 같아 가지고 , 일단은, 새로운 필터를 만들어서 DB라는 이름으로 , 이렇게, 만들어 주도록 할게요 이게 참고로 정렬이 새로 만들 때 정렬이 되지 않는데 껐다 키면 이게 알파벳 순서로 정렬이 되기도 하고 근데 지금 당장 얘를 정렬하고 싶다고 하면은 약간 꼼수 같은 앤데 그냥 아무데나 , 이렇게, 넣었다가 다시 꺼내주면은 , 자, 이렇게, 위치가 알파벳 순서로 정렬이 됩니다. 이거 약간 짜잘한 팁입니다. , 자, 그건 그렇고 여기다가 이제 뭐 오늘 추가할 두 개의 클래스가 있는데 db-connection 이라는 클래스를 하나를 만들 것이고요. 그 다음에 또 하나를 만들어 가지고 db-connection-full 이라고 해가지고 , 이렇게, 두 개를 두 개의 클래스를 만들어 가지고 작업을 해볼 겁니다. DB Connection은 말 그대로 DB랑 연결하는 하나의 단위를 얘기하는 거고 그걸 이제 풀링 해가지고 재사용해서 사용한다라고 , 일단은, 큰 개념을 생각을 하시면 되겠어요 근데 요 코드들은 이제 뭐 그렇게 깊게 엄청 심오하게 연구할 필요는 없고 어차피 그냥 ODBC라는 애가 제공하는 그런 기능들을 우리가 사용하는 것이기 때문에 그냥 생각날 때마다 기억이 안나면 어떤 함수가 뭘 하는지 궁금하면 조금씩 MSDN을 살펴보고 하는 식으로 진행을 하면 됩니다. 이전에 다른 네트워크나 멀티셰드처럼 그렇게 심오하게 볼 필요는 없다는 얘기가 되는 거죠. 이걸 만들면서 정확히 살펴볼 건데 당장은 이제 MSDN을 살펴보기 보다는 그냥 큰 그림을 살펴보시길 바라겠습니다 이게 어떤 느낌으로 코드가 만들어진을 본 다음에 어느정도 익숙해진 다음에 각각의 세부적인 함수가 무엇을 하는지 보는게 조금씩 더 쉽다고 보시면 되겠어요 , 자, 일단은, db커넥션 프리하는 걸 , 이렇게, 만들어 줄 건데 생성자를 만들어주고 소멸자도 만들어 줄 것이고요 그 다음에 내부적으로 락을 사용할 것이고 그리고 여기서 SQL HENV라는 걸 사용할 건데 , 일단은, 이거를 사용하기 위해서 헤더를 2개를 추가해야 됩니다 근데 우리가 내부적으로 커넥션 풀에서 어차피 db커넥션을 사용할 것이기 때문에 여기다가 db커넥션 헤더를 , 일단은, 추가를 해주도록 할게요 그리고 db커넥션 헤더에 돌아가 가지고 여기서 이제 우리가 사용할 include sql.header 그리고 include sql.extended 라는 요 두개의 헤더를 일단 추가를 하고 시작을 해보도록 하겠습니다. 두개를 추가했고 , 자, 그 다음에 다시 커넥션 풀로 돌아가가지고 코드를 이어서 만들어보자면 이제 얘가 이제 밑줄이 없어졌죠? sql h env인데 sql은 뭐 그냥 sql의 약자고 h는 핸들의 약자고 env는 environment의 약자입니다. 즉 어떤 환경을 담당하는 그런 핸들이다 라고 , 일단은, 요약을 해주셔도 되겠어요 그래서 이름을 조금 더 알기 쉽게 Environment 환경이라고 일단 짓도록 하겠습니다 처음에는 SQL NULL 핸들로 , 일단은, 초기화를 해주도록 할게요 그 다음에 이 DB Connection Pool을 만드는 이유는 연결을 여러 개를 맺어 가지고 그거를 매번 마다 우리가 DB 요청을 할 때마다 얘를 재사용하게 될 거기 때문에 이거를 그냥 , 이렇게, 지금까지 만들어둔 애들을 , 이렇게, 들고 있도록 하겠습니다 그래서 이거를 Connections라고 , 일단은, 이름을 지어주도록 할게요. 줄을 좀 정렬을 해주도록 하겠습니다. , 자, 그 다음에 여러 가지 함수를 만들어 줄 건데 먼저 연결을 하는, 그측 이 커넥션 풀을 만들어주는 함수를 하나를 만들어주도록 하겠습니다. 커넥션 카운트 몇 개의 커넥션, DB 커넥션을 만들어 줄 것인지를 , 이렇게, 기입을 할 것이고, 그 다음에 두 번째 인자로는 커넥션 스트링을 받아주도록 할 거예요. , 자, 요런 커넥션 스트링을 말 그대로 DB에 연결을 할 때 어떤 DB랑 어떤 환경으로 어떤 조건으로 연결을 할지 등등을 이제 받아주는 그런 부분이라고 생각하시면 되겠습니다 뭐 이거는 , 사실, DB 커넥션 스트링은 어느정도 아실 것 같고 , 자, 그 다음에 클리어 함수랑 또 이제 실질적으로 요 풀에서 DB 커넥션을 꺼내는 함수랑 그리고 반납하는 함수를 만들어 줄 겁니다 근데 DB 커넥션 같은 경우에는 , 사실, 뭐 굳이 얘를 쉐어드 포인터로 사용할 필요까지는 없는게 얘는 진짜 단순하게 팝을 해가지고 여기서 어떤 한 행동을 해가지고 쏴준 다음에 바로 다시 반납을 하는 식으로 이제 계속 재사용을 하게 될 겁니다. 그렇기 때문에 뭐 굳이 얘를 레퍼런스 카운팅 해가지고 이리저리 막 건네주는 그런 작업까지는 아니기 때문에 그냥 일반 생 포인터로 얘만 좀 예외적으로 관리를 하도록 할게요. 어지간해선 다른 애들은 스마트 포인터를 사용했었는데 얘네들은 그냥 이렇게만 만들어 보도록 합시다. 그래가지고 Connect, Clear, Pop, Push , 이렇게, 사실, 4개의 함수만 , 일단은, 만들어 주면 되겠습니다. 어 그래서 이거 하나씩 구현부를 , 일단은, 추가해주도록 할게요 전 마우스로 손가락이 아파서 마우스롤 다 , 이렇게, 하나씩 추가를 해주도록 하겠습니다 클리어도 만들어주고 팝도 만들어주고 푸쉬도 , 이렇게, 만들어주도록 할게요 그 다음에 다시 올려가지고 여기부터 작업을 해볼건데 뭐 , 사실, 생성도에서는 딱히 할 건 없을 것 같고 소멸자에서는 그냥 클리어 함수를 호출해 주도록 하겠습니다. , 사실, 어지간해서 우리가 db커넥션 풀을 날릴 일은 없었겠지만 그래도 이왕 만드는 김에 정리하는 작업을 여기 넣어봤고요. 가장 중요한 부분은 이제 커넥트라고 해가지고 연결을 요청... 연결을 맺어주는 부분입니다. 얘는 처음에 서버가 뜰 때 딱 한 번만 , 일단은, 해주면 된다고 보시면 되겠어요. , 자, 그래서 이제 db랑 연결을 해야 되는데 먼저 락을 걸어 줄 것이고 , 자, 여기부터 이제 온갖 함수들이 사용이 될 텐데 굳이 지금부터 구글링을 하면서 MSGN을 살펴볼 것까지는 없을 것 같아요 그냥 전체 흐름을 살펴보시길 바라겠습니다 먼저 sql-alloc-handle 이라는 함수를 이용해가지고 얘가 이제 굉장히 자주 사용이 되는데 어떠한 사유로 얘를 이제 사용하는지를 계속 , 이렇게, 우리가 적어주게 됩니다 처음에는 sql-handle-env 라고 해가지고 여기 있는 이 env 를 만들어 줄 것이다 얘를 연동시켜 줄 것이다 라고 일단 하는 거고요 두번째 인자를 그냥 sql-handle-null-handle 를 넣어주면 되고 그 다음에 세번째 인자로 드디어 이 environment 자체를 여기다가 넣어가지고 얘를 채워주세요 라고 일단 , 이렇게, 넣어주시면 되겠습니다. 그래서 일단 , 이렇게, 핸들을 하나를 만들어 주시고 그 다음에 얘가 만약에 실패했다, success가 아니라고 하면 뭔가 문제있는 상황이니까 return false를 때려주도록 하겠습니다. 그 다음에 sql-set-env-attribute 라고 해가지고 아까 방금 만들어준 핸들을 이용해가지고 여기서 우리가 연결할 odbc 버전을 설정해 줄 수가 있어요 attribute-odbc-version 그 다음에 여기서 SQL 포인터 밸류라고 진짜 어떤 버전을 사용할 것인지 넣어주게 되는데 SQL 포인터 타입으로 캐스팅 해가지고 SQL OB ODBC 3 이라는 버전으로 즉 3점대 버전으로 일단 만들어주고 마지막 인자는 , 이렇게, 0으로 넣어주시면 되겠습니다 세부적으로 얘가 각각 무엇을 하는지는 문서를 찾아보시면 되는데 뭐 크게 중요한 부분은 아니에요 어차피 이건 한 번만 만들어주고 다시 쳐다볼 일도 없을 겁니다 그래서 , 이렇게, return false를 때려주고 , 자, 뭘 하는지는 잘 모르겠지만 지금 뭔가 , 이렇게, 환경이라는 애를 만들어놨다 그리고 환경은 딱 한 번만 디디 커넥션을 처음에 연결할 때 한 번만 필요하다라는 거 , 일단은, 어렴풋 알고 있는 겁니다 그 다음이 이제 중요한데 여기서 우리가 커넥션 카운트를 인자로 받아줬는데 그 개수만큼을 연결을 맺어줄 거에요 그래서 연결을 여러개를 맺어주는데 그 연결이란 무엇이냐면은 우리가 결국에는 그 연결이라는 DB Connection 이라는 개체를 통해 가지고 DB에다가 요청을 보내게 될 겁니다 근데 그 요청 자체를 한 스레드에서만 한다고 보장은 할 수가 없겠죠 뭐 스레드가 5개에서 동시에 DB에다가 요청을 보낼 수도 있을 테니까 그런 경우라고 하면은 커넥션 카운트를 스레드 개수만큼을 만들어가지고 하나씩 뭐 사용하거나 하는 식으로 돌려서 사용한다고 보시면 되겠습니다. 그래서 커넥션 카운트를 여러 개를 만들어 주고 이제 DB 커넥션을 본격적으로 만들어 주도록 할게요. 여기서 커넥션을 X, U로 만들어 주도록 합시다. DB 커넥션을 , 이렇게, 만들어 줄 것이고 그 다음에 얘를 만들어 줬으면 PushBack을 통해 가지고 커넥션을 , 이렇게, 넣어 주도록 할게요 여기까지 왔으면 성공한 거니까 Return True를 때려 줄 것이고 , 자, 그 다음에 여기서 커넥션을 그냥 , 이렇게, 만들어 주기만 하면 끝이 아니라 이제 우리가 여기서 사용하고 있는 이 Environment라는 핸들을 통해 가지고 실질적으로 커넥션을 만들어 주는 부분이 이제 여기 들어가야 됩니다 약간 이런 느낌이죠 커넥션을 통해 가지고 여기서도 나중에 우리가 Connect라는 함수를 또 만들어 줄 것인데 첫 번째 인자로 우리가 처음으로 할당받은 이 env environment 핸들을 넘겨줄 것이고 두 번째로 connection string을 넘겨주도록 하겠습니다. 그래서 return false 만약에 실패했으면 return false를 때려줄 것이고 그 다음에 빠르게 clear랑 pop push는 각각 만들어보자면 이건 뭐 딱히 엄청난 그런 작업을 할 건 아니고 그냥 정리작업입니다. 이 핸들을 체크해가지고 만약에 얘가 null handle이 아니다 라고 하면은 그냥 최종적으로 SQL 프리 핸들을 이용해가지고 정리를 해주도록 하겠습니다. 약간 클로즈 핸들 같은 느낌이죠? 그래서 뭔가 진짜 , 이렇게, 더 이상 필요 없다 싶을 때 얘를 정리해주고 항상 , 이렇게, 사유를, 내가 어떤 애를 지금 닫아주고 있는지를 핸들 타입을 같이 적어주는 부분이 조금 특이한데 뭐 이거는 크게 관심을 든 사양은 아니고 그냥 , 이렇게, 따라서 치시면 됩니다 그리고 실제로 MSN을 살펴보더라도 다 샘플 코드가 있으니까 참고하시면 되겠고 그 다음에 뭐 DB Connection 커넥션도 이제 하나씩 스네어를 하면서 다 꺼주도록 할게요 얘네들도 이제 날려... 메모리를 날려주고 그 다음에 커넥션 클리어를 때려주면 되겠죠 근데 실질적으로 어차피 얘는 이제 서버가 떠있는 동안 평생 사용할 예정이기 때문에 굳이 클리어를 사용할 일은 당연히 없긴 할 겁니다 그냥 라이브러리 차원에서 좀 깔끔하게 만들어주고 있는 거고 그 다음에 팝을 해야 된다 팝을 할 거면은 커넥션스를 체크해가지고 만약에 아무것도 없다고 하면은 널포인터를 뱉어줄 것이고 그게 아니라고 한다면은 지금 남은 애들 중에서 순서는 딱히 상관없기 때문에 그냥 백에서 아무거나 일단 하나 꺼내가지고 커넥션 팝 백을 한 다음에 그 다음에 니턴 커넥션으로 얘를 그냥 뱉어 줄 것이고 반환 할 때는 뭐 그냥 락을 잡은 다음에 커넥션에다가 푸시 백을 통해 가지고 다시 커넥션을 반납을 해주면 되겠죠 뭐 굉장히 단순합니다 , 자, 이렇게, 가지고 푸시 팝 그리고 클리어, 그 다음에 커넥트, 처음에 초기화하는 함수까지 , 이렇게, 만들어 놨으니까 이제 db커넥션 쪽에 가가지고 이어서 작업을 해 보도록 할게요. , 자, db커넥션 쪽에서는 얘도 이제 비슷하게 여러가지 함수들이 있을텐데 얘는 특이하게 핸들을 두개를 갖고 있을겁니다. 첫번째는 sql-hdbc 라고 해가지고 얘는 이제 핸들인데 데이터베이스 커넥션의 약자입니다 그래서 진짜로 커넥션을 담당하는 그런 핸들이고요 얘도 마찬가지로 널핸들로 , 일단은, 널값으로 초교를 하고 그 다음에 두 번째로는 SQLHSTMT 뭔가 이름 자체가 굉장히 수상한데 얘는 스테이트먼트의 약자라고 보시면 되겠습니다 어떤 상태를 관리하는 거죠 그래서 실질적으로 얘를 어떻게 사용하는 거냐면은 우리가 , 일단은, 연결을, db커넥션을 맺어가지고 연결을 딱 해준 다음에 거기다가 나중에 요청을 보낼 때 요 스테이트먼트를 통해 가지고 이런저런 인자들을 연결을 해주게 됩니다. 근데 이건 뭐 지금 설명하기보다는 그냥 사용 예를 보면 굉장히 직관적이니까 그냥 일단 두 개를 만들어야 된다라는 것만 어려운 부분 , 일단은, 알면 되겠어요. 그래서 아까랑 마찬가지로 , 일단은, 커넥트 함수를 얘도 이제 다시 사용할 건데 아까 처음에 우리가 처음에 만들어준 이 환경 그러니까 말 그대로 오디비스를 사용하는 그 환경이었죠? 걔를 일단 처음으로 , 이렇게, 받아줄 것이고 그 다음에 두 번째로 커넥션 스트링을 , 이렇게, 받아주도록 할게요 건네받아주는 거죠 그래서 얘를 일단 넘겨받은 애를 이용해가지고 커넥션 스트링이랑 같이 넘겨받아서 실제로 연결하는 부분을 만들어줄 것이고 그 다음에 얘도 정리하는 부분도 만들어줄 것이고 어 그 다음에 실제로 퀄이를 어떤 db 퀄이를 SQL Query를 실행하는 그런 Execute함수를 만들어 놓도록 하겠습니다. 그리고 우린 앞으로 이제 W 캐릭터로 통일해서 가기로 했으니까 W 캐릭터로 만들어 놨고요. 그 다음에 Fetch라고 해가지고 경우에 따라서 실행을 한 다음에 결과를 받아오는 그런 경우도 있겠죠. 만약에 그냥 인서트 계열의 그런 요청이 아니라 뭐 Select 같은 요청을 우리가 보냈다고 하면은 결과를 받아와야 되는데 뭐 그런 거와 관련된 부분이라고 일단 보시면 되겠어요. Fetch할 것이 있냐 없냐. , 자, 그 다음에 getRowCount라고 해가지고 데이터가 몇 개가 있는지, rowCount를 받아오는 부분이랑 그 다음에 unbind라는 함수를 만들어 줄 건데 이거는 조금 있다가 왜 뭐하는 애인지 일단 설명을 드릴 거고 그 다음에 두 번째로 , 자, 이제 bindParameter라고 해가지고 우리가 어떤 SQL query를 실행을 할 때 인자들을 넘겨줘야 되는 부분이 종종 자주 생기게 될 겁니다. 그래가지고 그 SQL query한테 우리가 인자를 넘겨줄 때 이 statement를 통해 가지고 그 인자를 넘겨줘야 되는데 그 부분이랑 관련이 되어 있다고 보시면 되겠어요. 근데 이것도 역시나 사용하는 실시 예를 보면 굉장히 단순하니까 , 일단은, 그냥 설명을 생각하고 그냥 바로 보여드리도록 할게요. sqlusmallint 라고 한 다음에 파라미터 인덱스 몇번째 파라미터인지 인자인지 넘겨줄 인자가 여러개가 될수도 있으니까 그 순서를 일단 지정해주는거고 그 다음에 SQL SmallInt 라고 해가지고 C타입이라고 일단 이름을 지어주도록 할게요 , 자, 이 C타입은 무엇이냐 이거는 좀 지금 보여드리는게 나을것 같은데 나중에 가면은 이런 형식들이 다 있습니다 우리가 사용하는 어 형식이 , 사실, 이 odbc라는게 꼭 c++에서만 사용하는건 그런게 아니다 보니까 , 이렇게, 형식들이 다 지정이 되어 있습니다. 그래서 우리가 이제 뭐 예를 들면 우리가 사용하는 형식의 만약에 float를 사용해 가지고 우리가 데이터를 넘겨 줄 것이다 라고 하면은 C타입은 이 sql-c-float 라는게 될 것이고 그거에 해당하는 odb-c 타입은 이제 sql-real이 될 것이다 라고 , 이렇게, 각각 타입이 , 이렇게, 정의가 되어 있습니다 그래서 한마디로 그냥 대칭적으로 우리가 뭘 사용할지 따라가지고 이 표를 참고해서 맞춰주면 된다고 보시면 되겠어요 그냥 뭐 그런 간단한 부분이고 그 다음에 sql-small-int 라고 한 다음에 이게 이제 뒤에 나오는 게 sql-type 진짜로 그 아까 뒤에 본 두 번째 타입을 넘겨 줄 것이고 그 다음에 sql-length라는 거랑 sql-pointer라는 거랑 , 이렇게, 이름을 지어주는 이유는 나중에 우리가 내부적으로 사용하는 함수들에서 다 요런 애들을 받아주기를 원하기 때문에 얘네들을 , 이렇게, 만들어 주는 거예요 , 자, 요렇게 , 일단은, 인자들을 다 만들어 볼 겁니다 마지막으로 넘겨주는 인덱스도 우리가 내부적으로 사용하는 다인드 파라미터 함수에서 실제로 요구하는 부분인데 이것도 나중에 같이 나오게 될 거니까 지금 , 일단은, 이렇게, 시그니처만 만들어주고 스킵을 하도록 할게요 그 다음에 거꾸로 이제 쿼리를 실행한 다음에 데이터를 거꾸로 긁어올 때 얘네들은 실행할 때 넘겨주는 인자고 얘는 데이터를 받아올 때 사용하는 인자라고 보시면 되겠어요 받아올 때도 우리가 어떤 메모리 주소를 건네줘가지고 거기다가 데이터를 받아와야 되기 때문에 얘도 똑같이 , 이렇게, 우리 메모리랑 실질적으로 요청하는 거랑 바인딩을 해가지고 , 이렇게, 묶어가지고 전달을 해줘야 됩니다 이것도 sql-u-small-int-type으로 컬라임 인덱스를 하나 만들어주고 sql-small-int-type으로 c타입을 받아주고 그 다음에 sql-u-length로 length를 받아주고 sql-pointer로 value 그 다음에 sql-length-pointer도 인덱스를 , 이렇게, 또 받아주도록 할게요 마지막으로 에러가 났을 때 공용으로 처리하기 위해서 handle-error라는 이제 SQL의 처리 번호를 받아가지고 어떤 에러인지를 그냥 로그로 찍어보는 간단한 함수를 만들어보고 오늘 이제 만들어 볼 애들을 여기까지 만들어 주면 기본적으로 DB 연동을 할 수가 있게 됩니다 굉장히 놀랍죠? 그래서 생각보다 그렇게 어마어마하게 어려운 작업은 아니에요 그냥 이 라이브러리를 사용하는 것이기 때문에 일단 이런 부분들을 만들어 보도록 하겠습니다 제가 늘 하는 이 부두수를 한번 하고 DB Connection 이라고 일단 주석을 달아주도록 할게요. 요즘은 이 초록색 주석이 안 보이면 좀 마음이 허전하더라고요. 그래서 일단 , 이렇게, 잡아준 다음에 , 자, 여기도 마찬가지로 하나씩 하나씩 임플레멘테이션을 만들어 주도록 하겠습니다. Execute 뭔가 실행을 하겠다. Fetch 데이터를 있으면 긁어오겠다. 데이터가 로우 카운트가 몇 개이냐 그리고 언바인드는 바인드한 거를 이제 깔끔하게 밀어줄 때 사용하는 거고 바인드 파라미터는 인자를 넘겨줄 때 얘는 거꾸로 칼럼을 우리가 받아올 때 사용할 것이고 핸들 에러는 에러가 날 때 처리하는 공용 함수다 라고 , 일단은, 보시면 되겠습니다 , 자, 이거를 만들어 보다 보면은 이제 지금 뭘 하고 있는지 좀 확연히 알게 될텐데 , 일단은, 순서대로 작업을 해보자면 요 코넥트부터 작업을 해볼 겁니다 얘는 아까 참고로 요 부분이에요 우리가 처음에 이 environment라는 환경을 만들어 가지고 버전이 어떤 버전을 사용할 것인지 , 이렇게, 지금 연동을 해놨었죠 여기다가 그래서 여기다가 이제 우리가 어떤 버전을 사용할 것인지 적어 놨고 그걸 이용해 가지고 다시 커네이션 스트링이랑 environment를 건네 줘 가지고 여기서 이제 진짜로 연결하는 부분이 이제 들어가게 된다고 보시면 되겠습니다 , 자, 그래서 얘도 마찬가지로 또 한 번 sql-alloc-handle 이란 함수를 또 사용하게 될 거예요 , 자, 얘를 다시 핸들을 할당하겠다 라고 하는 건데 이제는 핸들 종류가 살짝 달라졌어 달라집니다 이제는 sql hdbc 라고 해가지고 진짜로 이 커넥션이라는 핸들을 만들어 줄 겁니다 그래서 인자가 살짝 바뀌는 부분을 조심해야 되고요 핸들 dbc 아까는 env 였죠? environment 이제는 , 이렇게, 만들어주고 그 다음에 여기서 아까 만들었었던 애고 여기는 참고로 h...env를 받아줘야 됩니다. 오타가 됐는데 henv 입니다. 얘를 받아줘야 되는 거고 , 자, 이렇게, 해서 환경을 넣어주고 아까 만든 환경을 넣어주고 그 다음에 connection 이라는 요 우리가 만들어준 커넥션 핸들 자체를 이제 마지막 인재로 넘겨줘 가지고 이제 얘가 이제 만들어지게 될 겁니다 그리고 얘도 마찬가지로 만약에 실패했다고 하면은 뭔가 문제가 있는 거니까 석섹스가 아니라고 하면은 바로 그냥 리턴 펄스를 하고 종료를 해주도록 할게요 그 다음에 이 커넥션 스트링을 이용해가지고 실질적으로 db 연결을 연동을 해줄겁니다. 먼저 버퍼에다가 잠시 커넥션 스트링을 복사를 해주도록 하겠습니다. 맥스패스만큼을 , 이렇게, 스택 메모리를 할당한 다음에 wsc copy 문자열 복사함수를 이용해가지고 여기 스트링 버퍼에다가 커넥션 스트링을 복사를 해주도록 할게요. 그 다음에 거꾸로 이제 실제로 함수를 호출한 다음에 결과를 담아줄 그런 버퍼를 하나를 , 이렇게, 만들어 줄 것이고 그 다음에 sql.smallInt라고 해가지고 resultStringLength 즉 이 받아준 길이의 받아준 문자열의 길이는 얼마인지를 또 받아주는 변수를 하나를 , 이렇게, 만들어 줄 겁니다 그 다음에 이제 진짜로 sql-driver-connect driver-connect라는 함수를 사용할 것인데 버전이 여러가지 있는데 우리는 지금 이 와이드 캐릭터 w 캐릭터를 사용하고 있으니까 이 w가 붙은 버전을 이용해 줄 거에요 그래서 여기다가 이제 하나씩 하나씩 채워주면 되는데 먼저 connection 핸들을 , 이렇게, 넣어주면 되구요 두번째 인자는 , 일단은, 얘는 그냥 상관없으니까 null로 밀어주시면 되고 그 다음에 reinterpret cast sql wcharacter pointer type으로 string buffer를 그냥 , 이렇게, 건네주면 됩니다. 그리고 count of string buffer를 그 다음에 이어서 , 이렇게, 넣어주면 되고요. 커넥션 스트링 자체를 넣어주는 거죠 한마디로 뭐 굉장히 단순합니다 문서를 굳이 안 봐도 뭘 할지 예상이 가는 그런 부분이고 , 자, 그 다음에 reinterpret 캐스트를 해준 다음에 역시나 SQL W 캐릭터 포인터로 바꿔가지고 result 스트링을 건네주도록 할 겁니다 결과를 여기다가 그냥 저장해달라 이거죠 그래서 뭐 어떤 에러메시지든 뭐건 어떤 결과가 있었는지를 볼 때는 이제 나중에 얘를 꺼냈으면 되거고 카운터 오브는 지금 딱 이 버퍼의 길이라고 보면 되겠습니다 그리고 어... 버퍼가 얘는 이제 나중에 출력을 하면은 이 삼총사를 이용해가지고 여기다가 이제 뭔가 저장이 되겠죠? result string이 네, 그걸 이제 받아주는 부분이고 마지막 인자는 sqldriver no prompt로 , 일단은, 이렇게, 맞춰주시면 되겠습니다. 그래서 뭐 정확하게 뭘 하는지는 모르겠지만 이걸 이용해가지고 sqldriver connect라는 함수를 이용해가지고 진짜로 db에다가 연결을 한다라고 , 일단은, 딱 요약을 할 수가 있는 거죠. 그래서 얘가 이제 return하는 함수가 이제 sql return이라는 거로 이제 튀어나오는데 요 메시지가 얘를 이제 참고해가지고 성공했는지 여부를 판단할 수 있습니다 얘가 만약에 sql success 라는 아이 이거나 아니면 SQL SUCCESS WITH INFO 둘 중 하나라고 하면 성공한 거니까 만약에 요 부분이 뜨면 이제 그냥 return true를 때려주면 되겠습니다. 얘를 바로 , 이렇게, return 때려주도록 할게요. 둘 중 하나라도 하면 성공했다라고 인지를 하면 되는 거고 그 다음에 이걸 하기 전에 , 일단은, 우리가 방금 이 커넥션까지는 일단 만들어가지고 이 함수를 이용해서 연결을 했는데 그 다음에 여기 statement라는 건 아직 안 만들어 줬으니까 얘도 겸사겸사 같이 만들어 주도록 할게요. sql-alloc-handle 이라고 해서 얘도 이번에 이 함수를 호출한 사유는 sql-handle-stmt를 만들기 위해서다 statement-handle을 만들기 위해서라고 한 다음에 그 다음에 connection-handle을 건네줄 것이고 마지막 인자로 statement의 주소값을 , 이렇게, 넘겨주면 됩니다 얘도 마찬가지로 sql-success가 아니다라고 하면 실패한 거니까 return false를 , 이렇게, 때려주면 되겠습니다 그래서 이게 완성이 돼서 return true가 정성적으로 뜨면은 DB에 성공적으로 연결이 맺어진 상태다 라고 , 일단은, 볼 수가 있는 거죠. 그 다음부터 우리가 이제 이 execute 함수를 호출해가지고 막 요청을 빵빵 보낼 수가 있게 된 겁니다. , 자, 그리고 나머지부터 만들어보자면 뭐 클리어 함수는 그냥 뭐 , 사실, 굳이 필요 없긴 하지만 역시나 좀 깔끔하게 정리하는 함수를 만들어놓기 위해서 만들어준거고 null 체크를 해준 다음에 만약에 null이 아니라고 하면은 sql-free-handle 이라는 함수가 있었죠 얘를 유행가지고 사유는 sql-handle-dbc를 닫아주기 위해서입니다 라고 한 다음에 커넥션을 , 이렇게, 넣어주고 그 다음에 커넥션은 sql-null-handle로 이제 깔끔히 밀어주도록 하겠습니다 , 자, 이걸 한 번 더 복붙해가지고 우리의 그 스테이트먼트 핸들도 똑같은 방식으로 요렇게 , 일단은, 밀어 주도록 할 것이고 요 사유도 이제 sql-handle.stmt 라고 바꿔치기 해주면 일단 클리어 함수는 완료가 될 거에요 얘는 뭐 딱히 중요하지는 않고 그 다음에 execute 얘가 이제 굉장히 중요한 함수인데 얘 같은 경우에는 어떤 쿼리를 받아줄겁니다. sql 쿼리를 받아줘가지고 개를 실행해달라고 우리가 던져줄건데 sql exec direct w 라는걸 이용해가지고 역시나 와이드 캐릭터 버전으로 만든 다음에 첫번째 스테이트먼트를 이용해가지고 우리가 이런저런 인자들을 같이 던져줄 것이기 때문에 그거를 이제 스테이트먼트 핸들을 이용해가지고 작업을 해주게 될 것이고 그 다음에 SQL W 캐릭터 포인터로 Query를 넘겨주고 마지막으로 인자는 SQL NTSL을 , 이렇게, 설정해주면 됩니다. 그리고 여기서도 마찬가지로 SQL 리턴 값이 , 이렇게, 나오는데 이 리턴 값을 보고 성공했는지 실패했는지를 판단할 수가 있습니다. 그래서 만약에 요 리턴, 리턴값이 자동환성이 쓸데없이 되고 있는데 SQL SUCCESS 이거나 아니면 리턴값이, 리턴값이 어, SQL SUCCESS WITH INFO 둘 중 하나라고 하면은 성공한 거니까 리턴 뚫을 해로, 트롤을 때려줄 것이고 아니라고 하면은 핸들 에러로 가가지고 얘를 처리해주도록 할게요 얘는 이제 약간 얘, 이 리턴값을 보고 로그를 출력하는 부분이 굉장히 반복해서 등장하기 때문에 얘를 공용으로 묶어준거고 말이 나온 김에 핸들 에러부터 여기 맨 아래 가가지고 얘부터 작업을 해보도록 할게요 , 일단은, 먼저 만약에 리턴값이 SQL SUCCESS라고 하면은 뭔가 잘못 온겁니다 그냥 성공한 거니까 리턴을 때려줄 것이고 그게 아니라고 하면은 이제 하나씩 하나씩 체크를 해볼 거에요 , 자, 그래서 인자가 좀 많이 필요한데 sql smallint index 1번 이 에러가 여러개가 있을 수 있기 때문에 이거를 이제 여러번 호출하는건데 sql 더블 캐릭터를 하나를 만들어 줄 것이고 sql state , 자, 이렇게, 일단 두번째 인자를 만들어 줄 것이고 그 다음에 sql integer 그리고 native error 라고 , 이렇게, 세번째 인자를 만들어 줄 것이고 , 자, 이게 다 받아주는 인자이기 때문에 어쩔 수 없이 그냥 좀 복잡하지만 만들어 주고 있는 겁니다 이건 굳이 외울 필요는 없고 그냥 한 번만 만들어 주면 돼요 , 자, 그 다음에 error message는 이제 실질적으로 우리가 그 error 출력 함수를 호출할 때 여기다가 어떤 사유로 인해가지고 지금 실패가 일어나는지 error message를 출력을 해주게 됩니다. 얘가 이제 굉장히 중요해요. 그 다음에 small int로 message length 여기 위에 채워진 message가 얼마짜리 길이냐를 , 이렇게, return 해주게 될 것이고 마지막으로 sql return 값을 , 이렇게, 일단은, 만들어 주도록 할게요. , 자, 그 다음에 아 여기 인자로 받아준거랑 이름이 너무 같으니까 두번째 인자 같은 경우에는 다른 이름으로 바꿔주도록 합시다 에러리턴 이라고 일단 받아주도록 할게요 , 자, 그 다음에 여기서 무한 루프를 계속 돌것인데 그 다음에 이제 해야되는거는 무엇이냐면은 여기다가 sql-get-diag-w 이름부차도 굉장히 수상한 요런 함수를 호출해줄건데 얘가 이제 에러가 난 그 정확한 에러 메세지를 이제 추출해주게 됩니다. 그래서 여기서도 sql-handle-stmt 그리고 statement를 건네줄 것이고 여기다가 이제 왜 실패했는지를 보는 겁니다. index랑 sql-state 그 다음에 native-error 그 다음에 error-message 그리고 count-of-error-message error-message 버퍼의 길이를 넘겨줄 것이고 마지막으로 message-length를 이제 출력을 해주게 될 겁니다. 그래서 요런 거를 이제 다 넣어줘가지고 받아주게 되면은 여기다가 마찬가지로 우리가 에러를 체크하기 위한 이 리턴이 이제 , 이렇게, 뱉어지게 될건데 이걸 이용해가지고 다시 한번 체크를 할 수 있는데 만약에 SQL NO DATA가 떴다라고 하면은 어 이거 체크해봤는데 아무런 에러 없는데? 라는 상황이 되는거니까 그냥 바로 종료를 해버릴거고 그게 아니고 에러 리턴을 받았더니만 역시나 SQL SUCCESS가 떴다거나 아니면은 뭐 error return을 체크해봤더니만 sql success with info가 떴다고 하면 별다른 문제가 없는거니까 그냥 break를 때려줄겁니다 근데 그게 아니라고 하면은 여기까지 들어왔다고 하면은 이제 해당 번호에 해당하는 error message가 무엇인지를 이제 출력을 해주게 될거에요 그러면 여기다가 cout wcout. 한국어도 일단 포함이 될 수 있으니까 우리 환경에서는 한국어 환경도 그리고 locale kor로 , 일단은, 환경을 설정해주고 에러 메시지를 간단하게 이런 로고로 출력을 해주도록 할게요. 나중에 가면 이런 로고도 성의 없이 , 이렇게, 만드는 게 아니라 파일 입출력을 통해서 파일에다 남긴 거나 하는 식으로 다양하게 로그를 남길 필요가 있게 됩니다. 왜냐하면 실제로 라이브에서 우리가 서버를 띄울 때는 콘솔 로그는 더 이상 받지 않고 보통 서비스로 서버를 띄우기 때문에 파일 입출력으로 남겨야 돼요. 이건 개발 단계에서만 체크를 하는 겁니다, 한마디로. 그 다음에 인덱스를 증가시켜서 모든 에러 메시지를 하나씩 하나씩 이런 식으로 체크를 해주게 됩니다. 그래서 뭐 자세히는 모르겠지만 이 함수를 이용해 가지고 지금까지 일어난 에러를 체크할 수 있다라는 걸 , 일단은, 뭐 알 수가 있는 거고요. 그 다음에 겸사겸사 여기 error message에다가 실질적으로 일어난 문제가 무엇인지를 이제 출력을 해주게 된다라고 , 일단은, 뭐 결론을 내릴 수가 있을 거예요. 그래서 , 이렇게, 간단하게 handleError라는 함수를 , 이렇게, 만들어 봤고요. , 자, 그 다음에 나머지 부분 이제 드디어 좀 위로 올라와가지고 어... Fetch부터 만들어 보도록 할게요 얘는 이제 말 그대로 데이터를 이제 긁어올 때 사용하는 그런 함수라고 보시면 되겠습니다 그래가지고 SQL Return을 먼저 받아가지고 SQL Fetch라는 함수를 호출해가지고 얘가 만약에 성공했다고 하면은 받을 데이터가 있다는 의미이기 때문에 여기서 이제 뭔가를 받아주면 되겠어요 근데 여기서도 체크해가지고 사율을 체크한 다음에 success 라거나 아니면은 case가 success with info 라고 하면은 성공한 거니까 return true 를 때려줄 것인데 그게 아니라 데이터가 없다고 하면은 뭐 경우에 따라서 그냥 그 우리가 진행한 query는 완료가 되었지만 걔가 딱히 뭐 반환하는 값이 없는 경우도 있겠죠 그런 경우에는 no data가 뜰 거니까 끝나는 거고 그게 아니라 우리가 진짜 요청한거에서 뭔가 잘못됐다고 하면은 여기서 핸들 에러를 통해가지고 로그를 찍어줄 것이고 그게 아니라 그냥 기본 상태는 뭔지 모르겠지만 리턴 투로로 , 이렇게, 반환을 해주도록 하겠습니다 뭐 대부분 근데 여기서 걸리진 않고 여기 윗단에서 하나쯤 걸리게 될겁니다 그래서 fetch함수도 만들어놨고, 그 다음에 getrowcount, sql-length, count, 0번, sql-return, 데이터가 몇 개 있는지를 의미를 하는 겁니다. sql-rowcount를 추출할 것인데, statement를 통해 가지고 , 이렇게, 받아줄 것이다 즉 스테이트먼트는 우리가 인재를 넘길 때도 사용할 수 있지만 , 이렇게, 거꾸로 인재를 그러니까 출력된 결과물을 db에서 이제 긁어온 결과물들도 사용할 때도 , 이렇게, 이용을 한다고 보시면 되겠습니다 그러니까 말 그대로 상태라는 의미로 받아주시면 되겠어요 그래서 얘를 일단 사용하면 될 것이고 만약에 얘가 sql success가 떴다 그렇거나 아니면 리턴이 sql success with info가 떴다고 하면은 성공한 거니까 return static cast를 해준 다음에 , 자, 여기 우리가 방금 받아온 카운트를 뱉어줄 것이고 그게 아니면 그냥 return-c로 없다고 , 일단은, 뭔가 잘못됐다고 , 이렇게, 뱉어주도록 하겠습니다 거의 끝나가는데 그 다음에 이제 unbind 같은 경우에는 우리가 이 bind parameter, bind column을 통해 가지고 인자들을 넘겨주기도 하고 결과를 받아오기도 할 텐데 처음에 사용할 때는 그 이전에 있던 맵핑된 값들이 들어가 있을 수 있으니까 걔네들이 한 번 날려줘야 됩니다. 한마디로 초기화를 해주는 거죠. 그래서 그거를 sql-free-stmt라는 함수를 이용해가지고 스테이트먼트를 넣어준 다음에 여기서 이제 무엇을 해주고 싶은지 sql-unbind를 먼저 해줄 것이다 라고 , 이렇게, 하면 되고요. 그 다음에 두 개를 더 만들어가지고 똑같이 sql-reset-parameter도 초기화를 할 것이고 그 다음에 SQL CLOSE까지 호출해가지고 완전히 깔끔하게 요 스테이트먼 상태를 정리를 해주도록 하겠습니다. 언반드가 호출이 되었으면 이제 다시 얘를 처음부터 바인드 파람을 통해 가지고 깨끗이 이제 다시 사용할 준비가 된 거예요 , 자, 그래서 그 다음에 이제 바인드 파라미터랑 바인드 컬럼 이 두 함수가 이제 굉장히 중요한데 일단 만들어보고 간단한 사용 예를 보시면 이제 좀 감이 잡힐 거예요 , 자, SQL 바인드 파라미터 얘가 사실은 가장 아이고 파람 미터 요런 함수가 있습니다 요 함수를 호출해야 되고 첫 인자로 스테이트먼트를 받아주고요 우리가 지금까지 연동한... 그런... 어... 모든... 아, 이걸 Bind Parameter를 통해가지고 우리가 매번마다 얘를 호출해줘가지고 이제 요 Statement를 통해가지고 몇 번째 인자를 무엇으로 우리가 세팅하고 싶은지를 여기다가 각 채워준다고 보시면 되겠습니다 그래가지고 일단 기본적으로 몇 번째 인자를 채워줄 것인지 그리고 param sql-param-input 즉, 우리는 지금 인자로 얘를 설정하고 싶다라는 옵션을 주고 있는 거고요 그 다음에 C타입이랑 SQL타입을 각각 넣어줍니다. C타입은 아까 우리가 , 사실, 내부적으로 사용하는 그 뭐 C under bar 뭐시기라는 그 타입을 얘기하는 거고 그게 이제 변환되어 가지고 SQL에서도 하나의 타입이 있을 건데 그 타입을 각각 두 개를 지정해 주게 될 겁니다. 그래서 이건 나중에 사용해 보면 무슨 얘기인지 확실히 알게 되고 그 다음에 여기 사용하고 있는 이 아이들의 크기, 예를 들면 4바이트다를 하면 4를 이제 입력을 해주면 되는 거고 그 다음에 0을 입력, 얘는 상관이 없고 어, 그 다음에 실질적으로 데이터가 있는 걸 이제 포인터로 넘겨주게 될 거예요 그래서 포인터를 넘겨줄 것이고 0 마지막으로 인덱스라고 해가지고 얘는 이제 만약에 가변 길이일 경우, 예를 들면 우리가 문자열 자체를 전송해야 된다고 하면은 문자열은 길이가 제각각이기 때문에 그 마지막 정보를 여기다가 이제 넘겨주게 될 겁니다. 근데 그게 아니라고 하면 대부분은 그냥 0을 담은 그런 포인터, 그니까 정수 포인터를 그냥 넘겨주면 되게 됩니다. 이것도 뭐 사용해보면 무슨 얘기인지 알게 될 것 같으니까 그냥 간단하게 , 이렇게, 설명하고 여기서 최종적으로 이 sql-return이라는 거를 또 체크해가지고 만약에 sql-success가 아니고 그리고 요 값이 sql-success-with-info도 아니다 라고 하면은 뭔가 문제 있는 상황이니까 handleError를 통해 가지고 얘를 한 다음에 그냥 return false를 때려주도록 할게요. 그리고 여기서는 return true로 성공했으니까 return true를 해주도록 하겠습니다. 그 다음에 bind column도 거의 비슷한 느낌이에요. 위에 거랑 거의 비슷한데 얘는 이제 사용하는 함수가 sql-bind-col이라는 이 함수를 이용할 것이고 환경 핸들을 넘겨준 다음에 column-index 그리고 ctype 그 다음에 value-length-index를 순차적으로 건네주게 될 겁니다. 그리고 얘도 sql-return을 받아줄 것인데 얘를 받아줘가지고 역시나 에러 체크를 한 다음에 만약 얘가 SQL SUCCESS가 아니고 그리고 RETURN이 SQL SUCCESS WITH INFO도 아니라고 하면은 문제가 있는 거니까 역시나 핸들 에러를 호출해 줄 것이고 RETURN FALSE를 때려주고 그게 아니라고 하면은 성공한 거니까 RETURN TRUE를 때려주도록 하겠습니다. 굉장히 힘들었는데 , 이렇게, 하면은 , 일단은, 모든 준비가 끝났다고 보시면 되겠습니다. 그럼 이걸 어떻게 활용하느냐 그 부분이 나와야 되겠죠 먼저 여기 db 커넥션 풀은 전역으로 딱 하나만 들고 있을 겁니다 풀링을 하긴 할 건데 얘는 어떤 스레드이건 누가 필요하게 될지는 아직 예측할 수 없기 때문에 그냥 전역으로 놓고 필요한 애가 꺼내서 쓰게 될 겁니다 그렇기 때문에 우리가 전역으로 사용하는 애들은 코어 글로벌에다가 항상 여기서 관리하고 있었으니까 , 자, 코어 글로벌 쪽에 가가지고 여기다가 일단 넣어주도록 할건데 근데 만약에 이제 DB를 사용 안하는 경우도 있겠죠? 그럴 경우라고 한다면은 뭐 여기서 하기보다는 컨텐츠 단에서 , 사실, 이 전역 변수를 만들어 주는게 조금 나을 수도 있겠습니다 , 사실, DB를 사용할지 안할지는 아직 모르기 때문이죠 근데 지금은 그걸 신경쓰지 않고 그냥 , 이렇게, 이 갭체를 같이 만들어 주도록 할게요 DB Connection Pool 사용 안할거면 그냥 Connect라는 함수를 호출 안하도록 그냥 사용하도록 합시다 그래가지고 DB Connection Pool을 여기다가 헤더를 추가해준 다음에 이 변수를 아래쪽에다가 , 이렇게, 만들어 주도록 할게요. 널프인터로. 그 다음에 이쪽에다가 new db-connection-pool을 만들어주고 그 다음에 삭제를 할 때도 delete gdb-connection-pool 삭제도 해주도록 하고 그 다음에 서버콜을 빌드해가지고 별다른 문제가 없는지 체크를 , 일단은, 해 보도록 하겠습니다. , 자, 그래서 이제 문제가 없는 걸 확인을 했고 이제 커넥션 풀을 처음에 커넥트를 통해 가지고 우리가 원하는 개수만큼을 요 커넥션 스트링을 향해 가지고 db 를 연결을 해 줄 것이고 그러면 이 db 커넥션이 매져질 것이고 그 다음에는 팝을 해 가지고 db 커넥션 만들어진 걸 하나 꺼내 가지고 이런저런 연동을 해 준 다음에 바인드를 통해 가지고 바인드 파람, 바인드 콜 이걸 이용해 가지고 컬럼이랑 인자들을 다 세팅을 한 다음에 엑세큐트를 빵 때려주면은 실질적으로 걔가 이제 실행이 될 겁니다. 그 다음에 받아올 결과가 있다고 하면은 이제 Fetch를 이용해 가지고 하나씩 하나씩 이제 받아오면 된다라고 일단 볼 수가 있겠어요. 그래서 이걸 사용해 보도록 할 건데 먼저 DB가 있어야지 이걸 활용할 수 있겠죠 그래서 DB는 어떤 제품군이건 다 지원을 하긴 합니다 SQL 서버도 되고 MySQL, Oracle 다 되고 되긴 하는데 그냥 기본적으로 비주얼 스튜디오를 깔 때 같이 깔리는 이 4장으로 내장 DB를 활용할 거에요. 기본적으로 내장으로 SQL 서버가 , 일단은, 같이 설치가 됩니다. 간단하게 테스트할 때는 여기 내장 DB를 사용하는 게 굉장히 편하기 때문에 여기다가 테스트할 것이고 여기서 보기에서 SQL 서버 개체기 탐색기를 통해가지고 이 창을 이제 열어줄 수가 있는데 만약에 이게 뜨지 않는다고 한다고 하면은 처음에 Visual Studio 인스털러를 켜가지고 여기서 제 기억으로는 수정에 가가지고 여기서 하나를 설치를 해주셔도 되겠습니다. DB와 관련된 뭔가가 있거든요. 여기 찾아보면 데이터 스토레지 처리, 아마 얘를 일단 설치를 해주시면 그게 뜨게 될 겁니다. 그래서 이게 떴다는 가정 하에 저는 지금 데이터베이스를 여기 산 하에 그냥 서버디비라고 , 이렇게, 만들어 놨어요 똑같이 만들어 주시면 되겠습니다 우클릭 해가지고 새 데이터베이스 추가한 다음에 그냥 서버디비라는 이름으로 만들어 주고 얘가 만들어졌다고 하면은 여기서 우클릭 속성에 가서 살펴보면은 연결문자열이라는 게 나옵니다 그래서 여기서 다 이걸 긁을 필요는 없는데 여기서 중요한 부분 몇 가지만 보면은 처음에 이 데이터 솔스에 해당하는 이 부분만 , 일단은, 기억을 해 주시면 되겠어요 로컬 디비 짝대기 mssql 로컬 디비로 전 되어 있는데 여러분들은 뭐 다를 수도 있습니다. 그 이름을 기억을 하시고 그 다음에 디비 이름은 서버 디비라고 되어 있는 걸 볼 수가 있습니다. 이거 두 개를 일단 기억을 해주시면 되겠어요. 그래서 이거는 일단 기억을 하고 , 자, 그 다음에 다시 솔루션 탐색기에 와가지고 이제 어... 우리의 서버 코드로 돌아가도록 할 건데 , 자, 여기 게임 서버로 , 일단은, 돌아가가지고 DB를 이제 연결을 하고 간단하게 뭐 데이터를 밀어넣고 하는 부분을 실습을 해보도록 하겠습니다 , 자, 그래서 먼저 위에 가가지고 일단 오른쪽에 놓을게요 오른쪽에 작업하는게 좀 편한 것 같아서 CPP는 일단 Include DB Connection Pool을 사용할 거니까 얘를 추가를 해주도록 하고 , 자, 여기 타이머 관련 실습은 끝났으니까 이 부분은 날리고 여기다가 일단 이어가지고 실습을 해보도록 할게요 이 영역에다가 그러면은 먼저 가장 먼저 해야 되는 거는 무엇이냐 DB Connection Pool을 만들어줘야 되겠죠 여기다가 커넥트를 해가지고 우리가 필요한 개수만큼을 만들어주면 되겠습니다. 이거가 아니라 커넥트 , 이렇게, 해가지고 필요한 개수만큼 만들어주면 되는데 우리는 뭐 지금 그냥 테스트할 거니까 한 개만 만들어주도록 하겠습니다. 여기서만 그냥 간단히 테스트하고 해보고 마칠건데 나중에 가면은 뭐 충분하게 스레드 개수만큼을 미리 만들어 준다거나 하는 식으로 작업을 해주면 되겠어요. , 자, 그 다음에 여기다가 이제 두번째로 어... 커넥션 스트링이 들어가야 되는데 요 부분이 이제 조금 헷갈릴 수가 있습니다 먼저 이제 우리가 odbc를 활용할 때 odbc의 커넥션 스트링을 구글에 찾아보면은 나오는데 저같은 경우에는 지금 요런 형식으로 만들어주면 됩니다 , 일단은, 이거 그냥 구글에 보여드리는 게 나을 수도 있을 것 같네요 구글에 가가지고 odbc 커넥션 스트링 이라고 , 일단은, 딱 치면은 이제 여기서 굉장히 많은 정보들이 나오는데 예를 들면 우리가 사용하는 게 SQL 서버다 보니까 이 버전을 살펴보면 대략적으로 이런 느낌으로 만들어주면 된다는 걸 알 수가 있습니다. 패스워드랑 아이디 패스워드까지 입력을 하는 버전을 사용할 것인지 아니면 우리는 그냥 트러슬 커넥션으로 만들어 줄 거니까 이걸로 , 일단은, 작업을 하면 됐고요. 이걸 긁어와가지고 대략적으로 여기다가 일단 , 이렇게, 넣고 시작을 하도록 할게요. 이게 일단 양식이라고 보면 되겠습니다. 그 다음에 여기 드라이버라는 게 들어가는데 이거는 제품마다 어떤 DB를 사용하시냐에 따라서 살짝 다른데 우리는 지금 여기 내장 DB를 사용하고 있죠? 내장 DB 같은 경우에는 얘가 SQL, 서버, 네이티브, 클라이언트, 그 다음에 버전을 , 이렇게, 입력을 해주게 됩니다. 근데 이거는 이 버전은 , 사실, 뭐 깔리는 게 좀 다를 수도 있는데 이거는 또 어떻게 보냐면은 처음에 시작에서 ODBC를 가가지고 데이터 원본이라는 게 있습니다. 얘를 본 다음에 여기서 드라이버를 눌러보면 지금 설치된 모든 애들이 보이고 있는 겁니다. ODBC랑 연동할 수 있는 모든 애들이 보이는데 제가 사용하는 버전이 SQL Server Native Client 11.0 이라는 게 , 이렇게, 나와 있으니까 얘를 일단 그대로 입력을 해 준 거예요. 만약에 여러분들이 MySQL 연동을 할 것이면은 MySQL과 관련된 ODBC 드라이버를 설치를 해야 됩니다, 반드시. 그러면 여기에다가 이제 MySQL도 뜨게 되겠죠. 뭐 그런 식으로 설치해 주시면 되고 이게 연결이 안되면은 여러분들 환경에 따라가지고 조금 헤딩이 필요할수도 있어요 왜 안되는지는 뭐 이런저런 상황에 따라 다르기 때문에 근데 뭐 기본적으로 내장 DB를 사용할거면은 요렇게 사용하면 되고 그 다음에 이제 서버는 무엇이냐 아까 저같은 경우에는 이거였었죠 로컬 DB 로컬 DB에다가 짝대기 ms-sql-local-db 였습니다. 이거 지금 문자열로 하고 있으니까 짝대기 2개, 백슬래시 2개로 해줘야 되고요. 그래야지 얘를 인지를 할 수 있고, 그 다음에 데이터베이스 이름 같은 경우에는 server-db로 하기로 했으니까 이렇게만 , 일단은, 만들어주면 되겠습니다. 그러면 이 커넥션 스트링을 이용해서 접근을 할 것이고, 나중에 실제로 서버를 라이브로 만약에 나가서 만든다고 하면은 , 이렇게, 그냥 강제로 하드코딩으로 넣는 게 아니라 옵션을 빼가지고 뭐 여기는 서버 주소랑 서버 데이터베이스 이름이랑 비밀번호 같은 거, 어카운트 비밀번호 등등을 다 별도의 파일로 관리한 다음에 그거를 이제 읽어가지고 접근하는 식으로 만들면 되겠습니다. 지금은 뭐 그럴 필요까지는 없으니까 , 이렇게, 간단하게 그냥 크네이션 스탱을 바로 하드코딩을 해봤어요. 요런 느낌으로 , 자, 그래서 여기까지 만약에 성공했으면 일단 다음 단계 넘어갈 수 있는데 얘가 성공했는지는 반드시 체크를 해주도록 합시다. 무조건 성공해야 된다. 어스트 크래쉬를 해가지고 어디서 실패했는지 계속 찾아보기도 귀찮으니까 그냥 일단 크래쉬를 내보도록 할게요, 실패하면. , 자, 그 다음에 먼저 할 거는 크리에이트 테이블을 먼저 해줄 겁니다. 만약에 테이블이 없으면 만들어줄 것이다. 그래가지고 여기서 쿼리를 하나를 만들어줄 것인데 , 자, 여기부터는 이제 SQL Query를 만들어주는 겁니다. drop table if exists 그 다음에 dbo.table 이름은 그냥 골드라고 할게요. 골드라는 정보를 이제 저장할 것이다 라고 요렇게 테이블 이름을 만들어 줄 것이고 여러 줄로 만들어 줄 것이면 여기다가 백슬래쉬를 계속 , 이렇게, 달아주면 됩니다. 만약에 이 dbo.gold라는 테이블이 있으면 , 일단은, 걔를 날려줘라 왜냐면 새로 만들 것이기 때문이죠. 그 다음에 create table 이름은 dbo의 .gold, 골드라는 정보를 저장할 것이고 그 다음에 여기다가 , 이렇게, 만들어줄 것인데 이제 테이블을 설계하는 걸 그대로 넣어주고 있는 겁니다 테이블 설계는 이제 아이디 하나를 들고 있을 건데 int, not null, primary key, 그 다음에 identity까지 , 일단은, 넣어주도록 할게요 일식 증가하는 거죠, 오토인크리멘트로 그 다음에 두 번째는 골드라는 정보를 , 이렇게, 두 개를 들고 있도록 하겠습니다 뭐 딱히 의미는 없어요 어떤 유저가 돈을 얼마 들고 있다라는 그냥 굉장히 간단한 테스트를 하기 위해서 그냥 , 이렇게, 의미의 데이터를 넣어주고 있는 겁니다 네 그렇게 뭐 큰 의미가 있는 데이터는 아니고 , 자, 그래가지고 요렇게 , 일단은, 만들어주면은 얘가 이제 우리의 SQL Query가 되는 거죠 이거를 이제 바로 쏴주면 됩니다 그러기 때문에 여기서 뭔가 하나 빠진 것 같은데 요 부분이 일단 하나 빠졌네요 , 이렇게, 사실, 이렇게, 만들어 주도록 합시다 , 자, 그 다음에 db 커넥션을 , 일단은, 하나를 빼 올 거에요 db 커넥션을 빼 올 것이고 빼온 다음에 그냥 엑세큐트를 빡 날려주면 됩니다 요거 요 같은 경우에는 요 아이 같은 경우에는 별도로 어 인자로 넘겨줄 애들도 없고 그 다음 결과를 뭐 딱히 받아줄 필요도 없으니까 그냥 여기서 커넥션 풀에서 팝을 해가지고 커넥션을 하나 꺼내온 다음에 이걸 통해가지고 엑세큐트를 해서 요 쿼리를 그냥 바로 실행을 시켜주면 됩니다 진짜 그게 끝이에요 근데 성공했는지 굉장히 궁금하니까 실패했으면은 그냥 크래쉬를 내도록 어세티 크래쉬를 하나 내도록 할게요 , 이렇게, 하면은 이제 서버를 띄우면은 접근해가지고 DB에 커넥션이 맺어지면은 이제 여기다가 걔한테 접근해가지고 테이블이 있으면 삭제를 하고 새로 테이블을 만들어 준다라는 부분이 이제 , 이렇게, 들어가게 된다고 보시면 되겠습니다. 그 다음에 뭐 간단하게 뭐 추가적으로 데이터를 뭐 추가하는 부분도 만들어 보도록 할게요. , 자, 데이터를 3번에 걸쳐가지고 추가를 해줄겁니다. 그래서 3번에 걸쳐서 추가해줄건데 여기도 똑같이 , 이렇게, db커넥션을 먼저 꺼내온 다음에 이번에는 db커넥션에 unbind를 통해 인자들이 필요하다 보니까 혹시라도 기존에 사용하던 인자들이 있었으면 걔네들을 날려주도록 할겁니다 기존에 바인딩된 정보 날리는 부분이 먼저 들어갈 것이고 그 다음에 두번째로 이제부터가 좀 달라지는데 넘길 인자를 먼저 바인딩을 해줄겁니다 우리가 지금 실행하고 싶은 쿼리는 뭐냐면 execute를 해줄것인데 그냥 간단하게 뭐 insert query를 날려줄거에요 insert into dbo.gold 라는 테이블에다가 어... 골드라는 항목에다가 얼마의 값을 넣어줘라 여기다가 , 이렇게, 물음표를 하면 이 물음표에 해당하는 부분이 우리가 넘겨주는 이 인자들을 이용해가지고 걔가 여기 안에 들어가게 됩니다 즉 100이라는 인자를 바인딩을 시켜놓으면 여기 안에다가 100이 들어가게 된다는 얘기가 되는 거죠 그래서 , 이렇게, 간단하게 , 일단은, 쿼리를 만들었고 여기다가 넘겨줄 인자를 우리가 또 추가적으로 세팅을 먼저 해줘야 됩니다 그래서 , 이렇게, 먼저 들어갈 것이고 , 자, 그러면 db커넥션에 unbind 했으면 이제 넘길 인자를 바인딩을 해야 되는데 우리가 넘기고 싶은 인자는 먼저 메모리상에 , 이렇게, 골드라는 게 100이 있다고 가정해 볼게요 그럼 sql랜스를 먼저 하나를 또 할당해 줄 건데 얘는 , 사실, 뭐 가변적인 그런 데이터는 아니니까 그냥 0이라는 값으로 가만히 있으면 됩니다 이 문제가 아니기 때문에 얘는 사기 딱히 의미는 없어요 그리고 db커넥션에 아까 bind parameter라는 걸 만들어 놨었죠 얘를 이제 사용할 건데 첫 번째 인자는 1을 넘겨주면 됩니다 1부터 시작을 할 것이고 그 다음에 C타입 그냥 정수를 넘겨줄 것인데 인트 타입을 아까 표를 보면은 뭐 SQL C 언더바 시리즈가 있는데 그냥 SQL C long으로 일단 만들어주면 됩니다 그리고 이 아이가 C언어에서는 요건데 이게 반대쪽에서 SQL 쪽 데이터 타입으로 환산하면은 SQL integer로 이걸로 만들어주면 됩니다 그래서 이거에 맞춰가지고 내가 넣어줄 타입이 무엇인지 따라가지고 일단 얘를 세팅해주면 되고요 그 다음에 크기 사이즈 오브 골드 4바이트를 입력하면 됩니다 한마디로 그리고 데이터가 있는 애는 여기 골드라는 데이터를 넘겨주고 렌스를 그 다음에 마지막 인저로 요렇게 넘겨주면 됩니다 내가 무엇을 넘겨줄지 그리고 넘겨줄 데이터는 어디 있는지 그 다음에 추가적인 정보 옵션 정보를 넣어준다고 , 일단은, 볼 수가 있는 거죠 그래서 , 사실, 문서를 안 봐도 굉장히 직관적입니다 , 사실, 얘는 좀 직관적이지 않긴 한데 나머지 부분은 아 , 이렇게, 사용되는구나 라는 걸 알 수가 있는 거고 여기도 마찬가지로 성공적으로 바인딩이 되었으면은 에러가 안 나겠지만 만약에 문제가 있으면 여기서 바로 크래쉬를 내도록 할게요 넘길 인자 바인딩 그 다음에 마지막으로 SQL 실행이 , 이렇게, 실행이 되는 거죠 그러면은 3번에 걸쳐가지고 지금 데이터를 넣어주고 있으니까 , 자, 우리 지금 아이디 같은 경우에는 프라이머리키아 아이덴티티니까 그냥 무조건 1씩 증가하는 애일테고 여기 골드만 우리가 지금 설정을 해주고 있는 겁니다 골드를 100으로 넣어주세요 라는 데이터를 지금 3개로 만들어놨으니까 계속 데이터가 골드가 100이 들어간 채로 그냥 늘어나게 될 겁니다 그래서 얘가 일단 실행이 되면은 데이터가 종성적으로 다 들어갈 것이고 마지막으로 컬럼을 체크하는 부분도 일단 실습을 해봐야 되니까 거꾸로 방금 넣어준 데이터들을 읽어보는 실습을 해보도록 하겠습니다 그럼 얘도 똑같이 처음에 아까 들어간 부분 요 부분 , 일단은, 공용적으로 들어가야 되고요 , 자, 그 다음에 이번에 호출할 거는 SQL 실행할 부분은 뭐냐면은 얘를 복붙한 다음에 요 부분이 이제 바뀌게 되는데 SELECT 문으로 이제 할 겁니다 SELECT id gold FROM dbo.gold에서 뭐라고 할까요? WHERE gold는 얼마얼마 골드가 얼마 얼마인 애들을 추려가지고 우리한테 다 보여주세요 라고 셀렉트 문을 하나를 날려보도록 하겠습니다 , 자, 그러면은 여기다가 , 일단은, 두가지 정보가 필요하죠 먼저 인풋 파라미터 여기 물음표에다가 치환이 될 부분을 여기랑 똑같이 만들어줘야 되니까 넘겨줄 인자를 먼저 바인딩을 해주도록 하겠습니다 그 다음에 , 사실, 얘랑 뭐 별 차이가 없죠? 얘를 똑같이 , 이렇게, 만들어주면 되겠고 넘겨줄 인자를 바인딩을 한다 그래서 얘가 일단 실행이 되면은 골드가 100인 애들을 다 선택해서 우리한테 보여주세요 라는 명령어가 이제 실행이 될 겁니다 근데 이제는 아까와는 다르게 셀렉트 문은 우리가 뭔가를 받아가지고 걔를 이제 거꾸로 꺼내와야 되겠죠. 그러다보니까 걔를 이제 어디다가 결과물을 저장할지를 또 지정을 해줘야 되는데 그게 바로 bind column입니다. 그래서 먼저 , 이렇게, 두 개의 메모리를 사용할 것인데 아웃 아이디 아이디랑 골드를 받아주고 있으니까 인자를 두개를 , 이렇게, 만들어줘야 됩니다 골드랑 아이디를 받아줄 메모리를 , 이렇게, 만들어주고 그 다음에 sql 렌스는 똑같이 얘는 뭐 항상 있어야 되는거고 , 자, 얘는 아웃 렌스 얘도 sql 렌스 아웃 골드 렌스라고 합시다 , 자, 그 다음에 여기서 db 커넥션에 바인드 컬럼을 해줄건데 첫번째 컬럼을 이제 먼저 바인딩을 해줄거에요 sqlc long 그 다음에 size of outid 그 다음에 결과물을 이제 어디다가 저장해주면 되느냐 outid에다가 결과물을 저장해주세요 라고 일단 부탁을 해주고 있는거죠 outid length 그래서 여기서 나중에 결과물을 여기다가 저장을 해달라고 , 일단은, 우리가 요청을 해주고 있는 겁니다. 얘도 똑같이 바인딩이 성공했는지 , 이렇게, 체크를 해줄 것이고, 그 다음에 얘를 한 번 더 복붙해가지고 이번에는 1번이 아니라 2번, 두 번째 정보, 즉 이제 골드에 해당하는 거죠. 골드는 여기다가 건네주세요라고 부탁을 또 해주고 있는 겁니다. 그래서 , 이렇게, 두 번에 걸쳐가지고 , 일단은, 어... 지금 바인딩을 해준 것이고요 근데 그렇다고 해가지고 요거 엑세큐트가 실행이 되자마자 바로 여기에 딱 데이터가 들어가는 건 또 아닙니다 왜 그러냐면은 애덩크초의 셀렉트 문 자체가 데이터를 한 개만 뱉어준다는 보장이 없죠? 우리가 위에서 데이터를 세 개를 넣어놨으니까 세 개 다 골드가 100인 상태이다 보니까 실질적으로 얘가 어... 뱉어주는 결과물은 열이 세... 그니까 행이 세 개가 되겠죠? 그러다보니까 걔를 그냥 긁어오는게 아니고 와일문을 이용해가지고 디비컨의 Fetch를 , 이렇게, 무한루프를 실행해가지고 데이터를 , 이렇게, 반복적으로 긁어와야 됩니다. 세번에 걸쳐서 , 자, 그래가지고 여기서 , 이렇게, 체크를 해보면 아이디는 얼마얼마이다 아웃 아이디 그 다음에 골드는 얼마얼마이다 아웃 골드 , 이렇게, 추출을 해보면 Fetch를 한번 할 때마다 우리가 그 바인딩한 컬럼에다가 실질적으로 데이터가 이제 딱딱 들어가게 될 겁니다 그래서 그 정보를 각각 , 이렇게, 추출을 해가지고 지금 , 이렇게, 써... 그니까 로그를 찍어보고 있다라고 일단 볼 수가 있는거죠 좀 이해가 가시나요? 그래서 결국에는 바인드 파람은 인자를 넘길 때 바인드 컬럼은 결과를 받을 때라고 , 일단은, 생각을 하면 되고 이제 이게 잘 실행이 되는지 한번 빌드를 해가지고 실행을 해보도록 할게요 아 근데 실행하기 전에 제가 하나 누락한 점이 한 가지가 있는데요 우리가 커넥션 풀에서 db 커넥션을 뽑아서 쓰고 있으니까 다 사용했으면 이걸 다시 db 커넥션 풀에다가 푸쉬 해 줘 가지고 반납을 해줘야지만 이어서 또 사용할 수 있겠죠 이거를 하지 않으면 그 다음에 더 이상 꺼낼 수 없으니까 크래시가 날 겁니다 그래서 얘를 , 이렇게, 몇 번 마다 추가를 해주도록 하겠습니다. , 이렇게, 해주고 그 다음에 정상적으로 실행이 되는지 다시 한번 서버 빌드를 해서 실행을 해보면 되겠죠. 이제 뭐 별다른 문제가 없다고 하면은 뭐 여기 아이디가 추출이 되어가지고 출력이 되는 부분까지 정상적으로 이제 출력이 될 겁니다. 그래서 여기다가 간단하게 109번까지 일단 브레이크 푼을 잡아가지고 게임 서버만 간단하게 실행을 해보도록 할게요. 그러면 , 이렇게, 로그가 정상적으로 뚫고 1, 2, 3, 100, 100, 100으로 다 뜬다는 걸 볼 수가 있고요. 실질적으로 , 이렇게, 그냥 로그만으로 확인하는 게 아니라 여기 SQL 서버 개체 탐색기에 가서 실제로 데이터베이스를 살펴봐도 여기 테이블에 정상적으로 정보가 다 들어가 있다는 걸 볼 수가 있습니다. 여기 데이터 보기 하면 , 이렇게, 3개가 들어가 있죠. , 자, 이렇게, 해가지고 뭐 간단하게 데이터베이스 연동을 해보는 실습을 해봤는데 의외로 그렇게 크게 어려운 부분은 없긴 하지만 근데 지금 이렇게까지만 만들면 , 사실, 좀 아쉬운 부분이 몇 가지가 있습니다 일단 사용하기가 굉장히 더럽죠 우리가 정수를 넣느냐 아니면 나중에 뭐 플로트를 넣느냐 더블을 넣느냐 어떤 타입을 넣는지 따라가지고 , 이렇게, 매번마다 우리가 만들어줘야 되는 부분이라거나 아니면 , 이렇게, SQL 랜스를 만들어가지고 건네줘야 된다거나 하는 부분들이 굉장히 좀 지저분하니까 요런 부분들을 이제 좀 깔끔하게 정리해가지고 만드는 식으로 개선을 이어서 해보도록 하겠습니다. , 이렇게, 이번 강의는 마치도록 할게요.