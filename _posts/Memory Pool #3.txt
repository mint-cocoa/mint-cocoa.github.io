이렇게, 해가지고 지난 시간까지 좀 단순한 방법으로 락 프리 스택을 다시 한번 만들어 봤는데요 약간 미완성인 락 프리 스택이라고 말씀을 드렸죠 다수의 스레드가 동시에 팝을 하면 아주 극악의 확률로 요 부분에서 문제가 일어날 수 있다라는 얘기를 했었구요 , 자, 그 다음에 오늘 이제 좋은 소식이 하나 있고 나쁜 소식이 하나가 있는데 일단 나쁜 소식은 우리가 굉장히 애써서 만든 락 프리 스택을 그냥 삭제를 해버릴 거라는 게 좀 나쁜 소식이구요 하지만 그럼에도 불구하고 좋은 소식은 실질적으로 이 내용을 공부한 이유가 마이크로소프트에서 제공하는 s-list가 있는데 거의 똑같이 되어 있습니다 그래가지고 요 부분을 이제 하나씩 바꿔치기를 해볼 건데 s-list-header 라고 , 이렇게, 딱 치면은 , 자, 요거 대문자로 되어있는 걸로 이제 하나씩 바꿔치기 하면 됩니다 그래서 얘는 이제 헤더고 아 얘는 참고로 엔트리였죠 참 s-list-entry 라고 얘를 바꿔치기 하면 되고 얘가 헤더 header 그 다음에 여기서 initialize head 같은 것도 찾아보시면 initialize s-list head라는 이런 함수가 있습니다 이걸 이용해 가지고 똑같이 초기화를 해주면 되고요 그 다음에 여기서 push-entry list도 얘는 interlocked push-entry s-list라는 이런 함수가 있습니다 얘가 받아주는 인자도 마찬가지로 여기 있는 헤더에다가 그 다음에 s-list 엔트리를 , 이렇게, 받아주고 있으니까 , 이렇게, 바꿔치기를 해주면 되고요 그 다음에 여기 pop-entry-list를 하는 부분도 이 부분도 우리가 interlocked pop-entry-s-list라는 애로 바꿔치기를 해주면 정말로 마법같이 그냥 꼬지 곧대로 수정할 필요 없이 얘가 완벽하게 호환이 되어서 동작을 합니다 정말 그런지 한번 빌드해서 실행을 해봐도 뭐 지난 시간에 우리가 테스트 했던 거랑 마찬가지로 막 , 이렇게, 열심히 데이터를 넣고 빼고 하는 부분이 이제 실행이 될 거예요 그리고 여기 S-list 헤더랑 S-list 엔트리가 어떻게 되어있는지 궁금하니까 얘를 타고 들어가서 FCB를 눌러서 타고 들어가면은 S-list 헤더가 우리가 지난 시간에 만든 구조랑 굉장히 유사하게 되어있죠 그래서 우리가 괜히 , 이렇게, 복잡한 이름으로 얘를 막 비트 단위로 쪼개가지고 , 이렇게, 만들었던 이유가 결국에는 이거를 이제 모방해 보려고 한번 만들어 본 거고요 똑같이 되어있죠 그 다음에 S-list 엔트리 같은 경우에는 그냥 다음 노드만을 , 이렇게, 가리키고 있습니다 그리고 별다른 차이는 없고 이 문법은 혹시 처음 보셨을 수 있는데 여기서 type define을 해가지고 얘를 만듦과 동시에 별칭을 하나를 동시에 지어줄 수가 있습니다 그래가지고 이 구조체를 slistentry라고 이름을 할 것이고 또한 이 아이의 포인터 타입을 PSListEntry라고 이름을 지은 겁니다 그래서 나중에 예를 들면 우리가 이 뒤쪽에서 이런 식으로 SListEntry 포인터 형태로 쓸 거면 얘를 그냥 이 타입으로 호환을 해가지고 그냥 얘를 이용을 해도 얘가 SListEntry의 포인터 타입이다 라는 것을 찰떡같이 알아듣습니다 그렇게 해가지고 뭐 , 사실, 구현부 자체는 조금 다르게 당연히 되어 있겠지만 어찌됐건 사용하는 방법이나 아니면 이 구조 자체는 거의 차이가 없다는 걸 일단 알 수가 있는 거죠 그래가지고 , 이렇게, 락 프리 스택을 사용할 일이 생긴다고 하면은 요 방식을 이용해 가지고 그냥 만드시는 걸 , 일단은, 추천을 드립니다 그리고 이 방식을 사용하게 될 경우에는 결국에는 이전에 말씀을 드린 바와 같이 S-list 엔트리 라는 것을 상속을 받거나 아니면은 멤버 변수 MM 첫 번째로 , 이렇게, 넣어 가지고 16바이트 정렬을 해준 다음에 사용을 하면 된다고 , 일단은, 요약을 할 수 있겠어요 , 자, 그럼 이제 이 내용 우리가 지금까지 공부한 요 내용을 이용을 해 가지고 요 부분을 , 일단은, 좀 삭제를 해보고 다 삭제를 할게요 여기서 삭제를 한 다음에 여기 런치하는 부분만 잠시 , 이렇게, 남겨두고 그 다음에 이어가지고 우리가 이전에 이전에 만들었던 메모리 풀에 돌아가 가지고 요 부분을 살짝 수정을 해볼 건데 지금 , 이렇게, 락을 걸어 가지고 사용하고 있고 게다가 Q 같은 STL 자료 구조를 이용해 가지고 만들고 있었는데 지난번에도 말씀드린 것 같이 이런 Q랑 아니면 벡터 등등을 만약에 사용하게 되면 데이터뿐만 아니라 데이터를 담아두기 위한 공간을 별도로 할당해 가지고 관리를 하니까 그 부분이 살짝 아쉽게 느껴질 수도 있겠죠 그래가지고 결국엔 우리가 이전 시간에 공부한 애슬리스트 엔트리 를 상속을 받는 구조로 얘를 살짝 수정을 해볼 건데요 수정할게 많이는 없습니다 , 자, 일단은, 여기서 하나씩 작업을 해볼게요 , 일단은, 여기다가 오늘 이 애슬리스트 얼라인먼트라는 걸 정리해 가지고 16바이트 정렬을 다 해주도록 하겠습니다 그래서 메모리 헤더 같은 경우도 declare spec align을 해가지고 우리가 s-list alignment만큼을 이제 16바이트 정렬을 해주겠다라고 , 이렇게, 신호를 주도록 할게요 그 다음에 이 메모리 헤더를 이제 우리가 데이터로 사용할 것인데 s-list 엔트리를 여기 멤버 변수로 들고 있어도 되지만 나중에 포인터 캐스팅까지 염두에 두면 이왕이면 이 아이 같은 경우에는 S-list 엔트리를 상속받는 형태로 만들어 보도록 하겠습니다 상속을 받으면 이 아이가 들고 있는 데이터가 맨 첫 번째로 잡히기 때문에 사실상 이 얼룩사이즈 이전에 이 해당 S-list 엔트리와 관련된 정보들이 , 일단은, 저장이 된다고 보시면 되겠어요 외물이 구조상 그래서 , 이렇게, 일단은, 만들어 보도록 하겠습니다 그 다음에 조금 내려가지고 이제 이 Lock이랑 Q는 더이상 사용을 안 할 거지만 얘도 마찬가지로 무조건 첫번째 변수 혹은 상속을 받아도 되긴 하지만 얘같은 경우는 그냥 첫번째 변수로 S-list header를 , 이렇게, 만들어 주도록 하겠습니다. header 얘가 이제 말 그대로 실질적으로 락 프리 스택을 관리하는 아이라고 볼 수가 있는거죠 얘가 첫번째 노드를 가리키게 될겁니다 첫번째 데이터를 이거는 뭐 우리가 지난 시간에 실습을 해봤으니까 무슨 작업을 하는건지 대충 이해가 가실거라고 생각이 되고 , 자, 그 다음에 메모리 풀 시작을 할 때 처음에 초기화를 했어야 됐었죠 Initialize SList Head 이거 SList Head를 통해 가지고 여기다가 , 이렇게, 헤더를 넣어주면 실질적으로 헤더에 우리가 들어가 있는 값 중에서 예를 다갖고 다시 보면은 Depth랑 Sequence랑 등등의 정보가 있었는데 이 Alignment하는 region을 0으로 빡 밀어주는 그 작업을 여기서 Initialize S-Listed 헤더에서 해주고 있습니다. 사실상 초기화 작업을 해주게 된 다음에 , 자, 그 다음에 푸쉬부터 작업을 해보자면 락을 걸어 가지고 풀에다가 메모리를 반납하는 이런 코드가 있었는데 이제 락은 걸 필요가 없구요 그 다음에 풀에 메모리를 반납을 할 때는 그냥 Interlocked Push Entry SList 라는 걸 이용해 가지고 헤더에다가 우리가 원하는 요 데이터를 넣어주면 되는데 애정주 메모리 헤더라는 얘 자체가 이 s-list 엔트리를 상속받아서 만들어져 있기 때문에 요 아이가 결국에는 s-list 엔트리 로도 호환이 되죠. 그러니까 얘를 이제 , 이렇게, 바꿔치기를 해서 캐스팅을 해 줘 가지고 p s-list 엔트리로 , 이렇게, 바꿔주도록 하겠습니다. 네 그래서 이 애슐리스트 엔트리 타입의 포인터로 바꿔준 다음에 얘를 이제 여기다가 알아서 집어 넣어준다고 보시면 되겠습니다 , 자, 그리고 이어서 이 주성은 삭제하도록 하고 팝을 할 때는 원래는 여기서 Q에서 여분이 있는지를 체크해가지고 Q에서 데이터를 하나를 뽑은 다음에 없으면 이제 새로 만드는 부분이 실행이 되었는데 이제 이거를 굳이 , 이렇게, 할 필요가 없고 우리가 여기서 바로 이 헤더에서 그냥 데이터 하나를 추출해줄 수가 있겠죠 그 다음에 추출할 때는 interlocked popEntrySlist라는 함수를 이용할 것이고 여기다가 , 이렇게, 헤더에 주소값을 넣어주게 되면은 실질적으로 얘가 뱉어주는게 PLIST ENTRY 즉 리스트 엔트리의 포인터를 뱉어주게 되는데 얘도 마찬가지로 결국은 우리가 넣어준 값 자체가 메모리 헤더라는 아이를 , 이렇게, 리스트 엔트리 포인터로 치환해 가지고 우리가 넣어준 거다 보니까 얘도 똑같이 다시 캐스팅을 해서 복원을 시켜주면 되겠죠 메모리 헤더 타입으로 다시 바꿔주세요 라고 , 이렇게, 바꿔주면 되겠습니다 어차피 얘가 지금 상속을 받아가지고 , 이렇게, 스태틱 캐스팅도 캐스트도 잘 실행이 되는 걸 볼 수가 있습니다 그래서 , 이렇게, 만들어주면 되고 뭐 나머지 부분들은 딱히 뭐 수정할 건 없을 것 같은데 아 근데 그 다음에 얘가 이제 16바이트 정렬을 무조건 우리가 지켜가지고 해야 되는데 이 멀록 같은 경우는 꼭 그렇게 된다는 보정이 없기 때문에 이거 말고 여기서 얼라인드 멀록이라는 버전 하나가 더 있습니다. 얘를 이용하면 우리가 여기다가 원하는 정렬을 맞춰줘가지고 데이터를 할당을 해달라고 요청을 할 수가 있어요. , 이렇게, 일단 바꿔주면 되겠어요. 그리고 메모리 풀을 날리는 부분도 이 부분이 수정이 돼야 되는데 얘도 결국에는 데이터를 뽑아가지고 이 부분을 일단 복사하도록 합시다. 데이터를 뽑아가지고 , 이렇게, 걔가 null이 아니라고 하면은 해당 메모리를 날려주면 되는데 우리가 alignedWalloc으로 만들어준거는 alignedFree라는 함수로 이용해서 똑같이 짝을 맞춰줘서 , 이렇게, 삭제해주면 됩니다 , 자, 얘 header라는 이름보다 그냥 memory라는 이름으로 얘를 바꿔주도록 합시다 왜냐면은 우리가 애당초 여기 내부에서 이 header라는 변수를 사용하고 있기 때문에 , 자, 요 이름을 memory로 바꿔주도록 할게요 Ctrl-R-R 을 눌러서 , 이렇게, 바꿔도 되고 저는 이제 Visual Assist를 사용하니까 Ctrl-Shift-R 을 이용해서 이름을 바꿔준 겁니다 메모이라는 이름으로 바꿔놨고 , 이렇게, 일단은, 싸그리 날려주면 되겠습니다 이 문법도 이제 뭐 처음 보시는 분들이라면 조금 이상하게 생각할 수도 있는데 굉장히 단순하게 이 코드를 실행을 한 다음에 그 다음에 여기서 뭐 if나 while을 이용해 가지고 이 메모리를 체크할 수 있겠지만 이걸 이제 1 플러스 1으로 그냥 한방에 해준다고 보면 되겠습니다. , 일단은, 캐스팅을 해가지고 이 부분을 여기 메모리에다가 넣은 다음에 그 다음에 null 체크를 해가지고 null이 아니면은 이제 아래 있는 aligned free 가 실행이 돼서 이걸 무한 루프를 이제 뺑뺑이를 도게 될 거에요 이게 늦늦이 두 개 있는 게 아니라 하나만 있는 건데 이 패턴이 굉장히 자주 등장합니다 그래가지고 여기서 동시에 널 체크를 하고 들어가고 싶을 때 이런 식으로 많이 만든다고 생각을 하시면 되겠어요 , 자, 이렇게, 일단은, 만들어 주면은 뭐 대충 완성이 되었고요 그 다음에 메모리 쪽으로 다시 돌아가 가지고 메모리 쪽에 고칠 게 없는지 살짝 살펴 보도록 하겠습니다 여기서 얼로케이트를 하는 부분을 유심히 보면은 메모리를 얼로케이트 할 때도 요 부분도 멀록 프리를 하고 있는데 마찬가지로 얼라인드 멀록으로 , 일단은, 바꿔 주도록 할게요 s-list alignment에 따라가지고 얘를 종료를 시켜 주겠다 그리고 프리를 할 때도 마찬가지로 얼라인드 프리 버전으로 맞춰주도록 하겠습니다 뭐 , 사실, 얘는 굳이 얼라인을 맞춰주지 않아도 애당초 풀에 들어갈 애는 아니니까 딱히 상관은 없긴 하겠지만 애당초 애슬리스트를 사용할 때 원래는 원칙상으로는 얘가 정렬이 돼야 되는 거다 보니까 나머지 부분들도 다 정렬을 그냥 해줬습니다 , 자, 이렇게, 해가지고 별다른 수정상이 없었는데 , 일단은, 다시 빌드해가지고 이게 잘 체험이 되는지 테스트를 해봅시다 이런 방식으로 락을 잡는 방식이 아니라 우리가 굉장히 단순하게 구조체를 하나 바꿔치기 해가지고 사실상 락 프리 구조로 얘가 돌아가고 있는 상태가 된 거죠 그래가지고 락을 걸어가지고 사용하는 방식이나 , 사실, 락을 걸지 않고 사용하는 방식이나 , 사실, 코드상에는 그렇게 어마어마하게 큰 차이가 없습니다 성능은 나중에 비교를 해봐야겠지만 성능도 사실상 어마어마하게 큰 차이가 나지 않는 것 같아요 개인적으로 그래서 , 일단은, 다시 게임 서버 들어가서 이걸 간단하게 테스트를 해보기 위해서 예를 들면 나이트라는 클래스를 만들어준 다음에 어 뭘 넣어볼까요 그냥 뭐 hp 랜덤 hp 를 , 이렇게, 아무렇게나 넣어주고 그 다음에 여기 런치를 할 때 나이트를 만들어 줄 때 xnew 를 이용해 가지고 우리가 메모리 풀을 이용하는 버전을 만들어 놨으니까 요 버전을 이용해 가지고 , 이렇게, 만들어 보도록 할게요 만들어 줬으면은 나이트의 hp는 얼마 얼마입니다 라고 로그를 찍고 그 다음에 디스 스레드 슬랩4를 이용해 가지고 대충 6ms 쿨쿨 차고 삭제를 하고 요런 작업을 한 스레드 5개를 만들어 가지고 뭐 , 이렇게, 실행을 시켜 줄 수가 있겠죠 그리고 얘를 실행해 보면 아무 문제 없이 잘 실행이 된다는 걸 볼 수가 있습니다 물론 , 이렇게, 간단하게 테스트를 할 게 아니라 실질적으로 테스트를 하려면 훨씬 더 극한의 상황을 만들어 가지고 테스트를 하긴 해야 되겠지만 일단 기본적으로 , 이렇게, 우리가 만들어준 방법을 이용해서 X-Alloc이라는 것 자체가 애당초 풀 얼로케이터를 사용할 것이기 때문에 얘가 다시 타고 타고 가 가지고 우리가 만들어준 메모리 풀을 이용해 가지고 작업이 된다는 걸 예측할 수가 있는 거죠 , 자, 이렇게, 해서 메모리 풀을 간단하게 락 프리 구조로 만들어 봤구요 어 이런 코드가 굉장히 단순하면서도 , 사실, 효과가 굉장히 좋습니다 그래가지고 우리가 매번 마다 동적할당을 하는게 아니라 실제적으로 이미 사용한 다음에 반납한 애들을 다시 재사용하는 그런 로직이 이제 실행이 되어 가지고 굉장히 메모리 할당이 빈번하고 특히나 작은 그런 짜잘한 아주 사이즈가 작은 메모리들이 자주 개입한다고 하면은 요런 메모리 풀 적용을 적극적으로 고려를 해볼만 합니다 , 자, 이렇게, 해가지고 메모리 풀에 대한 내용을 마치도록 할게요 이건 이제 어느 정도 자랑할 수 있는 그 정도가 일단 되었다고 볼 수가 있는 겁니다 , 사실, 락 프리로 할 때 가장 큰 장점은 제가 개인적으로 보기에는 약간 간지가 나서 그런 것 같아요 , 사실, 락을 잡는 구조나 락프리 구조나 성능에는 엄청 차이가 없지만 왠지 우리가 락프리 기반의 그런 코드를 만들었다고 하면 굉장히 기술적으로 있어 보이죠 발표하기도 굉장히 좋고 하지만 실수한 코드를 보면 그렇게 어마어마하게 어려운 부분은 없었다는 걸 , 일단은, 알 수가 있었습니다 , 자, 이렇게, 해가지고 조금 내용이 길어졌는데 락을 걸지 않는 인터락트 기반의 그런 스택을 이용해가지고 메모리 풀을 수정하는 작업까지 , 일단은, 완료를 해봤습니다.