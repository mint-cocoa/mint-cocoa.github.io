자, 이제 이번 시간에는 우리가 앞으로 중요하게 사용할 Overlapped 모델에 대해서 알아보도록 할 건데요 , 사실, 이전 시간에 배웠던 Select나 Event Select 등등은 클라이어서 사용할 수 있긴 하지만 서버 입장에서 우리가 당장 사용하지는 않을 그런 기본기를 다지는 용도로 공부를 했다면 이제부터는 진짜로 우리가 서버를 만들 때 활용할 아이니까 조금 더 중요도가 높아집니다 , 자, 그런데 정확하게 이 오버래프트 모델을 어떻게 사용하는지 등등에 대한 내용은 나중에 코드에서 알아볼 거고 오늘 제가 ppt를 준비한 이유는 단어 정리를 좀 해보고자 합니다 블록킹, 논블록킹 그리고 동기방식과 비동기방식, 싱크로너스, 에싱크로너스 이런 여러가지 용어들을 제가 종종 언급을 했지만 이거에 대해서 약간 교통정리를 한 적은 없었죠 그리고 blocking이랑 synchronous라는 이 동기방식을 equal로 같은 개념이라고 생각을 하거나 아니면 non-blocking이 비동기랑 또 같은 용어라고 혼동을 하는 경우가 종종 있는데 이게 엄밀히 말하면은 약간 뉘앙스 차이가 있습니다 그래서 이게 어떻게 다른지 , 일단은, 한번 알아보도록 할게요 , 자, 이걸 이제 굉장히 잘 요약하는 요런 그림이 하나가 있는데요 어... 제가 출처를 표시하는 편인데 이거는 어디가 원본인지 모르겠더라구요 이제 뭐 블로그에 이리저리 다 굴러다니는 그런 그림을 하나를 일단 퍼와서 혹시라도 나중에 출처를 알게 되면 뭐 따로 영상 말미에 뭐 남기거나 하도록 하겠습니다 뭐 어찌됐건 블록킹, 논블록킹, 싱크런스, 에이싱크런스라고 , 이렇게, 일단은, 두 개 두 개가 다르다는 걸 알 수가 있고요 , 이렇게, 둘둘 해가지고 표를 네 칸짜리로 , 일단은, 만들어 봤습니다 제가 만든 건 아니죠 , 이렇게, 만들어 놨습니다 누군가가 그래서 이거를 살펴보면은 , 일단은, 기본적으로 블록킹이랑 논블록킹에 대해서 먼저 얘기를 해보자면 이거는 비교적 구별하기가 굉장히 쉬워요 그냥 함수를 우리가 호출을 할 때 함수가 대기를 하는지 아니면 무조건 바로 빠져나와 가지고 바로 호출이 완료되는지만 , 일단은, 생각을 하면 됩니다 우리가 다시 시간을 되돌봐 가지고 소켓 프로그래밍을 맨 처음에 공부를 할 때 우리가 리드랑 라이트 함수를 이용함과 동시에 소켓을 그냥 기본 소켓으로 만들어 가지고 활용을 할 때는 기본적으로 블록킹 방식으로 동작을 했었습니다 그래서 여기서 만약에 우리가 리드나 라이트를 한다고 하면 호출하는 순간에 이제 대기 모드에 빠져 가지고 계속 기다리다가 실질적으로 그 작업이 완료가 되어야지만 그 함수가 이어가지고 호출이 됐었죠. 그동안에 사실상 요 스레드는 그냥 잠든 상태로 그냥 멍때리고 있었습니다. 반면 우리가 , 이렇게, 블록킹 방식으로 하는게 조금 마음에 안들어 가지고 Ioctl 모시기 해가지고 소켓의 옵션을 바꿔가지고 논블록킹 소켓으로 만든 다음에 그 다음에 리드랑 라이트 등등을 호출했을 때는 소켓 자체가 논블록킹 방식이었기 때문에 함수가 논블록킹 방식으로 진행이 되었었죠 그래가지고 호출을 하자마자 그냥 무조건 결과가 있건 없건 완료가 될 수 있건 없건 그냥 바로 빠져나오는 걸 우리가 체크할 수 있었습니다 근데 이제 이런 경우에 만약에 우리가 리시브를 요청을 했는데 실질적으로 내 수신버퍼에 데이터가 없었다 라고 하면 사실상 뭐 리시브할 데이터가 없으니까 실패하는 상황이었고 거꾸로 내가 데이터를 보내달라고 샌드 요청을 했는데 내 커널 송신 버퍼가 꽉 차가지고 거기다가 복사를 할 여분의 공간이 없어가지고 실패를 하는 그런 경우라고 하면은 바로 반환은 하지만 어 익셉션이 떠 가지고 그 에러 코드를 살펴보면은 이웃 블럭 모시기라고 딱 썼었죠 그래서 제가 말씀을 드리기를 원래는 블록킹 상태여야 했었는데 야 너가 논블록킹으로 만들어 달라며 라고 땡깡을 부리는 그 실습을 우리가 여러 번 확인을 한 적이 있습니다 그래서 결국에는 블록킹과 논블록킹의 방식은 구분하기가 굉장히 쉬운데 그냥 함수가 대기를 하는지 아니면 바로 완료가 되고 경우에 따라가지고 일처리를 할 수 없었으면은 그냥 어떤 에러 메시지를 통해가지고 에러 코드를 이용해가지고 뱉어주는지를 이제 우리가 구분을 할 수 있었다는 얘기가 되는 거죠 물론 논 블록킹을 딱 호출했는데 정말 운 좋게 바로 반환이 될 수 있었던 상황이라고 한다면 즉 바로 완료가 되는 상황이라고 했으면 에러 메시지 없인 잘 실행이 되었을 거고요 어찌되건 요렇게 해가지고 블록킹과 논 블록킹 두 가지 방법이 있었습니다 근데 다시 한번 이거를 유심히 살펴보면은 결국에는 우리가 블록킹 방식을 사용하건 논블록킹 방식을 사용하건 리시브나 샌드 억셉트 같은 기본 함수들은 다 동기방식이라는 걸 우리가 알 수가 있습니다 , 자, 그래가지고 어 블록킹이랑 논블록킹 쪽에 잠시 그림을 다시 한번 살펴보면은 결국 리드가 쭉 대기를 하다가 실질적으로 이 리드를 우리가 요청하는 행동이 끝날 때까지 대기를 한다가 이제 요 블록킹 방식이었고 논블록킹 방식은 무조건 빠져나오기 때문에 리드랑 라이트 같은 걸 했을 때 바로 빠져나오는 대신 이웃 블럭 같은 이런 에러 메시지 코드로 할 수 있다가 일단 이 그림에 격론이 되는 거고 이어서 그러면 우리가 기존으로 사용했던 리드 라이트 같은 경우에는 설령, 블록킹이건 논블록킹으로 할 수 있는 이 두가지 차이는 있긴 하지만 기본적으로 이제 , 이렇게, 수평으로 보면은 얘가 동기방식의 함수라는 것은 변형이 없다는 거죠 동기방식 동기라는 것 자체가 동시에 일어나는 이라고 우리가 분석을 하면 되고요 비동기는 거꾸로 A가 붙으면 영어에서 이제 그 약간 not 의 의미가 됩니다 거꾸로 그래서 동기가 아닌 즉 동시에 일어나지 않는 이라는 단어의 의미를 , 일단은, 잘 기억을 하면 됩니다 그래가지고 결국에는 그럼 무엇이 동시에 일어나고 무엇이 동시에 일어나지 않느냐라면 다시 한번 요약하면 블록킹이랑 논블록킹은 진짜 이 함수 자체가 바로 완료되느냐 아니냐를 이제 분석을 하는 거였다면 이 동기랑 비동기에서 얘가 의미하는 바는 우리가 요출한 행동 자체가 동시에 일어나는지 아니면 한참 후에 뒤늦게 일어나도 되는지를 의미를 하는 겁니다 비동기라고 해가지고 동시에 일어나면 안 된다는 얘기는 아니지만 거꾸로 꼭 동시에 일어나야 되지는 않는다라고 분석하는 게 조금 더 정확해요 그래가지고 이 흐름을 지금 유심히 보면은 우리가 뭐 리드나 샌드 같은 걸 만약에 요청했다고 가정을 해볼게요 그러면 우리가 지금까지 사용하던 read나 write 같은 함수에서는 우리가 요청을 했으면 그게 거의 동시에 이어서 실행이 막 열심히 되면서 완료가 되면 반환되는 이런 형태로 동작을 했었습니다 그런데 만약에 우리가 read나 write 같은 거를 비동기 방식을 지원하는 그런 방식의 함수로 호출을 해주게 되면 우리는 사실상 요청을 한 것 뿐입니다 예약을 한 거죠 send랑 receive를 해줄 것이지만 이 일감 자체를 네가 당장 실행하지 않아도 되고 한참 후에 실행해도 상관없다 라고 애덩초 시점 자체가 이제 분리가 되는 거예요 물론 이거를 조금 잘못 이해하는 분들은 이 비동기 방식이 다른 스레드가 개입을 한다라고 이해를 하는 분들이 가끔 계신데 이게 사실은 엄밀히 말해서 멀티 스레드랑은 완전히 또 다른 개념입니다 왜냐면 우리가 소위 Node.js 같은 그 자바스크립트를 사용하거나 아니면 뭐 유니티에서 Coroutine을 사용할 때도 그게 결국에는 비동기 방식은 비동기 방식입니다 왜냐면은 애당초 우리가 어떤 함수를 실행을 할 때 그게 당장 실행이 되지 않고 나중에 실행돼도 된다는 어떻게 보면 간접적인 허락을 해주기 때문에 그 실행시점이 뒤로 밀릴 수가 있다는 얘기가 되는 거고 그게 바로 비동기 방식이라고 볼 수가 있는 거예요 이거를 다시 한번 비유해보면 이런 거죠 만약에 내가 어떤 사람한테 대답을 듣고 싶어가지고 그냥 급해가지고 전화를 건다고 가정해봅시다. 내가 전화를 걸어가지고 어떤 질문을 하게 되면은 그 사람이 바로 저한테 답변을 줄 겁니다. 이건 완전히 동기방식인 거죠. 당장 답을 달라. 근데 똑같은 질문을 제가 메일로 딱 싸줬다고 하면은 그 행동 자체는 제 입장에선 뭐 , 사실, 전화나 메일이나 딱히 다를 바가 없지만 상대방 입장에서 그 응답을 주는 형태가 메일로 내가 만약에 물어봤다고 하면은 그게 뭐 하루 이틀 혹은 한 달 후에 답장이 올 수도 있겠죠. 즉 뭔가 내가 요청한 행동 자체의 그 시점 자체가 호출할 때의 시점과 실제 실행될 때의 시점이 완전히 분리가 되어 가지고 나중으로 미룰 수 있는 게 , 사실, 비동기라고 볼 수가 있는 겁니다. 즉 동시에 일어나지 않는다라는 의미가 되는 거죠. 그래가지고 오늘 왜 이런 내용을 알아보냐면 , 사실, 우리가 지금까지 알아본 4가지 중에서 지금까지는 항상 이 동기방식의 혹은 블록킹, 논블록킹 방식 끝까지는 우리가 해봤어요 이 위에 두 개는 일단 해본 적이 있지만 알았단계로 우리가 넘어가서 사용을 해본 적은 없습니다 리시브랑 샌드 같은 경우에도 항상 우리가 사용했던 버전은 이 동기방식을 사용했었는데 이제 오늘 새로 알아볼 새로운 좀 특별한 샌드랑 리시브 여기 WSA라는 게 앞에 붙게 되는데 그 방식은 이 비동기 방식을 지원하게 될 거예요 그래서 실질적으로 어떤 차이가 생기게 되냐면 우리가 지금까지는 리시브랑 샌드를 하기 전에 뭔가 셀렉트 모델이거나 아니면은 이벤트 셀렉트 같은 거로 진짜로 내가 원하는 상황이 왔는지를 살짝 엿본 다음에 그 다음에 동기 방식의 샌드랑 리시브를 빵 호출했다면 이제는 약간 방법 이론이 달라져 가지고 리시브나 샌드 자체를 우리가 예약하는 형태로 진행을 해 줄 겁니다 그냥 먼저 실행을 빵 하게 될텐데 그게 이 비동기 모드이기 때문에 비동기 방식이라서 사실상 당장 실행이 되지 않고 예약이 걸려가지고 나중에 뭐 준비가 되면은 걔가 이제 알아서 실행이 되는 그런 차이가 생기게 될겁니다 , 자, 그러면 이제 비동기 방식에서는 동시에 일어나지 않는다고 했으니까 우리가 어떤 호출을 해가지고 뭐 요청을 했다고 해도 실질적으로 백그라운드에서 한참 후에 실질적으로 우리가 요청한게 실행이 될 수도 있겠죠 그러면은 결국에는 이 시점이 다르다는 얘기는 우리가 언젠가는 어떤 방식으로건 우리가 요청했던 그 일감이 진짜로 실행이 완료되었는지 아닌지는 판별할 수 있어야 되는데 크게 두 가지 방법이 있어요 하나는 , 이렇게, 지금 그림에서 본 바와 같이 콜백 방식으로 받아가지고 우리가 이제 요청할 때 당초 그 일감이 내가 요청한 게 다 끝나면 콜백 함수를 실행해줘라고 어떤 함수를 건네줘가지고 걔가 거꾸로 우리한테 알려주는 그런 방법이 있고 두 번째는 그냥 이벤트 방식으로 이제 커널 쪽에서 어떤 이벤트를 시그널 상태로 빵켜주게 되면 우리가 그걸 체크해가지고 탐지를 하는 방법이 있습니다. 즉, 두 가지 방법 중 하나를 우리가 선택을 해야 되는 거고 그 두 가지 방식에 대해서 다 알아보도록 할 거예요. 그래가지고 좀 헷갈리는 내용이긴 한데 결국에는 , 이렇게, 네 가지 방식 중 결국에는 우리가 알아본 거 윗두 방식에 대해서 알아봤었고 이제 드디어 이 아래 단계인 기동기에 대해서 알아보겠다라는 예고를 해드리고 있는 거고요 참고로 이 개념은 뭔가 사람마다 관점이 조금씩 달라요 그래가지고 이게 IBM 쪽 블로그에서 되게 유명하게 처음에 기관 글에서 나오는 표인데 이쪽에서는 셀렉트 모델을 블록킹 에이싱크러너스로 구분을 하긴 했는데 어떤 사람들은 이거를 이쪽에다 놓지 않고 오른쪽에다가 놓는 경우도 있기 좀 의견이 많이 다릅니다 그래가지고 사실은 이 비동기에다가 블록킹이라는 이 조합은 굉장히 안 어울리는 조합이긴 해요 얘 같은 경우는 이제 우리가 계속 이 함수가 실질적으로 일감이 완료될 때까지 계속 대기를 하겠다는 게 블록킹이었는데 애정초유 일감 자체는 나중에 실행해도 된다고 했으니까 뭔가 앞뒤가 약간 안 맞는 느낌이 들긴 하죠 그래가지고 현실적으로 엄청 자주 사용이 되는 그런 조합은 아니고 보통 이 세 가지 조합 특히나 이 대각선으로 블록킹 싱크로너스랑 논블록킹 에이싱크로너스 이 조합을 이제 많이 사용하게 될 겁니다 이것도 참고삼아 알아주시면 될 것 같고 그래가지고 오늘 이제 최종적으로 실행을 해볼 거는 요 asynchronous 에다가 논블럭킹 조합으로 이제 작업을 해보게 될 거예요 그래가지고 , 이렇게, 되면은 이제 흐름이 어떻게 되냐면은 우리가 리드는 리드인데 이 asynchronous 버전의 리드를 빵 호출해 주게 될 겁니다 그럼 사실상 우리가 커널한테 이제 뭔가 요청을 하긴 했는데 윤허를 해주는 거죠 지금 당장 꼭 실행해도 되진 않으니까 니가 완료가 될 때 그냥 우리한테 통지만 해줘라고 어떤 식으로든 요청을 해주게 될 거고 만약에 완료가 되었으면 그 완료된 거를 우리가 요청한 거에 따라 가지고 시그널로 줄 수도 있고 콜백 함수를 호출해서 줄 수도 있다라는 게 이제 전체적인 흐름이 될 겁니다 이거에 대해서 잠시 알아본 이유는 결국에는 이 동기랑 비동기에 대한 내용을 살짝 구분을 하셨으면 해서 간단하게 언급을 드린 건데 , 사실, 이건 약간 말장난이기도 해서 당장 모른다고 해도 , 일단은, 코드를 분석하는 게 조금 더 중요하다고 볼 수 있기는 해요 그래가지고 일단 지도를 그려봤고 오늘 이제 드디어 여기 네번째에 있는 non-blocking asynchronous 조합을 이용한 이 마지막 방법에 대해서 , 일단은, 실습을 해볼 거고 그게 이제 overlapped model이라고 , 일단은, 볼 수가 있겠습니다 overlapped model을 사용할 경우에는 이제 receive, send, accept 이런 계열들의 함수들이 다 이제 용어가, 함수가 바뀌어가지고 WSA-RECEIVE, WSA-SEND 이런 식으로 바뀌게 될 거고 걔가 이제 비동기 입출력을 의미를 하게 될 겁니다 우리가 어떤 RECEIVE랑 SEND를 이제 사실상 요청을 하지만 예약을 하는 식으로 , 사실, 요청을 하는 거죠 그래가지고 나중에 실행이 완료되면은 돌아올 것이고 이제 그거를 본격적으로 코드를 작업을 하면서 한번 이제 어떤 식으로 구현을 할지를 한번 실습을 해보도록 하겠습니다 , 자, 이제 다시 코드로 돌아와 가지고 지난번과 마찬가지로 원래 했던, 지난 시간에 했던 내용을 , 일단은, 싸그리 삭제를 하도록 하고 여기부터 시작을 다시 해보도록 하겠습니다. 그래서 오늘 이제 다룰 내용이 굉장히 중요한 이 OverlappedIO 소위 비동기에다가 non-blocking 이 조합을 이제 이용하는 방식을 사용을 해보도록 할 거예요. , 자, 그리고 이걸 사용할 때 , 사실, 뭐 비교적 흐름은 간단한데요 이 오버랩드 함수를 우리가 먼저 걸어 줄 것이고 함수를 호출한다 함수를 건다라고 표현을 하는데 예를 들면은 뭐 wsadcv wsasend 등등 우리가 하고 싶은 행위에 따라 가지고 요런 별도의 버전이 하나가 더 있습니다 그 다음에 요 함수가 오버랩드 함수가 성공했는지 확인을 해야 되는데 당장 성공할 수도 있고 실패할 수도 있습니다 당장 성공했다는 거는 정말 운 좋게 어.. 우리가 요청한 타이밍에 뭔가 진짜로 그 행동이 완료가 될 수 있어가지고 바로 끝난 것일테고 그러면은 이제 바로 성공했으면 결과를 얻어서 처리를 하면 될 것이고 그게 아니라 실패했으면 사유를 확인을 해야 되는데 이 사유가 정말로 펜딩 상태일 수가 있어요. 그러니까 우리가 원래 논블록킹 방식으로 할 때 우리가 논블록킹 해가지고 샌드를 했는데 사실상 그 샌드가 완료가 될 수 있는 상태가 아니었다고 하면은 E would block라는 에러를 떴었는데 그거랑 굉장히 유사하게 실패 사유를 봐가지고 만약에 그 사유가 아직 준비가 되지 않아가지고 펜딩 상태가 떴다라는 그런 상황이 된다고 하면은 추후에 완료가 되었을 때 우리한테 통지를 해달라고 이제 어떤 식으로든 요청을 해주면 됩니다 그게 이제 두 가지 방식 중 하나로 하면 되는데 이벤트 방식과 콜백 방식 , 사실, 두 가지 방법 중 하나로 우리가 완료 통지를 받을 수 있다고 볼 수가 있는 거예요 이번 시간에는 이제 이벤트를 사용하는 가장 첫 번째로 배우는 방법에 대해서 , 일단은, 알아보도록 할 겁니다 , 자, 그래가지고 여기서 말하는 이 Overlapped 계열의 함수가 뭐 , 일단은, 오늘 사용할 것은 WSA send랑 WSA receive 이 두가지를 알아볼건데 나머지들도 다 있습니다 Accept 같은 경우에는 뭐 , 이렇게, Extended가 붙어가지고 비동기로 동작하는 그런 애들이 다 들어가 있어요 얘네들을 사용할 때는 이제 나중에 우리가 서버 라이브러리를 만들 때 알아보겠지만 그냥 기본적으로 막 사용할 수 있는 거 아니고 조금 준비 과정이 필요한데 그거는 오늘 다루진 않고 이 라이브러리를 만들 때 좀 다루도록 하겠습니다 생각보다 약간 귀찮은 작업을 해야 되가지고 막 포인터를 얻어오고 그런 작업이 필요해서 일단 이거는 다루지 않고 이 두 가지 방식으로만 , 일단은, 실습을 해보도록 할게요 , 자, 그런데 여기 보면은 WSA 리시브랑 샌드에 대한 MSDN 문서를 보면은 인자들을 살펴볼 수가 있는데 거의 유사하게 되어 있다는 걸 볼 수가 있습니다. 인자 개수라던가 얘네들이 하는 역할도 거의 비슷해요. 그쵸? 이 부분만 딱히 바뀌었고 사실상 똑같다는 걸 볼 수가 있는데 이 각각의 인자들이 무엇을 넣어줘야 되는지 간략하게 언급을 하고 일단 실습을 할 때 보다 정확하게 한번 살펴보도록 합시다 , 일단은, 맨 먼저 한번 엿보도록 할게요 WSA 샌드를 한다고 딱 가정했을 때 여기서 , 이렇게, 인자를 굉장히 많이 받아주는데 맨 처음에 넣어줘야 되는 게 비동기, 입출력, 소켓을 일단 넣어주면 되는 거고요 이건 비교적 간단하죠 그냥 소켓을 넣어주면 되고 그 다음에 얘가 두번째랑 세번째 버퍼 카운트랑 여기 number of bytes 아 이거 이 버퍼랑 버퍼 카운트 이 두개가 , 사실, 세트라고 보시면 되겠어요 말 그대로 어 버퍼를 입출력 버퍼를 받아주게 되는데 그걸 굉장히 특이하게 WSA 버프라는 구조체로 받아주게 됩니다 배열의 시작 주소 및 어 개수라고 , 일단은, 보시면 되겠어요. 그래서 이 WSA 버퍼라는 것을 또 , 이렇게, 유심히 살펴보면은 뭐 비교적 단순하게 되어있는데 , 자, 얘를 이제 살펴보면은 그냥 이런 식으로 어떤 캐릭터 형 포인터에다가 렌스 , 이렇게, 두 가지로 되어있다는 걸 볼 수가 있습니다. 그러니까 만약에 우리가 뭐 이런 식으로 캐릭터 버퍼를 우리가 뭐 샌드 버퍼로 사용한다 100바이트짜리를 사용한다고 했으면은 ws-buffer를 만든 다음에 ws-buffer에 buff를 이 주소로 연결을 해주고 그 다음에 크기는 백바이트다라고 , 이렇게, 일단은, 연결을 시켜주면 된다는 얘기가 되는 거죠 근데 왜 굳이 WSA 버프 배열의 시작 주소 및 개수를 받냐면은 이거를 이런 식으로 그냥 한 개만 만들어 가지고 전달을 해줘도 되지만 얘네들을 여러 개를 만들어 준 다음에 그거를 한 번에 전달을 해줄 수도 있습니다 즉 이거를 뭐 예를 들면 두 개를 만들어 줘 가지고 첫 번째는 뭐 요런 아이고 그 다음에 뭐 두번째에는 다른 버퍼를 예를들면 샌드버퍼2가 있다고 가정해볼게요 이런식으로 두개를 동시에 전달해줄수가 있다는 얘기가 되는거죠 , 자, 그러면은 아니 왜 굳이 버퍼를 두개를 , 이렇게, 연동해주나 하면은 이게 이제 나중에 알아볼 굉장히 우아한 기법중에 하나가 스케터게더라는게 있습니다 이것도 , 일단은, 적어드리는게 나을것 같은데 스케터 그래가지고 한 마디로 쪼개져 있는 버퍼들을 합쳐가지고 한 번에 보내준다라는 개념이 되는 건데 이게 이제 굉장히 유용하게 이제 활용이 될 거예요 나중에 가면 우리가 패킷을 보낼 때 이런저런 패킷을 막 만들어 줄 텐데 걔네들이 이리저리 분산이 되어 있을 겁니다 근데 그거를 걔네들이 , 이렇게, 우리가 연동을 연결을 해 줘 가지고 하나에 뭉쳐가지고 요 버퍼에 있는 내용이랑 요 버퍼에 있는 내용을 한 번에 샌드를 해줄 수가 있기 때문에 이게 굉장히 성능적으로 우아하다고 보시면 되겠어요 , 자, 이건 좀 나중에 다룰 내용이니까 조금 어려우니까 , 일단은, 그래서 어찌됐건 요기 있는 두 번째 인자를 이용해가지고 두 번째랑 세 번째 인자가 결국에는 우리가 보내줄 샌드 버퍼랑 리시브 버퍼를 전달해준다 하지만 그게 하나가 될 수도 있고 여러 개가 될 수도 있다라는 그런 내용이 될 것입니다 뭐 그리고 이제 이어가지고 그 다음에 여기 number of bytes sent 혹은 어 이게 만약 리스브였으면 내가 받은 그 바이트의 개수를 즉 보내고 받은 바이트 수를 이제 세번째 인자로 받아줄 것이고 네번째로는 그냥 상세 옵션인데 그냥 0으로 일단 넣으시면 됩니다 이건 나중에 뭐 문서를 찾아보시면 되고 그 다음에 다섯번째로 wsa overlapped라는 구조체의 주소값을 받아주게 됩니다 그래서 이 WSL Overlap도 얘도 뭐 살펴보면은 내부적으로 살짝 들어가가지고 이 오버랩드라는 걸 살펴보면은 뭐 이래저래 좀 복잡하게 되어 있어요 근데 뭐 기본적으로 요게 있는 internal, internal high라는 뭐 이런 이상한 값들은 그냥 운영체제 내부에서 자기가 사용할 것이기 때문에 우리는 신경을 전혀 안 써도 되고 우리는 당장 요 마지막에 있는 h-event라는 요 핸들만 신경 써주면 됩니다 즉 요 아이들은 운영체제가 사용하는 것이고 이거는 우리가 넣어주는 것이다 전달해주는 것이다 라고 , 일단은, 보면 되겠어요 여기다가 전달해줄 때는 우리가 이번 실습에서는 이벤트 방식으로 통지를 받고 싶기 때문에 그 이벤트의 핸들을 이제 여기 오버랩트의 H 이벤트에다가 우리가 여기다가 이제 크리에이트 이벤트를 통해서 만들어진 그 이벤트를 여기다가 연결해주게 될 겁니다. 이건 나중에 실습을 하면 나오게 될 거고 어찌됐건 이 과정에서 뭔가 필요한 그런 일종의 인자들을 이 WS의 오버랩트 구조체로 넘겨준다라고 볼 수가 있는 거죠. 그래가지고 우리가 최종적으로 넘겨준 아까 핸들값을 이용해가지고 우리가 통지를 받을 때 그 아이를 시그널 상태로 운영체제가 바꿔주게 되면 우리는 그 이벤트의 시그널 상태를 탐지해가지고 완료가 되었다라는 걸 판별할 수가 있게 될 겁니다. 그리고 이 아이는 입출력이 완료되면 운영체제가 호출할 콜백 함수를 지정하는데 오늘은 얘는 사용하지 않을 거고 여기서 이벤트 방식으로 받을 것이기 때문에 일단 얘는 무시를 해도 됩니다. 그리고 , 이렇게, 여러 가지 인자들이 있는데 이 중에서 몇 가지 중요한 그런 개념들이 있는데 처음 할 때 좀 잘못 사용하는 경우가 있어요 그게 뭐냐면 여기 두 번째 인자랑 여기 overlap과 관련된 이런 정보들을 넘겨주는데 send랑 receive 특성상 WSA, 얘네들은 비동기이다 보니까 호출 시점이 우리가 딱 실제로 샌드랑 리시브가 일어난 시점이 우리가 호출한 시점이랑 다를 수 있다고 했었죠 나중에 실행이 될 수도 있기 때문에 이 함수가 당장 실행이 완료되었다고 해가지고 실제로 입력이나 출력 그러니까 샌드랑 리시브가 완료가 되었다는 보정이 없습니다 그렇기 때문에 이 WSA 오버래프트 구조체랑 그리고 실질적으로 우리가 넘겨준 이 샌드랑 리시브 버퍼를 그 상태에 우리가 여기서 요청을 한 그 상황에서 그냥 가만히 냅둬야 돼요 그걸 괜히 건드려가지고 나중에 커널이 접근해가지고 리시이브 버퍼를 참고할텐데 그거를 우리가 막 덮어쓰거나 다른 값으로 막 바꿔주면은 우리가 해당 처음에 샌드를 할 때 요청한 데이터가 아니라 엉뚱한 데이터가 갈 수 있다는 얘기가 되는 거죠 이제 이 부분이 조금 조심해야 되는 부분인데 , 일단은, 나중에 좀 이걸 완료한 다음에 다시 한번 언급을 드리도록 하고 뭐 어찌됐건 요런 굉장히 다양한 인자들을 받고 있다 그리고 스케터 계단은 , 사실, 요 부분에 해당하는 것이고 , 이렇게, 해서 간단하게 wsa-send랑 wsa-receive는 무엇을 하는 애들인지를 알아봤습니다 다시 한번 큰 흐름을 보자면 오버랩드 모델을 어떻게 사용할 것이냐 오늘은 이벤트 기반의 오버랩드 모델을 사용할 것이기 때문에 순서를 한번 요약을 해보자면 비동기 입출력 지원하는 소켓을 생성하고 통지 받기 위한 이벤트 객체를 같이 생성을 해줍니다 , 자, 그 다음에 비동기 입출력 함수를 호출해줄 것이고 즉, ws-send나 ws-receive 둘 중 하나를 호출해주게 되고 이 상황에서 1에서 만든 이벤트 객체를 같이 넘겨줍니다 어떻게 넘겨주냐면은 여기 ws-overlapped 구조체 안에다가 아까 h 이벤트라는 걸 받아줬었죠? 핸들값을 이벤트를 이 구조체를 통해 가지고 우리가 넘겨주게 될 거예요 마치 예전에 우리가 이벤트 셀렉트를 할 때 소켓이랑 이벤트랑 막 바인딩을 했던 그런 느낌처럼 뭔가 이벤트 요 아이를 통해가지고 통지를 해달라고 뭐 부탁을 해주는 거죠 그러면은 이제 이 샌드랑 리시브를 만약에 우리가 호출했을 때 비동기 작업이 바로 완료가 될 수 있고 바로 완료되지 않을 수도 있습니다 근데 만약에 바로 완료되지 않으면 펜딩 오류가 뜨게 될 거예요 펜딩 이 오류 코드를 통해 가지고 우리가 아, 우리가 요청한 게 당장 실행되지 않았고 나중에 통지가 오겠구나라는 걸 예측할 수 있는 거고 만약에 바로 완료가 되면은 그냥 뭐 좋은 상황이니까 그냥 넘어가면 됩니다 예전에 C샵 서버 혹시 서버 그 강의를 보셨으면 약간 비슷한 느낌으로 당장 완료가 될 수도 있고 안 될 수도 있다고 했는데 지금이 약간 유사한 상황이라고 볼 수가 있는 거예요 바로 될 수도 있고 안 될 수도 있다 그래가지고 만약에 어..이 우리가 결국에는 WS의 펜딩이 떠가지고 나중에 완료가 된다고 예약이 되어 있으면 결국에는 나중에 운영체제가 백그라운드에서 열심히 우리가 요청한 샌드랑 리셉을 하다가 어..결국은 완료가 되면은 이벤트 객체를 통해가지고 Signaled 상태로 만들어서 완료 상태를 우리한테 알려줍니다. 간접적으로. 그럼 우리는 이 시그널 상태가 켜져 있는지 아닌지를 탐지해가지고 시그널 상태로 들어오면은 뭔가가 완료되었구나라고 인지를 하고 진행을 해주면 된다는 얘기가 되겠습니다. 어 그리고 이제 시그널 상태가 켜져 있는지를 체크하기 위해서는 뭐 우리가 이전에도 사용해봤지만 wsa wait for multiple multiple event 함수 있었죠 호출해서 이벤트 객체의 시그널 상태를 판별하면 될거구요 이거는 이전 시간에 사용해본거니까 좀 감을 잡으셨을거 같고 그 다음에 최종적으로 wsa-get-overlapped-result를 호출해서 비동기 입출력 결과 확인을 하고 및 데이터 처리를 해주면 된다라고 보시면 되겠습니다. 그래서 이제 코드를 만들면서 이 순서대로 그냥 그대로 작업을 하게 될 거예요. 그럼 마지막으로 이제 이 함수는 지난번에 사용해본 적이 있으니까 넘어가고 이제 이 함수만 뭘 하는 행동인지 얘가 뭘 하는 건지만 알아보면 되는데 얘도 역시나 처음에 배울 때는 항상 , 이렇게, 문서를 한번 살펴보는 게 좋은 습관입니다. 그래서 이런식으로 소켓을 하나 받아주고 오버랩트 스트럭트의 포인터를 받아준 다음에 여긴 딱 봐도 트랜스퍼된 결과물을 뭔가 넣어주는 것 같고 이 f-weight 같은 경우에는 모든 작업이 끝날 때까지 대기를 할 것인지 아니면 하나라도 완료되면 뭐 빠져나올 것인지 등등을 의미하는 것 같고 이 flag 같은 경우에는 거의 사용을 안 하니까 여기다가 상세한 옵션을 지정할 수 있는데 그냥 거의 사용 안 할 거니까 기본적으로 null로 그냥 넣어주면 된다라는 얘기가 , 이렇게, 나와 있습니다. 그래가지고 이런 느낌으로 일단 사용한다라는 걸 살펴볼 수가 있었고요. 간단하게 또 요약을 해드리자면 1번 비동기 소켓 그 다음에 2번은 우리가 처음에 넘겨준 오버랩드 구조체를 다시 넘겨줄 것이고 3번이 전송된 바이트 수 그리고 4번이 비동기 입출력 작업이 끝날 때까지 대기할지 여부를 의미를 하는데 근데 우리가 만약에 애당초 얘를 호출하기 전에 WS의 WaitFor 모시기 즉 이 Multiple Event 모시기를 이용해가지고 객체의 시그널 상태를 우리가 대기해가지고 빠져나와가지고 얘를 호출하는 거라고 하면은 애당초 이미 비동기 입출력 작업이 끝났다는 의미이기 때문에 그냥 False를 리턴해줘도 됩니다 그리고 마지막으로 5번이 비동기 입출력 작업 관련 부가 정보 관련 부가 정보 거의 사용 안함이라고 일단 유효할 수 있겠네요. 참고로 얘가 아까 잘못 말씀드린 것 같은데 비동기 입출력 작업이 끝날 때까지 대기를 할지 아닐지를 의미를 하는 겁니다. 제가 딴 거랑 조금 헷갈렸는데 여기 설명을 보면 펜딩 오버랩트 오퍼레이션이 완료가 될 때까지 기다려야 될지 아닐지 등등에 대한 요구라고 합니다 , 이렇게, 해가지고 굉장히 다양한 인자들을 받고 있는데 이걸 실질적으로 활용하는 거 보면 생각보다 그 정도로 복잡하진 않아요 근데 이거를 오늘 어떻게 테스트를 해볼 거냐면 , 일단은, 아까 얘기한 대로 이 accept 같은 경우도 비동기 방식의 함수가 더 마련되어 있긴 한데 그런데 비동기 방식을 사용하려면 사전 작업이 필요하기 때문에 오늘은 Accept 같은 경우에는 기존과 마찬가지로 동기 방식으로 구현을 하고 더 중요한 Send랑 Receive만 비동기 방식을 이용하는 형태로 한번 테스트를 해보도록 하겠습니다. 여기서 위까지는 딱히 달라질 점이 없고요. 이제 이어서 아래에서 작업을 이어가 보도록 할게요. 참고로 오늘 테스트할 것은 기존과는 다르게 약간 에코서버 형태로 테스트하지 않고 클라쪽에서는 샌드만 하고 이쪽에서는 리시브만 하는 형태로 , 일단은, 간단하게 작업을 해보도록 하겠습니다. 이제 구조를 좀 잡으려면 조금 더 복잡해지는데 어차피 이런 관련된 부분들은 나중에 우리가 서버 코에도 이제 IOCP를 다루게 되면서 이제 본격적으로 크게 작업할 것이기 때문에 , 일단은, 간단하게 어떤 모양으로 한수호출이 되는지만 간략하게 테스트하고 넘어가도록 할 거예요. , 자, 그래가지고 뭐 , 일단은, 여기서 루프를 계속 돌건데 처음에 클라이언스 소켓을 그냥 , 이렇게, 받아주도록 합시다 일단 하나만 1 대 1 대응으로 이제 하나만 연결을 한다고 일단 또 굉장히 간단하게 가정을 해볼게요 그래가지고 accept 함수를 요렇게 호출을 해줄 것인데 listen-socket을 대상으로 , 자, 여기서 우리가 늘 하던 대로 client-address랑 그 다음에 address-length를 요렇게 받아줬었죠 우리가 항상 하던 거 있죠 , 자, 그거를 여기 위에다가 만들어 주도록 할게요 sock-address in client-address 그리고 address-length는 size of client-address를 , 이렇게, 각각 받아준 다음에 이 accept를 이제 빵 때려가지고 호출해 주는데 지금 소켓 자체가 논블럭킹 소켓이기 때문에 얘가 바로 빠져나오게 될 겁니다 그러면은 클라이언스 소켓이 invalid 소켓인지를 체크를 해가지고 인벨리 서켓이 아니라고 하면 성공한 거니까 그냥 바로 무한 루프에서 빠져나올 것이고 그게 아니라고 하면은 ws의 get last error를 통해 가지고 얘가 무슨 이유로 지금 에러가 떴는지를 봤는데 이 wood block이라고 하면은 딱히 문제가 되는 상황 아니고 그냥 아직 연결한 애가 없다는 의미니까 continue를 때릴 것이고 여기까지 왔으면 진짜 뭔가 문제가 있는 상황이니까 그냥 return을 때려주도록 할게요 , 자, 코드가 좀 이쁘지가 않은데 나중에 가면은 이거를 비동기 accept로 사용할 것이기 때문에 뭐 이런 부분들이 다 해결될 겁니다. 지금은 간단하게 테스트 하기 위해서 좀 , 이렇게, 안 이쁘게 만들어 봤구요. , 자, 그 다음에 이어가지고 Session을 일단 하나를 뭐 , 이렇게, 만들어 주도록 하겠습니다. Session에다가 클랜소켓 , 이렇게, 연결해가지고 일단 여기다가 만들어 줄 것이고 원래 세션에서 보면은 우리가 지금 이런 식으로 소켓 리시브 버퍼랑 리시브 바이트 샌드 바이트가 있는데 여기다가 추가로 WSA 오버 랩트를 여기다가 , 이렇게, 넣어 주도록 할게요 이런 식으로 , 자, 오늘은 샌드 바이트는 뭐 딱히 필요 없긴 한데 일단 이거는 얘는 그냥 삭제를 해 주도록 합시다 그냥 이 버퍼만 , 일단은, 필요하고요 , 자, 그래가지고 세션을 , 이렇게, 만들어 줬고 클라이언트 소켓을 지금 넘겨준 요런 상황입니다 그러면 이제 이어가지고 아까 우리가 해야 될 일감들을 유심히 살펴보면은 이제 여기서 소켓도 있어야 되지만 통지를 받을 이벤트 객체도 같이 만들어 줘야 된다고 했었죠? 그러니까 여기다 WSA 이벤트를 만들어 주도록 할게요 WSA 이벤트 WSA Create Event 이건 지난 거번과 마찬가지입니다 그래서 이 세션에 대한 우리가 이 출력 통지를 이 이벤트를 이용해 가지고 받을 것이다 라는 걸 알 수 있기 때문에 그렇기 때문에 아까 Overlapped라는 이 객체에다가 h 이벤트를 방금 우리가 만들어준 이 이벤트로 , 이렇게, 그대로 얘를 넘겨주도록 할게요 그러면 여기까지 왔으면 , 일단은, 뭐 클라이언트가 연결이 되었다라고 신나게 메시지를 찍어 줄 것이고 그 다음에 이제 이어가지고 상대방이 계속 나한테 메시지를 써주게 될 겁니다. 뭐 샌들을 계속 보내주게 될 거예요. 그러면 여기서 다시 루프를 돌면서 그냥 무한대로 리시브를 받아가지고 그걸 출력하는 그냥 간단한 코드를 한번 만들어 보도록 합시다. , 자, 그런데 , 일단은, SS의 리시브를 이제 호출해 줄 것인데 얘가 사실은 비동기 방식의 리시브라고 했었죠? 리시브를 걸어주는 형태라고 했었습니다 클라이언트 소켓을 넣어 줄 것이고 두번째 인자로 우리가 사용할 리시브 버퍼를 WSA 버퍼라는 구조체를 통해 가지고 넘겨줘야 되는데 WSA 버프라고 합시다 WSA 버프의 첫번째 버퍼가 실질적으로 우리가 샌드 리시브 버퍼에 해당 포인터 주소를 넘겨주면 되구요 포인터를 넘겨주면 되고 그 다음에 렌스는 버프 사이즈 짜리이니까 얘를 그냥 크게 넘겨주면 되겠습니다 그 다음에 이 아이를 이제 여기다가 넘겨주면 되는데 원래는 배열 형태로 여러 개를 넘겨줘도 되지만 지금은 딱 한 개만 만들어가지고 넘겨주고 있으니까 이 아이의 주소와 1을 넘겨주면 되겠습니다 참고로 이 WSA 버퍼라는 이 구조체 메모리는 리시브를 호출한 다음에 날려도 상관없는데 이 리시브 버퍼 자체는 절대로 건드리면 안됩니다 이게 핵심이에요 , 자, 그리고 이제 이어가지고 그 다음 인자가 디워드 형태로 Receive Length라는 거랑 디워드로 Flag라는 걸 , 이렇게, 만들어 준 다음에 얘네들을 각각 넘겨줘야 되는데 Receive 랜스를 해가지고 내가 몇 바이트를 받았는지를 , 이렇게, 뱉어줄 것이고 그 다음에 Flag라는 걸 그냥 , 이렇게, 넘겨주면 되겠습니다 얘는 딱히 사용을 안 할 것이고 그 다음에 Overlapped와 관련된 주소를 받아주고 있으니까 얘를 일단 넘겨주면 되고 마지막에는 그냥 null로 , 이렇게, 밀어주면 되겠습니다 그럼 이게 사실상 우리가 Receive를 하던 거를 이제 비동기 방식으로 호출한 셈이 되는 거예요 , 자, 그러면 이제 여기서 얘가 바로 완료가 될 수가 있고 아니면은 바로 완료가 되지 않을 수가 있습니다 이거는 그때그때마다 상황이 다르겠죠 만약에 누군가가 나한테 이미 샌드를 해가지고 내 리시브 버퍼에, 수신 버퍼에 이미 데이터가 있었다고 하면 얘가 바로 완료가 될 것이지만 그게 아니라고 하면은 , 사실, 얘가 , 일단은, 실패가 뜰 겁니다 완료는 바로 빠져나오긴... 빠져나오는 거는 바로 빠져나오는데 진짜 소켓 에러가 뜨는지 안 뜨는지는 상황에 따라 다르다는 얘기가 드는 거죠 말을 하니까 너무 헷갈리네요 저도 여기서 바로 쏟게 내려가 뜨지 않았으면 리시브가 그냥 한번에 성공한 굉장히 아름다운 상황이니까 여기서 데이터 리시브 렌스는 얼마얼마이다 라고 로고를 찍고 또 이어가지고 루프를 돌면서 똑같은 작업을 계속 할 건데 만약에 상대방이 내가 이 리시브를 걸어주는 순간까지는 아직 데이터가 안 왔는데 안 왔다고 하면은 이제 잠시 뭔가 펜딩 상태가 되겠습니다 아직까지는 데이터가 안 왔으니까 당장은 완료가 되지 않는다 그러면은 그 상황이라고 한다면은 우리가 이제 나중에 혹시 나중이라도 데이터가 오면은 나한테 알려주세요 라는 식으로 이제 예약을 걸어 놔야 되겠죠 예약을 건너보기보단 완료 통지를 받아야 되겠죠 그걸 하기 위해서는 ws.getlast.error를 통해 가지고 , 일단은, 사유를 체크를 하는데 만약에 io 펜딩 상태라고 하면은 이거는 딱히 문제가 있는 상황이라기 보다는 그냥 말 그대로 내가 받을 데이터가 없어 가지고 지금 펜딩 상태가 뜬 거예요 그럼 이건 약간 문제라는 상황은 아니죠 그냥 문제는 아니고 그냥 펜딩 좀 뭔가 지연이 되고 있다라는 얘기가 하고 있는 거고 이 상태에서는 그럼 이제 우리가 어떤 식으로 완료 통지를 받을 것이냐 뭐 여러가지 방법이 있지만 지금 우리가 사용하고 있는 이 방식에서는 이벤트를 통해 가지고 전달을 받겠다고 했었죠 그러니까 사실상 ws의 wait for multiple event를 통해 가지고 이 이벤트가 시그널 상태로 바뀔 때까지 그냥 잠수를 타서 기다리도록 합시다 해가지고 이벤트를 넣어줄 것이고 모든 애들이 다 끝날 때까지 대기를 하겠다는 뭐 그냥 true로 넣어줘도 되겠고요 지금 하나밖에 없으니까 그리고 wsainfinite 그리고 false , 자, 요렇게 , 일단은, 만들어주도록 할게요 이건 지난번에 사용해봤던 그런 함수죠 어차피 하나밖에 없으니까 내가 완료될 때까지 대기를 하겠다라고 , 사실, 이건 트롤하나 펄스나 별 차이가 없구요 그 다음에 무한대로 대기를 하겠다라고 해가지고 여기서 그냥 잠수를 타준 겁니다 그러면 얘가 이제 시그널 상태로 바뀌었다고 하면 빠져나오게 될 것이고 여기서 우리가 WSA, Get Overlapped Result라는 거로 결과를 확인할 수 있다고 했었죠 Session에 Socket을 넣어주고 그 다음에 Session에 Overlapped 주소를 넣어주고 Receive Length를 다시 받아오고 그 다음에 Weight는 False 그리고 마지막은 Flag라는 사용 안 할 거를 그냥 그대로 , 이렇게, 넣어주면 되겠습니다 그러면은 이 Receive Length를 지금 두 번 사용하고 있는데 여기서 만약에 소켓 에러가 뜨지 않았으면은 바로 리실렌스가 채워지면서 여기로 올테시고 그게 아니라 여기로 일단 들어왔다고 하면은 우리가 여기서 펜딩 상태이기 때문에 대기를 해가지고 진짜 실질적으로 내가 어떤 데이터를 받을 때까지 대기를 한 다음에 그 다음에 그 결과물을 , 이렇게, Overlapped Result를 통해 가지고 지금 다시 얻어서 이제 빠져나오게 된다라고 부서있는 거죠 그러니까 흐름이 사실상 1번, 2번 , 이렇게, 빠져나올 수도 있고 1번, 2번, 3번, 4번 , 이렇게, 진행될 수 있다고 볼 수가 있는 겁니다 만약에 엘스 상황이라고 했다면 진짜로 뭔가 연결이 끊겼다거나 문제 있는 상황일 테니까 여기서는 연결을 끊어준다거나 하는 식으로 뭔가 잘 처리를 해주면 되겠습니다 , 일단은, 여기까지는 처리하지 않을 것이고 그래가지고 , 이렇게, 해가지고 진행을 하면 될 것이고 만약에 빠져나왔으면 정리를 해주면 되겠죠 Close Socket 이런 건 , 사실, 오늘 테스트할 때는 큰 의미는 없긴 하지만 항상 정리를 하는 건 좋은 습관이니까 Event도 , 이렇게, W Event를 꺼주도록 합시다 이 흐름을 이제 잘 분석을 해주시면 되겠어요 여기까지는 뭐 별다른 어려운 건 없죠 Accept를 받아가지고 그 다음에 내가 Receive를 할 때 지금 딱 이 방식 WS Receive로 Receive 함수를 그냥 걸어준 셈이 되는 겁니다 당장 호출이 완료될 수도 있지만 뭐 나중에 시간이 될 때 뭐 데이터가 왔을 때 그제서야 얘를 완료해도 된다 너한테 그 호출 시점 자체를 이제 위임하니까 일감 자체를 나중에 진짜로 뭔가 어떤 일이 일어났을 때 완료해도 된다라고 우리가 쿨하게 넘겨준 것이고 그 상태에서 바로 끝날 수도 있고 아니면은 좀 있다가 나중에 완료 통지가 올 수도 있다라고 이제 흐름이 분류가 되는 겁니다 이래가지고 얘는 이제 계속 루프를 돌면서 리시브를 깨주는 형태로 이제 동작을 하게 될 거예요 그리고 두번째로 클라이언트도 오늘은 이왕 하는김에 클라이언트도 비슷하게 이 WSA Sand 라는 대칭적으로 이제 비동기 Sand 를 이용해 가지고 그냥 작업을 해 보도록 할게요 , 자, 그래 가지고 뭐 Connect 같은 경우에는 기존과 마찬가지로 그냥 좀 무식하게 이게 지금 논블록킹 방식이다 보니까 좀 지저분한 코드가 되었구요 , 자, 그 다음에 조금 이제 내려 가지고 Connect 까지 됐으면은 이제 여기서 Sand 하는 부분에서 원래는 요렇게 동기 방식의 Sand 를 이용했었는데 그게 아니라 얘도 똑같이 대칭적으로 요기 있는 요 두가지 코드를 긁어오도록 합시다 요렇게 WSBuff를 채워주고 얘는 이제 Receive Length가 아니라 Send Length라고 이름을 바꿔주도록 할 것이고 Flag는 그대로 똑같이 만들어주면 될 것이고 그럼 여기 첫번째 인자에는 우리가 이제 Send Buffer와 그 다음에 Length는 이제 100으로 요렇게 넣어주면은 이게 말그대로 내가 보낼려는 이 Send Buffer를 자체를 요기다가 이제 전달해주게 되는거죠 그러면 역시나 WSA 샌드를 호출해줄 것인데 얘는 이제 비동기 방식으로 동작하게 될 것이고 클라이언트 소켓이랑 이제 정말 대칭적입니다 WSA 버프 한 개밖에 없다 그 다음에 결과는 여기 샌드 렌스를 통해 가지고 알려줘 그 다음에 플래그는 , 이렇게, 넘겨주면 되고요 그리고 이어가지고 LP 오버랩드 오버랩드 구조체를 이제 하나 넘겨줘야 되고 마지막은 널PTR로 , 이렇게, 해주면 됩니다 아이고 얘가 이제 대문제가 아니라 어 여기 어딘가에서 우리가 오버랩트를 만들어 주도록 할게요 , 자, 그리고 그 전에 우리가 클라이언트 어 소켓을 만들어 놨으니까 소켓을 만들어 준 다음에 항상 우리가 같이 했던게 있었죠? 요가 우리 지금 요번 방식에서는 이벤트 방식으로 완료 통지를 받을 것이기 때문에 이벤트를 만들어 주고 오버랩트 구조체를 만들어 준 다음에 그 이벤트를 연결을 시켜 줘야 됐었습니다 그 부분을 여기서도 똑같이 해주도록 할게요 ws-event 그래서 ws-create-event를 통해서 이벤트 객체를 만들어 줄 것이고 overwrapped 구조체도 만들어 줄 것인데 여기 서버 쪽에서는 session을 안에다가 넣어놨지만 지금은 그냥 얘를 따로 , 이렇게, 관리를 하도록 할게요 그 다음에 overwrapped-h-event에다가 이 이벤트 핸들을 그대로 , 이렇게, 넣어주면 되고요 그 다음에 요 오버랩트를 여기다가 , 이렇게, 건네주면 되겠죠 그러면 샌드를 우리가 이런 식으로 비동기 방식으로 호출을 하고 있는 거고 얘도 역시나 리스브와 마찬가지로 바로 완료가 될 수 있고 아니면 나중에 뭐 지금 어떤 상황에 의해 가지고 내가 당장 커널 버퍼에 지금 복사를 할 수 없는 상황이라고 한다면은 나중에 완료가 될 수도 있을 겁니다 그러면은 요렇게 이제 코드가 붕괴가 되겠죠 , 자, 리시브하는 부분을 일단 날려주도록 할게요 오늘은 요렇게 간단하게 하기로 했으니까 , 자, 그러면 여기서 , 이렇게, 샌드 데이터까지 찍었는데 여기서 바로 빠져나와가지고 했으면은 애당초 우리 송신 버퍼가 여유가 있어가지고 바로 복수할 수 있었던 그런 상황이 될 것이지만 그게 아니라고 한다면은 경우에 따라서 ws-getlasterror 이용해가지고 펜딩이 또 뜰 수 있다는 얘기가 되는거죠 펜딩이 떴다는거는 뭐 특별히 잘못됐다는 상황은 아니고 그냥 말 그대로 지금 상대방이 데이터를 하도 안받아가지고 우리가 커널 버퍼가 송신버퍼가 차서 아직까지는 복수할 수 없다라는 상황이 되는 펜딩 상황인거니까 여기서 완료될때까지 잠시 대기를 타둡시다 wait for multiple event를 통해가지고 1 wsa event true wsa infinite 에고 underbar infinite 그리고 false , 자, 요렇게 대기를 타준 다음에 Get Overlapped Result를 이용해가지고 Client Socket 그 다음에 Overlapped 그리고 Send Length랑 False 그리고 Flex를 같이 요렇게 받아주면 되겠습니다. 얘도 마찬가지로 이쯤으로 엘스문으로 들어오게 되면은 뭔가 진짜 문제있는 상황일테니까 뭐 브레이크를 하던가 하면 될 것이고 그렇게 해서 얘도 굉장히 대칭적인 흐름으로 이제 코드가 만들어진다는 걸 볼 수가 있어요. , 이렇게, 해서 실행을 해보면 지금 왼쪽 오른쪽이 굉장히 대칭적인 구조로 되어 있고 한쪽은 계속 데이터를 보내줄 것이고 한쪽은 계속 데이터를 받아주는 그런 상황을 우리가 , 이렇게, 한번 만들어준 겁니다 서버, 클라, 이렇게, 지금 데이터를 잘 주고받고 있죠 그래서 지금은 간단하게 SEND랑 RECEIVE만 , 이렇게, 비동기 방식으로 만들어 놨지만 나중에는 CONNECT나 ACCEPT 같은 것도 다 비동기 방식으로 만들어 줄 겁니다 그래야지만 서버가 뭔가 , 이렇게, 무한으로 체크를 하는 더러운 코드들이 없어질테고 이런식으로 통지를 받아가지고 진행하는 식으로 만들어지게 된다는 얘기가 되는거죠 지금은 물론 약간 코드를 우리가 무식하게 좀 만들어놔가지고 이런식으로 만약에 데이터가 늦게 왔으면 여기서 또 대기를 타는 식으로 만들어놨지만 나중에 가면은 이게 만약에 우리가 이벤트 방식으로 구현한다고 해도 지난번에 우리가 이벤트 셀렉트 실습을 했던 것과 마찬가지로 이벤트를 한군데 다 모아놓은 다음에 WaitForMultipleEvent에서 예를 한 개짜리가 아니라 50개건 60개건 여러 개를 모아가지고 관찰하는 식으로 코드가 돌아가면 여러 개를 대상으로 관찰할 수 있게 되기는 하겠죠 물론 그렇다고 해도 지난번보다는 훨씬 낫긴 하지만 , 이렇게, 이벤트 방식으로 관찰하는 것 자체가 최선의 방법은 아니라는 걸 벌써 느낌적으로 알 수가 있습니다 뭔가 완료가 당장 되지 않았을 때 이런 식으로 대기를 타는 거 자체가 조금 마음에 안 들긴 하죠. 근데 , 일단은, 이게 어느 정도 기초가 되는 것들이니까 오버랩트 모델, 즉 이벤트 기반으로 통지를 받는 오버랩트 모델에 대한 실습은 , 이렇게, 일단은, 마쳐보도록 하겠습니다. 이 코드를 유심히 분석을 해보시면서 뭐 엄청나게 심오한 그런 내용이 있는 건 아니지만 이런 부분을 잘 분석을 해보시면 될 것 같고 다시 한번 말씀을 드리지만 만약에 우리가 WC 리시브를 중복해가지고 여러 번 호출하고 싶다라는 상황이 있을 수도 있겠죠 그런 경우에 진짜 조심해야 되는 게 요 오버레프트라는 요 아이를 똑같은 애를 계속 넣어주면 안 되고 그때마다 얘가 달라지게끔 유도를 해줘야 됩니다 그리고 이제 여기 있는 메모리를 우리가 ws-receive를 걸어 놓은 다음에 여기 중간에 완료가 완전히 될 때까지 얘를 건드려가지고 이 이벤트를 바꿔준다거나 아니면 이 버퍼 내용을 막 우리가 바꿔준다거나 하면 안 된다라는 것도 굉장히 중요합니다. 그래서 이 ws-receive랑 send를 할 때는 이런 부분이 굉장히 중요해요. 괜히 이거를 다른 값으로 중간중간에 바꿔버리면 우리가 예약을 한 이 부분에 의해서 실질적으로 커널 쪽에서 이 리시브 버퍼를 주소를 참고해 가지고 얘가 이제 데이터를 복사해 갈 텐데 그 시점에 데이터가 오염이 된 엉뚱한 데이터가 있으면 문제가 될 수 있다는 걸 꼭 기억을 해주시면 되겠습니다 요 부분만 조심하면 , 사실, 뭐 크게 어려운 부분은 없어요 , 자, 이렇게, 해가지고 , 일단은, 첫 번째 방법 오버랩트에다가 이벤트 기반을 섞어 가지고 통지를 받는 방법에 대해서 , 일단은, 간단하게 실습을 해봤습니다.