지난 시간까지 우리가 서비스라는 클래스를 만들어 가지고 우리가 작업하고 있는 이 네트워크 세션과 리스너와 ios 비코와 기타 등등을 묶어 가지고 관리할 수 있게 만들어놨구요 이제 오늘은 오늘부터 본격적으로 이제 세션과 관련된 그런 작업을 해보도록 하겠습니다 지난 시간에 우리가 process accept를 한 다음에 여기서 2도로 일단 냅둔 이 부분을 , 일단은, 채워 줄 거고요. Session이 이제 실질적으로 어떤 클라이언트가 접속을 해가지고 accept까지 만약에 되었다라고 하면은 이제부터 얘가 해야 될 일은 말 그대로 Receive를 걸어 가지고 패킷을 받을 준비를 해야 되겠죠 그러면서 이제 뭐 받고 보내고를 하는 식으로 동작을 하게 될 겁니다 , 자, 그러면 이제 , 일단은, Session 쪽으로 잠시 넘어가 가지고 요 부분부터 , 일단은, 설계를 한번 고쳐볼 건데 오늘 추가할 함수들이 뭐 상당히 , 일단은, 많습니다 , 자, 그래가지고 여기서 , 일단은, 하나를 하나씩 하나씩 추가해 볼 건데 , 일단은, 우리가 뭐 퍼블릭으로 열어주는 경우도 있고 프라이벗으로 열어주는 애들도 있고 뭐 둘 다 있을 테지만 외부에서 모든 함수들을 다 퍼블릭으로 열어주진 않겠죠 근데 나중에 이제 우리가 여기 게임 서버 보면은 실질적으로 사용할 때는 이 세션을 , 이렇게, 상속을 받아 가지고 게임 세션이라는 걸로 우리가 사용할 텐데 그렇다는 것은 최대한 네트워크와 관련된 내부적으로만 사용할 애들은 최대한 숨겨주는 게 좋기는 할 겁니다 근데 그렇다고 얘를 뭐 프라이베트로 아예 막아 놓으면은 애당초 우리 내부 코드에서도 아예 사용을 할 수가 없게 되니까 이런 식으로 friend를 이용해 가지고 listener 라거나 iocp core 라거나 아니면은 뭐 서비스 클래스 같은 데서는 세션을 마음대로 접근해서 쓸 수 있도록 일단 요렇게 열어주도록 하겠습니다 , 자, 그건 그렇고 어 요기 일단 정보와 관련된 부분들도 , 이렇게, 있었구요 이어가지고 뭐 몇 개 누락한 것부터 추가를 해보도록 할게요 , 자, 이스커넥티드라고 해가지고 내가 연결되어 있는지에 따라 가지고 실질적으로 패킷을 이어서 계속 리셉을 해줄 것인지를 결정해 줄 거니까 IsConnected를 , 이렇게, 추가를 해 줄 것이고 그 다음에 SessionRef라고 해가지고 GetSessionRef 즉, SharedPointer로 자기 자신을 뱉어주는 헬퍼 함수를 만들어 주도록 하겠습니다 스태틱 포인터 캐스트를 해줘서 Session으로 바꿔준 다음에 내부에서는 Shared from this를 , 이렇게, 넣어주면 완성입니다. 그래서 혹시라도 이 내부에서 우리가 자기 자신에 대한 Shared PTR이 필요하다면 그냥 Get Session Ref를 사용하면 된다고 볼 수가 있겠어요. 그 다음에 인터페이스 구현은 그냥 , 이렇게, 냅두도록 하고요. 하는 김에 줄일이나 맞춰주도록 합시다. 이 정도로 , 이렇게, 맞춰주도록 할게요. 네, 그 다음에 이어가지고 또 추가될 것은 뭐냐면은 전송과 관련된 부분을 이어가지고 추가를 해주도록 할게요. 그리고 요 뭐 Get Handle이나 Dispatch 같은 경우에는 우리가 뭐 컨텐츠 단에서 이거를 당연히 건들 일은 없을 테니까 얘네들도 프라이벗으로 다 막아놓고 요 부분만 , 일단은, 상할 수 있도록 열어주도록 합시다. , 자, 그 다음에 전송과 관련된 부분이 이제 핵심인데 결국에는 여기서 우리가 리스너 쪽에서 처음에 , 이렇게, 드럭 세션이 이제 성공적으로 접속이 되어서 커넥션이 맺어졌으면 이제 맨 먼저 해줄 것은 리스너 쪽에서 session쪽 함수를 호출해줄겁니다 그래가지고 얘가 접속을 했다 onConnected같은 함수를 이제 호출해줘가지고 내부적으로 그걸 처리하는 식으로 우리가 동작을 시킬건데 이를테면은 프로세스 커넥트라는 함수를 , 이렇게, 호출해 주게 될 거에요 물론 지금 아직 정의가 안 되어있죠 리스너 같은 경우도 우리가 보면은 리지스터 프로세스 항상 이런 식으로 짝을 맞춰 가지고 우리가 작업을 했었던 거 마찬가지로 세션 쪽에서도 다 그런 식으로 작업을 해 줄 겁니다 이 컨베이션을 , 이렇게, 잡아 줄 것이고 리지스터는 말 그대로 우리가 비동기 함수를 걸어주는 그 역할을 하게 될 것이고 그게 성공적으로 만약에 호출이 되었으면 프로세스로 들어오는 식으로 짝을 지어가지고 항상 동작을 하게 될 겁니다 그래서 요 부분에서 우리가 순차적으로 만들어 줄 거는 register connect 그 다음에 register receive 그리고 register send 이 삼총사를 , 일단은, 만들어 주도록 할 거구요 걔네들이 완료되었을 때 프로세스하는 함수들도 똑같이 process connect랑 그 다음에 process receive 얘 같은 경우는 다만 인자를 numberOfByte를 , 이렇게, 내가 전송받은 byte를 받아줄 것이고 마찬가지로 processSand 같은 경우에도 numberOfByte를 , 이렇게, 인자로 받아주도록 하겠습니다. 그 다음에 handleError라고 해가지고 에러코드에 대해서 우리가 처리하는 공용함수를 , 이렇게, 만들어 주도록 할게요. 지금 같은 경우는 , 사실, registerConnect는 우리가 걸어주지 않을 것이고 커넥션이 맺어지면은 여기서 바로 프로세스 커넥터를 때리고 있지만 경우에 따라서 서비스 중에서 나중에 클라이언트 서비스로 만약에 동작을 하게 되면은 직접적으로 리지스터 커넥터를 걸어 줘 가지고 그 행동 자체도 우리가 W 우리가 이전에 만들어 준 커넥터 엑스텐딩 함수를 호출해 가지고 그 결과를 IOCP를 통해 가지고 통보를 받게 될 겁니다 , 일단은, 지금 당장은 얘는 사용하지 않고 있는 거예요 혹시라도 뭐 이게 무엇인가 궁금하실까 봐 말씀을 드린 거고 그 다음에 이어가지고 얘는 이제 protected로 또 만들어줄건데 이 영역은 뭘 하는거냐면 이제는 컨텐츠 코드에서 오버로딩해서 사용할 그런 함수들을 파주도록 할겁니다 onConnect connected라고 할까요? 뭔가 연결이 되었다 라고 할 때 이제 onConnected라는 요 함수를 이제 불러줄거니까 혹시라도 연결이 되었을 때 뭐 로그를 찍어 본다거나 아니면은 뭐 체크할 게 있다고 하면은 얘를 여기 게임 세션에서 오버라이드 해가지고 사용을 해라 이런 거죠 마찬가지로 뭔가 어떤 패킷이 들어왔을 때 onReceive 얘는 , 일단은, 뭐 대략적으로 이런 모양으로 어떤 버퍼에다가 렌스 같은 걸로 받아 가지고 , 이렇게, 만들어 줄 것이고 이거는 나중에 Receive Buffer를 만들 때 다시 다룰 건데 대충 이런 느낌으로 일단 만들어줄 것이고 그 다음에 onSend 어떤 데이터를 성공적으로 보냈을 때 얘를 호출해줄 것이고 그 다음에 onDisconnected 뭔가 끊겼다 라고 할 때 이 아이를 호출해주게 될 겁니다 그래가지고 결국 접속하고 끊기고 받고 보내고에 대한 행동들을 다 요렇게 기본적으로 정의를 해준 상태에서 우리가 내부적으로 서버코드에서 얘를 호출해줄 것이기 때문에 혹시라도 요런 뭐 보내거나 받는 상태에 대해서 궁금하다고 하면 여기서 이제 오브라에 대해서 사용하라고 일단 던져주는 거구요 그래서 오늘 대충 만들 시리즈들은 한 이 정도에서 끝날 것 같네요 이 정도만 , 일단은, 충분할 것 같고 그 다음에 이제 이거를 하나씩 만들어 볼 건데 참고로 이 내부에서도 서비스에 대한 존재를 알아야지만 실질적으로 서비스에 자신을 등록하거나 끊거나 하는 행동을 할 수 있으니까 위크PTR로 서비스를 들고 있도록 할게요 쉐어드 포인터로 들고 있지 않는 이유는 말 그대로 순환을 최대한 줄이기 위해서 서비스 내에서 우리가 세션을 물고 있게끔 했으니까 얘는 위크PTR로 가지고 있을 거고 사실은 우리가 서버가 크래쉬가 나거나 종료되지 않는 이상 서비스는 항상 어딘가에 , 이렇게, 떠 있을 테니까 얘는 그냥 위크 PTR로 그냥 들고만 있었고 널 체크 같은 건 하지 않고 그냥 바로 사용을 하도록 하겠습니다. , 자, 그 다음에 여기 위에 올려가지고 클래스 서비스를 , 이렇게, 전방 선언을 해주도록 하겠습니다. 그래가지고 일단 이 서비스까지 추가가 되었고 다시 올려가지고 서비스를 연동하는 부분들도 만들어주도록 할게요. , 자, 이 맨 위에 있는 부분들은 그냥 우리가 외부에서 사용할 함수들을 여기다가 정리해 주도록 합시다 예를 들면은 디스커넥트 뭔가 우리가 이 세션이 어... 연결이 끊겼다거나 아니면은 뭐 해킹 의심이 된다거나 할 때 강제로 디스커넥트를 빵 호출해주고 들건데 그 함수를 하나를 만들어 줄 것이고 나중에 가면은 우리가 디스커넥트 하는 사유가 굉장히 여러가지가 있을 수가 있어요 뭐 해킹 의심이라거나 아니면은 진짜로 상대방 연결이 끊겼다거나 등등의 사유가 있을 수 있으니까 이런 식으로 그리고 콘스트 W 캐릭터 사유 자체를 인자로 , 이렇게, 받아가지고 이걸 이용해서 로그를 찍어 보도록 할 겁니다. 그 다음에 sharedptr service get service 라고 해가지고 우리가 저장하고 있는 이 서비스에다가 서비스를 이용해가지고 SharedPty를 만들어서 , 이렇게, 반환을 해주도록 할게요. 얘는 그냥 널체크 안하고 바로 사용하도록 할 겁니다. 그리고 마찬가지로 외부에서 서비스를 지정할 수 있는 함수도 , 이렇게, 만들어주도록 하겠습니다. 서비스. 서비스는 서비스. , 자, 이렇게, 한 수의 선언을 다 만들어놨고 이제 하나씩 하나씩 구현부를 만들어 보도록 하겠습니다. 디스코넥터도 만들어주고 그 다음에 여기 밑줄에 그어있는 거 하나씩 다 만들어 보도록 할게요. register connect register receive register send process connect process receive 그 다음에 send handle error까지 이것까지 , 일단은, 다 구현을 해보도록 하겠습니다. 그리고 이제 내부적으로 멀티셋 환경에서 돌아가야 되다 보니까 우리가 실질적으로 락도 사용을 할 예정입니다. 그래서 여기다가 use lock을 걸어 줄 것이고 여기다가 수신 관련된 기능들을 나중에 넣어 줄 것이고 통신과 관련된 기능들도 추가로 넣어 줄 겁니다. 그 다음에 이제 마지막으로 여기는 IoCP 이벤트 재사용을 하기 위한 멤버 변수를 갖고 있을 거예요. 소위 말해서 지금은 Receive 이벤트 하나만 , 이렇게, 만들어 주도록 하겠습니다. , 자, 이거는 뭐 , 일단은, 작업을 하면서 이걸 왜 , 이렇게, 사용하는지 설명을 드릴 건데 , 일단은, 함수의 흐름부터 다시 한번 살펴보도록 합시다 결국에는 아까 리스너 쪽에서 처음에 얘가 접속했을 때 프로세스 커넥트라는 걸 호출해 줘 가지고 코드를 작업할 때 그냥 이 의식의 흐름이 헷갈리니까 얘부터 , 일단은, 따라가 가지고 작업을 하는 게 좀 좋습니다 아 근데 그 전에 서비스라는 요 아이를 Set Service를 해가지고 연동을 시켜줘야 하는데 그거는 , 자, 여기 서비스에서 우리가 맨 처음에 Create Session이라는 걸 호출해가지고 Session을 여기서 만들어주죠? 만든 것과 동시에 자기 자신을 연동을 시켜주도록 할게요. 여기서 그냥 바로 해주도록 하겠습니다. 까먹지 않도록. Shared from this , 자, 얘는 , 일단은, 이렇게, 냅두고 그 다음에 결국에는 Session 쪽에 처음에 연결이 왔을 때 Process Connect로 해가지고 여기서 이제 커넥션이 맺어졌으니까 할 일을 해라 라고 할 수가 있는데 맨 먼저 할 거는 이 커넥티드 값을 true로 , 일단은, 세팅을 해 줄 겁니다. 그 다음에 이어서 세션 등록을 해 줄 거고요. get-service에다가 add-session을 통해 가지고 get-session-ref를 , 이렇게, 넣어 주면 되겠죠. 진짜로 연결이 되었으니까 이제서야 비로소 서비스에다가 이 세션을 추가를 해 주는 겁니다. 그 다음에 여기 지금 에러가 뜨는거는 위에 올려가지고 헤더를 추가 안해서 그런거니까 서비스 헤더를 요렇게 추가를 해주고 다시 내려오도록 할게요 , 자, 그러면 , 일단은, 세션 등록이 되었고 그 다음에 나중에 콘텐츠 코드에서 오버로딩을 하게 되겠지만 우리는 일단 온코넥티드를 여기서 빵 때려줄 거예요 지금은 딱히 뭐 별다른 기능을 하고 있지 않지만 나중에 뭐 요런데서 얘를 오버라이드해서 사용한다면 이게 꽤 중요한 역할도 할 수 있겠죠 그 다음에 그 다음부터는 어... 수신 동록을 이제 처리해줘야 되겠죠 여기까지 , 일단은, 다 끝났으면은 이제 우리가 리시브를 처음으로 걸어줘야 됩니다 그래서 리지스터 리시브를 빵 때려주게 될 거예요 물론 아직까지는 상대방 측에서 데이터를 안 보냈을 수도 있지만 얘가 낚싯대처럼 일단 낚싯대를 물에 던져놔야지 고기를 낚을 수 있는 것처럼 얘는 무조건 한 번은 호출을 해줘야 됩니다 처음에 한 번 이거는 우리가 컴피션 포트 모델을 할 때도 비슷한 상황이 있었죠 그래가지고 그 다음으로 리지스터 리시브 작업을 하도록 여기로 넘어올 건데 이 리지스터 리습을 할 때 먼저 체크할 거는 이스커넥티드 상태를 체크해가지고 만약에 커넥티드가 끊겼다 뭔가 어떤 사유로 인해가지고 더 이상 연결이 끊겼다라고 하면은 그냥 바로 리턴을 때려주도록 하겠습니다 뭐 다양한 사유가 있을 수 있겠죠 진짜로 연결이 끊길 수도 있겠지만 그냥 서버 쪽에서 요 클라이언트가 해킹 의심이 되어가지고 그냥 뭐 밴을 때렸다거나 해가지고 연결을 끊어주는 상황도 있을 거고 그런 다양한 상황에 대해서 처리를 하기 위해서 이스커넥티드를 항상 , 이렇게, 체크를 하고 작업을 해주도록 할 거예요 , 자, 그 다음에 여기서 이제 wsa-receive 함수를 드디어 걸어줘야 됩니다. wsa-receive 지금 오랜만에 등장했죠? 소켓을 먼저 넣어주고 그 다음에 여기다가 wsa-buffer라는 걸 만들어 줬어야 되는데 이거는 뭐 그냥 사실은 여기 이벤트에도 물고 있어도 되고 아니면 그냥 스택 메모리에다가 실시간으로 만들어도 뭐 큰 차이가 없습니다. 그래서 이런 식으로 reinterpret-cast-receive-buffer를 , 일단은, 건네주도록 할게요. 이 리시브 버퍼는 지금 임시로 사용하는 거고요 나중에 가면 이것도 뭐 따르게 사용할 예정입니다 , 일단은, 간단하게 테스트를 성공시키기 위해서 , 이렇게, 만들어 주고 있는 거고 리시브 버퍼에 렌스를 그냥 , 이렇게, 넣어 주도록 하겠습니다 그 다음에 number of bytes라는 인자랑 Flag라는 인자를 만들어가지고 여기다가 넣어줄건데 먼저 WSA 버퍼를 한 개만 넣어주겠다라고 , 이렇게, 넣어주고 그 다음에 Flag가 들어가는데 얘는 NumberOfByte의 추소를 넣어줄 것이고 그 다음에 Flag를 또 , 이렇게, 넣어주고 있구요 그 다음에 이어가지고 Overlapped 구조체의 포인터로 주소를 받아주고 있는데 우리가 실질적으로 이제 이벤트라는 ReceiveEvent라는 걸 여기서 만들어 줘가지고 어.. 연동을 시켜주면 됩니다 근데 요기서 이제 고민이 되는거는? 얘를 실시간으로 만들어줄까? 그니까 , 이렇게, 만들어줄수 있겠죠? 첫번째 방법은 리습이벤트를 그냥 계속 실시간으로 만들어주는겁니다 뭐 요렇게 만들어가지고 뭐 리습이벤트를 만들어줄건데 뭐 이걸 X뉴로 만들건 뭐 어떤식으로 만들건 리습이벤트로 만들어준 다음에 리스비 이벤트에다가 내 자신을 어.. 에고 소문자죠 소문자 리스비 이벤트에다가 어.. 오너를 shared from this를 해가지고 내 자신을 등록시키고 그 다음에 요 receive 이벤트를 뭐 건네주는 방식도 괜찮아요 그 다음에 이제 만약에 process receive가 뜨면은 다시 요 receive 이벤트를 받아가지고 삭제를 하면서 뭐 이런식으로 만들고 삭제하고 만들고 삭제하고 하는 식으로 뭐 동작을 시켜도 됩니다 근데 곰곰히 생각을 해보면 어차피 얘는 세션마다 하나씩 꼭 갖고 있을 거예요 그래가지고 얘는 Receive를 실행을 할 때 레퍼런스 카운팅을 하는 용도로도 활용이 되고 그 다음에 이 오버랩 데다가 내가 지금 어떠한 그런 요청을 보내고 있는지를 같이 넘겨줘 가지고 최종적으로 IOCPQ에서 컴피션 포트에서 이 Receive 이벤트란 걸 꺼내 가지고 우리가 Receive 처리를 해야 된다는 걸 인지할 수 있게 하는 두 가지 용도로 사용이 됐었는데 굳이 , 이렇게, 매번마다 만들기 보다는 그냥 애당초 세션마다 하나씩 갖고 있으면 되는 거니까 , 이렇게, 멤버 변수로 만드는 것도 괜찮다는 생각이 듭니다 이게 좀 재사용할 수 있는 부분이다 보니까 , 이렇게, 일단 만드는 것도 나쁘지 않다는 얘기가 되겠어요 그래서 이거는 뭐 어떻게든 그냥 만들어 주시면 되는데 저는 , 일단은, 실시간으로 만들기 보다는 , 이렇게, 내부적으로 들고 있는 식으로 만들어 주도록 할게요 그래서 Receive 이벤트의 owner만 , 일단은, 이렇게, 바꿔 주도록 하겠습니다. 이게 사실상 reference count를 1 늘리는 상황인 거죠. 그래야지만 우리가 wReceive에 등록을 시켜 놓는 동안에 절대로 이 세션이 삭제가 되지 않게끔 유도를 할 수 있기 때문에 , 이렇게, 만들어 준 겁니다. , 자, 그러면은 여기는 결국에는 Receive 이벤트의 주소를 받아 주고 있고요. 마지막은 컴피션 루틴은 뭐 사용하지 않을 거니까 그냥 널로 , 이렇게, 밀어 주시면 되겠습니다 , 자, 이렇게, 만들어주면 wsa-receive가 완성이 되고 그 다음에 만약에 이게 실패했다 socket error라고 하면 , 이렇게, 만약에 실패했다라고 하면은 이게 진짜 에러인지 아닌지를 먼저 체크를 해야 되겠죠 그래서 에러코드를 먼저 확인할 건데 ws-getLastError를 확인해봤더니만 만약에 에러코드가 펜딩이 아니었다 IOPending이 아니라고 하면은 진짜로 뭔가가 문제가 있는 상황입니다 근데 펜딩상황이라고 했다면은 뭐 , 사실, 문제있는 상황은 아니죠 그거는 말 그대로 지금 당장 리시브할 데이터가 없고 나중에 처리될 예정입니다 라는 얘기다 보니까 얘는 뭐 펜딩일 때는 아무 처리도 안해도 되지만 펜딩이 아니라고 할 때는 진짜로 뭔가가 문제가 있는 거니까 핸들 에러를 통해 가지고 이 에러 코드를 공용으로 처리를 하고 그 다음에 필요하다면 로그를 찍는 식으로 만들어주고 그 다음에 여기서 중요한 게 이 receive owner를 다시 null로 밀어줘야 됩니다. 얘가 사실상 release reference를 하는 거죠. 만약에 여기서 펜딩이 아니라고 하면은 이게 IoCP에 성공적으로 완료 통지가 뜨지 않을 것이기 때문에 여기서 반드시 처리를 하지 않으면은 레퍼런스 카운트가 영영 줄어 들지 않아 가지고 결국에는 이 세션은 영영 삭제될 수 없는 메모리 리익 현상이 이제 일어나게 될 겁니다 그래서 여기서 까맣지 않고 , 이렇게, 릴리스 레퍼런스를 한번 해준다는 걸 볼 수가 있어요 , 자, 그 다음에 의식의 흐름대로 핸들 에러를 지금 만들고 있으니까 이 부분을 일단 작업을 해 보도록 합시다 에러를 핸들링 하는 것은 지금 완벽하게 만들 필요는 없지만 대략적으로 에러 코드를 확인을 해서 어떤 특정 상황이면은 뭐 디스코넥트를 때릴건데 대표적으로 요런 상황이 있어요 WSA Econ Reset 아니면은 WSA Error Connection Aborted 라고 해가지고 진짜로 뭔가 연결이 실패했다 연결이 끊겼다라는 상황이 있을 수 있는데 이때는 그냥 Handle Error 라는 사유로 디스코넥트를 빵 때려주고 그 다음에 나머지 경우는 아직 뭐 잘 모르겠으니까 요기다가 나중에 로그를 섬세하게 찍어가지고 처리를 해주도록 할겁니다. 지금은 그냥 뭐 핸들 에러는 무언 뭐였다 라고만 , 이렇게, 간단하게 하고 놔두도록 할게요. 이 콘솔로 출력하는 것도 결국에는 스레드에서 안전하긴 하지만 어느 정도 컨택스위칭 비용 등등이 필요하기 때문에 실제로 로그를 찍을 때도 , 이렇게, 콘솔 로그를 바로 찍지 않고 이것도 일감 형태로 만들어 가지고 로그를 찍는 전문 스레드한테 떠넘기는 식으로 만드는 경우도 있습니다 그래가지고 이거는 투도로 , 일단은, 냅둔 거고 지금은 그냥 콘솔에 간단하게 찍고 마치도록 할게요 , 이렇게, 해가지고 일단 핸들 에러를 , 이렇게, 처리를 했고요 그러면 다시 돌고 돌아가지고 요 부분은 , 일단은, 이렇게, 완성이 되는 겁니다 네 커넥션이 끊겼으면은 리턴을 하고 그게 아니면은 레퍼런스를 1 , 이렇게, 늘려가지고 리스 이벤트를 지금 처리를 해주고 있구요 그 다음에 요 부분에서 이제 다시 날려주고 또 처리를 하는 부분이 이제 , 이렇게, 들어가게 됩니다 그리고 뭐 이런 부분에서 리지스터 처음에 할 때 얘를 이닛 해가지고 값을 000으로 다 밀어주는 것도 일단 괜찮을 것 같네요 그래서 이런식으로 초기화하고 오너를 세팅하고 그 다음에 밀어주는 부분이 들어갔고 그럼 만약에 이 부분으로 들어오지 않는다고 하면은 펜딩 상태로 걸린 상태라는 얘기가 되는 거죠 그렇게 되면은 실질적으로 WSA 리시브가 언젠가 완료가 될텐데 그게 뭐 곧바로 완료가 될 수도 있고 아니면은 나중에 뒤늦게 펜딩 상태여가지고 나중에 만들려고 될 수도 있겠지만 양쪽 상황에 대해서 무조건 통지가 오게 될 겁니다 자꾸만 자동완성에 의해가지고 한줄이 띄워지는데 다시 , 이렇게, 좀 네 수정을 해줬고요 , 자, 그래가지고 IOCP에서 결국에는 통지가 오게 되면은 요 부분에서 디스패치 쪽에서 쓰레드들이 계속 관찰하고 있다가 여기서 GetQueueCompletionState에서 빠져나와가지고 디스패치를 빵 때려주게 되겠죠 그러면 디스패치가 이번에는 우리의 SessionDispatch로 넘어오게 될 것인데 즉 요 부분으로 일단 넘어오게 될 것이고 이제 이어서 이 부분을 처리를 해줘야 됩니다 그래서 이제 투도로 우리가 냅둔 거 이 부분을 처리해 줄 건데 IOCP 이벤트의 이벤트 타입을 먼저 체크해 가지고 얘가 어떤 상황인지를 봐야 되겠죠 커넥션을 맺으려고 했던 상황이냐 아니면은 이벤트 타입의 리시브 타입이었냐 그것도 아니면은 샌드를 하고 있던 상황이었냐에 따라 가지고 각각 처리를 해주면 되겠습니다 디폴트는 그냥 브레이크를 때려 주도록 할게요 커넥션을 맺는 그 커넥터였으면 프로세스 커넥터를 해줄 것이고 리시브를 맺는 거였다고 하면은 그니까 리시브를 하는 상황이었다면은 넘버 오브 바이트를 건네줘가지고 프로세스 리시브로 넘겨줄 거고 샌드를 하고 있었던 상황이라고 하면은 프로세스 샌드를 호출하게끔 , 이렇게, 각각 넘겨주면 되겠죠 그래서 이 이벤트의 사유를 봐가지고 각각에 맞는 사유에 따라 가지고 함수를 호출해주게 될 거고 , 일단은, 프로세스 샌드는 뭐 이번 시간에 만들지 않고 지금은 리시브만 하고 있으니까 여기 리시브로 넘어와 가지고 요 부분을 작업을 하도록 하겠습니다 그럼 여기서 먼저 해야 되는 건 뭐냐면 , 일단은, 성공적으로 이 비동기 ws의 리시브가 완료가 된 상태니까 요 코드를 긁어 가지고 얘도 똑같이 , 이렇게, 일단 릴리즈 레퍼런스를 하고 시작을 해주도록 하겠습니다 그래가지고 이제 더 이상 예약이 걸려있는 이 리시브가 없다 보니까 자기 자신을 , 이렇게, 레퍼런스를 1 줄여준 상태라고 볼 수가 있는 거구요 , 자, 그 다음에 여기서 만약에 number of bytes가 0이다라고 하면은 0바이트 리시브를 했다는 것은 그냥 연결이 끊겼다는 상황입니다. 이건 무조건 연결이 끊긴 거예요. 그러니까 디스커넥트를 할 건데 뭐 사유는 receive0라는 사유로 우리가 알아들을 수 있게 , 이렇게, 만들어주고 그 다음에 여기서 이제 추가적으로 뭐 이런저런 작업을 해주면 되겠지만 오늘은 이제 그 리시브 버퍼와 관련된 부분은 아직 안 만들어 줄 것이기 때문에 그냥 간단하게 몇 바이트만 받았다라는 로그만 찍어 보도록 할게요 또 이런 식으로 number of bytes and lengths 그 다음에 여기서 이제 여기까지 끝났으면 그 리시브 통지가 완료되어 가지고 우리가 모든 일감을 다 끝내놨으니까 이제 다시 낚싯대를 또 물에 던져야지만 다음 데이터를 또 받을 수가 있겠죠 그래서 다시 수신 등록을 , 이렇게, 해줘야 되겠습니다 그래서 이게 계속 왔다 갔다 하면서 돌고 있는 거죠 근데 이거 결국엔 리스너에서도 항상 이런 식으로 register accept랑 process accept가 왔다 갔다 하면서 진행이 됐던과 마찬가지로 결국 session이라는 애도 처음에 한번 register receive를 누군가가 호출해 줄 건데 걔가 완료가 되면 process receive로 들어오고 process receive를 다 한 다음에 다시 register receive를 하는 식으로 , 이렇게, 왔다 갔다 갔다 하면서 동작을 하게 될 겁니다 네 , 이렇게, 일단은, 뭐 만들어 줬어요 그리고 참고로 어차피 이런 식으로 여기 있는 리습 이벤트를 재사용 할 거라고 하면은 이런 식으로 오너를 매번 받아 날리지 않아도 되지 않을까 라는 생각이 드는데 뭐 그것도 맞는 말입니다 그런데 , 이렇게, 하는 지금 하는 이유는 보다 명확하게 지금 이 Owner에 대한 생명 주기를 관리하기 위해서 , 이렇게, 만들어주고 있는 거고요 만약에 예를 들면은 이걸 여기서 하지 않고 그냥 어차피 사용할 내 자신을 연동하는 거니까 생성자에서 , 이렇게, 만들었다고 하면은 이제는 조금 애매해지는 게 이 Owner를 언제 날려야 되는지가 살짝 애매해지죠 말 그대로 아직 우리가 이 WS Receive를 걸어주지 않았다고 하면은 얘를 날려도 되긴 하지만 그게 아니라 이미 걸린 상태라고 하면 반드시 프로세스 리시브가 뜬 상태에서 얘를 날려줘야 되는데 그런 타이밍 이슈가 생길 수 있기 때문에 우리는 , 일단은, 최대한 간단하게 하기 위해서 진짜로 논리적으로 이해하기 쉽게 걸어줄 때 즉 이 리시브를 호출하기 직전에 레퍼런스 카운트를 1 늘려주고 실패하면 줄이고 완료되면 또 줄이고 이런 식으로 만들어 준 겁니다 이게 가장 이해하기 쉽다고 볼 수 있겠어요 그리고 만약에 이런 코드를 누락하면 어떻게 되느냐 당연한 얘기지만 레퍼런스 카운팅이 결국에는 알맞게 되지 않아 가지고 영영 이 세션이 삭제가 되지 않는 상태로 동작을 하게 될 겁니다 즉 메모리 릭이 일어난다는 거죠 이건 이따가 테스트 해보면 될 것 같고 , 이렇게, 해서 여기까지 , 일단은, 만들어 놨으면 정상적으로 , 일단은, Receive는 될 것 같은데 일단 에러가 없는지 빌드를 한번 간단하게 해 보도록 할게요 그러면 지금 흐름이 만약에 맞다고 하면 여기 Process Connect로 먼저 들어올 것이고 Process Connect로 들어오는데 우리가 맨 처음에 Create Session을 할 때 이미 IOCP에다가 이 Session을 등록을 해 놓은 상태이기 때문에 실질적으로 Process Connect를 때려가지고 여기서 Register Receive를 하는 순간에 여기서 ws의 리시브를 걸어주게 되면은 완료 통지를 우리가 iocp 코어를 통해 가지고 정상적으로 받게 될 겁니다 그러면은 결국에는 외부에서 , 이렇게, 열심히 열심히 이 iocp 코어를 관찰하면서 일감이 떨어지기만을 기다렸던 애들이 깨어나가지고 한 명이 얘를 딱 실행하게 될 건데 iocp 이벤트의 오너는 지금 우리가 세션으로 연결을 시켜놨기 때문에 그 세션을 찾아가지고 디스패치를 빵 때려주게 될 겁니다 그러면은 디스패치를 때려주면은 다시 요로 들어오게 될 것이고 지금은 우리가 요 아이죠 프로세스 리시브가 호출이 될 것이고 얘가 호출이 되면은 요 부분이 호출이 된 다음에 다음 리시브까지 받을 수 있게 해놨으니까 이제 뭐 상대방이 계속 데이터를 보낼 때마다 얘가 지금 리시브를 성공적으로 다 해줄 수가 있게 될 겁니다 그래서 실질적으로 그런지 빌드를 해가지고 한번 실행을 해 보도록 할게요 , 자, 그러면은 게임 서버에서 ReceiveDataLens가 백백백백백백백 , 이렇게, 계속 뜬다는 걸 볼 수가 있습니다 그래가지고 이제 이런 식으로 세션이 정보를 받는다라는 걸 일단 알 수가 있는 거구요 , 자, 그 다음에 이제 두번째로 잠시 껐다가 중요한 게 뭐냐면은 어... 만약에 우리가 강제로 클라이언트를 끈다고 가정을 해봅시다 연동이 된 상태에서 클라이언트를 꺼버리면 이제 Receive 0가 분명히 뜰 거예요 Receive 0가 떴다는 것은 연결이 끊겼다는 의미라고 했었죠 그러면은 실질적으로 여기 Session에 소멸자까지 호출이 되어가지고 진짜로 Session이 삭제가 되는지도 테스트를 해볼 필요가 있습니다 그래가지고 여기서 만약에 일로 안 들어오면은 뭔가 문제가 있다는 상황이라고 볼 수가 있는 거죠 , 자, 일단은, 지난번과 마찬가지로 , 이렇게, 게임 서버랑 더미 클라이언트가 실행되는 상태에서 클라이언트만 일단 강제로 빵 꺼보도록 할게요 그런데 지금 딱 보면은 여기 브레이크 포인트에 안 잡혔다는 것은 지금 뭔가 , 이렇게, 문제가 있는 상황입니다 그럼 이제 이 문제를 찾아봐야 되겠죠 아 근데 뭐 지금 같은 경우는 사유가 딱 여기 있네요 우리가 디스커넥트를 만들다 말아가지고 그런 거였는데 어 디스커넥트 같은 경우에는 , 일단은, 커넥티드 상태를 체크해가지고 exchange false를 해서 , 자, 요렇게 일단 만들어주게 되면은 얘가 false를 넣어주는데 기존의 값을 뱉어주는데 기존의 값이 false였다고 하면은 벌써 connected가 이미 false였다는 상태니까 그냥 스킵을 할 것이고 connected가 원래 true였다고 하면은 exchange가 false로 성공하게 될 테니까 일로 넘어오게 될 겁니다. 즉, 한 번만 얘를 disconnect를 호출해주겠다라는 의도를 우리가 , 이렇게, 만들어 준 거고 여기에 들어왔으면은 이제 뭐 연결이 끊긴 상태가 맞으니까 , 자, 여기다가 일단 사유를 간단하게, 디스커넥트 사유를 찍어 주도록 합시다. 어떤 사유로 인해가지고 , 이렇게, 왔는지. 여기 W가 붙은 이유는 W 캐릭터 포인터이기 때문입니다. C아웃은 그냥 W 캐릭터로 일단 같이 동작을 하지 않아요. 그래서 요 부분 일단 조심하시고. 그 다음에 여기서 끊겼으면은 온 디스커넥터를 호출시켜가지고 얘도 마찬가지로 컨텐츠 코드에서 오버로딩 해가지고 어떤 애가 끊겼으면 어떤 처리를 할지는 나중에 따로 처리를 할 수 있게 , 이렇게, 좀 열어주도록 하고 뭐 그 다음에 소켓 유틸에 클로즈를 해가지고 이 소켓을 빵 닫아주도록 하겠습니다. 그리고 어 그 다음에 GetService에다가 LilySession을 호출해가지고 GetSessionRef를 , 이렇게, 넘겨주게 되면은 우리가 이 서비스라는 애에서도 애당초 자기가 관리하고 있던 그런 Sessions들을 관리를 여기서 하고 있었죠? Sessions라는 애에다가 얘가 지금 하나라도 물고 있는 순간 어, 레퍼런스 카운트가 1이 계속 유지가 되기 때문에 삭제가 안되고 있었던 상황으로 일단 이 이상이 되니까 얘를 , 일단은, 요렇게 릴리세션까지 호출을 해주도록 할게요 , 자, 그 다음에 위에다가 어... 에고 네, 오탈을 냈네요. 그럼 , 이렇게, 해주면은 디스커넥트가 호출되어 가지고 릴리세션을 통해 가지고 서비스에서도 얘가 등록이 해제가 될 테니까 최종적으로 레퍼런스 카운트가 0이 되어 가지고 삭제가 되지 않을까라고 예상을 할 수가 있습니다. 그럼 이제 다시 여기 세션 소멸자에다가 브레이크 포인트를 잡아 가지고 똑같은 테스트를 한번 더 해보도록 하겠습니다. 이런 부분도 굉장히 중요한 게 메모리 릭을 예방하기 위해서라도 이런 걸 꼼꼼히 살펴봐야 돼요. 더미 클라이트를 빵 끄면 이제는 브레이크 포인트가 여기 딱 잡혔다는 걸 볼 수가 있습니다. 굉장히 좋은 상황인 거죠. 그래서 , 이렇게, 성공적으로 지금 리셉은 0이 뜨면서 삭제가 되었다는 걸 알 수가 있는 거고 그 다음에 다음 실험은 뭐냐면 여기다가 브레이크 포인트를 걸되 아까 궁금했던 것 몇 가지가 있었죠 예를 들면 프로세스 리셉을 할 때 이 부분을 누락했다고 하면 레퍼런스 카운트가 절대 줄지 않을 테니까 이 상태에서 다시 똑같은 테스트를 해보면 이제는 브레이크 포인트가 잡히지 않는다는 걸 볼 수가 있습니다 , 자, 똑같이 제 옆에서 더미클라운트를 빵 껐는데 이제는 디스커넥트 리시브 0은 떴는데도 불구하고 지금 얘가 소멸이 되지 않았죠 소멸이 되지 않는 이유는 레퍼런스 카운트가 0이 되지 않았기 때문인데 0으로 되지 않은 이유는 결국에는 이 세션이라는 애가 내부적으로 들고 있던 이 리시브 이벤트에서 오너를 계속 들고 있는 상태에서 얘를 놔주지 않았기 때문에 그렇게 발생한 문제입니다 그래서 레퍼런스 카운팅이 들어가서 관리하면 크래쉬를 예방할 수 있고 , 이렇게, 비동기 입출력 함수를 호출하는 동안에 얘가 살아있는 걸 보장할 수 있지만 경우에 따라서 그렇다고 해서 이런 걸 까먹어서 우리가 깔끔하게 밀어주는 부분을 누락하게 되면 거꾸로 크래쉬는 나지는 않지만 메모리 리익이 일어날 수 있다는 그런 결론을 얻을 수가 있는 거죠 , 자, 이렇게, 해가지고 이번 시간은 간단하게 ws-receive만 , 일단은, 추가를 해봤구요 다음 시간에는 이제 뭐 송신과 관련된 send라는 부분에 대해서도 알아보고 그 다음에 지금은 굉장히 무식하게 여기다가 모든 데이터를 다 받아주고 있지만 이것도 이제 어떻게 처리할지 대해서 의논을 해보도록 하겠습니다.