자, 이어서 이번 시간에는 우리가 지난번에 작업한 TCP 서버를 간략하게 UDP 방식으로 수정을 해보면서 UDP 서버는 무엇이 다른지를 분석을 해보도록 하겠습니다 , 사실, 우리가 TCP 서버를 작업해봤으니까 UDP도 크게 적응하는 데는 무리가 없고 오히려 전체적인 흐름은 TCP보다 UDP가 조금 더 간단하다고 , 일단은, 볼 수가 있겠습니다 그리고 이제 이 tcp 서버의 흐름과 udp 서버의 흐름을 잘 비교를 해야 되는데 잠시 짧게 복습을 해보면 여기 소켓이 일단 두 개가 등장하는 걸 볼 수 있습니다 tcp 서버를 만들 땐 항상 , 이렇게, listen, bind, bind-listen, accept를 3총 차를 호출해줄 리슨 소켓을 먼저 만들어주고 얘가 일종의 문지기 역할을 한다고 했었죠 제가 안내원이라고 표현한 그 소켓이고 그 다음에 얘가 accept를 하는 순간에 실질적으로 우리가 커넥션이 맺어져서 같이 통신할 애가 여기 accept의 결과물로 튀어나오고 얘를 이제 보관해 가지고 클라랑 통신을 하기 위해서는 클라이언트 소켓을 이용해 가지고 통신을 한다는 게 TCP의 핵심이었습니다 , 자, 그래서 이어서 UDP로 이걸 바꿔볼건데 조금 내용이 헷갈리니까 일단 좀 여기서 여기까지 싸그리 삭제를 하고 새로운 마음으로 한번 시작을 해보도록 할게요 뭐 윈속을 초기화하고 종료하는 부분은 당연히 똑같고 여기부터 , 일단은, 작업을 해보고 그나마 좀 필요한 코드는 여기 왼쪽에서 긁어가지고 복붙을 하면서 진행을 해보도록 합시다 , 일단은, 맨 먼저 해야 될 것은 역시 서버 쪽에서 소켓을 만들어야 되는데 한가지 달라지는 점은 뭐냐면 우리가 이전에 TCP 서버에서는 Listen 전용 소켓을 하나 만들고 Accept를 통해 두 번째 소켓이 튀어나오면서 작업을 했었죠 결과적으로 클라이언트가 10명이 커넥션을 맺어가지고 붙는다고 하면 Listener 소켓 하나랑 클라이언트 소켓 10개 , 이렇게, 소켓이 11개가 만들어지는데 애당추 UDP 서버에서는 그런 방식이 아니라 그냥 소켓 하나만 뿅 만들어주면 그걸로 이제 계속 통신을 하게 됩니다. 유일한 소켓 하나를 만들어주게 된다고 보시면 되겠어요 서버 소켓 이런거 만들어줄 것이고 , 자, 소켓을 만들어주는데 , 일단은, ipv4는 똑같이 만들어줄 것이고 그 다음에 두번째 인자가 원래는 우리가 soc-stream 이라는걸 사용했었는데 udp로 사용할거라면 soc-dgram 이라는걸로 바꿔주기를 해주시면 되겠습니다 그 다음에 마지막 인자는 그냥 0으로 넣어주시면 되겠어요 그 다음에 만약에 서버 소켓이 invalid 소켓이다. 그러면 뭐가 문제가 있다는 얘기니까 여기서 에러 처리를 해주면 되겠죠. 참고로 지금 , 이렇게, 에러 처리를 하는 코드를 너무 반복되니까 위에다가 handleError라는 공용 코드로 , 이렇게, 만들어 놓도록 할게요. 이유를 뭔가 건네주면은 거기다가 로그를 찍을 때 이유 ~~ arrow code 라고 , 이렇게, 친절하게 찍어 주도록 합시다. 그래서 여기서는 이런 느낌으로 소켓 대상으로 핸들 arrow 해라 라고 , 이렇게, 한번 만들어 보도록 할게요. 그래서 이제는 서버 쪽에서도 똑같이 통신을 할 때 항상 이 서버 소켓을 이용한다가 가장 , 일단은, 차이가 일어나는 부분이라고 생각하시면 되겠어요. 그 다음에 서버 쪽에서 원래 이제 소켓을 만든 다음에 어찌됐건 바인딩을 해 줘 가지고 서버의 주소를 서버 소켓에다가 , 이렇게, 딱 연동을 시켜 줘야 됐었죠. 그 핸드폰 개통하는 거라고 제가 이제 표현을 했었는데 그거는 이제 똑같이 진행을 하게 됩니다. , 자, 그래가지고 잠시 여기있는 내용을 긁어가지고 복원을 해보도록 하고 얘가 이제 IPv4 버전이었죠? 서버 어드레스를 , 이렇게, 설정하는데 어.. 여기서 굳이 이런식으로 우리가 특정 주소를 맵핑하기보다는 원래 우리가 이전에 서버 시간에는 , 이렇게, 했었죠? 서버 어드레스에 씬 애드레스의 satdr을 host-to-network-long을 이용해서 in-address-n 이라는 것을 이용해서 , 이렇게, 웹핑을 해줬습니다. 이거는 똑같이 복원을 시켜주도록 할게요. 그 다음에 바인딩까지도 역시나 똑같습니다. 바인딩을 하는데 서버 소켓에다가 속 어드레스 포인터 얘를 그대로 , 이렇게, 넣어주고 사이즈 오브 서버 어드레스를 , 이렇게, 넣어준 다음에 만약에 여기서 소켓 에러가 발생했다라고 하면은 우리가 만들어준 핸들 에러를 호출해서 바인드 실패했다라고 로그를 찍어주고 동료를 해주면 되겠습니다. 그 다음에 바인딩까지 된 다음에 원래 이 다음 단계가 TCP로 만들 때는 바인드 다음에 리슨 그 다음에 억셉트까지 했었죠 리슨이 이제 진짜로 내가 영업 시작하겠다라는 의미고 억셉트로 호출하기 시작을 하면은 이제 진짜로 누군가가 옆에서 커넥션을 요청을 해가지고 커넥트를 하면은 연결이 맺어지고 이런 식으로 TCP는 진행이 되었었는데 UDP는 , 사실, 이게 준비의 끝입니다 여기서 이제 그냥 데이터를 받아주면 돼요 뭔가 좀 허무하죠? , 자, 그래가지고 여기서 이제 그냥 받아주면 되는데 얘가 이제 사용하는 함수는 receive 가 아니라 일단 기본적으로 receive from 이라는 요 함수를 이제 이용할 거예요 물론 이것도 이제 뭐 늘 그렇듯 msdn 살펴보고 이런 것도 도움이 되겠지만 인재를 보면은 왠지 처음 보는 것 같지가 않은 애들이 요렇게 들어가 있습니다 소켓, 캐릭터 버프, 렌스, 플래그 그 다음에 여기 뒤에는 딱 봐도 뭔가 나한테 메시지를 보낸 그 아이라는 걸 우리가 예측을 할 수가 있습니다 , 자, 그래가지고 어떻게 보면은 뭔가 Receive랑 옛날에 있던 Accept가 약간 짬뽕이 되어가지고 1 플러스 1으로 합쳐진 느낌이죠 , 자, 그래가지고 이걸 한번 작업을 해볼건데 서버 소켓을 대상으로 , 일단은, 데이터를 받아줄 버퍼를 만들어 주도록 할게요 Receive 버퍼 한 1000바이트 짜리로 , 이렇게, 만들어 주고 Receive Buffer와 Size of Receive Buffer를 이용해가지고 내가 지금 받을 수 있는 크기가 얼마인지를 입력을 할 것이고 그 다음에 Flag는 뭐 우리가 항상 0으로 세팅했었으니까 똑같이 0으로 세팅한 다음에 , 자, 그 다음에 From이랑 From Length라고 해가지고 이제 여기서 나한테 연결을 해준 아이가 누구인지를 뱉어주고 있습니다 원래는 이걸 이제 Accept로 우리가 받아줬던 그 부분이 지금 합쳐졌다고 볼 수가 있는 거죠 그래가지고 이걸 윗부분에다가 속 어드레스인 클라이언트 어드레스는 무엇인지를 추출을 해볼건데 , 일단은, 클라이언트 어드레스를 0으로 항상 깔끔하게 초기화를 해서 쓰레기값을 다 날려버리도록 할것이구요 , 이렇게, 그 다음에 address-length를 sizeof client-addr 해가지고 이 주소를 넘겨줬었죠. 이게 accept할 때 굉장히 비슷한 작업을 해봤었는데 비슷한 느낌으로 똑같이 만들어 보도록 하겠습니다. client-address를 건네주고 그 다음에 address-length 이 사이즈는 얼마인지 이 int의 포인터를 , 이렇게, 넘겨주는 형식으로 동작을 우리가 했습니다. 그러면 얘가 뱉어주는 거는 int를 뱉어주고 있는데 역시나 우리가 예전에 tcp에서 리시브가 실제적으로 얘가 받은 패킷의 바이트 개수를 반환했던 거랑 마찬가지이기 때문에 여기서 만약에 얘가 0 이하로 떨어진다고 하면 뭔가 문제가 있는 상황이 될 테니까 여기서 우리가 receive from에서 뭔가 에러가 났다라고 그냥 종료를 시켜주도록 하겠습니다. 물론 나중에 클라우트가 여러개가 되면은 전체 프로그램을 종료하면 안되고 그 아이에 대해서만 커넥션을 끊어준다거나 하는 식으로 동작을 하게 만들어줘야 되겠죠 그래서 여기까지 왔으면 , 일단은, 뭔가 Receive가 성공했다고 우리가 예측을 할 수 있으니까 이쪽을 한번 긁어가지고 복붙을 해보도록 할게요 ReceiveData, ReceiveLength는 얼마 얼마이다 라고 간단하게 테스트를 하기 위해서 로그를 찍어주고 그 다음에 상대방한테 똑같이 반사를 해 줘 가지고 이 똑같은 데이터를 뱉어 줄 것인데 얘도 마찬가지로 send가 아니라 sendTo라는 함수가 있습니다 그리고 얘도 굉장히 유사하게 인자들이 잡혀 있는 거 볼 수가 있는 거죠 Socket, Buff, Length, Flag 똑같고 그 다음에 2라고 해가지고 이제 나한테 어 누가 누구한테 데이터를 보내줄 것인지를 여기다가 입력을 해주면 되는데 우리가 방금 위에서 receive from을 이용해가지고 나한테 정보를 전달해준 아이가 누군지를 추출했으니까 얘를 그대로 전달을 해주면 되겠습니다. 그리고 데이터를 보낼 때는 항상 이 서버 소켓을 이용한다는 게 또 굉장히 특이하죠 이게 원래는 우리가 TCP로 만들 때는 리슨 소켓 같은 역할이었는데 그게 아니라 얘는 진짜 이걸 이용해가지고 뭔가 데이터를 보내준다 그리고 사실상 연결이 뭔가 맺어지지가 않고 그냥 쿨하게 보낸다라는 두 가지를 , 일단은, 유심히 봐야 됩니다 , 자, 그래서 요렇게 만들어 줄 것이고 그 다음에 속 address 포인터는 client address 에다가 마지막으로 size of client address 까지 , 자, 요렇게 넣어주면 , 일단은, 완료가 되겠고 어 이 send to 같은 경우에도 이제 에러 메세지 에러 코드가 있겠죠 이런 식으로 에러 코드가 뱉어 줄 것인데 이 에러 코드에 따라 가지고 에러 코드가 만약에 어 우리가 send 할 때 어떻게 했었나요 여기 result 코드가 socket error가 아니면 이라고 했으니까 얘도 똑같이 뭔가 socket error를 뱉어줬다 라고 하면은 뭐 늘 하던대로 handle error 코드를 그냥 호출해 주도록 하겠습니다 짜잔 하고 socket error면은 send to가 실패했다 뭐 , 이렇게, 일단은, 처리를 해주도록 할게요 물론 여기도 상대방이 연결을 못 받는다거나 연결이 끊겼다거나 하면 샌드2가 실패할 수도 있는데 그 경우에는 원래 프로그램을 종료하는 게 아니라 역시나 해당하는 이 클라이어 대상으로 연결만 원래 끊어주는 식으로 동작을 해야 되겠죠 걔만 무시하는 식으로 원래 프로그램을 강제 종료하는 경우는 없을 텐데 역시나 간단하게 처리를 하기 위해서 , 이렇게, 만들어 볼 것이고 여기까지 왔으면 결국에는 데이터가 성공적으로 보내진 거니까 이 로그를 긁어가지고 Receive Lens를 출력해 주도록 할게요. 그러면 사실상 우리가 이전에 했던 거랑 완벽히 똑같이 복원이 된 겁니다 단지 프로토컬이 변화했기 때문에 동작하는 방식이 조금 다르다는 차이가 있는 거죠 그래서 여기서 ReceiveFrom이랑 SendTo를 똑같이 사용해봤으니까 사실은 우리가 클라를 만들 때 대칭적으로 만들어주면 돼요 그래서 여기도 똑같이 클라이언트도 만들어보도록 합시다 얘도 똑같이 핸들 에러를 그대로 넣어놓고 이제 하나씩 하나씩 분석을 해보도록 할게요 클라이언트 소켓을 만들어주는데 원래 속 스트림으로 만들어준 것을 속 디그램으로 바꿔치기를 해줘야 된다고 했었죠 그 다음에 핸들 에러 소켓을 그냥 , 이렇게, 복붙을 해가지고 일단 클라이언트 소켓이 만들어졌구요 그 다음에 내가 데이터를 보낼 상대방을 이제 만들어줘야 됩니다 물론 여기서는 우리가 그걸 해줄 필요가 없었던 게 나한테 데이터를 보내준 애한테 데이터를 다시 샀기 때문에 그냥 요걸 재사용해도 됐지만 그게 아니라고 한다면은 내당초 내가 처음에 데이터를 보낼 서버의 주소를 우리가 , 이렇게, sock address in 이라는 걸 이용해가지고 만들어 줬었죠 그래서 이거는 이제 똑같이 , 이렇게, 그냥 만들어 주면 , 일단은, 된다고 볼 수가 있겠습니다 , 이렇게, 삭제를 하도록 하고 그 다음에 원래 TCP에서는 커넥트를 했는데 UDP에서는 기본적으로는 커넥트를 할 필요가 없어요 연결도 하는 개념이 아니라 그냥 데이터를 보내는 개념이라고 했습니다 여기까지는 일단 삭제를 하면 되고 그 다음에 샌드버퍼에다가 데이터를 넣어가지고 여기서 샌드를 하고 있었는데 얘는 잠시 , 이렇게, 수정을 해보도록 할게요 샌드가 아니라 이제 샌드 툴을 이용해 가지고 데이터를 보낸다고 했었죠 요 아이를 이용해 가지고 , 이렇게, 샌드 툴을 해주게 될 건데 샌드 툴을 하게 되면은 뒤에다가 이제 인자 두 개를 더 받고 있고 그게 바로 요 주소라는 걸 알 수 있습니다. 내가 어디 대상으로 데이터를 보낼 것이냐를 지금 의미를 하고 있는 거죠. 그러니까 우리 입장에서는 서버한테 데이터를 보낼 것이니까 속 address 포인터로 서버 address를 넣어주고 size of server address를 , 이렇게, 넣어주면 똑같이 데이터를 보내는 작업이 될 것이고 소켓 에러가 떠가지고 뭔가 데이터가 전송이 되지 않았다 라고 하면은 오른쪽에 있는 send to handle 에러를 그대로 복붙해서 뭔가 종료를 시켜 줄 것이고 그게 아니라 정상적으로 잘 데이터가 갔다고 하면은 똑같이 요 로그를 찍어 준 다음에 그 다음에 이어서 상대방 쪽에서 send 툴을 해서 데이터를 보내줄 거니까 얘도 데이터를 받아줄 준비를 해주면 되겠죠 근데 물론 지금 같은 경우에는 어차피 서버가 우리한테 다시 데이터를 쏴준다는 걸 아니까 우리가 요 만든 서버 어드레스를 이용해서 다시 넣어줘도 되긴 하는데 원래 일반적인 상황에서는 , 이렇게, 데이터를 받아준 애가 누군가 나한테 데이터를 쏴준 애가 누군지 모를 테니까 이거를 별도의 이런 소켓 어드레스로 관리해서 넣어주도록 할게요 , 자, 그래가지고 이쯤에다가 얘를 복붙한 다음에 얘는 클라이언트 어드레스가 아니라 뭐라고 할까요 내가 그냥 나한테 데이터를 쏴준 즉 내가 이제 리시브 하는 상태의 그 주소라고 일단 해가지고 리시브 어드레스라고 , 일단은, 이렇게, 이름을 바꿔치기를 해주도록 하고 그 다음에 receive 가 아니라 역시나 receive from 이라는 함수로 얘를 바꿔치기 해주면 되고 그 다음에 두번째 세번째 인자로 각각 socket address pointer 그리고 여기다가는 receive address 그리고 address length 를 각각 요렇게 넣어 줬으면 됐습니다 그러면은 이제 여기다가 데이터가 알아서 나한테 데이터를 보낸 애들이 누군지가 채워지게 될 겁니다 얘가 끝나게 되면은 그 다음에 요 부분도 똑같이 receive from이 실패했습니다 라고 , 이렇게, 바꿔치기를 하고 로고를 찍어주고 1초마다 이걸 반복하는 식으로 만들어주면 되겠습니다 그래서 흐름이 굉장히 , 일단은, 비슷하다는 걸 알 수가 있어요 그냥 send, receive는 거의 비슷한데 함수 이름만 바뀌었고 커넥션이 맺어지지 않는다는 차이가 있지만 큰 틀에서는 일단 차이가 없다고 볼 수가 있겠습니다 그래서 이 상태에서 F5를 눌러가지고 실행을 해보면 뭐 당연히 정상적으로 서버, 클라가 , 이렇게, 100바이트씩 서로 사이좋게 막 보내고 받고 보내고 받고 하는 거를 우리가 확인을 할 수가 있습니다 , 자, 그 다음에 닫아본 다음에 여기서 이제 몇 가지만 더 언급을 드리자면 이거는 , 사실, TCP도 마찬가지였는데 내가 서버 입장에서는 여기서 바인드를 해가지고 내가 어떤 주소인지를 소켓 회사가 우리가 연동을 시켜줬는데 클라이언트에서는 그 작업을 해주지 않는다는 걸 알 수가 있습니다 근데 사실은 내부적으로 우리가 sand2라는 걸 호출하는 이 시점에 사실은 나의 IP 주소랑 그리고 포트 번호가 설정이 됩니다 근데 이 포트 번호는 우리가 딱히 명시를 해준 적이 없죠 그러니까 , 사실, 그냥 자연스럽게 지금 사용 가능한 포트 중 아무거나 하나를 골라가지고 자동으로 이제 할당이 된다고 보시면 돼요 이거를 보고 싶으면은 여기 거꾸로 서버 쪽에서 receive from을 한 다음에 클라이언트 어드레스가 채워지게 되는데 요 부분을 브레이크 포인트를 잡아가지고 살펴보도록 할게요 그러면은 이제 데이터가 가게 되면은 잠시만 종료를 하고 다시 실행해볼게요 다시 실행해서 보면 클라이언트 어드레스가 채워지는 걸 볼 수 있는데 포트 번호가 55501로 채워진 걸 볼 수 있습니다 우리가 딱히 이런 포트 주소는 입력한 적이 없는데 샌드툴을 하는 순간에 자동으로 맵핑이 되어 가지고 얘가 사용할 포트가 정해진다 라고 , 일단은, 볼 수가 있는 거죠 그리고 이거는 참고로 예전에 우리가 사용했던 TCP도 마찬가지입니다. 우리가 명시적으로 지정을 하지 않아도 중간에 , 이렇게, 데이터를 보낼 때 이제 알아서 결정이 될 거예요. 물론 이제 TCP는 샌드할 때 결정이 되는 게 아니라 커넥트를 하는 순간에 똑같이 포트가 맵핑이 된다, 설정이 된다라고 , 일단은, 볼 수가 있고요. 그 다음에 두 번째로 우리가 TCP를 만들 때도 실습을 해본 것 중 하나가 , 자, 이런 식으로 만약에 패킷을 10개로 연속해서 보낼 때 과연 어떤 일이 일어나는지가 굉장히 궁금했었죠. 그래서 포문을 돌아가지고 요 작업을 10번 연속으로 빠바바바밤 해주고 반대로 서버 쪽에서는 이제 이 10번의 데이터가 올 때까지 잠시 여기서 대기를 해주도록 하겠습니다. this thread sleep for 대충 1초면 충분할 테니까 1초를 기다려 주도록 할게요. 그러면은 tcp에서는 얘가 100바이트를 10번 보냈다고 하면은 얘가 실질적으로 리시브를 할때 1000바이트를 받아가지고 한번에 1000바이트가 리시브로 들어왔다는걸 우리가 테스트를 한적이 있는데 이제 만약에 이거를 UDP로 바꿔본다음에 테스트를 해보면 어떤식으로 동작할까를 보도록 합시다 , 자, 그러면은 잠시만 다시 빌드를 해볼게요 이게 좀 , 이렇게, 다시 한번 빌드를 해서 진행을 해보고 그 다음에 얘를 유심히 보면 원래는 TCP에서는 1000바이트였는데 얘는 여전히 100바이트만 , 이렇게, 잡히고 있다는 걸 볼 수가 있습니다 그래가지고 제가 예전에, 그러니까 이전 시간에 TCP vs UDP 강의를 하면서 UDP의 차이 중 하나는 바운더리의 개념이 있다 즉 어떤 데이터를 보낼 때 경계선이 명확하게 있다고 했었죠 즉 100바이트를 보내면 진짜 100바이트가 온다고 했었습니다 물론 순서는 뒤바뀔 수 있을지언정 이 바이트의 크기는 명확하게 경계선이 있어가지고 서로 합쳐지지 않는다고 했었죠 그래가지고 실질적으로 이 패킷을 지금 100바이트를 10번 보내면 얘가 이스프럼을 할 때 진짜 100바이트씩을 받는다는 걸 우리가 확인을 할 수가 있었습니다 이게 이제 TCP랑 UDP랑 굉장히 다른 점이라는 걸 볼 수가 있는 거죠 , 자, 그 다음에 요 부분은 다시 복원을 해주고 , 자, 그 다음에 이제 마지막으로 살펴볼 점 중 하나는 뭐냐면은 이게 일단 기본적인 UDP의 사용방법이기는 해요 그러니까 여기서 뭐 끝내도 상관없기는 한데 여기서 그나마 조금 아쉽다고 해야 되나요? 좀 귀찮게 느껴지는 부분은 우리가 애당초 샌드툴을 할 때마다 이런 식으로 정보를 다시 넣어주고 있었죠? 서버 어드레스는 누구인지 아 근데 이걸 꼭 , 이렇게, 해야 되느냐 그냥 처음에 내가 어떤 애한테 보낼지 등록을 해놓은 다음에 그냥 뭔가 즐겨찾기처럼 그 해당 주소를 이용해가지고 그냥 알아서 보내주면 안될까라고 생각할 수 있는데 실제로 UDP를 사용한다고 해도 그렇게 뭔가 즐겨찾기처럼 등록하는 버전이 하나가 더 있습니다. 그걸 이제 우리가 Connected UDP라고 해요 Connected UDP 여기서 Connected UDP라고 해가지고 진짜로 TCP처럼 연결이 맺어진다는 의미는 아니고요 내부 동작은 똑같지만 그냥 이 소켓 자체에 즐겨찾기처럼 내가 보낼 이 대상 자체가 등록이 된다라는 느낌으로 받아쳐줘야 됩니다 그래서 어떻게 하면 되냐면 여기다가 Connect를 똑같이 호출해 줘가지고 여기 클라이언스 소켓에다가 소켓 어드레스 그 다음에 사이즈 오브 서버 어드레스를 그냥 그대로 똑같이 넣어주면 돼요. 그러면 사실상 이제 즐겨찾기 처럼 이 소켓에 내가 UDP로 보내긴 보내겠지만 어떤 애를 대상으로 보낼지가 일단 , 이렇게, 등록이 된다고 보시면 되겠습니다. 그러면 이런식으로 샌드2로 할 때 매번마다 내가 누구한테 보낼지를 매번만 입력을 해줄 필요가 없다는 얘기가 되는 거고 그래가지고 , 이렇게, Connected UDP로 할 때는 SEND2로 보내는 게 아니라 기존과 마찬가지로 SEND로 보내게 됩니다 참고로 원래 , 이렇게, 디폴트 상태로 동작하는 즉, SEND2랑 RECEIVE FROM을 이용한 UDP를 우리가 Unconnected UDP라고 해요 이게 이제 기본 상태고 이걸 이어가지고 Connected UDP로 바꿔보자면 잠시 얘를 복붙하고 말씀을 드리자면 그냥 샌드로 얘를 바꿔치기하고 이 두번째 나지막에 있던 서버와 관련된 이 주소 인자를 그냥 날려주면 됩니다. 사실상 TCP랑은 굉장히 유사하게 , 이렇게, 보내는 느낌이라고 볼 수가 있는거죠. 마찬가지로 Receive From 같은 경우에도 이 Receive From 자체는 Unconnected UDP, 즉 기본 UDP는 , 이렇게, 사용하긴 하지만 이어서 우리가 살펴볼 Connected UDP에서는 역시나 Receive From이 아니라 그냥 Receive를 이용해서 사용해주면 되고 마지막에 있던 두 개의 인자는 그냥 날려주시면 됩니다. 이렇게도 똑같은 UDP 방식으로 , 일단은, 동작한다고 볼 수가 있는 거죠. 네 그래가지고 요렇게 해가지고 , 자, 다시 한번 더미 클라이언트 빌드를 해주고 똑같이 실행을 해보도록 할게요 , 자, 그러면 뭐 아까와 마찬가지로 다른 점 없이 정상적으로 , 이렇게, 100바이트씩 서로 주고받는다는 것도 알 수가 있습니다 그러니까 UDP를 한다고 해도 조금 더 효율적으로 만약에 우리가 어차피 클라란 서버가 계속 오랫동안 통신할 거라고 하면 이런 식으로 Unconnected 방식보다는 Connected 방식으로 만들어가지고 , 이렇게, 뭔가 주소를 등록한 다음에 사용하면 된다라는 걸 , 일단은, 알 수가 있는 겁니다. 하지만 기본 틀은 어찌되건 커넥티드로 하나, 언커넥티드로 하나, 동작 방식에서는 차이가 없어요. 실질적으로 커넥션이 맺어져서 서버랑 뭔가 진행이 되는 건 아니고 그냥 , 이렇게, 쿨하게 상대방의 주소를 매버마다 , 이렇게, 지정해서 보낸다는 차이가 있는 거죠. 그래서 이런 코드를 유심히 볼 때 느낄 수 있는 것은 애정쪽 우리가 TCP로 커넥션이 맺어져서 데이터를 주고받을 때는 상대방이 나랑 커넥션을 맺어진 다음에 둘끼리 서로 여기서 accept로 뱉은 소켓을 이용해가지고 둘이 계속 통신을 했었는데 얘는 그게 아니라 그냥 요렇게 소켓을 하나만 만들어가지고 이리저리 통신을 한다는 것도 알 수 있고 심지어 여기서 누가 나한테 데이터를 보내야 된다라는 딱히 제약사항도 우리가 두지 않았습니다 그래가지고 실질적으로 그냥 저 멀리 있는 쟤 누군가가 우리한테 막 데이터를 UDP로 쏴줄 수가 있다는 얘기가 되는 거죠 이 UDP 포트가 열려 있다고 하면은 그냥 여기다가 UDP로 우리한테 데이터를 막 보낼 수 있다는 얘기가 되는 거고 물론 이걸 나중에 이제 방화벽 등등을 통해 가지고 어느 정도 보완은 처리해줘야 되겠지만 기본적으로 TCP에 비해서 UDP가 조금 더 위험하다고 이제 느껴지는 부분이 요런 부분입니다 그래서 보안 측면에서는 , 사실, UDP를 불필요하게 이제 열어두면 안되고 가급적이면 TCP를 활용해야 되고 , 이렇게, 아무나 붙을 수 있는 환경을 , 사실, 최대한 방지를 해야 되겠습니다 뭐 그런거 약간 보안적인 얘기고요 뭐 어쨌든 요렇게 해가지고 , 일단은, UDP에 대한 간단한 실습을 해봤구요 뭐 진짜로 별로 어려운 부분은 , 일단은, 없다는 걸 알 수가 있습니다 근데 우리가 이제 앞으로 만들 서버 같은 경우에는 , 사실, UDP가 아니라 TCP로 계속 만들게 될 거예요 MMO 서버는 대부분 TCP로 만드는 경우가 많다고 말씀을 드렸죠 , 자, 그래가지고 , 이렇게, 해서 그냥 간단하게 UDP가 어떤 느낌인지만 살펴보고 이제 넘어가 보도록 하겠습니다.