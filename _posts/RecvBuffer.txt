자, 이렇게, 우리가 지난 시간까지 이제 어떻게 보면은 세션에 대한 그런 큰 틀은 어느 정도 잡아놓은 상태고 이제는 조금 더 세분화 해가지고 하나씩 하나씩 더 완벽하게 만들어 보는 시간을 가져보도록 할 거예요 그 중에서 먼저 첫 후보는 , 일단은, 요 Receive Buffer를 살짝 수정을 해보도록 하겠습니다 우리가 Sand랑 Receive는 완전히 정책이 다르다고 했었죠 Sand같은 경우가 훨씬 더 까다로우니까 좀 더 쉬운 Receive쪽부터 건드려볼 건데 그러면은 얘를 왜 고쳐야 되느냐 지금 어떠한 문제가 있는지를 곰곰히 생각을 해봅시다 우선은 한가지 , 일단은, 다행인 것은 Receive같은 경우에는 멀티스레드 환경을 고려하지 않아도 된다고 했었죠 실질적으로 한 번에 한 스레드만 여기 리지스터랑 프로세스 리시브로 들어오게 될 것이기 때문에 이 부분은 신경 쓸 필요가 없어요 이 말이 잘 이해가 안 가신다고 하면 실질적으로 리지스터 리시브를 우리가 딱 한 번만 걸어 놓은 상태죠 낚싯대는 한 개밖에 없습니다 그러다 보니까 결국에는 리시브가 1바이트라도 있어가지고 리시브 대상이 있다고 하면은 완료 통지가 여기 워커 스레드들 대상으로 완료 통지가 올 것이고 디스패치를 하게 되면은 타고 타고 가가지고 여기 프로세스 리시브로 들어오게 되고 얘가 다 끝난 다음에서야 다음 등록을 , 이렇게, 또 해주게 됩니다. 그렇기 때문에 무조건 낚싯대는 하나이기 때문에 하나의 스레드만 실질적으로 얘를 실행할 수 있다는 굉장히 아름다운 상황이기 때문에 , 일단은, 멀티스레드와 관련된 문제는 , 일단은, 없기는 합니다. , 자, 근데 그럼에도 불구하고 , 이렇게, Receive Buffer를 그냥 생으로 사용하는 것은 약간 문제가 있어요 이게 뭐냐면은 요 코드에서 우리가 리지스터를 할 때마다 지금 WSA Buffer를 만들어가지고 어떤 위치에다가 최대 몇 개의 Byte를, 최대 크기를 얼마만큼 받을 수 있는지를 우리가 , 이렇게, 지금 입력을 해주고 있습니다 , 자, 그런데 tcp의 특성상 우리가 지금 tcp 서버를 만들고 있죠? tcp의 특성상 패킷이 상대방 총에서 100바이트를 보냈다고 해도 그게 정확히 100바이트 채로 온다는 보장이 없어요 우리가 tcp vs udp에 대해서 다룬 내용이긴 하지만 tcp는 경계선에 개념이 없다고 했었죠? 바운더리가 없기 때문에 설령 상대방이 100바이트를 보냈다고 해도 그게 뭐 잘려가지고 20바이트만 일단 우리한테 넘어올 수 있다는 얘기가 되는 겁니다 그럼 이제 문제가 되는 게 뭐냐면은 원래 우리가 뭐 패킷을 설계할 때 물론 이 부분은 나중에 가서 정확하게 또 나오겠지만 대부분의 경우에는 Packet을 완전체로 받아야지만 개를 처리할 수가 있을 겁니다. 100 바이트를 받아 가지고 거기서 이제 뭐 어떤 유저가 어디 어디에 이동을 하겠다라는 식으로 뜻이 전달이 될 텐데 내가 어디로 이동하겠다는 목적지가 잘려 가지고 아직 도착하지 않았다면 당연히 걔는 처리할 수가 없는 상태일 겁니다 그렇기 때문에 이런 식으로 매번 마다 모든 데이터가 처리됐다고 가정을 하고 첫 번째 주소로 건네줘가지고 기존에 있던 정보를 덮어쓰는 형태로 만들어주면 안된다는 얘기가 되는거죠 그럼 이제 어떻게 해야되느냐 결국은 이게 약간 패킷 설계는 연동이 되어있는데 어떻게든 패킷이 완전체로 왔는지 안왔는지를 판별할 수 있는 수단을 마련해야되고요 그리고 보통 그거는 그냥 간단하게 패킷 데이터에다가 헤더를 만들어가지고 이 패킷이 몇 바이트 짤인지를 , 이렇게, 기입을 해주게 됩니다 뭐 이건 나중에 뭐 따로 다룰 얘기니까 그냥 참고하시면 될 것 같고 그래서 지금 오늘 당장은 어떤 식으로든 패키지 완전체로 도착했는지 안했는지를 우리가 구분할 수 있다고 가정을 하고 그러면 완전체로 도착하지 않았다고 하면 기존에 있던 데이터를 남겨두고 뒤이어가지고 덧붙여가지고 데이터를 복사하는 식으로 이제 뭔가를 만들어야 되겠죠? 그렇기 때문에 이거를 조금 더 총괄해서 관리하기 위한 ReceiveBuffer 라는 클래스를 만들어 보도록 하겠습니다 여기 네트워크 쪽에다가 ReceiveBuffer 라는 클래스를 , 이렇게, 만들어 주도록 할게요 그래서 얘가 이제 좀 더 이런 저런 합치고 뭐 쪼개는 기능들을 이제 담당하게 될 건데 , 자, 이건 코드를 만들면서 살펴보도록 하겠습니다 , 자, ReceiveBuffer CPP는 오른쪽에 헤더는 왼쪽에다가 일단 놓고 시작을 하도록 할게요 , 자, 저의 부두술 항상 , 이렇게, 영역을 집어주고 그 다음에 요 아이가 바로 Receive Buffer 다 라고 , 일단은, 간단하게 , 이렇게, 주석을 남기도록 하겠습니다 , 자, 그러면은 이제 무엇을 해야 되느냐 어 , 일단은, 기본적으로 요 아이가 그냥 우리가 Session에서 사용하던 요런 Byte 배열과 같은 식으로 어찌됐건 뭔가 저장소는 포함을 하고 있어야 되겠죠 데이터를 저장할 공간을 , 자, 그러기 때문에 , 일단은, 뭐 Receive Buffer 를 요렇게 만들어 줄 거고 만들어 줄 때 생성자에서 버퍼 사이즈를 그냥 같이 받아 주도록 하겠습니다 소멸제도 만들어 줄 것이고 그 다음에 얘가 내부적으로 뭐 들고 있는 핵심 정보는 어.. 뭐 요런 요런 이런 저런 정보들이 있을 텐데 버퍼 사이즈가 얼마인지도 들고 있을 것이고 그 다음에 현재 읽는 위치랑 그 다음에 라이트 포즈라고 읽어주고 쓰고 있는 위치를 기록을 할 것이고 그 다음에 뭐 일단 벡터로 만들어 보도록 할게요 버퍼라고 해가지고 실질적으로 데이터를 저장하는 이 버퍼를 만들어 보도록 하겠습니다. , 자, 이제 이것에 대해서 간단하게 설명을 하자면 여기서 리드포즈랑 라이트포즈가 뭘 의미하냐면은 우리가 결국에는 요런 식으로 어떤 바이트 배열을 이용해가지고 데이터를 이제 집어 넣을 겁니다. 근데 이 리드포즈랑 라이트포즈는 일종의 커서라고 생각을 하시면 됩니다. 지금 커서가 , 이렇게, 지금 여기 깜빡깜빡 거리는 커서 요 아이를 커서라고 하고 요 상태에서 우리가 뭐 타이핑을 해가지고 , 이렇게, 코드를 만들었었죠. 마찬가지로 처음에 시작할 때는 리드하는 위치랑 라이트하는 위치가 둘 다 0으로 , 이렇게, 위치하게 될 거예요. 이 상태에서 우리가 데이터를 복사해가지고 Receiver Buffer에다가 데이터를 쓰게 되면은 이제 라이트가 앞으로 가게 될 겁니다. 예를 들면 우리가 대충 한 요기서 요기 3바이트 정도 를 만약에 우리가 데이터를 밀어 넣었다 라고 하면은 그 다음 위치로 이제 w 가 이동하게 되겠죠 다음에는 여기부터 이제 데이터가 복사될 것이다 라는 그런 나이고 반대로 여기서 이제 데이터가 계속 채워지게 되면은 뒤늦게 우리가 어 여기 있는 데이터를 분석해 가지고 그거를 처리하려고 노력을 할 건데 그게 바로 이 리드 커서의 역할입니다 리드 포지션이죠 여기부터 데이터를 읽어 주세요 그래서 실질적으로 이 리드랑 라이트 사이에 낑겨있는 요 부분이 사실상 지금까지 유효한 데이터라고 , 일단은, 볼 수가 있는 겁니다 그래서 , 이렇게, 해가지고 쓰는 쪽에서는 이쪽에다가 계속 데이터를 쓰고 읽는 쪽에서는 뒤늦게 , 이렇게, 처리하는 느낌으로 커서가 두 개가 등장해가지고 지금 관리하고 있다라고 볼 수가 있는 거죠 그러면 결국에는 리드를 하다가 뭐 이런 식으로 리드도 앞으로 갈 것이고 그에 뭐 질세라 W도 계속 앞으로 , 이렇게, 가다가 뭐 이런 식으로 계속 계속 등장하게 될 것이고 근데 어느 순간에 가면은 데이터가 꽉 차게 되겠죠 여기서 더 이상 앞으로 갈 수가 없을 텐데 요 부분이 이제 살짝 애매합니다 그래서 이제 뭐 보통 리시브 버버를 만들 때 굉장히 다양한 방식이 있지만 뭐 가장 오래되고 정석적인 방법은 그 순환 버퍼를 사용하는 겁니다 순환 버퍼라 하면 여기 시작과 끝이 마치 연결이 되어 있는 것처럼 즉, 얘가 한 사이클을 돌면은 이 다음으로 뺑뺑이를 돌아가지고 다시 여기서 시작을 해가지고 , 이렇게, 순환 형태로 계속 동작하는 무한대로 동작할 수 있는 버퍼를 만드는 게 있다는 하나의 방법인데 근데 이 끝부분을 처리하는 게 생각보다 조금 깐돌았습니다 네 그건 그렇고 저는 이제 이거 제가 제일 좋아하는 방법은 뭐냐면은 , 일단은, 버퍼를 좀 여유를 둬가지고 관리를 할 거예요 공간을 그 다음에 이런 식으로 계속 데이터를 1차원 형태로 관리하면서 계속 써 내려가다가 운 좋게 리드랑 라이트가 정확하게 겹쳤다고 하면은 더 이상 데이터가 없다는 얘기죠 이미 모든 데이터를 다 처리했다는 얘기니까 그 상태가 되면은 리드랑 라이트를 다시 0번 위치로 뿅 이동을 시켜주도록 할 거예요 그러면 당연히 복사 비용이 없겠죠 그게 아니라 만약에 데이터가 꽉 차가지고 이제 라이트가 끝까지 왔고 리드는 여기까지 왔는데 아직도 유효한 데이터가 있다고 하면은 어쩔 수 없이 여기 두 개의 데이터를 처음 위치로 다시 , 이렇게, 복사한 다음에 라이트 커서를 다시 , 이렇게, 이동을 해야만 되겠죠 여러가지 상황이 있는데 기본적으로 운 좋게 리드랑 라이트가 동일한 위치에 겹쳤다고 하면은 아무런 복사 비용 없이 그냥 첫 위치로 이동시키고 그게 아니라고 한다면은 뭐 약간 찌끄레기 남은 데이터들을 0번 위치에다가 복사를 해준 다음에 컷업 위치를 , 이렇게, 다시 조절해준다라고 결론을 얻을 수가 있을 겁니다. 그래서 이 방법으로 , 일단은, 만들어 보도록 할 거에요 , 자, 여러가지 , 일단은, 함수들을 만들어 줄 건데 각각 기능은 이어서 설명을 드리도록 할 거니까 , 일단은, 형태만 만들어 보도록 할게요 number of byte 그 다음에 write 성공적으로 read를 했다 성공적으로 write를 했다라고 해가지고 커서를 실질적으로 움직이는 부분이구요 그 다음에 현재 리드 포지션은 어디입니까? 라는 질문에 대해서 버퍼에서 리드 포지션을 포지션에 주소를 뱉어 줄 것이고 현재 써야 되는 위치는 어디입니까? 에서는 여기를 right pose로 교체를 하면 될 것 같고 그 다음에 얘는 복사할 필요가 없었네요 생각해보니까 현재 데이터 사이즈는 얼마인가 유효한 데이터 사이즈는 얼마인가 라고 하면은 여기서 여기까지죠 W에서 리드를 뺀 바이트 크기만큼이 내가 실질적으로 사용하고 있는 데이터의 크기라고 볼 수 있으니까 라이트 포지션에서 니드 포지션을 , 이렇게, 빼서 반환을 해주도록 하고 그 다음에 여유 공간은 얼마입니까? 실제적으로 내가 쓸 수 있는 공간은 얼마냐고 물어보면 최종 버퍼 사이즈에서 라이트 위치를 빼주면 되겠죠 그렇기 때문에 이런 식으로 버퍼 사이즈에서 라이트 포지션을 빼주겠다라고 하면 얘가 지금 여유 있는 공간이라고 볼 수가 있겠습니다 그래서 , 일단은, 이렇게, 간단하게 만들어 볼 것이고 , 자, 그 다음에 뭐 이쁘게 좀 정렬을 해보도록 합시다 , 이렇게, 몇 칸을 띄워가지고 네, 요렇게 , 일단은, 정렬을 해줬고 , 자, 그 다음에 어... 여기 있는 이제 함수들을 하나씩 만들어 보도록 할게요 얘도 만들어주고 얘도 만들어주고 얘도 만들어주고 리드랑 라이트를 다 만들어 볼 건데 , 자, 기본적으로 Receive 버퍼에서는 버퍼 사이즈를 바꾸고 있는데, 이거를 , 일단은, 잠시 여기다가 , 일단은, 저장을 해줄 것이고 그 다음에 버퍼를 리사이즈 해가지고 실제로 그 크기만큼을 우리가 잡아주도록 하겠습니다 소멸자에서는 딱히 뭘 해주지 않아도 될 것 같고 그 다음에 실질적으로 on lead랑 on write부터 만들어 볼 건데 얘는 말 그대로 데이터를 성공적으로 lead 했거나 write 했으면 이제 커스터를 앞으로 당기는 역할을 맡게 될 겁니다 근데 혹시 모르니까 일단 예외 체크부터 합시다 number of bytes가 만약에 데이터 크기보다 더 크다고 하면은 유효한 데이터보다 더 많이 읽었다는 얘기니까 뭔가 좀 이상하다는 얘기죠 그러니까 실패로 처리를 하도록 할게요 근데 물론 이런 경우는 딱히 일어나지 않을 겁니다 그냥 안전 차원에서 , 이렇게, 만들어주고 그 다음에 리드 포즈를 number of bytes만큼 읽었다고 했으니까 얘를 앞으로 이동을 시켜 주도록 할 거예요 얘를 복붙해가지고 라이트도 거의 비슷한데 얘는 프리사이즈로 바꿔가지고 여유분 만큼을 우리가 라이트 할 수 있다고 했었죠? 그니까 예를 들면 지금 요 상황에서는 요기까지 , 일단은, 요기서 요기까지 , 일단은, 라이트를 할 수 있다는 얘기가 되는건데 그거를 초과해가지고 쓰려고 하면은 뭔가가 문제있는 상황이니까 펄스를 때려주고 그게 아니라고 하면은 일단 라이트 포즈를 요렇게 증가시켜주도록 하겠습니다 말 그대로 커서를 옮겨주는 부분이죠 , 자, 그 다음에 클린하는 부분에선 얘는 이제 뭐 하는 거냐면은 일단 라이트랑 리드가 다 확정이 되었다고 가정을 해볼게요 뭐 예를 들면 리드는 여기 있고 라이트는 여기 있고 이런 식으로 확정이 되었을 때 이제 정리를 하려고 하는 겁니다 만약에 운 좋게 리드랑 라이트랑 같은 포지션에 있다고 하면은 우리가 데이터를 다 처리했다는 얘기가 되는 거니까 더 이상 아무런 데이터도 없다 보니까 두 커스를 그냥 첫 위치로 아무런 복사 비용 없이 이동을 시킬 수 있는 상태고요 그게 아닌데도 불구하고 이제 거의 끝자락에 도착해 가지고 더 이상 쓸 수 있는 공간이 많이 없다 싶으면은 어쩔 수 없이 원래 유효하던 데이터를 처음 위치로 복사를 한 다음에 커서를 각각 , 이렇게, 이동을 시켜줘 가지고 다시 이제 처음 위치로 이동시켜서 계속 복사할 수 있도록 유도를 해줄 겁니다 그래서 먼저 데이터 사이즈를 먼저 추출을 해볼 건데 데이터 사이즈는 얼마입니까? 만약에 데이터 사이즈가 0이라는 얘기는 리드랑 라이트 커서가 딱 마침 겹친다는 상황이죠 딱 마침 읽기랑 쓰기 커서가 동일한 위치라면 둘 다 리셋 시킨다 라고 볼 수 있는 거고 그래서 이럴 때는 그냥 리드 포지션이랑 라이트 포즈를 다 0으로 밀어버린다라고 볼 수 있는 거죠 근데 만약에 그게 아니라고 한다면은 무조건 데이터를 복사해가지고 원위치로 하기보다는 조금 기다렸다가 , 사실, 최대한 요 케이스에 들어오는 게 우리한테는 가장 아름다운 상황이죠 불필요한 데이터 복사를 막을 수 있으니까 근데 정말로 정말로 자리가 없어가지고 뭐 끝까지 왔다고 하면은 이럴 때는 어쩔 수 없이 데이터를 앞으로 땡겨줄 수밖에 없습니다 그러면 , 일단은, 뭐 여기서 어떤 식으로 만들어 줄 수 있냐면은 , 일단은, 기본적으로 무조건 데이터를 앞으로 옮기는 코드부터 , 일단은, 간단하게 만들어 보도록 할게요 근데 이건 뭐 그냥 간단하죠 맴 커피를 해가지고 예를 들면은 첫번째 주소가 데스티니션이니까 버퍼의 0번 주소에다가 현재 데이터가 있는 위치는 버퍼의 리드 포지션 위치에 지금 데이터가 들어가 있고 그거를 데이터 사이즈만큼을 땡겨가지고 이 0번 위치에다가 강제로 옮긴다라고 하면 되겠죠 물론 이제 나머지 데이터들은 그대로 남겠지만 기존에 있던 데이터를 뭐 굳이 우리가 삭제를 할 필요는 없고 그냥 냅둬도 됩니다 어차피 나중에 덮었을 테니까 그래서 유효한 범위의 데이터를 여기 앞으로 땡긴다라는 부분이 , 이렇게, 처리가 될 것이고 그걸 했다고 하면은 이제 리드 포즈를 0으로 그 다음에 라이트 포즈는 데이터 사이즈만큼으로 설정을 해주면 이제 데이터를 복사한 다음에 리드랑 라이트가 각각 이런 식으로 들어가게 될 겁니다. 그래서 , 이렇게, 처리가 되는 거죠 근데 요 방법이 이제 뭐 굉장히 편하고 우아하긴 한데 뭐 살짝 아쉬운 점을 꼽아보자면은 만약에 운 좋게 우리가 운 좋게는 아니고 대부분의 경우 , 사실, 일로 들어오겠지만 뭐 데이터가 일부 짤려와 가지고 우리가 모든 데이터를 처리하지 못해 가지고 찌그레기가 , 이렇게, 남았다고 하면은 그 찌그레기를 처리하기 위해서 매번마다 , 이렇게, 복사하는 비용이 들어가게 될 겁니다 그래서 이 복사 비용을 최대한 줄이려면 어떻게 해야 되느냐 이것도 여러가지 방법이 있겠지만 굉장히 단순한 방법은 우리가 실질적으로 처음에 사용하는 이 최대 버퍼 크기보다 이거를 더 크게 잡아주는 겁니다 예를 들면 원래 버퍼가 우리가 5바이트만 사용할 거라고 했으면 이거를 한참 더 크게 만들어 놓은 다음에 여기서 끝까지 갈 때까지 최대한 이거를 하지 않고 억제를 하면서 계속 리드랑 라이트를 하다보면 언젠가는 운이 좋게 리드랑 라이트가 겹치는 상황이 딱 발생할 확률이 높아질 때니까 그 상태에서 다시 , 이렇게, 리드랑 라이트를 앞으로 땡겨주면은 아무런 복사 비용 없이 이제 우리가 사용할 확률이 높아질 겁니다 이런 식으로 조금 더 최적화를 할 수가 있겠죠 , 자, 그래서 이걸 어떻게 만들거냐면은 , 사실, 이 상태로도 상관없긴 한데 이거를 조금 더 효율적으로 동작시키기 위해서 버퍼 카운트라는걸 , 이렇게, 내부적으로 관리를 해주도록 합시다 실질적으로 얘가 요청한 버퍼보다 크기를 10배를 더 크게 잡아가지고 훨씬 더 크게 버퍼를 만들어 준다는 거죠 그래야지만 실질적으로 리드랑 W가 겹치는 상황이 더 빈번하게 일어날 테니까 끝까지 갈 때까지 언젠가 겹치기를 바라면서 크게 잡아주도록 할 거예요 그래서 여기 위에다가 Capacity라고 진짜 진짜 데이터 사이즈를 Capacity라는 변수로 관리를 하도록 하고 Receive 버퍼에서 우리가 처음에 버퍼 사이즈를 , 이렇게, 저장을 해 준 다음에 바로 위에다가 Capacity라는 거를 따로 만들어 주도록 하겠습니다 버퍼 사이즈에다가 버퍼 카운트 만큼을 곱해 줘가지고 더 크게 들고 있겠다 이거죠 그리고 얘는 하는 김에 위에다가 , 일단은, 더 효율적이니까 옮겨주도록 하고 얘는 캐페시티로 바꿔주도록 하겠습니다 즉 최대 데이터를 받을 수 있는 크기를 우리가 버퍼 사이즈라는 거로 단일 버퍼를 버퍼 사이즈로 관리할 것인데 그거보다 10배를 더 크게 잡는다 이거죠 그러면 나머지 부분은 , 일단은, 바뀔 필요가 없는데 여기서 Free Size 같은 경우는 어찌됐건 우리가 여유분으로 데이터를 쓸 수 있는 공간이라는 의미니까 이 부분이 Capacity로 , 일단은, 교체를 해주면 되겠습니다. 실제 버퍼 크기는 Capacity이기 때문이죠. 그리고 이 버퍼 사이즈는 단일 버퍼의, 즉 실질적으로 한 번에 쓸 수 있는 최대 크기를 이제 나타나게 될 거예요. 그러면은 그 다음에 이쪽에서 매번마다 이거를 무조건 해주는게 아니라 진짜 최악의 경우까지 가가지고 어.. 얘가 끝까지 갔는데도 진짜진짜로 끝까지 갔는데도 불구하고 지금 아직도 찌끄레기 데이터가 있었으면 그제서야 비로소 요 부분을 실행을 해주도록 할게요 그러니까 한마디로 요 요 공간이 버퍼 한개 미만 버퍼 한개 크기 미만이면 데이터를 앞으로 당긴다 라는 부분을 이제 여기서 실행을 시켜주면 될 거에요 프리사이즈를 체크해가지고 프리사이즈가 단일 버퍼 크기보다 작아지는 경우 즉 요 상황으로 보면 이제 얘가 W라는 애가 맨 끝에 있는 요 부분으로 이제 넘어온 순간에만 얘를 이제 실행해 준다는 얘기가 되는 거죠 그래서 , 이렇게, 하면 거의 대부분의 상황에서는 이 코드가 내부적으로 들어오지 않고 항상 리드 포지트랑 라이드 포즈가 겹치는 상황이 거의 대부분 일어나게 될 겁니다. 그러면 아무런 복사 비용 없이 커스를 앞으로 당길 수 있다는 굉장히 아름다운 상황이 된다고 볼 수 있겠어요. , 이렇게, 해가지고 리드 버퍼에 대한 내용을 간단하게 , 일단은, 만들어봤는데 이제 그러면 이것을 어떻게 사용하느냐 이거를 세션 쪽에 가서 사용을 하게 될 거예요. 세션으로 돌아가가지고 우리가 임시로 만들었던 요 Receive Buffer는 , 일단은, 삭제를 해주고 얘도 그냥 삭제를 해줄게요 그 다음에 위에다가 여기서 Include Receive Buffer를 추가를 해주도록 할 거고 그 다음에 쭉 내려가지고 우리가 수신 관련 내용을 넣기로 한 요 부분에다가 Receive Buffer를 내부적으로 , 이렇게, 만들어주도록 하겠습니다 Receive Buffer 얘가 말 그대로 수신 버퍼를 좀 더 효율적으로 관리하기 위해서 만들어준 클래스죠 , 자, 그 다음에 어 리시브 버퍼를 처음에 만들 때 버퍼 사이즈를 여기서 넘겨줘야 됐었죠 근데 이거는 뭐 하드코디 하기보다는 그래도 그냥 인원값으로 , 이렇게, 관리를 해도록 할게요 버퍼 사이즈는 , 일단은, 1, 2, 0, 0, 0, 0 64KB로 , 일단은, 기본 세팅을 해주도록 하겠습니다 64KB 네 요렇게 , 일단은, 만들어주도록 할게요 6, 5, 5, 3, 6 이게 기본적으로 가장 적당한 값이에요 그래가지고 여기서 리시브 버퍼를 만들 때 버퍼 사이즈만큼으로 일단 할당해가지고 이 버퍼를 만들어 주겠다라고 , 이렇게, 얘기를 해주면 될 것이고 그 다음에 리시브 버퍼와 관련된 부분이 조금씩 수정이 돼야 되는 거는 얘를 찾아보다 보면 원래 우리가 기존에 그냥 강제로 밀어넣던 이 부분이 이제 수정이 돼야 되겠죠 얘 같은 경우에는 항상 첫 번째 위치에다가 복사를 하는 게 아니라 이제는 라이트 포즈의 위치가 어딘지를 봐가지고 기존의 데이터를 건드리지 않고 계속 앞에다가 써 내려가는 식으로 이제 동작을 하게 될 겁니다 이 그림을 보면은 W컷서 위치에다가 계속 데이터를 쓴다는 얘기가 되는 거죠 이 앞에 데이터는 건드리지 않고 , 이렇게, 만들어주면 되고 그 다음에 Receive Buffer의 크기는 이제는 Receive Buffer에다가 Free Size를 추출해가지고 , 이렇게, 만들어주면 되겠죠 얘는 진짜로 요만큼의 데이터를 복사하라는 얘기는 아니고 실제 버퍼의 크기는 우리가 최대로 받을 수 있는 크기는 얼마인가를 의미하기 때문에 , 사실, 이 전체 프리사이즈가 실질적으로 우리 최대 버퍼 크기보다 훨씬 더 크게 잡힐 확률이 높겠지만 뭐 딱히 상관이 없습니다 어차피 실질적으로 넘버 바이트를 통해 가지고 여기서 복사된 커널 레벨에 있는 수심 버퍼에서 복사해온 사이즈는 이걸로 판별해 줄 거예요 그래서 , 이렇게, 일단은, 교체를 해주면 되겠습니다 , 자, 그러면은 실질적으로 우리가 여기서 걸어준 리시브가 완료가 되면은 우리가 늘 하던 대로 아이고 프로세스 리시브에 얘가 들어오게 되겠죠 프로세스 리시브를 통해가지고 요 부분을 이제 들어오게 될 겁니다 그러면 여기서는 이제 어떻게 처리를 해야 되느냐 먼저 우리가 먼저 체크한게 number of byte 라는 애를 어 요렇게 , 일단은, 체크를 0이 아닌지를 체크했고 그 다음에 이제 이어가지고 여기서 성공적으로 여기 들어왔다는 것은 성공적으로 우리가 건네준 버퍼에 데이터가 복사되었다는 의미가 되는 거니까 여기다가 receive... 아이고, receive 버퍼의 onWrite를 호출해가지고 numberOfByte만큼을 앞으로 땡겨줄 겁니다 근데 혹시라도 false가 리턴했다 뭐 , 사실, 이런 경우는 없긴 하겠지만 그렇다고 하면 뭔가 문제있는 상황이니까 안전하게 , 이렇게, 코드를 만들어주도록 할게요 onWrite overflow 뭔가 버퍼가 overflow됐다 라고 , 이렇게, 로고를 찍어주도록 하겠습니다 , 자, 그러면은 여기서 이제 데이터가 복사되었으니까 라이트 커서를 앞으로 당기는 부분이 이제 여기 들어가는 거고요 그 다음에는 이제 무엇을 해야 되느냐 어... 먼저 지금까지 쌓인 데이터의 사이즈가 얼마인지를 꺼내 주도록 합시다 Receive Buffer의 데이터 사이즈 이거는 지난번에 보냈던 데이터에다가 요번에 받은 데이터를 포함한 총 데이터의 크기를 얘기하고 있는 겁니다 지금 누적된 데이터의 크기가 요기에 이제 들어간다고 보면 되겠어요 데이터 사이즈로 갈게요. 이게 좀 낫겠네요. 그 다음에 onReceive를 우리가 호출해줄건데 얘를 Receive Buffer의 Read Pose 처음에 읽는 위치부터 시작해가지고 데이터 사이즈만큼을 이제 U 범위로 찝어주는 거죠 그게 실질적으로 지금까지 들어온 총 데이터의 영역이라고 볼 수가 있는 겁니다 그걸 우리가 컨텐츠 쪽으로 넘겨가지고 얘가 어떤 식으로든 처리를 해주게 될 거고 그거를 다 처리할 수도 있고 일부만 처리할 수도 있는데 실질적으로 걔가 처리한 최종 개수를 이 프로세스 렌스로 다시 리턴을 받아주게 될 겁니다. 그러니까 이 부분이 중요한 거예요. 그래서 지금까지 온 리습에서 항상 우리가 여기 게임 서버 코드를 보면 지금까지 우리가 데이터를 받아줄 때 리습을 한 다음에 그냥 이 렌스를 그대로 뱉어줬었죠. 이 모든 데이터를 처리했다라는 의미로 이제 받아주시면 되겠습니다. 네 그래서 , 이렇게, 해가지고 프로세스 렌스를 이제 뱉어주게 될 건데 얘가 실질적으로 내가 받은 요 데이터 중에서 내가 처리한 데이터의 개수를 얘기하고 있는 거니까 이제 이 만큼을 다시 커서를 리드 커서를 앞으로 땡겨주면 되겠죠 즉 여기서 내가 뭐 어디서 어디까지 처리했다고 하면은 그 리드 커서를 이제 앞으로 하나 둘 셋 이런 식으로 앞으로 당겨가지고 이제 여기 있는 데이터가 처리가 되었으면 더 이상 필요 없다는 상황이 되는 겁니다 이제 그 부분을 처리해주면 되겠어요 그래서 뭐 , 일단은, 예외 체크를 몇 개만 해주도록 할게요 0보다 작거나 아니면은 뭐 데이터 사이즈보다 더 많이 처리했다고 하면 이건 뭐 말이 안 되는 상황이니까 간단하게 예외 처리를 해주도록 하고 그 다음에 실제적으로 우리가 해야 되는 거는 Receive Buffer에 On Lead를 호출해 줘가지고 프로세스 렌스만큼을 우리가 처리한 개수만큼을 리드 커스터를 앞으로 당겨주게 될 겁니다 그래서 , 이렇게, 만들어주고 만약에 얘가 false가 떴다고 하면 역시나 이상한 상황이니까 뭐 여기서도 마찬가지로 on read overflow라고 , 이렇게, 로그를 찍어주도록 할게요 얘는 여기로 일단 주석을 옮겨주고 그래서 요런 느낌으로 이제 코드가 실행이 될 겁니다 그러면 결국에는 우리가 on write랑 on receive를 한번씩 해가지고 write cursor를 앞으로 당겨준 다음에 데이터를 최대한 처리를 해가지고 어, 데이터를 처리한 만큼 on read를 호출해서 read cursor를 앞으로 당겨줬으면 이제 그 다음에 마지막으로 해줘야 되는 거는 cursor 정리를 이제 시도를 할 겁니다 그래서 receive buffer에 clean을 호출해가지고 정리를 해보는데 만약에 정말 운 좋게 모든 데이터를 처리해가지고 read랑 write가 동일 포지션이 있다고 하면은 걔네들을 다 첫번째 위치로 빠빵 하고 순간 이동을 시킬 것이고 그게 아니라 정말 한참 동안 진행을 해서 거의 끝까지 이제 buffer를 사용했는데도 불구하고 아직까지 뭐 이런 식으로 리드랑 라이트가 겹치지 않았다고 하면은 여기 남아있는 데이터를 첫번째 위치에다가 복사를 시켜준 다음에 그 위치에 맞게 라이트를 당긴다라고 , 일단은, 볼 수가 있겠습니다. 그 부분이 이 부분이라고 보시면 되겠어요. 그래서 주석은 , 일단은, 뭐 더 이상 필요 없으니까 삭제를 하도록 하고 그래서 클린이 마지막으로 이제 실행이 될 겁니다. 그래서 이제 이 코드가 어... 실행이 되면은 이제는 기존에 있던 버퍼를 날리는게 아니라 계속 누적한 채로 관리를 하는 식으로 이제 동작을 하게 될겁니다 , 자, 그래서 이거를 이제 빌드를 해가지고 어... 지금 여기서 문제가 나는거는 아 여기 하나 더 고칠 때가 있는데 , 자, 리지스터 억셉트 같은 경우에는 여기서 맨 처음에 어... 받... 라이트 버퍼를 여기다가 넣어줘야 됐었는데 이제 그 부분이 살짝 바뀌어가지고 그런 것 같네요 그러면 여기서는 그냥 기본적으로 라이트 포즈를 , 이렇게, 건네주면 되겠죠 얘가 사실상 첫번째 위치이겠지만 처음 시작할 때는 , 자, 요 부분까지도 , 이렇게, 다시 빌드를 해가지고 빌드 성공이 되었으면 이제는 정상적으로 리시이브 버퍼를 사용할 준비가 된 겁니다 , 자, 그래서 요 상태에서 다시 똑같은 코드를 뭐 기존에 만들었던 걸 다시 이제 호출을 해볼건데 아무런 문제가 없다고 하면 이런 식으로 Receive가 12, 12, 12 클라도 12, 12, 12씩 잘 복사를 한다는 걸 볼 수가 있습니다 , 이렇게, 잘 되고 있죠 그리고 지금 같은 경우에는 , 사실, 클린 같은 걸 살펴보면 당연한 얘기지만 요로 당연히 들어오게 될 겁니다 대부분 TCP라고 해도 정말 우리를 골탕 먹이려고 데이터를 쪼개 보내는 게 아니라 상대방 쪽이 더 이상 데이터를 받을 수가 없어 가지고 일부 데이터만 보낼 수 있을 때 쪼개서 보내는 거기 때문에 아주 부하가 심해지지 않는다고 하면 거의 여기로 들어오게 될 겁니다 나중에 스트레스 테스트를 하면서 막 세션을 몇백개, 몇천개씩 만들어가지고 데이터로 쏘면 종종 이쪽에 들어올 일도 생기게 될 거예요 근데 지금은 일단 , 이렇게, 해서 마치도록 할게요 , 자, 이렇게, 해가지고 Receive Buffer라는 개념을 둬가지고 이제 수신 버퍼를 편하게 관리할 수 있는 그런 방법에 대해서 , 일단은, 알아봤습니다 , 자, 이렇게, 해서 이번 Receive Buffer 시간을 마치도록 할게요.