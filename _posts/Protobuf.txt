자, 이렇게, 해가지고 우리가 이제 지난 시간까지 결국에는 패킷을 만들고 직렬화하는 여러가지 기술들에 대해서 알아봤으니까 이제는 진짜로 우리가 앞으로 프로젝트에서 작업할 프로토버프라는 애를 연동을 시켜보는 실습을 할 겁니다 근데 이게 좀 단계가 생각보다 좀 복잡한 부분이 있어요 근데 한 번만 하면 되니까 좀 머리가 좀 복잡하더라도 좀 참고 따라오시면 될 것 같구요 프로토버프는 그 유명한 구글에서 만든 겁니다 만든 라이브러리고 참고로 이제 리니지M 이라거나 굉장히 유명한 프로젝트들이 프로토 버프를 채택을 해 가지고 사용해서 이제 개발이 되었어요 그만큼 신뢰성이 있고 많이 사용이 되다 보니까 어지간해서는 앞으로 포트폴리오를 만들건 작업을 하실 때 그냥 프로토 버프를 연동하는게 전 개인적으로 제일 좋은 것 같습니다 그만큼 많이 사용하기 때문이죠 , 자, 그런데 뭐 그럼 이제 이거 어떻게 사용할 것이냐 먼저 구글에 가 가지고 구글에 가서 구글 프로토 버프라고 , 일단은, 검색을 해보시면 친절하게 구글 사이트로 , 이렇게, 연동이 됩니다 그래서 여기 보면은 , 자, 이제 어떻게 시작할까요 딱 친절하게 설명이 나와있죠 먼저 구글 프로토 버퍼 프로토콜 버퍼 컴파일러라는 애를 다운로드 받으라고 합니다 그래서 Download 버튼을 눌러가지고 따라가 보다가 여기 이제 쭉 내려 보다 보면은 언어마다 이제 어떻게 어떻게 해야 된다라는 뭐 그런 얘기가 있는데 지금은 11플을 사용하고 있긴 한데 단계별로 하기 위해서 일단 요 링크에 가가지고 릴리즈에 가가지고 여기 쭉 내려보다 보면은 요 버전 프로토C라고 붙은 게 프로토 컴파일러라는 의미입니다 컴파일러만 , 이렇게, 따로 받을 수 있게끔 , 일단은, 하나를 요렇게 열어놨어요 그래서 , 일단은, 얘를 다운로드 받아가지고 바탕화면이나 어딘가에 , 일단은, 풀어 놓으시면 되겠습니다 , 자, 근데 이 컴파일러라는 게 무엇을 하는 것이냐 잠시 한번 설명을 드려보자면 우리가 우리만의 이런 포맷으로 만들기 위한 연습을 할 때 먼저 패킷 자체의 정의를 우리가 이런 xml 파일로 정의하고 있었죠 이게 , 사실, 원본 패킷의 정의였고 이거를 나중에 가면 만약에 우리가 그냥 요 방식을 채택할 거라고 하면은 툴을 만들어 가지고 그 툴을 돌려 가지고 요 내용을 쫙 읽어 가지고 이런 식으로 우리가 만든 이런 코드로 변환이 돼야 된다고 했었죠 이런 코드를 자동화 처리를 해서 만들어줘야 된다 라고 설명 드렸습니다 그리고 그 역할이 사실상 컴파일러의 역할이 되는 겁니다 그 툴 자체를 여기서 컴파일러라고 부르는 거에요 마찬가지로 우리가 프로토 버프를 사용할 때도 프로토 버프도 자신만의 이런 정의 기법이 있습니다 뭐 정의 포맷이 있는데 그걸 이제 프로토 파일이라고 할 거예요 나중에 작성하게 될 건데 프로토 파일을 먼저 만든 다음에 그걸 변환기를 통해 가지고 돌리면은 이런 식으로 뭐 언어별로 C++, C샵, 뭐 자바스크립 등 온갖 언어로 다 지원이 되긴 하지만 이런 식으로 자동화된 코드들이 만들어져 가지고 그거를 이제 사용하면 됩니다 그런 식으로 이제 만들어져 있어요 그래가지고 여기서 결국에는 아까 얘기하는 이 protoc라는게 protobuf 컴파이러라고 했었죠 즉 프로토 파일을 C++이나 C샵이나 온갖 언어에 맞는 그 실행 파일은 아니고 그 클래스로 만들어주는 부분이 이 역할을 담당하게 된다고 보시면 되겠습니다 , 자, 그래서 만약에 압축을 풀으셨으면은 이거를 이제 우리 프로젝트 쪽에다가 , 일단은, 복사를 해줄건데요 저같은 경우에는 지금 여기 상위 폴더에 가가지고 이쪽에다가 , 일단은, 그냥 박아놨습니다 , 자, 서버에 가가지고 방금 아까 다운받은 파일을 그냥 폴더 채로 여기다가 넣어놨어요. 나중에 위치는 어디서 관리할지는 나중에 논하도록 하고 , 일단은, 이 위치에다가 그냥 binary, dummy, client 뭐 쭉 있는 이 위치에다가 프로토 컴파일러를 그냥 , 이렇게, 넣어놨습니다. 그래서 여기 보면은 뭐 이 include 랑 readme 는 딱히 뭐 중요하지 않은데 여기 빈 파일이 있고 요 실행 파일이 있는데 얘가 바로 실질적으로 나중에 우리가 만들 프로토 파일을 변환하는 역할을 맡게 될 겁니다 근데 말이 나온 김에 그냥 프로토 변환부터 일단 한번 실습을 그냥 해보도록 할게요 , 자, 여기서 먼저 해야 될 것은 , 일단은, 아무 파일이나 하나 만들어 보도록 하겠습니다 새로 만들기 텍스트를 만들어 준 다음에 뭐 이거를 protocol.proto 라는 이름으로 , 이렇게, 일단은, 만들어 주도록 할게요 근데 만약에 여러분들이 이제 점을 찍을 수 없다 뭔가 좀 난 이 화면이 안보인다고 하면은 여기 윈도우즈를 보면은 어 여기 위쪽에 보기에 가서 위쪽에 보기에 가서 파일 확장면을 클릭하시면 이게 점까지 이게 앞으로 보일 겁니다 그래가지고 반드시 txt를 제거하고 proto.proto protocol.proto 라는 파일로 이제 만들어 줄 거예요 , 자, 그 다음에 이거를 뭐 문서 편집기나 메모장 이건 뭐 아무거나 상관없는데 그냥 여기 비주얼 스피드에다가 드래그 드롭 해가지고 그냥 여기서 그냥 작업을 하도록 하겠습니다 이제 요 파일을 작업을 할 건데 요 파일 포맷은 xml이 아니라 이제 우리가 만든 요 역할을 하게 되기는 하지만 자체적인 포맷이 있습니다 그래서 이것도 이제 살짝 살펴보면은 프로토콜 Basic 문서를 한번 살펴볼게요 구글에 가가지고 똑같이 프로토 버프를 친 다음에 여기서 Language Guide를 한번 찾아볼 건데 우리가 지금 다운로드 받고 사용하는 버전이 3번 버전 프로토 3.얼마였죠? 3번때를 사용할 겁니다 이게 2번때랑 3번때랑 문법이 완전히 달라졌어요 그래서 하나를 골라가지고 쭉 그거만 사용해야 되는데 뭐 최신에 나온 게 이제 3번이고 2는 더 이상 지원을 안 하다 보니까 그냥 이 버전을 사용하도록 하겠습니다 그래서 여기 뭐 굉장히 친절하게 어떻게 어떻게 사용을 해라라는 그런 친절한 뭐 설명들이 있는데 기회가 되면 이걸 한 번씩 읽어보면 도움이 되는데 뭐 지금 당장 너무 장황한 내용을 읽어볼 필요는 없고요 이게 생각보다 굉장히 단순하게 만들어져 있다는 거를 만들다 보면 이제 알게 되실 겁니다 그래서 , 일단은, 뭐 요런 느낌으로 만든다 라고 하니까 다시 요기 가가지고 아까 syntax 라고 한 다음에 equal proto3 이라고 해가지고 맨 처음에 버전이 이제 프로토 버프 3.대 버전이다라고 , 일단은, 요렇게 선언을 해줄 것이구요 이거랑 약간 굉장히 비슷하죠? xml이 버전이 무엇이다라고 지금 크게 외치는 거랑 약간 비슷한 느낌이라고 보시면 되겠습니다 그 다음에 package protocol 이라고 해가지고 어... 일단 요걸 일단 입력을 하시면 되구요 나중에 이제 뭐 파일이 추출되면 이게 어떤 역할인지 알게 되실건데 그냥 이름을 우리가 , 이렇게, 지어준겁니다 네임스페이스를 그 다음에 이제 이어가지고 우리가 지난번에 테스트하던 요 포맷을 그냥 그대로 여기서 한번 만들어 보도록 할게요 , 자, 패킷이 있는데 어... stest라는 용... 테스트라는 이름으로 , 이렇게, 만들어 놨으니까 여기다가 message s__test라고 , 이렇게, 만들어 줄게요 이게 사실상 어... 우리 그 C++코드로 치면은 struct를 만드는 거랑 그냥 비슷하다고 생각하시면 되겠습니다. 요런 느낌. 이 메시지 무엇 무엇 하는 게 struct다. 그냥 구조체를 만든다라고 생각하시면 돼요. , 자, 그 다음에 구조체를 만들 때 항상 우리가 멤버 변수들을 여기다가 , 이렇게, 정의를 했었죠. 마찬가지로 여기서도 이제 하나씩 정의를 해주면 되는데. 유인트24 아이디. 1, 여기 이제 1, 2, 3, 4 같은 숫자가 등장하는 거는 초기 값을 의미하는 게 아니라 얘가 여러 가지 데이터들 중에서 첫 번째 위치에 있다는 얘기입니다. 그래서 이 숫자를 넣어주는 이유는 혹시라도 나중에 우리가 만드는 파일에 대한 내용이 바뀌어가지고 이런저런 내용이 추가가 될 때 그게 서로 꼬이지 않도록 그 순서를 어떻게 보면 유지시켜주기 위한 용도라고 보시면 돼요. 그래서 그냥 생각할 필요 없이 그냥 1, 2, 3, 4 식으로 그냥 쭉 하나부터 , 이렇게, 순서대로 늘려주시면 되겠습니다. , 자, 그 다음에 유인트 32, HP는 2번, 유인트 16, 어택은 3번. , 자, 그 다음에 리스트가 등장하는데 , 이렇게, 가변적으로 여러개가 등장하는 것은 repeated라는 키워드를 붙여주시면 됩니다. , 자, repeated가 들어간 다음에 그 다음에 또 다시 포함해가지고 요런식으로 어떤 리스트가 동일한 데이터를 물고 있는 형태로 이뤄지다 보니까 이걸 어떻게 만들거냐면은 다시 한번 위에다가 message.buffdata 라는 또 하나의 구조체를 만들어 줄 겁니다 그 다음에 위에서 마찬가지로 얘는 버프 아이디가 1번 그 다음에 리메인 타임이 2번 이라고 만들어 주면 지금 안에 있는 부분을 만들고 있는 거에요 얘를 , 일단은, 하나의 스트럭트로 만들어 주고 있는 거고 얘도 안에서 요렇게 빅팀스라는 리스트를 갖고 있으니까 뭔가 배열이 배열 같은 리스트가 이제 등장한다고 하면 무조건 여러개가 등장하니까 repeated를 쳐놓고 요인트64의 victims가 3번이다라고 , 이렇게, 설계를 하는 겁니다 그러니까 우리가 뭐 C++나 C-Sharp 언어에서 struct나 class같은 거를 설계하는 거랑 완전히 똑같은 느낌으로 , 일단은, 쭉 만들어 주시면 되겠습니다 그래서 요렇게 만들어 준 다음에 요 내용이 리스트로 또 여러개가 들어간다고 했으니까 repeated 버프 데이터 , 이렇게, 일단은, 만들어주면 되겠죠 버프 4번 그래서 굉장히 놀랍게도 지금 이 내용을 똑같이 우리가 이 프로토라는 형식으로 그냥 만든 게 딱 이거입니다 그리고 나중에 가서 실습하겠지만 여기서 인원값도 넣을 수 있고 굉장히 많은 것들을 작업을 할 수 있어요 지금은 , 일단은, 간단하게 이런 구조체를 만드는 연습을 하고 이 구조체 자체가 이제 실질적으로 우리가 패킷으로 보낼 정보로 사용하면 됩니다. 근데 꼭 그런 용도로만 활용해야 된다는 건 아니고 이게 나중에 변형이 되면 그냥 일반 클래스나 스트럭트로 만들어지기 때문에 그거를 그냥 멤버 변수로 들고 있어도 됩니다. 이런 걸 그냥 최대로 활용해도 된다라는 얘기가 되는 건데 일단 지금 당장은 패킷 용도로 활용하고 있으니까 이걸 어떻게 사용하면 될지 이어서 만들어 보도록 할게요. , 일단은, 이 프로토 파일이 정의가 되었으면 이제 이 변환기를 돌려 가지고 여기 있는 내용을 우리가 원하는 형태로 이제 바꿔야 되는데 언어별로 C++, C Sharp, Java, JavaScript 등등 온갖 언어로 다 이걸 변환을 해줄 수 있기 때문에 우리가 명확하게 지금 어떤 언어로 얘가 변환을 해줄지 원하는지를 추가적으로 이제 기입을 해야 됩니다 그러기 위해서 프로토C를 실행하면서 인자들을 같이 넘겨줘야 되는데 이것도 구글에 가서 프로토3에 대한 가이드를 보면서 맨 마지막에 Generating Your Classes 라고 딱 써있죠 우리의 클래스를 만드는 방법이라고 해서 친절하게 , 이렇게, 만들면 된다고 힌트가 나와있어요 , 자, 그래가지고 , 일단은, 이 내용을 잠시 쭉 긁어가지고 그냥 얘를 이제 복사 , 이렇게, 해도 되고 복사를 한 다음에 잠시 다시 돌아와서 여기서 다시 한번 새로 만들기 그냥 텍스트 문서를 아무거나 만들어 준 다음에 배치 파일을 만들어 줄 거에요 그래서 gen package .bat라는 확장제로 만들어 주도록 하겠습니다. 이게 이제 배치 파일이라는 앤데 얘를 실행시키면 , 사실, 뭐 우리가 원하는 명령어들이랑 같이 실행하게끔 유도를 해줄겁니다. , 자, 이 배치 파일도 뭐 메모장이나 뭐랑 뭐 아무거나 열어도 되는데 이것도 드래그 드롭으로 그냥 비주얼 스튜디오에서 작업을 하도록 할게요. 이 공간에서 작업을 할 것이고 아까 복사한 내용을 그냥 그대로 복붙을 하고 시작을 해보도록 하겠습니다. , 자, 근데 여기서 말하는 내용이 다시 보면은 언어별로 우리가 어떤 식으로 만들어 줄지를 정하고 있는데 cpp는 당연히 cppout을 이용해 가지고 만들면 되는 거고요 나머지 언어들도 Java, Python, Go, Ruby 등등 C샵도 있고 굉장히 다량한 언어로 , 이렇게, 들어가 있다는 걸 볼 수 있습니다 이 설명서를 그대로 이제 사용하면은 결국에는 첫 번째가 protopath라고 해 가지고 우리의 프로토 파일이 어디 있느냐를 의미하는데 그런데 아까 문서를 보면은 이걸 프로토 패스라고 해도 되지만 그냥 대문자 I, import 패스의 약자인 대문자 I로 해도 똑같이 동작을 한다고 나와 있습니다 대신 여기 짝대기가 두 개가 아니라 하나로 , 이렇게, 바꿔 주시면 되겠어요 그래서 우리의 프로토 파일이 위치한 경로는 어딨냐라고 하는데 같은 경로에 있다라는 의미로 .slash로 , 일단은, 이렇게, 쳐주시면 되겠고요. 그 다음에 cppout, 즉 우리가 cpp, 즉 C++ 언어로 만들어 줄 거니까 얘를 그대로 냅둘 것이고 역시나 같은 경로에다가 파일을 출력하라고 같은 경로의 의미인 .slash를 일단 입력을 해주도록 하겠습니다. 그 다음에 지금 Java, Python, Go, Ruby 온갖 언어로 다 있는데 지금 당장은 필요 없으니까 여기까지 날려주면 되겠고 나중에 혹시 유니티 연동이 필요하다고 하면 C샵은 다시 살려주면 되겠죠 그래서 , 일단은, 요렇게까지 , 일단은, 쫙 날려주도록 하겠습니다 그 다음에 마지막으로 우리의 프로토 파일을 요렇게 이제 입력을 하면 되는데 우리는 지금 같은 경로에 어... 있으니까 .slash라고 한 다음에 protocol.proto라는 파일 이름으로 만들어놨으니까 얘를 이제 , 이렇게, 만들어 주시면 되겠습니다 그리고 요 protoc는 이제 proto.exe 를 의미하는 거니까 얘를 이제 , 이렇게, 만들어 주시면 되겠고 그 다음에 이제 이건 배치 파일 문법인데 만약에 문제가 있다 에러 레벨이 1 이라고 하면은 포즈를 때려 가지고 멈춰 주도록 할게요 , 자, 이렇게, 일단은, 만들어 주면은 이제 다음에 다시 어... 아까 만들어 준 , 자, 요 젠 패킷을 이제 딱 눌러주면은 더블 클릭해서 눌러주면 만약에 문제가 있다고 하면 이런 식으로 지금 에러 메시지가 출력이 될 겁니다 지금은 우리 배치 파일의 문제는 아니고 우리 프로토 파일에서 uint16 이라는 게 디파인되지 않았다는 굉장히 신기한 얘기를 하고 있습니다 즉 요 아이가 문제가 있다고 하는데 실제로 아까 문서를 살펴보면 여기서 프로토 3번에 대한 내용을 살펴보면 우리가 사용할 수 있는 애들이 몇 개가 있습니다 어... Scalar Value Type이라고 해가지고 우리가 사용할 수 있는 애들이 있는데 여기서 굉장히 재밌는 게 우리가 Int32라고 해도 우리가 C++에서 지금까지 사용했던 그 진짜 Int32가 아니라 실질적으로 데이터가 인코딩되어서 들어갈 때 Variable Length라고 합니다 이게 좀 사이즈를 압축해가지고 들어갈 수도 있어요 꼭 300T라는 보장이 없습니다 마찬가지로 Int64도 최대 사이즈가 Int64이기는 하지만 이게 이제 실질적으로 들어갈 때는 어... 어느 정도 압축돼서 들어갈 수 있다라는 얘기를 하고 있습니다 그리고 마찬가지로 여기 쭉 내려보다 보면 만약에 정말 정확하게 4바이트, 8바이트를 하고 싶으면 S-Fixed나 이런 걸 사용하면 된다라는 설명도 하고 있으니까 이런 것도 그냥 참고하면 될 것 같고요 그런데 만약에 우리가 지금처럼 U-INT 16을 사용하고 싶다고 하면 어떻게 되느냐 16이 없다는 걸 알 수가 있어요 그래서 그냥 이럴 경우에는 U-INT 32로 가장 가까운 내로 그냥 만들어 주시면 됩니다 그래서 아까 유인트 16이 없었기 때문에 에러가 난 거였으니까 어... 요걸 다시 돌아가가지고 , 자, 여기서 유인트 32로 얘를 일단 바꿔치기를 해주도록 할게요 그러면은 아까 일어났던 그 문제는 , 일단은, 해결이 될 겁니다 그래서 요기서 다시 GenPacket을 더블 클릭해주면 이제는 문제가 해결이 되었기 때문에 와우 굉장히 신기하기도 header 파일이랑 cc라는 이게 사실상 우리 cpp 파일에 해당하는 건데 요런 파일 두 개가 , 일단은, 요렇게 만들어져 있다는 거 볼 수가 있어요 그럼 이제 나중에 배치 파일에서 이거를 우리 쪽에 폴더로 복사하게끔 이제 추가적으로 내용을 만들어 주면 되는데 오늘은 첫날이니까 거기까지는 하지 않을 것이고 요 두 파일을 복붙 해가지고 컨트롤C로 복사한 다음에 그냥 직접적으로 넣어 주도록 하겠습니다 일단 게임 서버 우클릭 파일 탐색기에서 폴더 열기를 누른 다음에 여기다가 일단 복붙을 해줄 것이고요. 그 다음에 이거를 드래그 드롭으로 , 일단은, 이렇게, 갖고 와가지고 넣어준 다음에 우클릭 추가 새 필터를 만들어서 프로토콜이라는 폴더를 , 이렇게, 만들어가지고 여기 안에다가 , 이렇게, 넣어주도록 하겠습니다. 마찬가지로 더미 클라이언트도 우클릭 파일 탐색기에서 폴더 열기에 간 다음에 아까 마찬가지로 컨트롤 B로 복붙하고 얘를 다시 끌고 와서 메인에다가 넣어준 다음에 그 다음에 우클릭 추가 새 필터로 해가지고 프로토 콜 이라고 한 다음에 요 두 아이를 일단 집어 넣어 주도록 할게요 , 자, 이렇게, 일단 시작을 할건데 근데 뭐 굉장히 슬프게도 밑줄이 쫙 그어져 있는걸 볼 수 있고 당연한 얘기지만 여기서 빌드를 하려고 해도 마악 에러가 뜨면서 실패하게 될겁니다. 그러니까 지금까지 우리가 한거는 뭐냐면은 아까 예로 들면은 이 PDL이라는걸 요렇게 만들어 준 다음에 변환기를 이용해가지고 그게 어.. 우리의 우리가 자체적으로 만든 그 패킷을 이제 , 이렇게, 만들어 주게 된겁니다. 그러니까 요런 스트럭트를 만들어 준것까지는 됐는데 세부적으로 내부적으로 이 프로토콜을 이용하기 위해서 프로토 버프를 이용하기 위해서 사용돼야 되는 온갖 그런 기능들이 있을텐데 즉 예를 들면은 뭐 요런 느낌이죠 내부적으로 만들어줘야 되는 그런 포드도 있을텐데 그거를 우리가 지금 사용하지 않았기 때문에 , 이렇게, 에러가 나오고 있는 겁니다 그래서 결국에는 이 프로토 C라는 프로토 컴파일러를 이용해가지고 요 파일을 만든 것까지에서 끝내는 게 아니라 이제 나머지 기능들 여기서 사용하고 있는 요런 라이브러리들을 다 활용할 수 있게끔 이제 이 라이브러리를 또 찾아와가지고 다운로드 받은 다음에 저장을 해야 된다는 얘기가 되는 거죠 , 자, 그런데 지금 뜨는 에러 중에서 여기 자꾸만 뜨는 에러 중에서 여기 PCH가 뭐 없다라는 불만을 하고 있는데 그거는 얘를 우클릭 해가지고 속성에 간 다음에 C++에 가가지고 미리 컴파일된 헤더를 요 프로토콜 PBCC에 대해서는 사용 안함으로 , 일단은, 이렇게, 바꿔주시면 그 문제는 일단 해결이 됩니다. 이거 하나는 그냥 지금 해결하고 넘어가도록 할게요. 마찬가지로 얘도 미리 컴파일된 헤더 사용 안함으로 얘만 일단 , 이렇게, 바꿔치기 해주시면 되겠습니다. 요걸 누른 상태에서 해주셔야 돼요. 그럼 , 일단은, 에러가 없어지긴 했는데 이제 나머지 요 아이들을 이제 받으러 가야 되겠어요. , 자, 그런데 이거를 이제 받을 때 우리가 뭐 인터넷에서 다운받으면은 라이브러리 파일을 제공하는 방법이 여러 가지가 있지만 그 헤더들이랑 그 다음에 lib 파일로 라이브러리 파일을 제공하는 경우도 있고 아니면 그냥 소스 코드를 다 올려준 다음에 니가 알아서 빌드 해가지고 꺼냈어 라고 던져주는 경우도 있는데 불행하게도 프로토 버프는 이제 후제에 가깝습니다 그래가지고 이제 좀 복잡한 과정을 거쳐야 되는데 너무 귀찮다 싶으면은 제가 그냥 올려준 그 어 프로젝트에서 그냥 복붙 하셔도 상관이 없기는 해요 참고 삼아서 그런거고 , 자, 그 다음에 이제 뭐 하나 좀 선수 작업을 먼저 하자면은 여기 파일 탐색기에서 가서 지금 구조를 살펴보면은 우리가 라이브러리를 libraries라는 이 폴더에다가 지금 넣어놓기는 하고 있기는 한데 지금까지는 우리가 라이브러리를 사실상 서버코어 하나만 사용하고 있었기 때문에 뭐 굉장히 재미있게도 디버그랑 릴리즈 액션 서버 코만 , 이렇게, 들어가 있습니다. 근데 이제 나중에 지금 나중에 가면은 , 사실, 우리가 지금 당장 사용해야 되는 이 프로토버프나 여러가지 라이브러리들 여기에다가 이제 추가가 돼야 될 수도 있어요. , 자, 그래가지고 이걸 어떻게 할 거냐면은 , 일단은, 폴더를 하나 만들어 가지고 Include라는 폴더를 하나를 만들어 줄 것이고 그 다음에 폴더를 하나를 더 만들어 가지고 libs 라이브러리 파일들을 저장하는 폴더를 , 일단은, 만들어 주겠습니다. 그 다음에 LIBS 안에다가도 새 폴더를 만들어가지고 우리가 서버 코어를 라이브러리 형태로 지금 제공하고 있으니까 서버 코어드 여기다가 저장할 것이고 그 다음에 프로토 버프 같은 경우는 이 두 번째 폴더에다가 , 일단은, 넣어놓도록 할게요 그래서 , 이렇게, 일단은, 저장을 해놓을 것이고 그래서 여기서 지금 디버그랑 릴리즈라는 애는 , 사실, 서버코어에 라이브러리에 해당하는 파일들이 저장이 되어있죠 여기 지금 보면 라이브러리 파일입니다 LIB 그래서 얘네들을 두개를 Ctrl X로 잘라놓은 다음에 Ellipse에 가가지고 서버코어 안에다가 얘를 , 일단은, 넣어놓고 시작을 하도록 할게요 디버그 릴리즈를 각자 , 이렇게, 폴더로 그냥 구분을 해두도록 하겠습니다 그래서 뒤로 가서 프로토 퍼프는 이제 여기다가 넣어주면 되겠고 라이브러리 파일을 얘도 마찬가지로 뭐 미리 디버그랑 릴리즈라는 폴더를 , 이렇게, 똑같이 만들어 놓도록 할게요 그냥 앞으로 , 이렇게, 작업을 합시다 동일해서 , 자, 그러면 여기는 이제 라이브러리 자체는 여기 안에 들어가게 될 거고 그 다음에 라이브러리를 라이브러리만 있으면 되는 게 아니라 이제 C++에서는 이게 좀 짜증나는데 헤더 파일도 원래 같이 갖고 있어야 됩니다 그래서 헤더 파일들은 이제 여기다가 다 넣어놓게 될 거예요 근데 서버 코어 같은 경우는 헤더 파일을 굳이 LIB에다가 넣어줄 필요는 없었고 애당초 코드 자체를 여기 서버 코어라는 요 부분에서 헤더 파일들이 다 옹기종기 모여있었기 때문에 그냥 요 경로를 우리가 연결을 해주고 있었어요 그래서 참고삼아서 다시 한번 살펴보자면 여기 이제 게임 서버 설정을 들어가가지고 우클릭 속성에 한번 가가지고 지금 우리가 어떻게 설정하고 있었는지를 한번 살펴보도록 할게요 그러면은 지금 vc++ 디렉터리라고 되어있는 부분에서 라이브러리 디렉터리가 지금 , 이렇게, 일단은, 잡혀있습니다. , 자, 화살표를 누른 다음에 편집을 눌러가지고 한번 살펴보도록 할게요. 그러면은 지금 라이브러리까지는 잡혀있는데 여기다가 오늘 추가한게 lips라고 이제 여기다가 넣어놓기로 정해놨으니까 얘를 , 일단은, 이렇게, 추가를 해주시면 되겠습니다. lips까지 , 이렇게, 넣어주시고 ok를 누르면 되겠고요. 그 다음에 포함 디렉터리도 똑같이 편집에 가서 살펴보면은 서버코어 같은 경우에는 때마침 딱 여기 있었기 때문에 뭐 별다르게 얘를 바꿀 필요가 없었지만 이제 나머지 파일들은 여기다가 넣어줄 것이 아니기 때문에 이 버튼 줄 추가를 눌러가지고 어... , 자, 일단 얘를 복사한 다음에 복붙 해가지고 넣어준 다음에 얘는 서버코어는 아니고 라이브러리즈, 이거 오타 조심해야 됩니다. 에 인클로드에다가 넣어주기로 했으니까 얘를 , 이렇게, 일단은, 만들어주도록 할게요. 여기 백슬래시 넣어주셔야 되고요. , 자, 이렇게, 한 다음에 순서는 여러분 마음대로 해도 상관이 없습니다. 그래서 이 두 개를 이제 반드시 넣어주게 작업을 해주도록 할 거예요. 그 다음에 확인을 눌러주시고 적용 OK를 눌러주시면 되는데 게임 서버뿐만 아니라 더미 클라이언트에서도 똑같은 작업을 한 번 더 해줘야 됩니다. 얘도 마찬가지로 지금 라이브러리 디렉터리가 지금 요 경로로 잡혀 있으니까 얘도 편집에 가가지고 아까와 마찬가지로 여기다가 libs backslash를 추가해줄 것이고 ok를 눌러주고요. 그 다음에 포함 디렉터리도 여기서 편집에 간 다음에 마찬가지로 얘도 보고 오픈한 다음에 서버 코어가 아니라 libraries에 include라는 폴더를 찾아라 거기에 헤더가 있을 것이다 라고 , 이렇게, 일단은, 만들어서 ok를 눌러 주도록 할게요 아이고 굉장히 긴 작업이었는데 , 이렇게, 일단은, 만들어주고 이제 이어가지고 protobuf 라이브러리를 일단 다운로드 받을 겁니다 이걸 혹시 처음 하시는 거라고 한다면 이게 결국에는 라이브러리를 컴파인 할 때 이리저리 다른 경로에 있는 걸 막 합쳐가지고 찾을 것인데 우리가 결국에는 여기 지금 PCH에 보면은 디버그 모드에서는 파일들이 지금 어디 어디에 있다 이 파일들을 인클로드 해 줘 가지고 인클로드가 아니라 이 라이브러리들을 추가해 줘라라고 우리가 , 이렇게, 전처리 단계에서 우리가 해주고 있습니다. 그런데 이 경로를 우리가 지금 이렇게만 놓고 있죠? 그래가지고 아까 우리가 입력해준 그 경로들을 다 서칭해가지고 debug//servercorelib라는 이 파일이 있는지를 막 열심히 찾아줄 건데 그 경로를 의미한다고 보시면 되겠습니다. 참고로 우리가 살짝 경로를 바꿔놔가지고 이제는 기본적으로 아까 libs라는 폴더에 찾기로 했으니까 libs 산하에서는 코를 먼저 찾아야 되겠죠? 서버코어의 디버그에 서버코어 lib가 있을테니까 요렇게 , 일단은, 맞춰주면 되겠고 얘도 마찬가지로 요렇게 , 일단은, 넣어주면 되겠습니다. 그리고 얘를 복붙한 다음에 이쪽에서도 위쪽에서도 마찬가지로 , 이렇게, 바꿔주면 , 일단은, 문제는 해결될 거예요 더미 클라이언트만 일단 살짝 빌드를 해볼까요? 어차피 이거 프로토콜 넣어놔서 지금 안 될 테니까 이 부분은 지금 얘를 못 찾고 있어가지고 에러 나니까 이제 이어서 뭘 해야 되느냐? 다시 구글에 가서 여기 가서 이건 뭐로 검색하면 되냐면 구글 프로토버프 C++ 라이브러리 다운받고 싶다라고 구글에 치면 첫 번째 링크로 , 이렇게, GitHub가 뜹니다 구글에서 관리하고는 하는 거고 여기서 브랜치라는 걸 , 이렇게, 지금 24 브랜치스로 되어있는데 얘를 눌러서 살펴보면은 버전별로 우리가 다운받을 수가 있는데 저는 3.17 이 버전으로 다운로드를 받아보도록 할게요 그래서 여기 가가지고 들어간 다음에 여기서 코드를 눌러가지고 다운로드 집을 , 이렇게, 눌러보면은 , 자, 이런 식으로 이제 다운로드를 받게 됩니다 그 다음에 이걸 이제 압축을 풀어가지고 얘같은 경우에도 어딘가에다가 , 일단은, 넣어주시면 되는데 저같은 경우는 , 일단은, 바탕화면에 얘를 넣어놓고 진행을 해보도록 할게요 그래서 다운로드 받은 거를 압축 풀어가지고 지금 바탕화면에 보면은 이런 파일이, 이런 폴더가 있는데 굉장히 묘하게도 얘를 이제 빌드를 해야 된다고 했었는데 딱히 솔루션 파일이 없다는 걸 볼 수가 있습니다 그래서 얘는 당장 비주얼 스튜디오로 빌드를 할 순 없고 이 CMake라는 요 아이를 다운로드 받아가지고 빌드를 해야 됩니다 또 귀찮게 굴고 있는데 그래서 여기 가가지고 다시 구글에 가가지고 구글에다가 CMake라는 걸 찾아보면은 역시나 링크가 있을 것이고 여기 사이트에 들어온 다음에 다운로드에 들어오시면 됩니다 여기 다운로드 버튼을 눌러가지고 들어오면 되고요 , 자, 그 다음에 뭐 64 인스털로 저는 그냥 이걸로 깔았어요 얘를 , 일단은, 다운로드 받아가지고 그냥 설치 설치를 해서 , 일단은, 그냥 똑같이 넘어간 다음에 어 여러분들 컴퓨터에 CMake가 깔렸으면은 이제 걔를 열어주시면 됩니다 CMake , 자, 요렇게 해가지고 그냥 열어주시면 돼요 요 실행 파일을 찾으면 됩니다 요기 윈도우즈에 가가지고 이거는 뭐 말씀드릴 필요 없죠 그냥 이걸 그냥 추가하셔서 클릭해서 넘어오면 되구요 여기서 굉장히 친절하게 , 자, 소스 코드는 어디 있습니까 내가 어디다가 빌드를 해주면 될까요 라는 굉장히 친절한 메시지를 지금 , 이렇게, 어 메시지를 통해 가지고 안내문을 하고 있는데 말 그대로 아까 여러분들이 방금 다운로드 받은 그 폴더에 c메이크 폴더를 여기다가 넣어 주시면 됩니다 저 같은 경우는 지금 여기다가 넣어 놨어요 바탕화면에 요기 요기 해서 이 버전의 CMake라는 요 소스 코드를 입력을 해주시고요. 결과물은 이제 어디다가 만들어 드릴까요? 라고 하는데 이거는 뭐 역시나 바탕화면 어딘가에다가 만들어도 되고요. 아니면은 아까 폴더에 여기다가 만들어 주도록 할게요. 여기다가 우클릭 세 폴더, 솔루션이라고 해가지고 세 폴더를 , 이렇게, 만들어 준 다음에 그 경로를 떠넘겨 주도록 합시다 여기서 마지막만, 아이고 CMake가 아니라 솔루션이라는 데다가 결과물을 만들어 주라고 , 일단은, 이렇게, 만들어 주도록 할게요 그 다음에 Generate 버튼을 딱 눌러주면 되는데 여기서도 이제 버전을 골라주는데 저는 비주얼 스튜디오 2019를 사용하고 있기 때문에 얘로 일단 설정해주고 그 다음에 Finish를 눌러가지고 , 일단은, 실행을 막 해보도록 하겠습니다. 근데 일단 첫번째에서 실행을 할 때 뭔가 , 이렇게, 에러가 날 겁니다. , 이렇게, 에러가 나는데 큰 문제는 아니고 이걸 이제 다시 한번 바꿔줄 건데 테스트랑 나머지 애들은 다 꺼주고 프로토 C 바이너리랑 셰어드 립스 두 개만 , 일단은, 켜도록 할게요 이 프로토 C 바이너리는 참고로 아까 다운받은 그 프로토 컴파일러를 의미하는데 , 이렇게, 소스코드로 다운받아 가지고 걔를 만들어 줄 수도 있다는 걸 일단 그냥 실습을 하려고 만들어 준 거고 얘가 , 일단은, 당장 우리가 진짜 필요한 그 라이브러리 파일을 만들어 주게 될 겁니다 그래서 얘네 두개를 설정한 상태에서 다시 Generate를 빡 눌러주면은 아무런 문제 없이 , 일단은, 실행이 될 것이구요 , 자, 그 다음에 다시 이제 얘는 다 썼으니까 그냥 꺼도 되구요 솔루션에 가보면은 , 자, 이제는 굉장히 신기하게도 이 Protobuf 라는 SLN 이라고 해가지고 Visual Studio 솔루션 파일이 만들어져 있는 걸 볼 수 있구요 이걸 그냥 더블 클릭 해가지고 잠시 기다리면은 Visual Studio가 켜지면서 이제 이거를 우리가 직접 빌드할 수 있게끔 됩니다. , 자, 이거 좀 실행하는데 뭐 시간이 좀 걸릴 수 있는데 아이고 저는 지금 왼쪽에 다른 곳에 가가지고 얘를 , 일단은, 끄집어내자면은 지금 요런 화면이 있습니다. , 자, 그래가지고 이걸 디버그로 한번 릴리스로 한번 똑같이 그냥 실행을 하면 됩니다. 지금 올 빌드로 되어있는데 그냥 냅두고 솔루션 다시 빌드를 그냥 전체 빌드를 팡 때려보도록 할게요. 그래서 기다리면 이제 실행이 될 것이고 요 마찬가지 작업을 이제 얘가 다 끝나면은 릴리스로도 똑같이 해주면 되겠습니다 그래가지고 일단 라이브러리 파일을 먼저 만들어가지고 추출한 다음에 그거를 다시 우리가 작업하고 있는 서버 쪽에다가 갖고 와가지고 라이브러리 파일을 , 일단은, 작업을 하면 돼요 , 자, 근데 이게 좀 오래 걸리는 것 같으니까 잠시 강의를 끊고 이거 디버그랑 릴리스 각각 하고 넘어오시면 되겠습니다 라고 하는데 벌써 끝났네요 그냥 릴리즈도 요렇게 해서 다시 한번 빌드를 하고 기다리도록 하겠습니다 , 자, 그래서 완료가 되었으면 프로토 버프는 더이상 필요 없으니까 얘는 그냥 끄셔도 되고요 그러면 아까 우리가 깔아준 이 솔루션에서 디버그랑 릴리스라는 폴더가 만들어지게 될 겁니다 , 자, 그래서 , 일단은, 디버그에 들어가 보면 결과물이 , 이렇게, 들어가 있는데 굉장히 반가운 애가 보이죠? 그래서 이런 식으로 코드로 빌드할 수 있다라는 걸 볼 수 있었는데 지금 당장 우리한테 필요한 거는 이 아이가 아니고요 여기 lib-protobuf-d, 디버그의 약자인 d가 붙은 이 시리즈들을 , 일단은, 갖고 와야 됩니다. 여기 5개가 있는데 Ctrl-C로 복붙한 다음에 우리의 libraries-libs-protobuf-sana의 디버그에다가 , 일단은, 다 갖다 놓도록 할게요. 마찬가지로 솔루션에서 릴리즈 쪽에 가보면 얘도 마찬가지로 파일 개수는 좀 적긴 한데 , 이렇게, 3개가 있을 겁니다. 3개를 복붙해가지고 프로토버프의 릴리즈에다가 , 일단은, 갖다 놓고 시작을 하도록 할게요. 근데 뭐 참고로 말씀드리면은 이 LIB랑 DLL은 꼭 있어야 되는데 이 EXP는 필요 없는 거예요 그래서 그냥 얘는 그냥 날려도 되고요 마찬가지로 디버그에서도 EXP랑 ILK는 뭔지 모르겠는데 그냥 삭제를 해주셔도 되니까 상관없고 얘네들은 그냥 남겨주시면 되겠습니다 , 사실, 이 PDB도 필요 없는데 얘는 좀 옵션이긴 하니까 그냥 냅두도록 할게요 얘는 혹시라도 여기서 뭐 크래쉬가 날 때 뭐 크래쉬 덤프를 남기는 뭐 그럴 때 이제 유용한데 이거는 일단 냅두도록 하고 DLL이랑 LIB는 꼭 있어야 되니까 얘는 , 일단은, 그냥 냅두도록 하겠습니다 , 자, 이렇게, 해가지고 디버그랑 릴리스 쪽에다가 우리의 프로토버프 라이브러리를 , 일단은, 여기 저장한 상태구요 그 다음에 하나가 빠졌죠 여기 인클로드 쪽에서 프로토버프와 관련된 소스 코드를 여기다가 , 일단은, 다 복붙을 해야 됩니다 그래서 얘 같은 경우에는 어디 있냐면은 아까 우리가 설치를 한 이 폴더 위치에 가보면은 여기서 프로토버프에서 쭉 내리다보면 src 소스라는 폴더가 있어요 그래서 여기 가보면 구글이라는 폴더가 있는데 여기 안에다가 다 프로토버프가 들어가 있습니다 그래서 무조건 이 밖에 있는 구글을 그대로 긁어가지고 이거를 여기 인크루드 쪽에다가 , 이렇게, 넣어 주시면 되겠습니다 그리고 이왕이면 이름도 안 바꾸고 그냥 냅두기를 추천드려요. 왜냐하면 아까 내부적인 라이브러리에서 구글 모시기 모시기 이 경로를 이용해서 구글 프로토버프의 어디어디를 찾는 식으로 구현이 되어 있기 때문에 그냥 , 이렇게, 냅두시면 되겠습니다. 굉장히 힘들었는데 그래서 다시 서버로 돌아가보면 아까 우리가 처음에 계속 에러가 났던 이런 파일들이 구글의 프로토버프에 모시기 모시기로 지금 찾고 있다는 걸 볼 수가 있는데 이제는 정상적으로 만약에 다 로드가 되었다고 하면 이제 이 문제가 해결이 되겠습니다 , 일단은, 서버를 먼저 다시 빌드를 하고 여기서 문제가 있으면 이어서 한번 실행을 해보도록 할게요 , 자, 일단은, 지금 몇가지 에러가 나고 있는데 설정이 제대로 됐는지를 한번 살펴 봅시다 여기서 서버 코어 인클루드에 있다고 우리가 알려주고 있었구요 라이브러리즈에 인클루드에다가 갖다 놨으면은 괜찮을 것이고 오케이 , 자, 그 다음에 PCH에 돌아가가지고 요 부분을 , 일단은, 처리를 안해놨죠 , 자, 이제는 아까랑 좀 에러가 달라지는게 링크 에러가 뜰거에요 이건 굉장히 좋은 신호입니다 링크 에러는 여기 있는 include 자체는 찾았는데 실질적으로 라이브러리 파일 자체가 연결이 안되어있는 거라서 지금 요 부분이 빠진 겁니다 그래서 Ctrl-D, Ctrl-B 두 번 복사해가지고 여기서 경로를 이제 입력을 해주면 되는데 lips 폴더 안에 protobuf 라는 안에다가 debug 산하에 lib.protobuf.d 라는 파일이 있을 것인데 얘를 찾아 달라고 하면 되겠죠 이 라이브러리를 니가 사용해라 그래서 같이 링크를 해주면 될 것이고 여기도 마찬가지로 protobuf 산하에 release 산하에 lib.protobuf 입니다 여기 얘는 d가 없어요 참고로 디버그의 약자에서 d가 붙은건데 얘는 없습니다 그래서 얘를 다시 , 이렇게, 두개를 붙여준 다음에 게임 서버를 다시 한번 빌드를 하면은 아까 일어났었던 링크 에러가 사라지면서 감동적으로 얘가 성공을 하는걸 볼 수가 있어요 그럼 이거를 똑같이 긁어가지고 위에다가도 얘도 똑같이 , 이렇게, 만들어 줘 가지고 더미 클라이언트도 똑같이 다시 한번 빌드를 해서 통과를 시켜 보도록 할게요 , 자, 여기까지 왔으면 이제 진짜로 프로토 버프 연동이 끝난 거구요 이제는 진짜로 아까 우리가 만들었던 요 프로토콜 이라는 애를 이제 사용할 준비가 된 겁니다 이 밑줄이 그어져 있는 거는 아마 다시 닫고 다시 비쥬얼 스튜디오를 열면 아마 날아갈 거에요 , 자, 그래서 , 일단은, 에러가 없으니까 이제 이어가지고 이거를 사용할 수가 있게 되었으니까 작업을 해보자면 일단 보내는 쪽부터 작업을 간단하게 해보도록 하겠습니다. 서버 패킷 핸들러에서 우리가 뭐 이것저것 작업하고 있었는데 이제 패킷 이터레이터랑 패킷 리스트는 사용 안 할 것이니까 다 날려 보도록 할 거고 그 다음에 프레그마 팩 아래 요런 저런 테스트 코드 우리가 열심히 공부할 때 사용한 코드도 필요 없으니까 다 날려 줄 것입니다. 굉장히 깔끔해졌네요 , 자, 그러면 이제 오늘 드디어 추가할 오늘 실습할 것은 뭐냐면 어디 있었나요 여기 게임 서버 쪽에서 이 부분에서 이 부분을 또 삭제를 한 다음에 똑같은 느낌으로 프로토 버프를 사용해 가지고 이제 만들어 보도록 할 건데 먼저 프로토콜 헤더 파일을 여기 위에다가 일단 추가하고 시작을 하도록 하겠습니다 프로토콜 pbh 그 다음에 이 파일을 살짝 옆보면은 다시 끄고 싶을 정도로 굉장히 뭔가 심오하게 , 이렇게, 만들어져 있다는 걸 볼 수가 있는데 자동 완성된 코드들이 , 이렇게, 들어갔다라는 걸 볼 수가 있습니다 그래서 이제 이거를 사용할 것이다 굉장히 복잡한 코드가 들어있고 근데 은근히 사용하는 거는 간단한데 지난번에도 말씀을 드렸지만 프로토버프는 그냥 임시 객체를 만든 다음에 걔를 채우고 그 임시 객체를 통해가지고 걔를 그냥 시리얼라이서를 빵 때려주면 된다고 했었죠 , 자, 그러니까 프로토콜 산하의 stest라는 요 구조체의 패킷을 만들어 볼게요 아까 여기 우리가 프로토콜 OO으로 붙여준 어... 아까 우리가 붙여줬었죠 프로토버프 파일에서 맨 처음에 이 네임 스페이스를 프로토콜로 설정해줬기 때문에 지금 얘가 일단 붙은 거고요 , 자, 그 다음에 얘를 이제 어쨌든 이 구조체를 채워주면 되는데 처음에 이거를 실습할 때는 너무 복잡하게 생각하지 마시고 그냥 점을 찍어 보면서 하나씩 그냥 읽어 보세요 어떤 기능이 있는지 어 뭐 이런 기능이 있구나 그러면은 당연히 얘지만 얘가 그냥 스트럭트라고 생각을 하면은 우리가 기본적으로 아이디를 채우는 것도 만들어 줬고 줄 테고 이 프로토 파일을 다시 한번 기준으로 생각해 보면 패키지 프로토콜로 붙였기 때문에 지금 프로토콜 땡땡이 붙은 건 알았는데 이제 이 s 테스트라는 걸 채울 때 id, hp, attack 그리고 버프가 리스트 형태로 들어가 있다 보니까 패키지.id를 찍어 가지고 요 기능과 관련된 애들을 살펴보면 됩니다 그래서 이 아이디는 딱 봐도 진짜로 그냥 아이디를 꺼내 쓰는 것 같고 아까 내려 보면은 set 아이디라는 게 있죠? 그래서 세팅할 때는 다 이 set 기능을 이용해가지고 만들어주면 된다는 걸 이제 알 수가 있습니다. 그래서 , 이렇게, 문서를 보기도 전에 그냥 한 번씩 때려 맞춰가지고 작업을 해보시면 굉장히 많은 도움이 돼요. 그래서 얘는 100, packet, set, attack은 10. 요 코드까지는 , 일단은, 만들어졌고 그 다음에 이제 궁금한 거 리피티드라는 거는 사실상 가벼운 길이였었죠 이게 사실상 뭐 벡터 같은 것처럼 여러 개의 데이터가 들어갈 수 있는 건데 얘도 마찬가지로 버프와 관련된 기능이 어떻게 만들어지는지 궁금한데 어 딱 봐도 버프 사이즈는 지금 그니까 벡터를 치면은 벡터의 사이즈가 몇 개인지를 나타내는 것일 거고 애드 버프라는 또 굉장히 재밌는 애가 있는데 add 버프 인자를 살펴보면은 인자는 딱히 안 받고 있지만 포인터를 뱉어 준다는 걸 볼 수가 있습니다 어 이거 예전에 우리가 작업했던 거랑 굉장히 비슷하죠? add 버프를 한 다음에 포인터를 이용해가지고 그 포인터에다가 저 데이터를 넣어주면 되겠구나 얘는 그냥 할당하는 거고 할당한 데이터를 우리가 다시 뭐 이런 식으로 받아가지고 작업을 하라라는 의미로 받아줄 수가 있는 거죠 근데 이 auto는 프로토콜의 버프 데이터의 포인터로 , 일단은, 이렇게, 만들어져 있을 겁니다. 얘를 데이터라고 할까요? , 자, 그래서 여기부터는 다시 버프 데이터를 채우는 부분이다 보니까 뭐 그냥 간단하게 데이터에 화살표를 당겨가지고 보면은 setBuffId가 당연히 있을 것이고 이런 식으로 그냥 데이터를 하나씩 채워주시면 되겠습니다. remain time도 1.2f 그 다음에 빅팀 같은 경우에는 리피티드이다 보니까 얘도 이제 똑같이 add 모시기가 있을 것 같은데 얘 같은 경우에는 이 위에는 다르게 위에서는 얘가 struct 타입의 리피티드이다 보니까 얘를 다시 , 이렇게, 뱉어 줘 가지고 태워 주라고 했지만 얘는 그냥 유인트 64다 보니까 막바로 여기다가 넣어 줄 수 있게 되었다는 것도 알 수가 있습니다 뭐 요런 식이죠 , 자, 그래서 이거를 그냥 두개를 일단 영역을 만들어가지고 요렇게 두개를 만들것이고 얘는 필요없으니까 삭제하고 그 다음에 뭐 얘는 200 2.5F 그 다음에 빅팀을 뭐 천번 이천번 두개를 , 이렇게, 넣어서 테스트를 해보도록 할게요 그냥 , 이렇게, 하면은 결국에 우리가 임시 객체를 만들어가지고 거기다가 데이터를 넣어준 셈이 되는 겁니다. 근데 하나 여기서 굉장히 재미있는 사실은 우리가 임시 객체를 만들어서 넣어줘도 되긴 하지만 이 임시 객체를 꼭 임시로만 사용할 필요는 없습니다. 그러니까 앞으로 우리가 그냥 서버 코드에서 요 아이를 뭐 세션의 멤버 변수로 들고 있다거나 하는 식으로 만들어도 된다는 얘기가 되는 거죠 네 그래가지고 뭐 이것도 나중에 이제 결국엔 컨텐츠랑 굉장히 연관성이 밀척해지는 그런 부분이라고 볼 수가 있겠습니다 근데 기본적으로 좀 뜬금없이 데이터를 채워서 보내고 싶을 때는 , 이렇게, 임시 객체를 만들어줘서 그냥 , 이렇게, 채워주시면 돼요 , 자, 그리고 또 하나 궁금한 거는 데이터 추가하는 방법이 진짜 이런 방법밖에 없을까 예를 들면 우리가 벡터에다가 뭐 이런저런 값들이 있는 상태에서 이 벡터 있는 값을 여기다가 뭔가 복사하고 싶다거나 하는 상태가 상황이 생길 수도 있는데 매번 마다 add 버프로 , 이렇게, 할당해서 만들어야 되느냐 라고 하면은 , 사실, 추가하는 방법이 여러 가지가 있다는 걸 볼 수가 있어요 이 버프랑 관련된 애를 찾아보면은 Mutable 버프라는 애가 , 이렇게, 들어가 있다는 걸 볼 수가 있습니다 얘는 뭐하는 일인지 굉장히 궁금한데 , 자, 여기 M을 한번 찍어보면은 M에다가 화살표를 당겨보면은 add, clear, get, mutable 막 굉장히 많은 기능들이 있다는 걸 볼 수 있고 심지어 add를 하나를 실행해봐도 그냥 추가하는 애가 있고 추가할 때 iterator-begin-end 즉, 범위를 줘가지고 이 안에 있는 애들을 싹으리 추가하는 경우도 있고 굉장히 다양하게 존재한다는 걸 알 수가 있습니다. 그래서 만약에 다른 이터레이터 타입의 데이터에서 얘를 채워주고 싶다고 하면은 이 방식을 이용하면 된다는 얘기가 되는 거죠. 그래서 뭐 데이터 하나씩 추가할 때는 그냥 add 모시기를 사용하되 뭐 이런 다른 기능들도 있다 나중에 이런 것도 한번 테스트를 해보면 좋을 것 같은데 , 일단은, 지금은 그냥 간단하게 넘어가 보도록 할게요 처음이다 보니까 제가 간단하게 하나 추가하고 설정하고 추가하고 설정하는 식으로 일단 만들어 봤어요 그럼 여기까지 일단 했으면은 우리의 그 객체가 완성이 된 거니까 이거를 다시 버퍼에다가 밀어 넣어주면 되겠죠 그럼 이제 그건 또 어떻게 해야 되느냐 pk점을 찍어 보면은 pkt점을 찍어 보면은 이제 뭐 앞에다가 아래다가 쭉 내려 보다 보면은 당연히 버퍼에다가 얘를 밀어 넣는 그런 기능들도 있을 것이고 거꾸로 버퍼 있는 내용을 꺼내 가지고 얘를 채우는 그런 거꾸로의 기능도 당연히 들어가 있을 겁니다 Merge from 뭐 이런 기능도 있고 Pass from 딱 얘도 뭔가 있어 보이죠 뭐 파싱을 해라 어떤 배열에서 파싱해서 얘를 채워줘라라는 부분도 있고 Serialize 와우 이것도 굉장히 재밌죠 딱 이 버전을 쓰면 좋을 것 같네요 이게 문서를 안 봐도 배열에다가 Serialize 해 줘 가지고 넣어 줘라라는 설명 자체가 우리가 뭘 해야 될지 너무 친절하게 설명해 주고 있는 것 같습니다 그래서 요 버전을 이제 활용하면 될 것 같다는 생각이 드네요 , 자, 근데 나중에 가면은 뭐 여러개가 이런 패킷이 한두개만 있는게 아니라 여러개가 생길 수 있으니까 이거를 최대한 좀 이쁘게 만들어 보기 위해서 서버 패킷 핸들러 쪽에 , 일단은, 돌아가가지고 여기다가 어... 좀 비슷한 기능을 한번 모아서 만들어 보도록 합시다. 뱉어줄거는 샌드 버퍼 레퍼런스를 뱉어줄것인데 메이크 샌드 버퍼라고 해가지고 뭐 지금은 당장은 프로토콜에 s 테스트를 Packet 이라는 거로 받아가지고 뭔가 , 이렇게, 만들어보는 시도를 한번 해보도록 할게요 그 다음에 여기서 위에서 include protocol pbh 는 추가를 해줘야 되겠죠 , 자, 그러면은 지금까지 우리가 항상 하던 걸 어떻게 했는지 생각해 보면 우선 데이터의 크기는 얼마이냐를 찾아봐야 되는데 여기 Byte Size랑 Byte Size Long이 있습니다 어 딱 봐도 얘가 바이트로 한산하면 얼마입니까? 라는 의미 같은데 얘를 일단 사용해 보도록 할게요 얘를 사용한 이유는 바이트 사이즈를 활용하면은 이게 좀 구식 버전인지 이 아이를 사용하라고 에러메시지가 뜨더라구요 그래서 그냥 한방에 이걸로 일단 사용해 보도록 하고 얘가 딱 봐도 데이터의 크기라는 걸 일단 알 수가 있어요. 근데 우리는 이제 최대 크기가 유인트 16이니까 얘를 , 일단은, 유인트 16으로 캐스팅을 해보도록 하겠습니다. 나중에 가면 이거 혹시 뭐 너무 초과하지 않는지 예외 체크를 해주면 되겠죠? 그래서 유인트 16으로 캐스팅을 해주고 근데 여기서 이 데이터만 막바로 집어넣으면 되는 게 아니라 우리가 항상 패킷 헤더를 만들어가지고 4바이트에다가 크기랑 이 패킷의 크기랑 그리고 이 프로토콜 아이디를 같이 넣어 줬었죠 그러니까 여기다가 추가적으로 패킷 사이즈를 개선할 때는 데이터 사이즈에다가 사이즈 오브 패킷 헤더를 더해가지고 , 일단은, 개선해 주면 되겠습니다 이게 양쪽에 사이즈 두 개가 개선이 되었고 그러면 , 일단은, 먼저 샌드 버퍼를 추출해 보도록 할게요 샌드 버퍼 매니저에서 오픈을 할 건데 이전에는 그냥 큰 사이즈를 먼저 할당한 다음에 그 내용을 빡 채워가지고 클로즈를 하는 식으로 작업을 했는데 이 방식에서는 애정초 우리가 패킷 사이즈가 얼마인지를 미리 계산할 수 있죠 그래서 굳이 낭비하지 않고 바로 그 크기만큼을 일단 오픈할 수 있다는 얘기가 되는 겁니다 그리고 나중에 끝날 때는 클로즈를 해주는데 얘도 패킷 사이즈 만큼을 사용할 거라는 걸 아니까 클로즈 해주고 리턴 샌드 퍼퍼를 샌드 버퍼를 요런 식으로 해줘가지고 버퍼를 만들어주면 되겠죠 그 다음에 이제 내용을 채워야 되는데 뭐 굳이 버퍼 라이터까지 갈 필요도 없을 것 같고 네 이거는 굉장히 간단하니까 그냥 , 이렇게, 만들어 보도록 할게요 패킷 헤더로 첫 주소를 캐스팅해 보도록 합시다 패킷 헤더 타입으로 , 일단은, 얘를 인지하게 눈속임을 해주고 샌드 버퍼의 시작 버퍼를 일단 갖고 와가지고 그 주소에다가 헤더의 사이즈는 패킷 사이즈 그리고 헤더의 아이디는 패킷 아이디 이거 패킷 아이디인데 아직 받아보지 않았네요? 이 패킷 아이디는 뭐 여기서 받아보도록 합시다 유인트 16 패킷 아이디라고 해가지고 그래서 이 아이디를 요렇게 넣어주면 되겠습니다 그 다음에 이어가지고 헤더가 완성이 되었으면은 그 다음 사바이트에다가 우리가 그냥 이 패킷을 serialize 해줘가지고 넣어주면 됐었죠 serialize to array라는게 있었으니까 얘를 찾아보다 보면은 요 버전으로 만들어 보도록 할게요 그럼 여기다가 일단 주소를 입력을 해줘야 되는데 이 시작 주소를 기준으로 4바이트를 건너뛴 거니까 딱 패킷 헤더만큼을 건너뛰면 되겠죠 그러니까 사실상 요런 느낌이 되겠습니다 헤더의 1번으로 접근하면 애당초 얘가 4바이트니까 정확히 우리가 원하는 데이터의 시작 위치가 딱 나오겠죠 여기다가 데이터 사이즈만큼을 넣어줘라 라고 , 이렇게, 요청을 하면 될 것 같습니다 그 다음에 얘가 성공했는지를 불리언으로 리턴하는데 나중에 가면은 이걸 뭐 체크하면 되겠지만 지금은 그냥 억세트 크래쉬로 잘 진행이 되고 있는지만 체크를 해보도록 하겠습니다 그래서 정말로 , 이렇게, 만들어 주게 되면은 버퍼를 열어주고 헤더 채워준 다음에 데이터를 밀어넣고 닫아주고 라는 부분이 정상적으로 완료가 된다고 보시면 되겠어요. 근데 패키지 한두개가 있는게 아니니까 얘는 이제 거의 공용적인 코드가 되겠죠. 그러다보니까 이거를 템플릿으로 요렇게 만들어주도록 할게요. 타임네임 T 그리고 요 부분까지를 T로 , 이렇게, 바꿔치기 해준 다음에 지금 우리가 만들고 있는 것은 static sandbuffer ref 라고 하고 make sandbuffer 라고 한 다음에 프로토콜의 s 테스트 패킷을 받아주는 버전을 하나를 따로 , 이렇게, 파주도록 하겠습니다 그래서 이 구현부를 만들어줄 때는 얘를 그대로 호출해주면 되겠죠? 이름이 좀 같으니까 얘는 내부적으로만 활용한다는 의미로 언더바를 붙여준 다음에 여기다가 그냥 return makeSandBuffer를 , 이렇게, 호출해준 다음에 패킷은 그대로 넘겨주고 요 프로토콜 아이디는 몇번이었네요? 1번이었죠? stest가 1번이니까 요렇게 만들어 달라고 , 일단은, 요청하면 되겠네요 그럼 나중에 패킷이 늘어날 때마다 요런 코드를 반복해서 만들기보다는 이것도 뭔가 자동화된 툴을 만들어가지고 요런 부분만 쭉 추출할 수 있게끔 만들어주면 일단 좋을 것 같다는 생각이 드네요 최대한 반복적인 그런 부분은 툴로 처리하는게 훨씬 좋습니다 , 일단은, 패킷 처리를 이런식으로 해가지고 결국에는 아까 돌고 돌아와가지고 게임 서버 쪽에서 실질적으로 , 이렇게, 인자들을 다 넣어 줘가지고 임시 객체를 만들어 줬으면 이제 서버 패킷 핸들러의 메이크 샌드 버퍼를 호출해가지고 이 해당 패킷에 대한 샌드 버퍼를 만들어 달라 라고 하면 되겠죠 샌드 버퍼 랩프를 뱉어줄텐데 샌드 버퍼 아이고 날렸네요 서버 패킷 핸들러의 메이크 샌드 버퍼를 호출한 다음에 요 내용이 채워진 걸 그대로 브로드 캐스팅을 해주면 되겠습니다 뭐 브로드 캐스팅을 해줘도 되고 특정 유저한테만 보내줘도 되고 이건 이제 컨텐츠 쪽에서 알아서 해야 된다는 얘기가 되는 거죠 그래서 , 이렇게, 객체를 채워주고 객체를 버퍼로 만들어주고 버퍼를 보내주는 요런 형식으로 만들어주면 이제 기존과 마찬가지로 코드가 굉장히 잘 돌아가게 될 거예요 , 자, 여기 게임 서버 , 일단은, 한번 빌드를 해보도록 할게요 별다른 문제가 없는지 빌드를 한번 해보도록 하고 , 자, 문제가 , 일단은, 없었으니까 통과가 잘 된 것 같네요 그러면 거꾸로 클라이언트 패킷 핸들러 쪽으로 이제 돌아가 가지고 얘도 이제 좀 처리를 해보도록 합시다 이제 pdl.xml은 사용 안 할 거니까 연구 제거를 하기 위해서 삭제를 , 일단은, 때려 주도록 할 것이고 , 자, 그 다음에 Packet Iterator, Packet List , 자, 재미있게 실습을 했으니까 날려 보도록 할게요 그러면은 결국 handle-as-test라는 요 부분으로 들어오는데 여기서 위에서 우리가 작업하던 요 임시 코드들을 다 날려 주도록 할 것이고 코드가 대충 , 이렇게, 정리가 될 것 같습니다 그리고 버퍼리더도 다 날려주고 여기서 , 일단은, 시작을 해보도록 합시다 , 자, 그래가지고 어 , 일단은, 여기서 s-test라는 1번이라는 아이디를 체크해가지고 넘겨온 상태까지는 , 일단은, 지금 구현이 되었구요 , 자, 그 다음에 여기서 거꾸로 프로토콜의 s-test 형태로 이 패킷을 다시 이제 추출하면 되겠습니다 이 객체를 이제 거꾸로 다시 만들어주는거에요 얘를 만들어줘서 serialize 해서 넘겨줬으니까 이제는 거꾸로 deserialize를 해줘가지고 얘를 채워주면 되겠죠 근데 지금 에러가 나는거는 음... 여기 프로토... 프로토콜에 PBH를 추가를 안해서 그런 것 같구요 , 자, 얘가 , 일단은, 추가가 될 것 같고 안되나요? , 자, 이건 그냥 에러 어 비주얼 시디어 에러 같은데 빌드에서 통과 되는지 볼게요 , 자, S 아 대문자죠 S 테스트 대문자여서 그런 거였네요 , 자, 그 다음에 이제 이어가지고 뭘 해볼까 하다가 PKT에서 path from array 라는게 있었죠 아까 얘는 딱 봐도 뭔가 array 즉 어떤 바인트 배열에서 데이터를 추출해가지고 얘를 만들어 달라 라는 의미로 보입니다 근데 여기서 버퍼에다가 header 4바이트는 건너뛰고 나머지의 데이터가 있을 거니까 건너뛰어가지고 패킷 헤더만큼을 건너뛰어서 데이터가 있을것이니까 , 이렇게, 계산을 해줄것이고 렌스는 거꾸로 여기서 사이즈오브 패킷 헤더만큼을 빼줘야 되겠죠 그러면 데이터가 있을테니까 얘가 뿅 채워지게 될겁니다 근데 실패하는지 여부는 불리언으로 , 이렇게, 뱉어주고 있는것 같으니까 어서트 크래쉬를 한번 때려서 안전하게 잘 되고 있는지를 볼건데 나중에 가면은 진짜로 이제 뭐 서로 클라 해킹 등을 위해가지고 얘가 잘못된 패킷이 올수도 있으니까 이건 나중에 뭐 체크를 해보면 되겠죠 근데 지금 , 일단은, 요렇게만 하면은 뭐 더러운 코드가 필요 없이 그냥 여기 있는 내용이 알아서 잘 채워지게 될 겁니다. 그럼 이제 진짜 잘 채워졌는지 테스트하기 위해서 패킷 아이디랑 그리고 하나씩 출력을 해보도록 하겠습니다. HP도 출력을 해보고 그 다음에 패킷의 어택, 공격력도 출력을 해보도록 할게요. , 자, 그 다음에 버프 사이즈가 몇 개인지 간단하게 로그로 찍어보도록 할게요. 패킷에 버프 사이즈 요 아이겟네요 딱 봐도 , 이렇게, 만들어 볼 것이고 그 다음에 이제 하나씩 순회를 할 건데 버프를 순회하는 방법도 당연히 여러가지 있겠지만 이런식으로 어 레인지4 문법도 당연히 지원할 것 같으니까 한번 , 이렇게, 한번 해보도록 하겠습니다 그럼 버프를 하나씩 돈데 리피티드 PTR 필드라는 거가 아무런 문제 없이 얘를 지원한다는 걸 볼 수가 있고요. 그럼 이 상태에서 버프 인포는 무엇 무엇인지 또 출력을 해보도록 하겠습니다. 버프의 버프 아이디 출력을 해보고 한 칸 띄고 버프의 리메인 타임도 출력을 해보고 이런 식으로 모든 데이터들이 정상적으로 잘 들어가 있는지를 확인하고 마치도록 할게요. 그 다음에 피해자들 목록을 또 추출해봅시다. 먼저 빅팀스 언더바 사이즈, 빅팀 사이즈가 몇 명인지 보고 그 다음에 해당하는 빅팀스를 하나씩 출력을 해보도록 할게요. 얘 같은 경우에는 인트 6사이다 보니까 그냥 막바로 사용하면 되겠네요. 이런 식으로 한 칸 띄도록 할게요. 그 다음에 여기서 엔드 라인을 쳐보도록 합시다. 아 그래서 더미 클라이언트도 빌드해가지고 별다른 문제가 없다고 하면은 이제 이쪽 부분에서 아까 우리가 보내준 부분이 정상적으로 처리가 되겠죠 , 자, 근데 요 상태에서 지금 실행을 하면은 이런식으로 립 프로토 퍼프 D DLL이 없어서 코드를 실행할 수 없다고 두번 연속해서 에러가 뜨고 있는데요 , 자, 이건 왜 그런거냐면은 아까 우리가 , 자, 여기서 보면은 라이브러리 경로 립스 프로토 퍼프 디버그에다가 , 이렇게, 다 코드를 옮겨놨습니다. 그러니까 라이브러리를 옮겨놨는데 이 lib라는 경우 같은 경우는 스태틱 라이브러리여 가지고 우리가 코드를 빌드를 할 때 그 우리의 바이너리에 얘가 포함이 되어 가지고 같이 코드가 나가게 됩니다. 그래서 사실상 이 라이브러리에 있는 내용이 우리의 실행 파일에 묶여서 나간다는 얘기가 되는 건데 근데 이 DLL 같은 경우에는 그게 아니기 때문에 이 DLL은 별도로 우리의 실행 파일이 실행되는 경로에다가 같이 얘를 그냥 갖다 놔야 됩니다. 즉, 얘를 복붙, Ctrl-C로 , 일단은, 복붙해가지고 뒤에 간 다음에 Binary Debug 쪽에 얘가 이제 우리의 실행 파일이 될 거니까 여기다가 , 일단은, 얘를 같이 붙여놔야 된다는 얘기가 되는 거죠. 그래서 실제적으로 나중에 배포할 때도 이게 사실상 우리의 서버가 될 것인데 얘랑 얘랑 같이 이제 옮겨다니면서 세트로 붙어 다녀야 된다는 얘기가 되겠습니다. 이 DLL이 꼭 필요하다는 얘기가 되는거죠. 얘를 실행시키기 위해서. 마찬가지로 디버그 말고 릴리즈도 마찬가지로 이 DLL을 똑같이 복붙한 다음에 우리의 실행 경로를 다시 찾아가지고 바이너리 릴리즈 산하에 여기다가 , 일단은, 넣어주시면 되겠습니다. , 자, 이걸 넣어주고 다시 똑같이 실행을 해보면 이제는 문제없이 코드가 막 실행이 되면서 우리가 아까 넣어준 데이터가 그대로 잘 들어가 있다는 것도 , 이렇게, 확인을 할 수가 있어요 , 이렇게, 해가지고 프로토버프를 간단하게 활용을 해보는 첫 번째 연습을 해봤는데요 굉장히 장점이 많다는 걸 일단 알 수가 있습니다 워낙 많이 사용하는 그런 라이브러리다 보니까 안정성도 굉장히 뛰어날 것이고 그리고 굉장히 다양한 방법으로 데이터를 채우게끔 지원을 해준다는 걸 알 수가 있습니다 그리고 참고로 저는 이걸 C샵으로는 몇 번 해봤는데 C++로는 거의 뭐 해보지 않았음에도 불구하고 그냥 딱 인터페이스만 봐도 아 이런 기능이 있겠구나라는 게 벌써 예상이 가더라고요 그리고 실질적으로 우리 코드에 딱 맞춰서 붙일 때도 serialize 해주고 deserialize 해주고 막 그런 부분들이 굉장히 쉽게 처리가 되게끔 다 이미 구인이 되어 있다는 것도 어떻게 보면 굉장히 큰 장점이라고 볼 수가 있는 거고요 그리고 나중에 우리가 만약에 얼리얼 엔진이 아니라 유니티랑 서버 연동을 하고 싶다고 해도 비슷한 방식으로 C++이 아니라 C샵도 지원하기 때문에 얘를 이제 똑같이 C샵으로 생성해가지고 유니티 쪽에서 작업을 해서 우리한테 넘겨줄 수도 있을 겁니다 그래서 뭐 굉장히 많은 장점이 있다 그리고 심지어 또 장점을 하나를 더 나열해보자면 나중에 우리가 뭐 게임을 출시해가지고 성공해서 퍼블리셔 쪽에 어서 이제 우리 게임을 운영을 해줄 건데 퍼블리셔랑 만약에 우리가 뭐 이런저런 네트워크 통신을 해야 되는 경우가 생길 수도 있어요 예를 들면은 뭐 해당 계정을 받아와가지고 넥슨 PC방 가맹점이면 어떤 보너스를 주고 하는 그런 코드가 있을 수도 있겠죠 그런데 그런 경우에 우리가 자체적으로 만든 프로토콜을 사용하게 될 경우라면 서로 연동하는 게 굉장히 힘들 수가 있는데 프로토버프는 워낙 모든 회사들이 많이 사용하는 부분이다 보니까 만약에 프로토버프를 이용해서 프로토콜을 맞춘다고 하면 이런 부분도 협업하는 데 굉장히 큰 도움이 생기게 될 겁니다 너무 칭찬만 하는 거 같은데 어찌됐건 , 이렇게, 해가지고 굉장히 많은 장점이 있으니까 연습을 해보실 때는 , 이렇게, 사용하는 거를 적극적으로 추천을 드린다 정도로 마무리할 수 있을 것 같고 앞으로 우리가 코드를 작업할 때도 프로토버프를 이용해서 작업을 하게 될 겁니다 근데 여기서만 끝내면 살짝 아쉬운 점이 그럼에도 불구하고 우리가 지금 코드를 만들 때 보면은 패킷을 하나 만들 때마다 이런식으로 함수를 연동하는 부분을 , 이렇게, 손수 하나씩 만들어줘야 되겠죠 그거랑 여기 스위치 케이스로 지금 패킷을 읽는 부분도 패킷을 만들 때마다 우리가 지금 수동으로 여기에다가 함수를 만들어줘야 될 겁니다 지금 상태로라면은 그렇게 좀 아쉬운 분들이 몇 가지가 있기 때문에 다음 시간에서는 이 protobuf가 적용된 코드를 조금 더 이쁘게 세련되게 자동화 해가지고 너무 반복적인 그런 작업 없이 잘 사용할 수 있게끔 유도를 해 보도록 할게요 , 이렇게, 해서 오늘 강의를 마치도록 하겠습니다.