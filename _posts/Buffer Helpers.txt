자, 우리가 지난 시간까지 이런 식으로 이제 그래도 대부분의 네트워크 핵심 기능들은 , 일단은, 거의 다 완성을 했고요 이제 이어서 알아볼 내용은 실질적으로 이런 팩킷들을 주고 받는 여러가지 정책들에 대해서 알아보는 시간을 가져보도록 할 겁니다 소위 팩킷 직렬화와 관련된 부분을 오늘 본격적으로 시작할 건데 일단 샌드버퍼가 여기 네트워크 안에 안 들어가 있더라구요 네 제가 작업하다가 까먹은 것 같은데 요 부분 , 일단은, 놓도록 하고 , 자, 그리고 , 일단은, 뭐 프로토콜 그리고 패킷 관리에 대해서 알아볼 건데 사실은 이 네트워크 코어 같은 경우에는 한 번만 만들어 두면은 그 다음에는 거의 건드릴 일이 없게 될 겁니다 그리고 심지어 회사에서도 요런 네트워크 코어 관련된 부분들은 잘 아는 사람이 드물어요 실력이 떨어져서라기 보다는 이거는 진짜 한 번만 만든 다음에 그 다음에 프로젝트 사이에서 계속 돌려 쓰는 경우가 굉장히 많습니다 굳이 위험하게 버그 위험이 있는 그런 네트워크 코어를 새로 만들 이유는 별로 없다는 얘기가 되는 거죠 근데 정작 우리가 이제 컨텐츠 개발을 하게 되면은 대부분의 시간들을 윗단에서 소위 여기 게임 서버 윗단에서 계속 작업을 하게 될 텐데 이때 특히나 가장 중요한 부분이 이제 이 패킷을 어떻게 만들어주고 전송할 것인가가 가장 중요한 부분이 되겠습니다 그래서 요 부분에 관련해서도 굉장히 할 얘기가 많아요 그런데 뭐 나중에 가면 결국 구글 프로토 버프로 이거를 사용하는 실습을 해보긴 할 건데 그럼에도 불구하고 이거를 손수 우리가 관리하는 연습을 몇 번 해봐야 되는 이유는 이게 어떠한 옵션이 있고 각각의 장단점은 무엇인지 등을 어느정도 이해하고 그 다음에 구글 프로토버프를 사용하더라도 하는게 좋기 때문이죠 무작정 구글에서 만들었으니까 좋을 것 같다라고 그냥 프로토버프를 쓴다거나 유명하니까 쓰겠다라는 행동은 굉장히 무책임한 겁니다 , 자, 그래가지고 뭐 이런 Packet Serialize 방법에 대해서 알아보기 전에 , 일단은, 오늘은 그냥 간단하게 지난번에 작업을 하다가만 이 코드에 대해서 좀 언급을 해보자면 이게 지금 작업을 하는 게 상당히 귀찮다는 걸 알 수 있습니다. 버퍼를 꺼내 가지고 이 Byte 버퍼에다가 데이터를 밀어 넣는 작업이 굉장히 지저분하죠. 지금까지 우리가 사용한 바이트 수는 4라는 걸 손수 머리로 계산해가지고 여기다가 4를 입력해가지고 맵 카피를 해주고 클로즈 할 때도 지금까지 사용한 데이터가 얼마인지 등등을 , 이렇게, 수동으로 계산했는데 당연히 이런 식으로는 실수할 여지가 너무 높기 때문에 좋은 방법이 아닐 겁니다 , 자, 그래가지고 오늘은 간단하게 버퍼에다가 데이터를 쓰고 그리고 버퍼에서 데이터를 읽을 수 있는 어떻게 보면은 버퍼를 읽고 쓰는데 도움이 주는 그런 클래스를 만들어 볼 건데요 이름하여 버퍼 리더라는 이름으로 , 일단은, 리드할 때 사용할 클래스를 하나를 만들어 주고 그 다음에 마찬가지로 버퍼 라이터라고 해가지고 버퍼에다가 어떤 내용을 쓸 때 도움을 줄 클래스를 하나를 만들어 보도록 하겠습니다 요런 아이들은 이제 뭐 최종적으로 쓰일지는 약간 의문이 들기는 하는데 나중에 프로토 버퍼를 쓰면은 필요 없을 수도 있긴 하지만 그래도 , 일단은, 기본적으로 우리가 실습을 할 때 동안은 굉장히 유용하게 쓰일 겁니다 , 자, 그래서 뭐 , 이렇게, 일단은, 만들어 보도록 할게요 제가 늘 하는 짓거리를 일단 먼저 시작을 하고 버퍼 리더 , 자, 이렇게, 주석을 달고 시작을 해 보도록 합시다 , 자, 그럼 버퍼 리더는 C-Sharp 강의로 치면은 Array Segment라는 아이가 계속 등장했었는데 그 개념과 굉장히 유사하다고 보시면 돼요 C-Sharp을 강의를 안 보셨으면 상관없는 얘기지만 , 자, 그래가지고 여기서 일단 버퍼리드를 만들 건데 얘가 하는 역할은 결국에는 어떤 포인터랑 그리고 어떤 영역을 찝어가지고 관리를 해주는 역할을 맡게 될 겁니다 우리가 버퍼를 지금 사용할 때 윗단에서 그냥 포인터를 덩그러니 넘겨주고 그 다음에 사이즈도 같이 넘겨줘 가지고 이 샌드버퍼라는게 결국에는 어떤 시작 주소와 크기로 이루어진 개념이죠 그러다 보니까 그거를 조금 더 편하게 관리하기 위해서 이 버퍼리더를 사용할 것이고요 , 일단은, 시작 주소를 이 버퍼라는 이름으로 관리를 할 것이고 그 다음에 사이즈, 이 버퍼의 크기는 얼마입니까? 라는 걸 관리할 것이고 그 다음에 포지션이라고 해가지고 내가 지금 어디까지 읽었느냐를 , 이렇게, 관리를 삼총사로 관리를 하도록 할게요 , 자, 그러면은 뭐 생성자 그 다음에 생성자 두번째 생성자는 옵션들을 요렇게 버퍼와 사이즈와 그 다음에 마지막 인자는 옵션으로 포지션을 받아주는 거를 받아줄 것이고 혹시 모르니까 소멸제도 만들어 줄 것이고 그 다음에 버퍼는 무엇이냐 그냥 return 버퍼를 꺼내 쓰도록 , 자, 요렇게 만들어 줄 것이고 그 다음에 사이즈도 뱉어 주도록 합시다 그리고 리드 사이즈 지금까지 내가 얼마만큼의 데이터를 읽었느냐 , 사실, 이 포지션이라는게 약간 커서의 역할입니다 쭉 앞으로 가가지고 내가 어디까지 읽었는지를 지금 관리하게 될 것이고 얘는 그래서 그냥 포지션을 뱉어주면 되겠고 그 다음에 Free Size 라고 해가지고 아직까지 안 읽은 그 데이터가 얼마 있느냐를 Free Size 라는 이름으로 관리를 하도록 할게요 뭐 이름이 좀 이상하면 바꾸셔도 되구요 , 일단은, 요렇게 만들어 보도록 하겠습니다 그 다음에 음... 이제 여러가지 옵션을 만들어 줄 것인데 그 전에 생성자부터 , 일단은, 만들어 보도록 할게요 생성자 아휴 손이 아파서 그냥 마우스로 할게요 임플레멘테이션 임플레멘테이션 오케이 , 이렇게, 해서 생성자부터 , 이렇게, 만들어 놨고 그 다음에 까먹지 않고 , 자, 여기서 버퍼에다가 버퍼를 전달하고 사이즈에다가 사이즈를 전달하고 포지션에다가 포지션을 전달하고 서밀장에서는 아직 딱히 할 건 없으니까 요렇게 , 일단은, 냅두도록 하겠습니다 가장 먼저 우리가 작업할 것은 뭐냐면은 요 아이인데 버퍼 리더 참수를 뱉어줄 거고 오퍼레이터를 요렇게 오버로딩 해가지고 사용할 거예요 데스티니션 , 자, 요 아이가 이제 뭘 하는 거냐면은 우리가 어 Cout을 활용할 때 이런 식으로 데이터를 밀어넣는 짝대기 표시를 우리가 굉장히 편하게 사용을 했었는데 사실은 이런 것들도 다 오버로딩 대상입니다. Operator 오버로딩을 해가지고 이런 식으로 짝대기도 우리가 활용할 수 있게 되는 거예요. 그래서 이 버퍼 리더에다가 데이터를 꺼내서 쓰고 싶다 라고 하면은 예를 들면 이 화살표를 이용해 가지고 뭔가 진짜 데이터를 꺼내 쓰는 느낌으로 이제 표현을 하게 된다는 얘기가 되는 거죠 이거는 나중에 실습을 해볼 건데 , 일단은, 구현부부터 만들어 보도록 할게요 템플릿이다 보니까 여기 아래다가 만들어 줄 것이고 버퍼 리더 참조 값을 뱉어 줄 거고 버퍼 리더에 오퍼레이터 짝대기 t-destination , 자, 요렇게 만들어 주도록 하겠습니다 그래서 여기 해당 내용물을 지금 버퍼가 우리가 지금까지 읽은 위치에서 내용을 꺼내 가지고 그거를 요 데스티니션에다가 복사해서 전달해 준다는 얘기가 되는 거죠 그렇기 때문에 실질적으로 요런 식으로 현재 위치에서 reinterpret 캐스트를 해가지고 T타입의 포인터로 캐스팅한 다음에 그걸 다시 접근해서 데이터를 복사를 해주겠다라는 의미가 되는 거고 버퍼의 포지션 위치의 주속을 이용해 가지고 해당 위치를 T타입으로 인식을 시켜 가지고 데이터를 복사를 해 주겠습니다 뭐 , 이렇게, 일단 만들어 줄 수가 있을 거에요 그 다음에 포지션은 size of T를 추가를 해 준 다음에 return this를 때려 주도록 할게요 , 자, 여기 포지션을 더해 주는 거는 내가 이제 여기서 시작을 할 건데 여기서 데이터를 읽었으면 자동으로 컷서가 그 앞으로 당겨지게 될 겁니다. 또 이만큼 읽었으면 자동으로 컷서가 앞으로 당겨지게 될 것이고 이런 식으로 뭔가 우리가 데이터를 읽을 때마다 자동으로 읽은 위치가 계속 앞으로 당겨지는 부분이라고 보시면 되겠습니다. , 이렇게, 만들어야지 실질적으로 우리가 작업을 할 때 훨씬 더 편하게 작업할 수가 있을 거예요. 아직 이게 정확히 어떻게 사용될지 이해가 안 가셔도 나중에 완성된 코드를 보면 이해가 가는 거니까 이건 대충 넘어가도록 할 것이고 , 자, 그 다음에 요렇게 꺼낼 수 있는 경우도 있지만 다른 버전들도 만들어 놓도록 하겠습니다 , 일단은, 픽 이라는 버전 그러니까 데이터를 살짝 엿보고는 싶은데 요 커서를 조작하고 싶지는 않은 경우도 생길 수가 있겠죠 예를 들면은 뭐 어떤 상황이 있을 수 있냐면 우리 세션에서 조립을 할 때 잠시 패킷 헤더만 살짝 엿봐가지고 얘가 팔싱할 수 있는지 없는지만 체크하고 싶은 이런 경우도 있을 텐데 지금은 비록 우리가 , 이렇게, 사이즈를 개선해가지고 할 수 있지만 만약에 피크라는 기능이 있어가지고 내가 해당 위치에서 뭔가 데이터를 꺼내 쓸 수 있는지만 살짝 엿보고 싶다 가면 이 함수를 활용을 하면 되겠습니다 그래서 이런 함수도 만들어주고 물론 지금 만드는 내용은 절대적인 내용들이 아니라 여러분들이 만들고 싶은 대로 다 만들어도 됩니다 이게 뭐 공제 같은 게 아니에요 네 그래서 일단 피크랑 리드라고 해가지고 데이터를 읽는 함수와 그 다음에 데이터를 엿보는 함수를 각각 요렇게 만들어 주도록 할게요 그래서 , 이렇게, 각각 만들어 주고 그 다음에 임플레멘테이션이랑 요 아이도 임플레멘테이션을 각각 , 이렇게, 입력을 해 주도록 하겠습니다 , 자, 피크 같은 경우에는 뭐 굉장히 간단한데 지금 , 일단은, 공간을 공간이 더 이상 읽을 공간이 있는지를 확보를 해야 되겠죠 마우스 커스가 끝까지 갔으면 끝난 거니까 그래서 그 공간을 체크해 봤더니만 내가 읽어야 될 사이즈보다 얘가 더 작다고 하면은 그냥 실패 처리를 해줄 것이고 그게 아니면 성공 처리가 되는 것이고 성공 처리를 하기 전에 데스티니션에다가 내가 읽고 싶은 크기만큼을 복사 시켜 주도록 할게요 얘는 맴 카피를 이용해 보도록 합시다 데스티니션에다가 버퍼의 포지션 위치에 있는 값에서 렌스만큼을 복사해주세요 라고 , 이렇게, 일단은, 만들어 보도록 하겠습니다 리드도 피크랑 거의 유사한데 얘는 단지 차이점이 그냥 마우스 커서 포지션을 앞으로 이동시킨다고 , 일단은, 생각하시면 되겠어요 그래서 뭐 굳이 만들어보자면 기존에 있던 피크를 재사용해보면은 얘가 만약에 실패했으면 얘도 똑같이 실패한 것이고 성공했다고 하면은 얘는 유일한 차이는 이제 렌스를 렌스만큼을 포지션을 앞으로 당겨준 다음에 리턴 트롤을 때려주겠다라는 차이가 생기게 되는 거죠 뭐 요렇게 , 일단은, 만들어 볼 수가 있을 거예요 , 자, 그러면은 , 이렇게, 일단은, 끝내도 되는데 그래도 조금 더 사용하기 쉽게 얘를 뭐 여러가지 버전으로 만들어 놓도록 합시다 이번에는 Peak는 Peak인데 T포인터에 Destination을 바로 넘겨줄 경우는 이런식으로 Destination에다가 Size of T를 직접적으로 , 이렇게, 받아주도록 할게요 그리고 Read도 마찬가지로 템플릿 버전 하나를 더 만들어가지고 혹시라도 좀 더 편하게 사용하고 싶다 여기 Length까지 굳이 입력하지 않고 그냥 T타입의 포인터만 , 이렇게, 넣어준다고 가정을 하면은 그러면 Return, Read, Destination, Size of T로 요렇게 건네 주도록 할게요 , 자, 일단은, 뭐 리드는 어 리드 버퍼는 이정도에도 , 일단은, 우리가 당장 필요한 기능은 충분하니까 잠시 정렬만 해주고 마치도록 합시다 리드 음 하는김에 오퍼레이트도 정렬해볼까요 요런식으로 짜잔 네 이쁘게 이쁘게 정렬을 하고 마치도록 하겠습니다 그래서 이 기능들을 잘 활용하면 데이터를 꺼냈을 때 조금 더 편리하게 활용할 수 있다는 결론을 내릴 수가 있는 거죠 그리고 실습을 이어서 해보기 전에 버퍼라이터도 비슷한 방식으로 , 일단은, 만들고 이어서 이걸 실습해보는 시간을 가져보도록 할게요 , 자, 일단은, 요기서 요기까지 버퍼리더를 싸그리 복붙해가지고 어 겹치는 내용이 꽤 있을 수 있다보니까 버퍼라이터 코드에 돌아가서 헤더는 왼쪽 cpp는 오른쪽으로 다시 이동시키고 , 자, 요 부분 버퍼리더 부분을 그대로 복붙해왔습니다 근데 이제는 버퍼라이터가 되겠죠 그래서 이제 얘를 라이터 라이터 라이터로 다 바꿔치기를 해주고 , 일단은, 기본적으로 멤버 변수는 똑같습니다 어차피 얘도 버퍼의 범위를 표현하는 것이기 때문에 버퍼의 시작 위치와 버퍼의 크기까지는 똑같고 그 다음에 이 포지션은 이제 라이트 포즈가 되겠죠 내가 어디까지 지금 썼느냐를 일종의 커서 역할을 하게 되면서 얘가 이제 관리를 해주게 될 겁니다 , 자, 요렇게 만들어주고 그 다음에 각각의 생성자로 만들어 주도록 할게요 Implementation Implementation 그리고 Implementation 그 다음에 복붙 해가지고 요렇게 옮겨 놓고 생성자는 뭐 얘도 마찬가지로 버퍼는 그대로 복사하고 사이즈도 그대로 저장하고 그 다음에 포지션도 요렇게 갖다 복사를 하도록 할게요 , 자, 이렇게, 그 다음에 얘 같은 경우에는 , 사실, 피크는 필요가 없구요 데이터를 잠시 옆보고 이런 개념이 아니고 그냥 데이터를 쓰는 역할을 하게 될 것이니까 , 사실, 이 피크는 필요가 없습니다 거꾸로 얘가 필요한 건 이제는 라이트라고 해가지고 데이터를 쓰는 그런 함수를 만들어줘야 되겠죠 이런 식으로 만들어줄 것이고 얘 같은 경우에는 우리가 여기다 넘겨주는 데이터를 이 버퍼에다가 복사하는 거니까 얘가 destination이 아니라 source라는 이름으로 이것만 바꿔치기를 해주도록 할게요 그래서 얘는 이제 write의 역할이 될 것이고 그 다음에 여기서 뭔가 꺼내 쓰는 짝짝이가 아니라 이제는 데이터를 밀어 넣는다는 표시로 , 이렇게, 바꿔주도록 하고 얘가 사실상 우리가 see out 할 때 요런 식으로 사용했던 이 짝짝이랑 똑같은 의미라고 일단 보시면 되겠습니다 , 자, 그래서 요걸로 , 일단은, 바꿔주도록 할 것이고 그 다음에 얘도 마찬가지로 아웃티 데스티니션이 아니라 내부에다가 우리가 데이터를 밀어넣는 작업을 할 것이기 때문에 두가지 버전으로 받아줄건데 왼쪽 값을 왼값 첨조로 넣어줄 때랑 그 다음에 오른값 첨조로 넣어줄 때 , 이렇게, 두가지 버전으로 얘를 각각 만들어주도록 하겠습니다 , 자, 요렇게 , 일단은, 만들어주고 그 다음에 또 필요한 음수가 뭐가 있을까 곰곰히 생각을 해보다가 어.. 우리가 나중에 가면은 요런 방식에서 사이즈 같은 거를 우리가 기입할 일이 생기게 될 텐데 요 아이 같은 경우에는 맨 마지막에 채워야 되는 경우가 또 생길 수가 있습니다 사실상 버퍼는 뭐 여기서 여기까지 엄청 큰 영역이 잡힐 텐데 먼저 헤더 역할을 하는 요 바이트는 비워두고 나머지 내용부터 꽉 채운 다음에 그 다음에 돌아와가지고 여기 있는 부분을 채울 수 있기 때문에 그거를 조금 더 편하게 할 수 있게끔 , 자, 이런 식으로 Reserve라는 함수를 하나 만들어 주도록 할게요 구현부를 보시면 이게 어떤 역할을 하는지는 알게 되실 거고 그래서 , 이렇게, 일단은, 다 정의를 하고 시작을 해 보도록 합시다 라이트만 , 일단은, 만들어 줄 것이고 그 다음에 라이트 같은 경우에는 약간 대칭적이긴 한데 먼저 프리 사이즈를 체크해가지고 렌스보다 작으면 라이트 할 공간이 없다는 거니까 return false를 때릴 것이고 그게 아니라고 한다면 맴 카피를 해 줘 가지고 우리 버퍼에다가 버퍼의 포지션 위치에다가 소울스의 렌스만큼을 맴 카피를 해준 다음에 그 다음에 이 포지션을 렌스만큼 당겨주고 트롤을 return 해주도록 하겠습니다 , 이렇게, 해가지고 이제 데이터를 밀어 넣는 거죠 그 다음에 템플릿이 붙은 시리즈들은 이쪽에서 만들어주도록 할 건데 먼저 리설브부터 만들어보자면 타임네임 T에다가 T타입 포인터로 버퍼 라이터를 뱉어줄 것이고 리설브를 해줄 것인데 얘도 , 일단은, 영역 체크만 간단하게 해줄 것이고 사이즈 오브 T보다 작다고 하면은 내가 예약을 할 수 없다는 거니까 그냥 널 포인터를 뱉어 줄 것이고 그게 아니라고 한다면 현재 내가 예약하고 있는 그 위치를 찝어 줘 가지고 걔를 그대로 리턴을 해 주도록 할 겁니다 즉, re-interpret-cast-title 포인터로 해 준 다음에 현재 위치, 버퍼의 position, 주소를 , 이렇게, 그냥 뱉어 줄 것이고 다만 그 전에 커서 자체는 앞으로 당겨 주도록 하겠습니다. , 자, 요렇게 만들어 주도록 할게요 그래서 이건 이제 사용 예를 보면은 이걸 왜 , 이렇게, 하는지 좀 이해가 쉽게 가실 거고 그 다음에 마지막으로 요 두 개만 더 만들어 주면 되겠죠 템플릿 타임네임 T 그 다음에 버퍼라이터 참조 버퍼라이터 의 operator 당기기 const t source 라고 해가지고 얘는 그냥 간단하게 reinterpret cast 버전으로 다시 데이터를 넣어 주도록 할게요 버퍼의 position 에다가 source 참고로 뭐 , 이렇게, reinterpret cast 버전을 하지 않고 맴 카피를 해서 데이터를 복사해도 똑같은 의미입니다 그건 큰 차이가 없어요 근데 작은 데이터로 복수할 거면 이게 조금 더 성능이 좋기 때문에 , 이렇게, 일단은, 만들고 있는 거고 이 부분은 그냥 유농적으로 하시면 되겠습니다 사이즈 오브 딜을 더해주고 리턴 디스 그리고 마지막으로 오른값 참조 버선도 요렇게 만들면 되겠죠 오른값 3조이다 보니까 얘는 복사하지 않고 std move를 사용하도록 합시다 , 이렇게, 해가지고 똑같이 얘도 , 일단은, 처리가 될 것 같네요 , 자, 요렇게 해가지고 뭐 리드랑 라이트 기능을 하는 그런 여러가지 뭐 헬퍼 클래스들을 만들어 봤는데 그럼 얘들이 이제 어떻게 사용하는지 한번 실시 예를 한번 사용을 해봅시다 , 일단은, 빌드를 해보고 다시 가가지고 위에서 우리가 결국에는 지금까지 사용하고 있던 게 게임 서버랑 더미 클라이언트 이쪽이었는데 요 부분 좀 지저분했던 부분을 한번 정리를 해보도록 할게요 그럼 이제는 먼저 위에다가 인크루드 버퍼 라이터를 추가를 해서 얘를 사용하도록 할 것이고 이 영역, 버퍼에 해당하는 이 영역 자체를 우리가 버퍼 라이터라는 클래스로 , 일단은, 이렇게, 찝어 줄 겁니다 샌드 버퍼에 버퍼를 받아 줄 것이고 그 다음에 우리가 샌드 버퍼에서 이 크기를 뱉어 주는 거는 일단 막아 놓긴 했는데 뭐 이거는 약간 뭐 고민이 되긴 하지만 , 일단은, 잠시 열어주도록 할게요. 이 Allocation Size라고 해가지고 우리가 버퍼 4096만큼을 찝어준거를 , 이렇게, 복붙해서 사용하는건 좀 마음에 안드니까 여기 가가지고 이쯤 위치에다가 Alloc Size를 뱉어주도록 하겠습니다. 버퍼에 최초 할당된 크기는 얼마입니까? 를 의미하는 거죠 보다보니까 여기 인트랑 유인트가 섞여있는데 유인트로 다 수정을 해주도록 할게요 한쪽을 맞춰가지고 작업을 하면 됩니다 섞어 쓰는건 별로 안좋을 것 같고 , 자, 이렇게, 해가지고 유인트로 다 바꿔놨구요 다시 돌아와서 그럼 이제는 이 버퍼는 신경쓰지 않고 이 버퍼라이터라는걸 이용해가지고 이제 우리가 관리를 해주게 될건데 먼저 패킷 영역 자체는 나중에 채울 수도 있으니까 bw.reserve를 , 이렇게, 해주도록 할게요 그래서 패킷 헤더만큼을 , 이렇게, 영역을 예약을 해주라고 한 다음에 그 다음에 재밌게도 얘가 바로 포인트를 뱉어 줘 가지고 나중이라도 우리가 이 헤더 위치에다가 데이터를 써 놓을 수가 있게 되는 거죠 즉 이 부분들이 이런 식으로 헤더로 바꿔치기가 되는 거고 이 코드들은 언제 어디서나 맨 마지막에 이런 식으로 작업을 해도 된다는 얘기가 되는 거죠 이왕이면 버퍼 클로즈하기 이전에 하는 게 낫겠죠 , 이렇게, 해가지고 나중에 데이터를 다 채운 다음에 해당 위치에다가 또 데이터를 기입할 수가 있게 된 거고요 그 다음에 일반적인 상황에서 일단 얘는 더 이상 필요 없고 이런 식으로 데이터를 복사한다거나 하는 걸 예로 들어봅시다 요렇게 문자열 하나만 넣으면 심심하니까 이제 좀 상황을 바꿔가지고 아이디랑 체력 그리고 공격력을 각각 밀어넣는다고 가정을 해봅시다 근데 얘는 유인트 64 체력은 유인트 32 공격력은 유인트 16짜리라고 , 일단은, 가정을 해볼게요 그럼 이제 요런 상황에서 이걸 어떻게 사용하면 되냐면은 bw에다가 이런식으로 진짜로 각각 우리가 cout을 사용하던 것처럼 뭔가 데이터를 밀어넣으면 되겠죠 근데 여기서 조심해야 될거는 캐스팅을 해줘가지고 얘가 뭐 id는 1001번 그 다음에 유인트 32로 체력은 100 그 다음에 공격력은 뭐 10 이런식으로 각각의 타입에 맞춰가지고 , 일단은, 넣어줘야 되는게 중요합니다 근데 뭐 기본적으로 요런식으로 데이터를 계속 밀어넣는식으로 작업을 하게되면은 결국에는 요 오퍼레이터 특성상 우리가 만들어준거 자체가 계속 현재 위치를 앞으로 계속 땡겨주고 있기 때문에 얘를 연속해가지고 요렇게 활용할 수 있게되요 그리고 여기서 버퍼라이터의 참조값을 뱉어준 이유도 얘를 이런식으로 연속해서 사용할 수 있게끔 만들어주는거죠 그리고 참고로 지금 이 라이트나 리드같은 경우에는 불리언으로 내가 여유공간이 있는지를 이런식으로 체크하고 있는데 요 오퍼레이터 같은 경우에 그걸 안해주고 있습니다 이거는 그냥 어디까지도 우리가 선택을 하면 돼요 이걸 진짜 범위 체크까지 넣어줄 것이냐 말 것이냐 넣어주면 안전하긴 하지만 솔직히 이거를 잘못 사용하는 거는 잘못 사용한 쪽의 책임이기도 하니까 나중에 가면 패킷을 만드는 작업을 굉장히 많이 할 것이기 때문에 조금이라도 이런 불필요한 체크를 아낄 수 있다면 조금이라도 성능 형상을 볼 수가 있겠죠 그러니까 이것도 여러분들이 유동적으로 선택을 하면 된다라는 결론을 얻을 수가 있는 거고 그래서 패킷을 뭐 이런 식으로 만들어주면 된다라고 일단 볼 수가 있겠습니다 , 자, 근데 , 이렇게, 뭔가 좀 가변적인 길이 지금 샌드 데이터를 만약에 넣어줘야 된다고 하면은 라이트 버전을 이용해서 , 이렇게, 만들어 줄 수가 있겠죠 예를 들면 샌드 데이터에서 우리가 특정 사이즈만큼 지금은 그냥 전체로 , 이렇게, 밀어 넣어주겠지만 특정 사이즈만큼 넣어주고 싶다고 하면은 이 라이트 버전을 사용하면 될 것이고 얘도 내부적으로 내가 지금까지 쓴 포지션을 계속 앞으로 당겨지게 될 거니까 이런 식으로 데이터가 결국 다 들어가게 된 다음에 우리가 사실상 Reserve랑 이 Operator랑 Write를 이용해가지고 데이터를 쓴 상태가 되는 거고 여기까지 왔으면은 그 다음 상태에서 내가 데이터를 얼마 만큼 썼느냐를 BW.WriteSize를 이용해가지고 이제 판별을 할 수가 있게 되는 겁니다 아 이거를 ReadSize로 냅뒀네요 , 자, 이걸 WriteSize로 , 이렇게, 바꿔치기해서 다시 빌드를 해주도록 할게요 그래서 이제 이 버전을 이용하면 이런 불필요한 계산을 아낄 수 있으니까 훨씬 더 코드가 우아해지겠죠 뭐 지금은 패킨 메시지는 그냥 1번으로 냅두도록 할 건데 나중에 가면 이게 프로토콜 아이디 소위 패킨 아이디가 될 겁니다 이건 뭐 테스트 메시지라고 합시다 그 다음에 마지막으로 클로즈를 할 때도 이런 식으로 어거지로 사이즈오브 계산을 하는 게 아니라 지금까지 우리가 이 버퍼 라이터에다가 얼마만큼의 사이즈를 썼는지를 다시 , 이렇게, 긁어와가지고 넣어줄수가 있다는 얘기가 되는거죠 뭐 , 이렇게, 일단은, 만들어줄수가 있을겁니다 , 자, 그래서 게임서버는 빌드해서 문제가 없으면 , 일단은, 통과가 된것이고 그 다음에 거꾸로 더미클라이트 쪽에서는 이제 이 버퍼리더를 사용해보면 되겠죠 인클로드 버퍼리더 얘도 굉장히 대칭적이다보니까 비슷하게 사용할 수 있는데 씨브 패킷 할 때 지금은 , 이렇게, 꺼내고 있던 거를 조금 그나마 깔끔하게 바꿔보자면 얘도 버퍼 리더를 , 이렇게, 하나를 만들어 줄 것인데 얘가 사실상 이 버퍼의 영역을 집어주는 그런 기능을 하고 있었죠 그러면 이 패킷 헤더를 어떻게 사용하면 되냐면 BR에다가 패더를 꺼내주세요 라고만 하면은 요 사이즈 자체를 얘가 인식을 해가지고 그 만큼을 꺼내준 다음에 그 다음에 포지션을 앞으로 이제 당겨줄 겁니다 그럼 이제 그 다음 데이터를 읽을 수가 있게 된다는 얘기가 되는 거죠 어 그 다음에 우리가 보낸게 이제 이 순서를 조심해야 되는데 우리가 보내준 순서로 그대로 다시 읽어야 됩니다 그래서 지금은 아이디, 체력, 공격력 순서로 얘를 읽어왔으니까 아이디랑 HP 그 다음에 어택을 각각 요렇게 만들어 준 다음에 각각 꺼내주도록 합시다 아이디 꺼내오고 HP 꺼내오고 어택도 꺼내오도록 할게요 그 다음에 정상적으로 맞는지 궁금하니까 간단하게 id는 얼마얼마 그리고 hp는 얼마얼마 각각 로그를 찍어보도록 할게요 이런식으로 hp 그리고 어택은 얼마얼마이다 엔드라인 , 이렇게, 로그를 찍어보고 , 자, 그 다음에 여기 receive 버퍼에다가 데이터를 긁어와야 되는데 어 요 부분은 뭐 아직까지 그렇게 뭐 이쁘게 할 방법은 많이 없지만 일단 간단하게 br-read 기능을 이용해가지고 receive 버퍼에다가 얼마만큼의 데이터를 긁어올 것이냐를 입력을 해야 되는데 , 자, 요 부분이 살짝 고민입니다 뭐냐면은 우리가 지난번에 보내준 요 크기를 보면은 어... 헤더가 이 사이즈죠? 전체 크기에서 원래 사이즈 of packet header만큼을 빼줬던 걸로 우리가 계산을 했었는데 지금 같은 경우에는 이게 살짝 달라져야 되는게 여기서 추가적으로 8-4-2만큼을 빼줘야 됩니다. 그래가지고 이게 왜 , 이렇게, 지저분한가 하면은 중간에 데이터가 , 이렇게, 낀 게 없기 때문에 얘가 이제 사이즈가 우리가 원래 처음에 보냈던 사이즈를 계산할 수 없기 때문에 , 이렇게, 어거지로 계산을 해준 것인데 그래서 , 이렇게, 뭐 가변적인 길이를 보낼 때는 요런 식으로 파싱하는 건 당연히 옳은 방법이 아니고 이건 이제 나중에 패킷 설계에 대해서 다룰 때 가변 길이는 어떻게 할지를 이제 고민을 해보도록 할 건데 뭐 결론부터 말씀을 드리면 가변 길이를 보내기 전에 내가 보낼 가변 길이의 크기가 얼마인지를 또 보내주면 됩니다 우리가 팩킷을 보냈더라도 팩킷 헤더에다가 팩킷 사이즈를 보냈던 것만큼 가변 길이 데이터도 가변 길이짜리 데이터가 몇 개가 있는지를 보내주는 게 일단 정석적인 방법이라고 생각하시면 돼요 지금은 딱히 그런 뾰족한 방법이 없으니까 그냥 좀 무식하게 크기를 우리가 직접 지정해가지고 , 이렇게, 파싱을 해주도록 하겠습니다 , 자, 이렇게, 해가지고 클라이언트도 빌드를 해보도록 할 것이고 정상적으로 , 일단은, 빌드가 되었으면 실행을 해보도록 합시다. , 자, 그러면은 뭐 별다른 문제가 없다고 하면은 이런 식으로 정상적으로 데이터가 잘 가고 있다는 걸 볼 수 있어요. 1110 그래서 뭐 이것도 꺼도 아무런 문제가 없고 이런 식으로 , 일단은, 사용할 수 있다라는 결론을 얻을 수가 있는 거죠. 그래서 여기서 굉장히 중요한 부분을 , 일단은, 실습을 해봤는데 이런 식으로 우리가 어떤 정보를 보내고 싶다고 할 때 소위 프로토콜이라고 하는 요 귀약을 우리가 맞춰줬죠 여기서도 int64, uint32, uint16 차례로 보여줬고 보내줬고 그거를 받을 때도 똑같은 순서로 , 이렇게, 받아준 걸 볼 수가 있는데 이게 바로 프로토콜의 설계 기초라고 , 일단은, 볼 수가 있겠어요 근데 물론 , 이렇게, 간단하진 않고 나중에 가면 문자알도 있을 거고 아니면 그냥 바이트 배열도 있을 수도 있고 그것도 아니라면 리스트 형태로 뭔가 가변적인 길이에 데이터도 넣어줄 수 있을 테니까 이런 부분을 어떻게 설계할지 다음 시간부터 본격적으로 고민을 해보도록 하겠습니다 오늘은 그냥 간단하게 이런 헬퍼 클래스드만 만들고 , 일단은, 마치도록 할게요.