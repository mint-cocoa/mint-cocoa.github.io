자, 이제 이번 시간에는 지난 시간에 이어가지고 요 오버랩트 모델에 대해서 또 알아볼 건데 어 지난번에는 우리가 이런 이벤트 기반의 오버랩드 모델을 사용했었다면 , 사실, 이 오버랩드 모델이 또 다른 방식이 한 가지가 더 있는데 완료 통지를 , 이렇게, 이벤트로 통지를 받는 게 아니라 그냥 콜백 함수를 우리가 전달해 줘 가지고 그 콜백 함수를 호출하게끔 유도를 해주는 두 번째 방법이 있습니다. 그래가지고 그 두 번째 방법에 대해서도 , 일단은, 알아볼 건데요. 여기 윗 내용은 삭제하고 이 부분이 이제 조금 수정이 될 겁니다. 그래서 지난 시간 했던 거를 잠시 다시 언급을 해보자면 지난 시간에는 오버랩들을 비동기 입출력 함수를 걸어준 다음에 이벤트 객체를 생성해가지고 그 해당 입출력 함수가 완료될 때 즉 리시브나 샌드가 완료가 될 때 우리가 같이 넘겨준 이벤트 객체를 통해서 알려달라고 운영체제한테 , 사실, 부탁을 한 셈이 되는 거죠 그래가지고 그 해당 샌드나 리시브가 바로 완료가 되지 않으면 펜딩 오류코드가 뜰 것이고 나중에 백그라운드에서 운영체제가 열심히 작업을 해가지고 그게 완료가 되면은 이제 우리한테 직접적으로 알려주지는 못하지만 그 해당 이벤트 객체를 시그널 상태로 빵 켜주게 될 겁니다 그러면 우리는 뭐 다른 일을 하다가 이제 좀 결과가 너무 궁금하다 싶으면은 그 해당 이벤트 객체의 시그널 상태를 감시해가지고 즉 WaitForMultipleEvent 같은 감시 함수를 호출해서 이벤트 객체의 시그널을 판별해서 빠져나온 다음에 GetOverlappedResult를 호출해서 해당 비동기 입출력 결과를 확인하고 이어서 데이터를 처리한다는 식으로 , 이렇게, 동작을 해줬습니다. , 자, 그런데 두번째 방법은 뭐냐면 , 이렇게, 이벤트를 건네줘가지고 이벤트의 시그널 상태를 바꿔주세요가 아니라 그냥 애당초 콜백 함수를 하나를 건네준 다음에 운영체제한테 해당 입출력이 완료가 되면 해당 콜백 함수로 호출해줘 라는 식으로 요청하는 두번째 방법이고 그게 사실은 이 다음 시간에서 알아볼 소위 IOSP랑도 굉장히 밀접한 관련이 있기 때문에 어떻게 보면은 어 좀 끝판왕을 공부하기 위한 사전 단계라고 일단 볼 수 있겠습니다 , 자, 그래가지고 오늘 이제 알아볼 것은 컴플리션 루틴 즉 콜백 기반의 오버랩트 모델에 대해서 일단 실습을 해볼 건데요 일단 흐름은 뭐 비슷한 부분이 있긴 합니다 먼저 입출력을 비동기 입출력 지원하는 소켓을 , 일단은, 먼저 생성을 하고요 , 자, 그리고 이런 통지를 받기 위한 이벤트는 이제 필요가 없구요 대신 우리가 콜백 함수를 하나를 만들어 줘 가지고 우리가 원하는 해당 입출력 함수 호출이 완료가 될 때 우리한테 거꾸로 호출해 달라고 부탁하기 위한 그 함수를 일단 만들어 준 다음에 그 함수의 시작 주소를 넘겨 주게 됩니다 즉 함수 포인터를 넘겨 준다는 얘기가 되는 거죠 완료루틴의 시장 주소를 같이 넘겨준다 라고 일단 볼 수 있겠습니다 , 자, 그 다음에 이제 뭐 마찬가지로 이제 입출력함수가 바로 완료되면 그냥 모두가 해피한 상황이고 별다르게 처리할 건 없지만 그게 아니라 바로 완료가 되지 않아가지고 이런 펜딩 오류코드가 뜨게 되면은 이제 운영체제가 백그라운드에서 열심히 열심히 작업을 하게 될 것이고 만약에 그 다음에 이제 완료가 되면은 원래는 아까 그니까 이전 시간에 알아본 방식에서는 시그널 상태로 이벤트 객체를 바꿔가지고 알려줬었죠 근데 그게 아니라 우리가 요 완료 루틴이라는 어떻게 보면 콜백 함수를 넘겨줬으니까 이제 어떻게든 운영체제가 끝났다는 의미로 콜백 함수를 호출을 해주기는 할 겁니다 여기서 하나의 문제는 뭐냐면은 비동기 입출력이 완료되면 운영체제는 완료 루틴 호출까지는 굉장히 아름다운데 근데 여기서 어느 시점에 운영체제가 완료 루틴을 호출해야 될까가 살짝 애매하긴 합니다 우리가 이전에 C샵에서 만약에 C샵 서버 강의를 들으셨으면은 비슷한 느낌으로 이제 비동기 작업이 완료가 되면은 운영체제가 스레드풀에 있는 스레드를 하나를 이용해 가지고 이 완료 루틴을 호출해줬었는데 C++에서는 일단 그렇게 동작은 하진 않습니다 이 오버랩도 모델에서는 , 자, 그렇다고 하면은 우리가 뭐 다른 코드를 열심히 실행하고 있는데 갑자기 끼어들어 가지고 중요한 타이밍에 그 해당 완료 루틴을 호출하는 건 좀 문제가 있겠죠 예를 들면 우리가 락을 잡아 가지고 정말 빠르게 처리해야 되는 작업을 하고 있는데 거기에 갑자기 딱 타이밍이 나빠 가지고 끼어들어 가지고 이 완료 루틴을 콜백 함수를 호출한다고 하면은 이제 굉장히 문제가 있을 수가 있을 겁니다 그러니까 어디까지나 우리도 마음의 준비를 해가지고 진짜로 이 비동기 입출력 함수에 콜백 함수가 호출이 돼도 된다라는 상태가 되어야만 그 콜백 함수를 호출할 수가 있게 됩니다 그래가지고 여기서 중간단계에서 이 운영체제가 완료되었다고 그냥 언제 어디서나 맞대로 얘를 호출하는게 아니라 우리가 이제 비동기 입출력 함수 호출한 쓰레들을 Alertable Wait라는 굉장히 묘한 상태로 만들어야 됩니다. 만든다. , 자, 그래가지고 얘는 말 그대로 나는 기다리고 있는 상태라는 거죠. 이 Thread 자체가 이제 대기를 타면서 이 비동기 콜백 함수를 호출할 준비가 되었다라는 상태로 얘를 바꿔주게 되면은 그제서야 비로소 그 중에서 만약에 이 완료 루틴이 하나가 호출이 될 수 있다고 하면 걔를 이제 호출해주는 식으로 동작을 하게 될 겁니다. 이거는 이제 그림으로 다시 좀 살펴볼 건데요. 말로 하니까 좀 너무 어렵네요. 근데 결국에는 이 alertable 상태를 어떻게 만드느냐 뭐 여러가지 함수가 있습니다 waitForSingleObject 요런 함수도 있고 waitForMultipleObjectsExtended 아니면 sleepExtended 아니면 wsawaitForMultipleEvent 이거 우리가 기존에 사용했던 요 함수에서도 이 alertableWait로 전환하는 것을 지원합니다 그래서 여러가지 그런 옵션들 중에서 하나를 선택해가지고 이 해당 Thread를 Alertable Wait라는 상태로 만들게 되면은 그때야 비로소 이 완료 루틴이 빵 호출이 된다라고 볼 수가 있는 거고 그래서 최종적으로 완료 루틴이 완료 루틴 호출이 모두 끝나면 Thread는 Alertable Wait 상태에서 빠져나온다라는 요런 흐름으로 , 일단은, 작업을 하게 됩니다 어 좀 말로 하니까 어려운데 일단 코드를 가 가지고 보면은 생각보다 그렇게 어마어마하게 어려운 그런 내용은 아닙니다 , 자, 그래가지고 이제 이거를 조금 수정을 해볼 건데 내려보면서 , 일단은, 여기 억세트하는 부분은 그냥 그대로 냅두도록 할 거고요 그 다음에 쭉 내려가지고 이 이벤트를 원래 만들어 가지고 Session Overlapped H 이벤트에다가 우리가 연동을 시켜놨는데 이제는 이벤트 방식으로 통지를 받는 게 아니다 보니까 얘는 그냥 , 사실, 안 해도 됩니다 그래가지고 이 이벤트랑 세션이랑 연동하는 그런 부분은 없어지고 그 다음에 어 여기 세션 원래 오버랩트 이걸 통해 가지고 우리가 이제 아까 연동한 그 이벤트에다가 어 이제 알림을 요청해 달라 그니까 걔를 식은 상태로 바꿔 달라고 요청했지만 이제는 그게 아니라 요 마지막 인자를 사용하게 될 거예요 요 마지막 인자가 이제 말 그대로 콜백 함수를 의미를 하는 거고 모든 호출이 다 완료가 되었을 때 기본적으로 요 콜백 함수를 호출해달라는 이제 우리가 부탁을 해주고 있는 겁니다 , 자, 근데 이 리시브를 살펴보고 이 마지막 인자를 살펴보면은 , 자, 요런식으로 되어 있어요 조금 내용이 복잡한데 이게 함수 포인터라는 걸 알 수가 있구요 함수는 함수인데 보이드형을 반환하고 그 다음에 요런 식으로 DWORD DWORD OVERLAPPED POINTER DWORD를 각각의 받아주는 요런 인자로 일단 되어있는 모양의 함수만 받아준다는 걸 알 수가 있습니다. 그러니까 우리가 멋대로 아무 함수나 다 여기다가 넣어줄 수는 없다는 얘기가 되는 거죠. 네 그래서 이 함수의 원형에 대해서 잠시 , 일단은, 살펴보자면 이쯤에서 한번 살펴볼까요? 네 여기서 이런식으로 되어있습니다. void completion routine 같은 이런 함수를 만들어줘야 되는데 여기서 인자로 아까 보면은 4개를 받아준다는걸 우리가 알 수가 있었습니다. 첫번째는 오류 발생시 0이 아닌 값으로 , 일단은, 튀어나오게 될 것이고 두번째로는 종송 바이트 수를 이제 뱉어 줄 것이고 3번으로는 비동기 입출력 함수 호출시 넘겨준 ws의 오버랩트 구조체의 조석값을 이제 반환해 줄 것이고 4번은 그냥 사용 안 할 거니까 0으로 일단 밀어 주시면 되겠습니다 이런 느낌으로 , 일단은, 만들어 주시면 되겠어요 함수를 그래서 위로 넘겨 가지고 똑같은 모양으로 한번 함수를 간단히 정의를 해 보도록 합시다 여기서 void callback, receive, callback 이라는 이름의 함수를 만들어 줄 것인데 여기다가 뭐 인자를 deward, error, deward, receivance, 그리고 deward, 그 다음에 lpwsayoverlapped, 말 그대로 overlapped의 포인터라는 의미이고 deward, flag를 각각 , 이렇게, 받아 주도록 하겠습니다. 여기서 Error, Receive Length, Overlap, Flag 같은 요런 아이들을 이용해가지고 이제 우리가 결과물을 어찌됐건 살펴볼 수 있다는 얘기가 되는거죠 이 Overlap은 우리가 처음에 연결해준 그 Overlap 구조체를 똑같이 그 주소를 뱉어 줄 거구요 에러가 났는지 그리고 데이터는 얼마만큼을 받았는지 등등을 이제 여기서 알려주게 됩니다 그럼 여기서 뭔가를 해주면 되겠죠 두두 , 일단은, 뭐 간단하게 데이터 리시브 렌스 콜백 이라고 얼마를 받았다라고 , 일단은, 리시브 렌스만 간단하게 출력을 하고 마치도록 할게요 근데 만약에 여기서 만약에 우리가 뭐 에코 서버를 만든다 만든다면 여기서 다시 wsasand 등등을 여기서 호출해주면 되겠습니다 그래서 , 이렇게, 호출할 함수를 요렇게 만들어 뒀구요 참고로 여기 콜백은 그냥 SD 콜이라고 이 함수의 호출규약을 얘기하고 있는 겁니다. 이거는 뭐 , 사실, 안 넣어도 아마 상관이 없을 거예요. 그리고 여기서 Receive 콜백을 , 이렇게, 넣어준 다음에 여기서 쭉 내려가지고 이제 마지막 인자, 우리가 원래는 null 포인터로 넘겨줬었던 이 인자에다가 receive callback을 , 이렇게, 건네주면 돼요. 이게 사실상 이제 우리가 함수 포인터를 넘겨준 셈이 되는 거죠. 함수 이름이 사실상 주소를 갖고 있기 때문에 이 함수의 주소를 우리가 , 이렇게, 넘겨주면 이제는 이벤트 방식이 아니라 이 callback 방식으로 , 일단은, 호출이 될 겁니다. 그러면 여기서 이제 똑같이 만약에 바로 얘가 , 이렇게, 떴으면 굉장히 아름다운 상황이고요 여기다가 일단 else문에다가 원래 있던 부분을 , 이렇게, 넣어주도록 할게요 구분하기 위해서 콜백으로 인해가지고 데이터를 받았는지 아니면 그냥 막바로 받았는지를 한번 구분을 해보도록 하겠습니다 그 다음에 만약에 바로 끝나지 않고 펜딩이 떴다고 하면은 원래는 우리가 요런 식으로 waitForMultipleEvent를 통해 가지고 이벤트 시그널 상태를 기다린 다음에 뭐 그 다음에 이제 이 getOverlappedResult를 통해 가지고 해당 상태를 우리가 판별할 수 있었는데요 , 자, 지금은 이거를 어떻게 수정을 해볼 거냐면은 얘를 잠시 삭제를 하고 그 다음에 여기서 alertableWait 상태로 바꿔줘야 됩니다. alertableWait 상태로 이제 들어가야 됩니다. 그러면은 뭐 함수가 여러가지가 있다고 했었는데 , 사실, 이 ws-waitForMultipleEvent도 알러터블 웨이트로 넘어갈 수 있는 후보 중에 하나라고 했었죠 왜냐면 여기 맨 마지막에 있는 인자가 불리언 알러터블이라고 되었는데 얘를 투로로 빵 켜주게 되면 이제는 얘도 알러터블 웨이트 상태로 넘어가는 기능을 해주게 됩니다 그래서 이런 식으로 만들어도 되고요 아니면 뭐 다른 함수들 여러가지 후보들이 있었죠 예를 들면 Sleep Extended 이 방식으로 여기서 대기시간과 알러터블 여부를 두고 있는데 그냥 무한대기를 할 것이고 true 를 입력해 가지고 나는 이제 alertable 상태로 빠질 것이다 라고 요렇게 만들어 주면은 이제 얘가 어 내가 호출할 콜백 함수가 있는지를 판별해 줘 가지고 뭔가 생길 때까지 이제 대기를 타 주게 될 겁니다 네 요런 흐름으로 이제 만들어지게 될 거에요 , 자, 그래가지고 이 흐름이 잘 이해가 처음엔 안 갈텐데 이 잠시 구글에 가 가지고 이 APC라는 개념에 대해서 한번 알아보도록 하겠습니다 , 자, 요렇게 alertable weight apc 를 치면은 요런 그림들이 이제 많이 뜨는 걸 볼 수가 있는데요 지금 여기 보면 apcq라는 개념이 있죠 즉 스레드마다 사실상 요 apcq라는 요런 영역이 이제 할당이 됩니다 스레드마다 독립적으로 있는 거예요 그래가지고 아까 우리가 콜백 함수 같은 그런 알러터블 웨이트 상태로 이제 호출이 되어가지고 콜백 함수가 호출이 되어야 된다고 했을 때 그 콜백 함수들을 다 여기다가 이제 하나씩 하나씩 차곡차곡 쌓아주게 됩니다 그러면 우리가 뭐 아까 Sleep Extended 같은 그런 계열의 함수를 이용해가지고 알러터블 웨이트 상태로 빵 진입을 했다고 하면은 만약에 여기서 내가 처리할 수 있는 일감이 있으면은 걔네들을 이제 완료 루틴을 하나씩 하나씩 처리를 하게 됩니다 그 다음에 다시 Alertable Weight를 빠져나오게 되어서 이어서 나머지 코드들이 이제 흐름 나머지 흐름으로 이제 넘어가게 됩니다 그렇기 때문에 여기서 다시 요약을 해보자면 Sleep Extended로 넘어와 가지고 여기서 기존에 예약한 콜백 함수가 만약에 준비되어 있으면 걔네들을 호출해줄 것이고 걔를 호출을 완료한 다음에 이제 빠져나와가지고 나머지 이어서 나머지 코드들을 실행한다는 흐름으로 진행이 된다는 얘기가 되겠습니다. 조금 헷갈릴 수가 있는데 디버그를 한번 해보면 조금 더 이해하기가 쉬울 거예요. , 일단은, 여기서 그냥 F4를 눌러가지고 한번 실행을 해보도록 하겠습니다. 그리고 조금 기다려 보면은 지금 서버가 , 이렇게, 지금 데이터 렌스 리시브 렌스 콜백 즉 여기로 바로 들어오진 않고 지금 이 안으로 계속 들어온다는 걸 볼 수가 있습니다 그리고 우리가 딱히 리시브 콜백을 당장 호출해라 라는 그런 코드를 넣어주지 않았음에도 불구하고 로그가 찍히는 걸 보니까 얘가 지금 호출이 되고 있는 상황이라는 걸 우리가 알 수 있는 거죠 굉장히 신기하게도 , 자, 그러면 여기다가 Brink Void를 딱 잡아보면 얘가 지금 걸렸는데 그 다음에 F10을 두 번 눌러가지고 얘가 끝난 다음에 흐름이 어디로 넘어가는지 살펴보면은 이 Slip Extended 끝난 다음으로 넘어가서 이 부분에 이어서 코드가 실행이 된다는 걸 알 수 있습니다. 즉, 여기서 약간 Alertable Wait를 빵 때리는 순간에 뭔가 꿈나라의 앨리스로 넘어가는 느낌처럼 APCQ를 이제 다 비우기를 시작을 하고 그 다음에 APCQ에 있는 그런 콜백 함수가 호출이 된 다음에 끝났으면 다시 Alertable Wait 상태에서 빠져나와서 이어서 그 다음 줄부터 쭉 이어서 실행한다는 흐름으로 , 이렇게, 만들어지는 것을 우리가 확인할 수 있다는 얘기가 되는 거죠. , 자, 그리고 한가지 혹시라도 잘못 이해하셨을까봐 한 번만 이것만 더 설명을 드리자면 지금 여기 apcq 안에 우리가 만약 여러개의 send나 receive 등등을 예약을 해가지고 여러개의 콜백 함수들이 , 이렇게, 예약이 돼있는 상태라고 하면은 5개가 있다고 해가지고 우리가 Alertable Wait 상태를 5번 진입해야 되는 건 아닙니다 한 번만 진입을 하면은 여기 안에 있는 내용은 그냥 싸그리 한 번에 다 비워지고 나서야 탈출한다라고 , 일단은, 기억을 해주시면 되겠습니다 혹시라도 이제 잘못 이해하셨을까봐 이건 다시 한번 설명을 드리는 거고 , 자, 그래가지고 다시 이제 뭐 돌이켜보면은 이 방식과 기존에 했던 이벤트 방식이랑 뭐 , 사실, 지금 요렇게 만들었을 때 느낌은 굉장히 비슷하긴 하죠 뭐가 달라진 건지도 잘 모르겠다 싶을 수도 있는데 유심히 살펴보면은 차이가 분명히 있습니다 우선 이전에 했던 이벤트 방식의 연동에서는 소켓 하나당 이벤트 하나를 똑같이 1대1로 연동을 시켜줘 가지고 사용을 했어야 됐고요 그 다음에 두 번째로 지금은 그냥 클라 하나만 받아 가지고 처리하니까 흐름이 굉장히 단순한데 나중에 가서 만약에 우리가 요 모델을 이용해 가지고 막 몇 천명씩 받아야 된다고 하면 , 이렇게, 간단하진 않겠죠 당연히 그래가지고 Receive를 한 다음에 , 이렇게, Wait를 하는 방식은 당연히 사용하지 않을 것이고 다수의 소켓에 대한 Receive는 걸어두되 , 이렇게, Wait for Multiple Event를 할 때는 다수의 이벤트를 체크하는 식으로 원래 만들었을 겁니다 그런데 애당초 이 함수 자체가 최대 한도가 정해져 있었죠 64개로 정해져 있었기 때문에 다수의 유저들 처리할 때 이 부분이 굉장히 귀찮아집니다 물론 이걸 이제 뭐 쓰레드를 여러 개를 만들어 가지고 64개끼리 묶어 가지고 처리한다거나 다양한 방법으로 이거를 확장해서 응용할 수 있기는 하겠지만 그렇게까지 할 필요가 있을까 싶기는 하죠 반면 우리가 지금 실습하고 있는 콜백 방식을 살펴보면은 Sleep Extended를 하는 순간 내부적으로 지금 예약되는 모든 콜백들을 다 호출해주게 될 거니까 사실상 그렇게 클라이언트 개수만큼 이벤트를 할당한다거나 하는 필요가 전혀 없다는 게 굉장히 큰 장점이라고 볼 수가 있는 겁니다 사실상 이 이벤트도 굳이 사용 안 하고 , 이렇게, 콜백 함수만 넘겨주고 걔네들을 한 번에 묶어가지고 처리할 수 있다는 굉장히 큰 장점이 일단 생긴다고 볼 수가 있겠어요 , 자, 그 다음에 두 번째로 한 가지를 더 언급하고 싶은 게 뭐냐면 여기 이제 콜백 함수가 호출이 되죠? 이거는 우리가 직접적으로 호출하지는 않고 APCQ가 비워지면서 즉, Alertable Wait 상태가 되었을 때 운영체제가 이제 Receive Callback을 호출해주게 될 것인데 이 인자를 보면 , 이렇게, 운영체제가 같이 이 인자들을 채워줘가지고 얘네들을 호출해줄 거라는 걸 일단 알 수가 있습니다 근데 이 인자들을 유심히 보면 Receive Length는 내가 받은 Byte 개수라는 걸 알 수가 있고 이 Flag은 사용 안 할 것이고 이 Error는 그냥 Error 여부였고 사실상 운영체제가 우리한테 뭔가 알려줄 수 있는 그런 정보는 이 Overlap라는 것밖에 없죠 그리고 이 Overlapped는 우리가 맨 처음에 넘겨준 이 주소랑 일치한다는 것도 알 수가 있습니다 그런데 굉장히 슬픈 게 이 Overlapped라는 이 구조체 자체가 처음에 어떻게 만들어져 있는지를 다시 한번 살펴보면 굉장히 허무하게 되어 있습니다 , 이렇게, Internal, Internal High라고 해서 이런저런 정보가 있는데 얘네들은 내부적으로 운영체제가 사용한다고 했었고 실질적으로 우리한테 유용한 정보는 요 핸들 H 이벤트라는 것 밖에 없어요 근데 심지어 우리가 이벤트를 사용 안 할 거면은 그 정보도 지금 당장은 쓸모없는 정보죠 , 자, 그러면은 다시 얘기를 하면은 요 4개 정보가 다 우리한테 쓸모없는데 만약에 클라이언트 소켓이 여러 개가 되어 가지고 어떤 지금 클라이언트 대상으로 이 리시브 콜백이 호출이 되었는지를 알고 싶다고 하면은 굉장히 난감한 상황이 될 수도 있습니다 그쵸? , 자, 그런데 여기서 함정은 뭐냐면은 보통 이 WS의 오버랩트라는 이 포인터를 받아주는 거는 맞기는 하지만 그렇다고 해가지고 진짜로 넘겨줄 때 이 오버랩트 포인터만 단그란이 넘겨주는 식으로 사용을 할 필요는 없다는 게 이제 함정입니다 이게 무슨 말이냐면 , 자, 우리가 세션을 정의를 할 때 세션을 어떻게 정했는지 보면은 지금은 좀 구조가 , 이렇게, 엉망으로 되어 있는데 만약에 얘를 이제 위치를 바꿔가지고 첫 위치에다가 얘를 , 이렇게, 위치를 바꿔준다고 합시다. 그러면 사실상 세션의 시작 주소랑 이 오버랩트 시작 주소가 offset이 얘가 0번이기 때문에 우리가 애당초 이런 식으로 세션의 오버랩트 주소를 넘겨줬다고 해도 내부적으로 이 오버랩트 포인터를 바로 다시 세션으로 캐스팅을 할 수가 있게 된다는 얘기가 되는 거죠. 왜냐면 얘가 0번 offset에 지금 위치해 있으니까 메모리 구조상 이 주소나 이 세션의 주소나 똑같은 주소가 되겠죠? 그러다보니까 뭐 이런식으로 얘를 다시 세션으로 막 캐스팅 해가지고 , 자, 이런식으로 우리가 활용할 수 있다는 얘기가 되는겁니다 그러면은 기존에 사용했던 그런 뭐 정보들을 다다시 복원을 시켜가지고 우리가 사용할 수 있겠죠? 이것도 한번 실습을 해볼까요? 여기서 한번 브레이크 폰들 잡아가지고 다시 한번 실행을 해보도록 할게요 , 자, 지금은 아 우리가 이거 클로즈 이벤트 때문에 그런거니까 다시 한번 삭제를 해주고 실행을 해보면 여기서 브레이크폰드가 잡혔는데 세션과 관련된 정보들이 다 다시 복원이 되어 있다는 걸 우리가 볼 수가 있습니다. 헬로월드도 잘 들어가 있고 메모리 구조상 결국에는 이 오버레프트 주소를 받았지만 그 주소가 세션 주소랑 일치하게끔 우리가 만들어 줬기 때문에 , 이렇게, 캐스팅할 수 있었다는 게 되는 거죠. 그래가지고 이 오버레프트 위치를 어디에 넣느냐도 굉장히 중요해지게 된다고 볼 수가 있는 거고요. 이것도 나중에 IOCP에서도 이런 식으로 정보를 넘겨주게 될 겁니다. , 이렇게, 해가지고 이 세 번째 인자가 굉장히 중요한 역할을 한다는 거에 대해서 일단 간단히 언급을 해봤고 그래서 결국에는 , 이렇게, 마지막 모델에 대해서도 알아봤습니다 , 자, 그러면 우리가 이제 굉장히 뭐 다양한 모델에 대해서 알아봤으니까 이제 IOCP에 넘어가기 전에 그냥 간단하게 한번 요약을 해보도록 합시다 맨 처음에 우리가 알아본 게 셀렉트 모델이었죠 그 다음에 알아본 게 WSA 이벤트 셀렉트라는 모델이었고 그 다음에 이어가지고 오버랩트 모델인데 두 가지가 있었죠 이벤트 기반 통지를 받을 것인지 이벤트의 시그널 상태를 인지해가지고 우리가 해당 입출력이 완료되었는지 본거나 아니면 오늘 방금 한 콜백 기반 컴플리션 루틴 기반의 그런 통지를 받을 것인지 얘는 사실상 APC를 이용해가지고 우리가 준비되었을 때 마음의 준비를 하면은 운영체제가 콜백을 호출해준다라는 얘기를 했었죠 그래서 크게 일단 4가지 모델에 대해서 일단 알아봤습니다 뭐 그리고 , 사실, 책에서 보면은 여기서 중간에 wsa-async-select라는 게 하나가 더 있긴 합니다 근데 얘는 좀 이제 굉장히 위치가 애매하긴 해요 그래서 딱히 뭐 다루지 않았는데 얘는 뭐 한 줄 요약하면은 socket-event를 window-message 형태로 처리를 한다라는 특징이 있습니다 window-message라는 건 뭐냐면은 우리가 이전에 dx12 강의 혹시 보셨으면은 클라이언트를 실행시킬 때 윈도우 창을 만들어가지고 보여줘야 됐었죠. 그럴 때 윈도우 API를 보면은 막 온갖 메시지 형태로 그거를 처리를 합니다. WM 언더바 페인트 이런 식으로 뭔가 그리겠다라는 메시지를 전달해 줘가지고 그리고 우리가 마우스 클릭을 하거나 키보드를 누르는 것도 다 메시지로 처리를 합니다. 그리고 이 모델에서는 실질적으로 네트워크 이벤트도 모든 거를 다 메시지 형태로 처리를 해가지고 넘겨주게 된다는 그런 굉장한 차이점이 있어요. 근데 얘가 좀 애매한게 일반 윈도우 메세지랑 우리가 결국 중요하게 생각하는 소켓 이벤트랑 같이 처리하니까 성능이 이제 굉장히 좀 아리달송하다 이거죠 같은 메세지들을 혼합해가지고 사용하다 보니까 그래서 얘는 뭐 딱히 사용은 하지 않을 거라 가지고 굳이 언급은 안 했어요 근데 나머지들부터 이제 뭐 알아보자면 셀렉트 모델 얘가 이제 맨 처음에 알아본 거였죠 얘는 이제 가장 큰 장점은 윈도우즈랑 리눅스 이제 공통으로 우리가 사용할 수 있다는 장점이 있습니다 나머지 애들은 이제 거의 윈도우즈 전용이라고 거의가 아니라 , 사실, 100% 윈도우즈 전용이라고 보시면 되겠어요 리눅스 진영으로 넘어가면 이제 뭐 다른 방식 e폴 등등의 다른 기법들을 이용할 것인데 뭐 그거는 지금 윈도우즈 서버를 다루고 있으니까 다루지 않을 것이고 그리고 역사가 굉장히 길기도 합니다 근데 단점이라고 한다면 성능이 지금 다루고 있는 모델 중에서 가장 최하라고 볼 수가 있어요 , 사실, 성능이 기본적으로 낮은 순에서 높은 순으로 올라간다고 생각하시면 되겠습니다 그리고 얘가 성능이 굉장히 안 좋은 이유는 매번마다 우리가 해당 소켓을 소켓셋에 등록하는 비용이 있었죠 그걸 매번마다 하니까 당연히 성능이 떨어질 수 밖에 없습니다 그리고 두 번째로는 다른 64개 제한도 있었죠 디스크립터셋에 넣을 때 최대 64개로 제한이 있었기 때문에 그거를 또 , 이렇게, 분배해가지고 64개끼리 모아가지고 처리하는 등등 이제 코딩이 굉장히 복잡해진다는 단점도 있었습니다 근데 이 64개 제한은 나머지들도 종종 등장하는 애니까 얘는 그렇다 치고 가장 큰 문제는 이 성능이 안 좋다 라는 게 단점이긴 하지만 그럼에도 불구하고 윈도우즈랑 리눅스가 공통으로 사용할 수 있다는 건 어떻게 보면 큰 장점이라고 볼 수도 있어요 왜냐하면 우리가 나중에 클라이언트 같은 경우에 클라이언트에서 서버에 접속을 할 때는 , 사실, 어떤 모델을 사용해도 크게 상관은 없습니다. 왜냐하면 서버와는 다르게 클라이는 그냥 서버에 하나만 연결해 줘 가지고 서버랑만 통신하면 되니까 뭐 그렇게 어마어마하게 네트워크 부하가 심하지도 않고 하다보니까 어떤 모델을 사용해도 상관이 없는데 만약에 우리가 요런 모델로 만들었던 과정을 해볼게요 클라우를 근데 여러분들이 얼리얼 엔진에서 요런 윈도우즈 기반 기능을 이용을 했는데 이제 모바일 빌드를 해가지고 만약에 안드로이드에다가 그걸 띄우고 싶다고 하면은 이제 여기서 문제가 됩니다 왜냐면 애당초 안드로이드는 리눅스 커널이다 보니까 이런 윈도우즈 계열의 API들은 사용할 수가 없어요 애당초 빌드에서 에러가 난다는 얘기가 되는 거죠 그러니까 그런 경우에서는 이런 셀렉트 모델을 이용을 하면은 윈도우즈 환경에서도 돌아가고 리눅스 환경에서도 돌아가는 일석이조 효과를 얻을 수가 있기 때문에 그런 경우를 한다면 이게 장점이 될 수도 있다는 얘기가 되는 겁니다 그래서 이 공통으로 사용할 수 있다, 크로스 플랫폼이라는 게 굉장히 큰 장점으로 , 일단은, 여겨질 수 있다는 전념을 얻을 수가 있고 이벤트 셀렉트는 굉장히 단순하면서도 비교적 성능이 뛰어나다고 볼 수가 있는 거죠 약간 중심이 잘 잡혀있는 그런 모델이라고 볼 수가 있겠습니다 사용하기도 굉장히 편리하고 단점은 역시나 64개 제한, 똑같이 얘랑 마찬가지로 이벤트 방식으로 우리가 체크를 할 때 WSA Wait for Multiple Event 같은 거 이런 이벤트를 감시하는 함수 자체가 제한이 있었다라는 게 조금 아쉽기는 하죠 일반적으로 저는 클라 쪽에서 사용하는 게 조금 더 좋은 것 같습니다 서버는 당연히 IOCP가 있으니까 이런 모델을 고민할 것도 없이 끝판왕이 , 사실, 우리가 다음에 알아볼 IOCP라고 생각하면 되는 거고 그 다음에 오버랩트 이기는 한데 이벤트 기반으로 할 때는 , 사실, 장점은 여기부터는 이제 그냥 성능이 좋다 성능이 이제 장점이 될 수가 있고 얘도 이제 64개 제한이라는 단점이 있었고 그 다음에 오늘 알아본 요 방식도 성능이 괜찮다라는 게 있지만 그럼 요 방식의 단점은 무엇이냐 왜 굳이 IOSP까지 넘어가야 되느냐에 대한 내용을 또 해야 되겠죠 근데 이제 오버블랙도 이 콜백 기반 오늘 배운 내용이 , 사실, 만능은 아닌 게 , 일단은, 여러 가지가 문제가 있는데 첫 번째로는 모든 비동기 소켓 함수에서 사용 가능하진 않습니다 예를 들면 우리가 Accept 계열 같은 거를 만약에 이 Overlapped Callback 기반으로 만들고 싶다고 해도 슬프게도 그렇게 할 수가 없습니다 왜냐하면 비동기 방식에 Accept Extended인 EX가 붙은 버전인데 여기를 유심히 보면 마지막에다가 Callback 루틴을 걸어주고 하는 부분이 전혀 없다는 걸 알 수가 있습니다 그래서 얘는 일단 사용할 수도 조차 없어요 그래가지고 모든 비동기 소켓 함수에서 다 지원을 하는 기능은 아니다 라는 것도 단점이고 두 번째로는 역시나 빈번한 알러터블 웨이트로 넘어가고 있는 으로 인한 성능 저하가 , 사실, 문제라고 볼 수 있겠습니다 결국 우리가 MMO 서버를 만들 때는 최대한으로 성능을 끌어올려야 되기 때문에 뭐 셀렉트 모델보단 낫습니다 정도로는 좀 부족하고 최대한 성능을 끌어당길 수 있는 그런 방법으로 일단 만들어도 되는데 이 오버렉트 기반으로 했을 때 이 콜백 기반으로 했을 때는 알럴타블 웨이트로 계속 호출하는 것 자체가 이 부분이 사실은 마음에 안 든다는 얘기가 되는 거죠 그래서 IOCP 같은 경우에는 , 이렇게, 매번 마다 알럴타블 웨이트로 바꿔가지고 처리하고 이런 부분이 일단 없어지고 그리고 이 부분의 또 하나의 단점은 뭐냐면 아까 얘기한 대로 APCQ라는 것 자체가 이 그림을 보면은 스레드별로 각자 있다고 했었죠? 그렇다는 것은 결국에 우리가 이런 식으로 Receive나 Send같은 것을 , 이렇게, 호출해준 다음에 동일한 스레드에서 alertable weight 상태로 들어가 가지고 개를 처리할 수 있다는 얘기가 되는 겁니다 다른 스레드가 대신 개를 처리할 수가 없다는 얘기가 되는 거죠 그러다 보니까 일감 분배 측면에서도 조금 아쉬운 부분이 생길 수도 있다라는 그런 결론을 얻을 수가 있습니다 그래서 요런 단점이 있기 때문에 이제 이어가지고 끝판왕인 IOGP에서 해결책을 알아보겠다 그리고 이건 이제 앞으로 우리가 서버 엔진에서 다루게 될 모델이니까 실질적으로 네트워크 라이브러리에도 이제 들어가게 될 모델이라고 결론을 얻을 수가 있겠습니다 이쯤 해가지고 , 사실, 뭐 가장 기본적인 기초적인 그런 네트워크 내용들은 어느정도 마무리가 되고 있는 것 같구요 마지막으로 용어 하나만 더 알려드리자면 이게 종종 , 사실, 뭐 엄청 중요한 그런 개념은 아니지만 프로액터 액터 패턴 이런 용어를 가끔 이제 책이나 면접에서 물어보는 경우가 있어요 그래가지고 이것도 뭐 알면 좋을 것 같은데 얘는 기본적으로 뒤늦게 라는 뜻이 있고요 프로액터는 미리라는 뜻이 있습니다 근데 우리가 논블록킹 소켓을 사용할 때 논블록킹 소켓을 사용할 때 했던 거를 유심히 생각을 해보면 소켓 상태를 확인을 한 다음에 뒤늦게 우리가 호출하는 식으로 뒤늦게 리시브나 샌드를 호출하는 식으로 우리가 작업을 했었죠. 상태를 확인한 다음에 뒤늦게 뭔가를 호출한다는 걸 리액터 패턴이라고 하고요. 반대로 우리가 지금 보고 있는 이 오버랩트 같은 경우에는 그냥 미리 오버랩트 계열의 기능을 이용해가지고 즉, ws의 모시기 샌드 ws의 리시브를 이용해가지고 , 일단은, 에라이 모르겠다 하고 리시브랑 샌드 자체를 미리 걸어 놓은 다음에 그 다음에 내부적으로 처리가 되겠죠. 그래서 미리 소깨 상태를 확인하고 뒤늦게 샌드 리시브를 호출하냐 아니면 그냥 미리 샌드 리시브를 호출하냐에 따라 리액터랑 프로액터라는 이름이 붙는다는 것도 참고삼아 알아주시면 될 것 같아요 , 사실, 이건 굳이 몰라도 됩니다 근데 , 이렇게, 부르는 경우가 있기 때문에 이 부분에 대해서도 , 일단은, 참고를 하시면 될 것 같고 , 이렇게, 해서 , 사실, 네트워크 내용이 이런 기초를 다질 때는 굉장히 지루합니다. 근데 이제 앞으로 IoCP에 대해서 공부를 하면서 조금씩 네트워크 라이브러리를 채워가다 보면 우리가 꿈에 그리던 굉장히 많은 유저들을 받을 수 있는 그런 서버 라이브러리가 완성이 될 테니까 조금만 더 참고 진행을 해주시면 되겠습니다.