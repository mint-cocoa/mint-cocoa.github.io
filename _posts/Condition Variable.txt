자, 이제 이어서 돌아와 가지고 이번 시간 주제는 어떻게 보면 지난 시간 했던 이벤트의 변종이라고 볼 수 있는 조건변수 즉 conditions variable에 대해서 알아보도록 할 건데요 지난 시간에 우리가 이제 윈도우 api를 이용해 가지고 이 이벤트라는 걸 만들어 가지고 한쪽에서 이벤트의 시그널 상태를 딱 바꿔주고 반대쪽에서는 이 시그널 상태를 누가 켜주면은 대기상태에서 빠져나와서 실행하는 그런 부분을 이용해가지고 이제 이벤트를 이용해가지고 최대한 불필요하게 대기를 하는 거를 방지를 하는 식으로 일단 작업을 해봤어요 그런데 , 사실, 이렇게, setEvent랑 waitForSingleObject를 사용하는 게 이제 이벤트를 사용하는 우리가 연습을 한 것이긴 한데 지금 유심히 이 코드를 보면 약간 불안정한 부분이 없지 않아 있습니다 만약에 , 이렇게, 슬리퍼가 진짜 오랜 기간을 한다고 100% 확률로 가정을 하면 이게 뭐 , 사실, 이상할 건 없기는 한데 만약에 그게 아니라 여기는 프로듀서 코드도 굉장히 빠르게 루프를 돌면서 여기는 데이터를 계속 밀어넣는 작업을 계속 계속 반복한다고 가정을 해볼게요 그 다음에 이제 우리가 보고 싶은 거는 여기서 데이터를 빼놓은 다음에 여기다가 데이터를 출력을 하는 게 아니라 실질적으로 데이터가 몇 개가 남아있는지 사이즈를 출력을 해본다고 가정해봅시다 그러면 굉장히 순진하게 생각을 하면은 데이터 한 개를 밀어넣고 setEvent를 한 번을 호출하니까 여기서도 waitForSingleObject를 한 번에서 깨어난 다음에 데이터를 한 번 추출하니까 이게 뭐 거의 0이나 1 사이에서 계속 유지되어 가지고 데이터가 늘어나지 않을까 라는 생각이 드는데 실질적으로 요 코드를 실행해 가지고 살펴보면은 , 자, 어떤가요 데이터가 지금 무한으로 계속 계속 늘어난다는 걸 볼 수가 있습니다 그러니까 어떻게 보면 이벤트 자체는 어 여기서 지금 이 컨슈머라는 이 두번째 스레드가 잠들게 하고 그 다음 첫번째가 깨우는 역할을 하고 있지만 실질적으로 여기 락을 걸어가지고 실행하는 나머지 부분이랑 이 이벤트랑은 지금 묶여있지 않기 때문에 여기서 또 묘한 순서에 의한 그런 틀어짐이 발생할 수 있다는 얘기가 드는 거죠 그러니까 여기 있는 코드랑 여기 있는 코드랑 이 코드랑 이 코드랑 분리되어 가지고 실행이 되고 있기 때문입니다 그래서 예를 들면 여기서 Set Event를 때려가지고 반대쪽 자고있던 Thread를 깨워가지고 여기 있는 Thread가 일어나서 이 부분을 실행한다고 가정을 해볼게요 근데 이 부분에 의해서 깨어난 다음에 여기 락을 잡아가지고 실행하는 이 중간 사이에는 텀이 있기 때문에 지금 첫번째 프로듀서 스레드에서 , 이렇게, 이전과 마찬가지로 대기를 타는게 아니라 바로 다시 다음 루프를 타가지고 또 먼저 락을 요렇게 잡아버린다고 과정을 해볼게요 그러면 사실상 얘는 아직 데이터를 꺼내지도 않았는데 또 한번 데이터가 한번 더 들어간 그런 셈이 될 수도 있다는 얘기가 되는 거죠 , 이렇게, 단순한 상황 말고 , 사실, 프로듀서 컨슈머가 스레드 하나씩 하는게 아니라 어디선가 뭐 굉장히 다소의 스레드가 컨슈머 역할을 한다거나 하는 더 복잡해지는 상황이 있다고 하면은 뭐 당연한 얘기지만 이런 상황이 빈번하게 발생할 겁니다. 그러다 보니까 지금 이런 식으로 프로듀서 컨슈머를 딱 , 이렇게, 끊어가지고 만들게 되면은 실질적으로 데이터가 계속 누적이 되는 그런 상황도 발생할 수 있다는 얘기가 되는 거죠 물론 지금 당장 요 상황을 해결하기 위해서는 뭐 예를 들면 이걸 이쁜문이 아니라 와일문으로 해가지고 진짜 모든 데이터를 꺼낼 때까지 실행하는 그런 등등의 방법이 있겠지만 여기서 결국 중요한 거는 우리가 사용하던 이벤트랑 여기 있는 락이랑은 어떻게 보면 별개로 생각을 해야 된다는 얘기가 되겠습니다 물론 이거를 너무 쉽게 생각해서 그러면 어 여기 이벤트를 여기 안에다가 넣어주면 그 문제가 해결되지 않을까라는 생각이 들지만 , 사실, 그건 당연한 얘기지만 해결 방법이 아닙니다. 락을 걸고 여기서 이벤트를 실행하게 되면은 설령 얘가 여기 있는 wait for a single object를 때문에 얘가 일어났다고 해도 결국에 여기 이 락 코드에서 대기를 해야 된다는 상황은 똑같이 발생하는 것이기 때문에 그것 때문에 아까 얘기한 문제가 해결된다는 얘기는 아니에요. 그래서 결국에는 이 락이랑 이벤트는 독립적으로 생각을 해야 되고 그래서 대부분의 경우에는 이벤트를 사용한다고 해도 멀티스레드 환경이다 보니까 , 이렇게, 락도 병행해서 사용하는 경우가 굉장히 자주 등장하게 될 겁니다. , 자, 어쨌든 뭐 이벤트에 대한 마무리는 여기까지 하고 그래서 오늘 이제 새로 배울 부분이 하나가 더 있는데 그게 바로 Condition Variable 이라는 애입니다. 얘가 이제 표준에 들어간 애이기 때문에 얘를 이제 막바로 , 이렇게, 사용을 할 수가 있어요. 얘가 Mutex 헤드에 들어가 있을 겁니다. , 자, 이게 이제 이 Condition Variable 이 그냥 임의로 모든 애들이랑 다 동작하는 건 아니고 이 표준 Mutex랑 짝지어가지고 동작을 하는 거고 그게 아니라 조금 더 일반적인 상황으로 확장하고 싶으면 Condition Variable Any라는 애가 있습니다 근데 얘 같은 경우에는 따로 여기 있는 Condition Variable이라는 헤더를 추가를 해줘야지만 얘가 인식이 될 거예요 근데 오늘은 당장은 이 위에 있는 기본 버전을 살펴보도록 할 겁니다 , 자, 이 condition variable 같은 경우에는 우리가 , 사실, 이벤트를 사용했던 거랑 굉장히 비슷한 느낌이긴 한데 하지만 condition variable은 kernel object가 아니라 user level object라는 차이가 있습니다 kernel object가 아니라는 거죠 그러니까 어떻게 보면은 kernel level까지 가가지고 우리가 직접적으로 뭔가 요청했던 것과 달리 얘는 이제 user level에서 뭔가를 api 자체를 우리가 요청을 하는 거고요 근데 물론 내부적으로는 결국에는 우리가 , 이렇게, 사용했던 것 같이 이벤트를 호출해 가지고 이제 알아서 잘 작동을 하게 될 겁니다 네 그래가지고 이제 유저 레벨이랑 커널 오브젝트 커널 레벨에서 하는 거에 차이는 뭐냐면은 커널 레벨에서 동작하는 애는 우리가 다른 프로그램 끼리도 서로 그 이벤트를 이용해 가지고 뭔가 동교화를 할 때 사용할 수 있지만 유저 레벨의 옵젝트는 동일한 프로그램 내부에서만 사용할 수 있다는 차이가 있는 거죠 물론 이건 어디까지는 이론적으로 그렇다는 거고 어차피 우리 MMO 같은 경우에는 다른 그런 프로그램들이랑 뭐 교류를 해 가지고 하는 그런 개념은 아니기 때문에 뭐 딱히 상관은 없기는 해요 , 자, 그리고 이 condition variable 같은 경우에는 이제 뭐 의외로 생각보다 그렇게 어려운 개념은 아니고 , 사실, 이 이벤트랑 굉장히 비슷한 방식으로 동작을 하게 됩니다 근데 조금 다른 경우는 다른 것은 무조건 여기 있는 이 락이랑 짝을 지어 가지고 이제 동작을 하게 될 거예요 그래서 , 일단은, 코드를 사용하는 예를 한번 보도록 할 건데 , 일단은, 이 프로듀서 쪽에서는 4단계로 , 일단은, 전형적으로 이뤄지게 됩니다 1번 락을 일단 잡은 다음에 그 다음에 우리가 뭐 사용하는 그런 공우 변수 값을 이제 수정을 하게 될 거예요 그리고 3단계는 이제 락을 풀고 마지막으로 최종적으로 조건분수를 통해 가지고 다른 Thread에게 통질하는 요런 스텝을 전형적으로 밟게 됩니다 , 자, 그래가지고 지금 여기서 살펴보면은 락을 잡는다라는게 지금 여기 유닛 락으로 , 이렇게, 동작을 하고 있고 그 다음에 공유로 사용하는 그런 변수값을 수정하고 있죠 여기서는 지금 공유로 사용하는 큐에다가 데이터를 밀어넣는 작업을 하고 있고 그 다음에 여기 영역을 , 이렇게, 집어넣었으니까 락을 풀어주는 부분도 자동으로 실행이 될 거고 마지막에 여기서 이제 이벤트를 통해서 원래 다른 스레드에게 통제하던 요 부분이 이제 setEvent를 하는 게 아니라 conditionVariable를 이용해가지고 여기서 notify1을 이제 호출해주게 됩니다 notifyAll 같은 경우에는 모든 스레드에게 통지를 하는 거고 notify1을 하게 되면은 얘는 딱 하나의 스레드만 깨우게 될 겁니다 wait 중인 스레드가 있으면 딱 한 개를 깨운다라고 보시면 되겠어요 그래가지고 뭐 , 사실, 전반적인 그런 스텝은 , 사실, 우리가 이벤트를 사용한 거랑 , 일단은, 크게 다르지는 않다는 걸 알 수가 있습니다 , 이렇게, 4단계를 , 일단은, 거치게 될 것이고 그 다음에 반대로 컨실러 쪽에서는 이제 어떻게 작동을 해야 되느냐 요 부분이 일단 조금 다른데요 , 일단은, 얘는 시작을 할 때 요렇게 , 일단은, 락을 일단 잡아 주도록 할 것이고 그 다음에 여기서 웨이트를 요렇게 때립니다 근데 여기서 락을 넣어주는 건 기본이고 여기다가 버전이 하나가 더 있는데요 여기 아래 내려 보면은 predicate 이라는 걸 받아주고 있어요 조건을 받아주고 있습니다 이 조건은 뭐 함수를 넣어줘도 되고 람다를 넣어줘도 되고 어떤 콜러블 타입이건 상관이 없는데 일반적으로 일단 람다로 일단 넣어주도록 할게요 여기서 얘가 원하는 그 깨어나는 조건 자체를 여기다가 넣어주는 겁니다 예를 들면 여기서 우리가 언제까지 기다릴 거냐면은 Q가 비어있지 않을 때까지 기다리고 싶다 이게 바로 탈출 조건이라고 볼 수가 있는 거죠 이런 식으로 , 일단은, 코드를 작업을 해 줄 수가 있어요 그러면 이제 이 두 개의 코드가 굉장히 묘하게 동작을 하는데 이것도 다시 한번 스텝을 정리해 보자면 이 컨디션 베리어블에서 웨이트를 하는 순간 무엇을 하냐면 , 일단은, 맨 먼저 락을 잡으려고 시도를 할 것이고요 근데 물론 위에서 이미 락이 잡혔으면 여기서 락을 따로 잡진 않을 것이고 , 일단은, 락을 잡으려고 무조건 락을 잡으려고 합니다. 안 잡혔으면 여기서 잡으려고 시도하는 거고 이미 잡혔으면 이 1번 단계는 자동으로 통과가 되겠죠. 그 다음에 우리가 바로 이어서 넣어준 여기 있는 이 조건을 체크를 해볼 겁니다. 조건을 체크해서 만약에 그 조건이 만족하고 있다. 좋은 상태. 그러 나오면 바로 빠져나와서 이어서 코드를 진행합니다. 즉 만약에 이 큐가 mt가 false인 상태라고 했다면은 , 사실, 얘는 락만 잡고 여기 wait하는 부분이 사실상 뭐 아무것도 하지 않고 여기서 스킵을 하고 다음 코드가 실행된다는 얘기가 드는 거고 근데 여기서 만약에 만족하지 않는다 즉 이 조건이 만족하지 않는다는 거는 아직까지 이 큐 안에 어떠한 데이터도 없다고 하면은 , 자, 요 부분이 중요한데 여기서 락을 풀어주고 대기 상태로 전환합니다 그래가지고 우리가 이벤트에서 여기서 wait for a single object를 해가지고 그 대기상태로 뿅 빠졌던 거랑 어떻게 보면 굉장히 유사하긴 하지만 항상 100% 확률로 그렇게 대기상태로 빠지는 게 아니라 조건을 확인해가지고 이 조건을 따라가지고 내가 대기상태로 빠질지 아니면 이어서 실행할지가 결정이 되는 그런 부분이라고 볼 수 있는 거죠 그래서 이름도 condition variable이라고 해가지고 이 조건이라는 게 붙죠 정말로 조건부로 대기를 하겠다라는 의미로 , 일단은, 받아주시면 되겠습니다 그래가지고 여기서 이 웨이트를 할 때 유심히 보면은 첫번째 인자로 유닛 락이라는 걸 받아주고 있습니다 얘가 락가드라는 받아주지 않고 무조건 유닛 락으로 받아주는 이유는 여기서 내부적으로 이 웨이트함수 내부에서 이 락을 경우에 따라서 , 이렇게, 풀어줘야 되는 경우가 생기게 되기 때문에 그렇기 때문에 유닛 락 같은 경우에는 실제로 우리가 사용하는 락을 중간에 우리가 원하면 풀어주고 할 수 있는 그런 추가적인 기능이 있다고 했었죠 그래가지고 락가드를 사용할 수는 없고 이 유닛 락 버전으로 무조건 얘를 사용해야 된다고 보시면 되겠습니다 그래서 어찌됐건 여기서 이제 락이 잡혔다고 해가지고 항상 끝까지 락을 잡은 상태라고 생각을 하시면 안 되고요 이 웨이트라는 애가 내부적으로 특정 조건에 의해 가지고 어떤 상태에 의해 가지고 만족하지 않으면 잠시 락을 풀어준 상태에서 대기를 한다는 걸 이제 반드시 숙지하셔야 되겠습니다 하지만 그럼에도 불구하고 결국에는 여기 빠져나와 가지고 이 아래 단계로 왔다는 거는 다시 락을 잡은 상태라고 볼 수가 있는 거죠 만약에 여기서 웨이트를 해서 계속 다시 대기를 타고 있는 여기 이 두 번째 조건에 의해 가지고 대기를 타고 있는 상태에서 누군가가 여기 노티파이 1을 빵 때려주게 되면은 얘는 이제 웨이트 중인 상태에서 잠시 깨어나와 가지고 다시 한번 이 처음부터 스텝을 다시 밟습니다 그래가지고 다시 한번 락을 잡으려고 시도를 할 것이고 이 락을 잡아가지고 제가 획득했다고 하면은 역시나 똑같이 조건을 확인해가지고 만족하면은 그제서 빠져나오고 만족하지 못했으면은 또다시 락을 풀어주고 대기상태로 빠지게 됩니다 뭐 요렇게 동작을 하고 있어요 그래가지고 어떻게 보면은 뭐 이벤트랑 뭐 느낌적으로 느낌으로는 비슷하긴 한데 조금 동작방식이 다르기 때문에 , 사실, 우리가 지금 사용하는 요 코드에서는 훨씬 더 효율적이라는 걸 또 볼 수가 있습니다 왜냐면 애당초 요 부분이 어.. 조건을 만족하지 않아가지고 Q가 엠티 상태라고 한다면은 더이상 진행할 필요도 없기 때문에 굉장히 효율적으로 이제 약간 코드가 묶여가지고 동작을 하는 그런 느낌이라고 볼 수 있는거죠 , 자, 그리고 추가적으로 우리가 이전에 이벤트를 사용할 때는 반드시 모든 애들을 소모하게끔 하기 위해서 여기다가 이제 무한 루프로 와일문을 하나를 더 뒀는데 사실은 지금 컨디션 베리어블을 사용할 때는 애당초 이 조건 자체가 여기에 묶여가지고 들어가기 때문에 , 사실, 굳이 여기서 또 한번 체크를 할 필요가 없기는 합니다 애당초 여기서 락을 잡은 다음에 Q가 MT인지 아닌지 체크를 해가지고 넘어오기 때문에 만약에 Q가 Q에 뭔가 데이터가 없다고 하면 애당초 빠져나오질 않겠죠? 그러니까 요 부분을 생략할 수 있고 게다가 심지어 만약 데이터 하나만 여기다 소모하는 게 아니라 다음 루프에서 다시 한번 똑같이 여기다가 무한 루프로 만들어 놨으니까 다시 한번 이 루프를 돌면서 역시나 뭔가 데이터가 있는지 없는지 똑같이 한번 다시 , 이렇게, 체크를 하게 되겠죠 MT를 그러다 보니까 여기다가 무한 루프로 계속 뺑뺑이를 돌지 않는다고 해도 모든 데이터를 다 얘가 언젠가는 알아서 소모를 시킬 겁니다 어떻게 보면 일반적인 우리가 사용하는 그런 프로듀서 컨슈머 같은 , 이렇게, 공용큐를 사용해 가지고 데이터를 사용하는 거랑 어떻게 보면 잘 궁합이 잘 맞다고 볼 수가 있는 거죠 , 자, 그건 그렇고 이제 여기서 또 하나 좀 이상하게 생각할 수도 있는 거는 애당초 여기서 노티파이 원을 해가지고 땅 해가지고 여기다가 우리가 웨이트인 스레드를 애당초 다시 끼워 놨으면은 그러면은 사실은 뭐 굳이 조건을 체크할 필요 없이 뭔가 있다고 가정을 해가지고 진행을 할 수 있는 거 아닌가라는 생각을 하실 수도 있습니다 근데 그렇지는 않은 게 뭐냐면은 애당초 이 조건을 우리가 추가적으로 넣어주는 이유는 뭐냐면요 그러니까 결국엔 질문이 이거죠 지금 notify1을 했으면 항상 조건식을 만족하는 거 아닐까라는 생각이 들 수도 있겠지만 이런 상황을 스피리웨스 웨이크업이라고 합니다. 직역하면 약간 가짜 기상 같은 느낌인데요. 역시나 이벤트에서도 똑같이 발생한 문제지만 여기서 락을 잡아주고 풀어주는 거랑 여기서 조건변수를 노티파이 땅 때려주는 거랑은 분리되어서 별개로 동작을 하고 있기 때문에 여기서 우리가 노티파이를 딱 때려줘 가지고 얘가 다시 깨어나서 락을 잡고 어... 락을 잡을 때까지 또 누군가가 개입을 해가지고 끼어들어가지고 여기 있는 데이터를 자기가 꺼내서 사용한다거나 뭐 어찌 됐건 이 조건 자체를 현재 상태에서 뭔가 바꿔치기를 할 수 있기 때문에 그 상태에서 요 입장에서 보면은 얘는 진... 진작에 시그널을 받아가지고 이 노티파이 시그널을 뿅 받아가지고 일어났지만 다시 한번 확인해보니까 뭐야 내가 원하던 데이터가 없네라는 상황이 충분히 발생할 수 있다는 얘기가 되는 거죠 그런 걸 우리가 가짜 기상이라고 합니다 그래서 결국에는 이 문제 자체는 notify1을 할 때 정말로 우리가 락을 잡고 있는 것이 아니기 때문에 이런 문제는 항상 발생할 수 있기 때문에 , 이렇게, 추가적인 조건을 다시 한번 크로스체킹 한다고 보시면 되겠어요 , 자, 물론 또 하나의 질문은 뭐냐면은 이 조건을 반드시 지켜야 되는 것인가 이 락을 풀지 않고 이 4번을 예를 들면은 노티파이 1을 여기다가 안에다가 넣어주면 안 될 것인가 라는 질문도 생길 수가 있는데 , 이렇게, 해도 동작은 똑같이 합니다 그렇게 뭐 추천되지 않는 방법이긴 하지만 동작은 잘 해요 근데 여기서 문제는 뭐냐면은 여기서 락을 잡은 상태에서 우리가 노티파이를 딱 때려주고 있는데 이쪽에서는 이제 웨이트 상태에서 깨어나가지고 깨어나자마자 얘가 첫번째로 하려는거는 요 단계죠 락을 획득하려고 시도를 할겁니다 근데 에덩초이 위쪽에서 락을 풀어주지 않으면은 이 단계에서 계속 대기를 타면서 얘는 이제 락을 잡으려고 계속 시도를 할거에요 사실은 여기서 락을 잡고 하나 안하나 결국 별 차이가 없는게 이 깨어나는 쓰레드 입장에서는 얘가 일어나자마자 결국 얘도 경합을 해가지고 락을 잡으려고 하고 락을 잡으려면 얘가 락을 놔줘야지만 얘가 잡을 수 있다는 얘기가 되는 거니까 , 사실, 여기 안에 넣는다고 해가지고 뭔가 문제가 해결이 되는 개념은 아니라고 볼 수가 있는 거죠 네 이게 약간 좀 아리덜성한데 그래서 기본적으로는 락을 풀고 조건변수를 통해서 다른 쓰레드에게 통지를 하는 게 이제 정성적인 방법이라고 보시면 되겠어요 뭐 그러다 보니까 어찌됐건 이 락을 잡는 거랑 통지라는 시점이 조금 분리가 되다 보니까 어쩔 수 없이 이 아이 입장에서도 보면 기껏 이제 시그널을 받아 가지고 일어났더니만 내가 원하는 상황이 발생하지 않는 상황이 될 수도 있다는 그런 묘한 문제가 지금 발생하고 있는 거죠 그래서 뭐 어찌됐건 이 컨디션 베레블을 사용할 때 여기다가 우리가 원하는 조건을 이상적인 조건을 , 이렇게, 넣어 주다 보니까 얘가 어떻게 보면 조건부로 대기 상태가 되고 만약에 원하는 상태가 이미 만족된다고 하면 빠져나와 가지고 실행할 수 있는 굉장히 우아한 코드가 , 이렇게, 달성이 된다고 보시면 되겠습니다 그러면 이제 이거를 우리가 나중에 온라인 게임 서버를 만들 때 어떻게 응용을 할 수 있냐면 역시나 , 이렇게, 한쪽에서는 데이터를 밀어 넣고 한쪽에서는 데이터를 빼내 가지고 사용하는 상황이 종종 등장하게 될 수밖에 없겠죠 우리가 이벤트를 사용할 때도 똑같이 알아봤지만 뭐 예를 들면은 한쪽에서 클라이언트가 패킷을 쏴가지고 그 패킷이 도착해가지고 그게 컨텐츠 딴 큐에 들어가서 처리가 돼야 되는데 한쪽에서는 그걸 밀어주고 있고 반대쪽에서는 그 큐를 계속 체크를 하면서 뭔가 데이터가 있으면 이제 그걸 꺼내가지고 실행을 하는 그런 부분으로 로직이 분리가 되어있다고 가정을 할 때 무한정 데이터가 없음에도 불구하고 무한정 뺑뺑이를 돌면서 체크를 하는 것보단 , 이렇게, 없을 경우에는 조건부로 잠시 자기가 알아서 실행권을 놓아주고 대기상태에 빠지는 게 CPU 낭비를 아낄 수 있고 최대한 효율적으로 동작하는 방법이라는 걸 알 수가 있는 거죠 , 자, 그렇게 해가지고 , 사실, 결국엔 이벤트를 사용하는 거랑 굉장히 비슷한 느낌이긴 하지만 조금 더 얘가 우아하게 동작을 한다는 걸 알 수가 있었고 결국에는 그래가지고 실질적으로 직접적으로 , 이렇게, 옛날 방식인 생API를 이용해가지고 이 크리에이티 이벤트를 사용하거나 하는 방식은 , 사실, 잊으셔도 되고 어지간해서는 이 방법을 사용하기를 추천드립니다 컨디션 베리어블 이것도 이제 C++11에서 표준에 들어왔으니까 리눅스나 윈도우 진영 양쪽에서 다 공용으로 활용할 수 있는 방법이니까 어지간해서는 이 방법을 일단 추천드린다고 보시면 되겠어요 , 자, 이렇게, 해가지고 조금 내용이 길어졌는데 이 조건변수에 대한 내용도 이쯤에서 마무리를 짓도록 하겠습니다.