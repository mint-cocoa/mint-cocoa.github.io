자, 이렇게, 해서 지난 시간까지 이제 가벼운 데이터를 보내는 방법에 대한 어느 정도 결론을 얻었구요 문자열이나 바이트 배열 이라거나 아니면 일반 리스트를 어떻게 처리하는지 간단한 방법으로 , 일단은, 실습을 해봤습니다 그래서 이제 이번 시간부터 본격적으로 패킷 직렬화에 대한 연구를 진행을 할 건데 이게 이제 굉장히 다양한 스타일이 있고 또 깊이 들어가면 굉장히 어려운 내용이기도 합니다 그래가지고 최대한 좀 쪼개 가지고 여러 강의를 만들어 가지고 단계적으로 이제 학습을 하는 식으로 제가 진행을 해보고자 해요 그리고 나중에 설령 우리가 프로토 버프를 사용한다고 하더라도 프로토 버프와 또 하나의 옵션인 플랫 버퍼와의 차이에 대해서도 이해를 해야 되고 여러 가지 그런 이해도 측면에서 이런 걸 직접 한 번씩은 구현을 해보는 게 굉장히 많은 도움이 됩니다 그래가지고 패킷 직렬화에 대해서 연구를 해볼 건데 근데 제가 용어 설명을 아직 딱히 안 드린 것 같네요 패킷 직렬화라는 의미는 무엇일까 직렬화 이 용어가 , 사실, 온라인 게임뿐만 아니라 굉장히 자주 쓰이는 용어인데요 이걸 잠시 설명하기 위해서 메인으로 가서 설명을 드리도록 할게요 Packet 직렬화 이걸 소위 Serialization이라고 합니다 얘는 뭔가 직렬화라는게 뭔가 납작하게 만들어가지고 일렬로 만들다라는 느낌이 드는 단어입니다 근데 그러면은 우리가 Packet을 보내가지고 상대방이랑 통신을 할 때 왜 굳이 그냥 고제고대로 메모리에 있는 데이터를 다 보낼 수 없느냐부터 얘기를 해야 되겠죠 근데 이거는 제 입장에서는 너무나도 당연하다 보니까 이거에 대해서 생각조차 안하고 있었는데 제가 예전에 게임 학원을 한번 다닌 적이 있었는데 거기서 이제 저와는 다르게 이제 아예 그런 비전공자 입장에서는 이게 전혀 당연하지가 않더라구요 그래서 이 부분을 이제 꼭 언급해야 되겠다라는 생각이 들었었는데 예를 들면은 , 이렇게, 플레어라는 클래스가 , 이렇게, 있다고 가정을 해봅시다 그래서 뭐 이런저런 데이터를 갖고 있는데 여기서 뭐 HP도 들고 있고 공격력도 들고 있고 막 이런저런 데이터가 있어요 게다가 심지어 여기다가 상대방 내가 주시하고 있는 타겟 나의 적군은 누구인가와 같은 정보들도 들고 있고 그 다음에 뭐 예를 들면은 벡터로 뭐 다른 정보들도 들고 있다고 가정해볼게요 버프 아이디 같은 거 그러면 요런 상태에서 우리가 플레이어를 동적할당을 할 수가 있겠죠 예를 들면은 요런 느낌으로 플레이어 그러면은 여기서 동적할당에서 만들어진 그 모든 메모리 자체를 고대로 보내면 안될까라는 생각이 듭니다 근데 이거 , 사실, 직렬하는 얘기는 네트워크뿐만 아니라 파일 입출력에서도 똑같이 등장하는 얘기에요 근데 제가 굉장히 좀 재밌었던 사실은 이제 게임 학원에서 결국 하고 싶었던 건 뭐냐면은 그냥 이런 플레이어 데이터가 있었는데 그거를 네트워크 게임은 아니긴 하지만 싱글 게임 기준으로 세이브 로드 기능을 만들려고 했어요 어떤 친구가 그래가지고 이제 파일 입출력을 이용해가지고 그 친구가 한거는 그냥 여기 있는 모든 데이터를 고지곳대로 깨알같이 그냥 파일에다가 다 적어놨습니다 그 다음에 다음에 게임을 띄울 때 여기 있는 내용을 다시 고지곳대로 복원을 시켜가지고 실행을 해봤는데 뭐 당연히 크래시가 났겠죠 그래가지고 어? 이게 왜 크래시가 나지? 라는 굉장히 신기한 경험을 한 겁니다 근데 그게 어떻게 보면 당연한 게 뭐냐면은 , 자, 여기서 이런 HP랑 어치택 같은 정보는 아무 상관이 없어요 근데 사실상 요 플레이어가 동적할당이 되는 요 주소라는 것 자체는 가상 주소이기 때문에 얘는 프로그램을 실행할 때마다 계속 주소가 바뀝니다 그렇기 때문에 이전 상태에서 우리가 이전에 실행할 때 저장한 그 주소 자체를 당연히 save 파일에 저장하면 어차피 다음에 게임을 띄울 때는 그 정보는 더 이상 유효하지 않게 바뀌기 때문에 그것을 그렇게 고지곳대로 복원을 시킬 수가 없다고 보시면 되겠어요 마찬가지로 이 Vector라는 것도 결국에는 동적 배열이고 동적 배열이라 하면 내부적으로 어떤 배열을 들고 있는 그런 형태로 만들어져 있겠죠 그러니까 얘네들도 마찬가지로 그냥 고지곳대로 여기 있는 데이터를 그 배열 주소 같은 거를 파일에다가 적어봤자 아무런 쓸모가 없다는 얘기가 되는 겁니다 마찬가지로 우리가 이제 이 Player라는 정보를 클라이언트한테 보낸다고 가정을 해도 이 HP랑 어택은 상관없겠지만 이런 포인터 같은 주소를 메모리에 있는 거를 고지곳대로 포인터 값으로 그 주소 자체를 상대방한테 넘긴다는 거는 아무런 쓸모가 없다는 얘기에요 그래서 직렬화 한다는 얘기는 결국에는 여기 있는 모든 정보들을 납작하게 요렇게 어떤 바이트 배열 같은 거로 , 이렇게, 납작하게 만들어가지고 우리가 상대방한테 보내줄 수 있게 만들어준다라는 , 일단은, 의미로 받아주시면 되겠습니다 사실상 지금 구조상으로 HP랑 Attack도 있겠지만 이 Target이라는 포인터 자체는 다른 주소를 가리키고 있는 거죠 그렇기 때문에 잠시 그림판을 켜가지고 보여드리자면 예를 들면은 이런 느낌입니다 , 자, 펜을 들어가지고 플레어라는 정보가 요렇게 있는데 여기서 HP Attack이 있고 그 다음에 Target이라는 정보가 있는데 요 Target은 또 다른 메모리 공간을 요렇게 가리키고 요런 형태로 지금 있다는 거죠 마찬가지로 버프라는 애도 결국에는 동적 배열이다 보니까 , 이렇게, 다른 메모리에 있는 어떤 일련의 주소값을 이용해가지고 접근을 하는 그런 형태라고 볼 수가 있는 거죠 딱 봐도 뭔가 메모리가 메모리 상에 존재하는 데이터들은 이리저리 막 이런저런 주소들을 차지하고 있는데 이거를 serialize 한다 라는 의미는 결국에는 얘를 납작하게 만들어 가지고 모두가 이해할 수 있는 그냥 하나의 데이터로 쫙 이어서 만드는 개념이라고 , 일단은, 생각을 하시면 되겠습니다 그럼 반대로 여기 있는 데이터들 이용해가지고 얘를 다시 복구하는 거는 역직렬화라고 하는 거죠 뭐 근데 그건 딱히 중요한 용어는 아니고 그래가지고 이 직렬화하는 개념이 결국에는 메모리에 있는 데이터를 , 이렇게, 바이트 배열로 쭉 만들어준다라는 거로 , 일단은, 봐주시면 되겠어요 그리고 우리가 하고 있는 것도 결국에는 그걸 위한 연구다라고 볼 수가 있는 거죠 그래서 벡터랑 스트링 같은 것도 뭐 고지곳대로 그냥 요기는 정보를 그냥 복붙하는게 아니라 항상 이런식으로 데이터를 꺼내가지고 카운트도 놓고 막 온갖 난리를 쳤던 이유도 , 사실, 이런 이유였습니다 , 자, 이게 뭐 직렬화에 대한 용어 설명이었구요 어... 그 다음에 그러면은 이제 이거에 대해서 본격적으로 연구하기 전에 이전에 만들었던 부분, 즉 요 부분 어딨나요 , 자, 요 부분부터 일단 시작을 해보도록 할게요 이게 사실상 우리가 뭐 직렬화에 대한 어떤 부분 기초 단계를 지금 계속 하고 있던 거고 만약에 여러분들이 그냥 엄청나게 큰 규모의 게임을 만드는 게 아니라 간단한 포포를 만든다고 하면은 , 사실, 여기까지만 만들어도 그냥 충분하고 넘칩니다 왜냐면 저도 실제로 제가 이전에 보여드렸던 와우포플은 와우포플 같은 경우에 그냥 요런 형태로 만들었어요 제가 그때는 학생이었기 때문에 그냥 뭐 요런 정보들을 하나하나씩 그냥 집어 넣어가지고 이런 함수 단위로 묶어가지고 얘네들을 재생하는 형태로 만들었고 어차피 그런 작은 게임이라고 한다면은 패킷 자체가 한 10개에서 20개 사이면은 충분하게 사용할 수 있기 때문에 , 이렇게, 사용할 수가 있었어요 근데 이제 좀 진지하게 큰 규모 게임을 만든다고 하면은 요렇게 만드는거는 살짝 여러가지 문제들이 이제 등장하게 될겁니다 뭐 , 일단은, 간단하게 생각을 해보면 뭐 요런 함수들을 일일이 만드는 것도 굉장히 끔찍하다는 생각이 들죠 이거 뭐 너무 반복적인 작업도 많고 게다가 이리저리 또 고치다 보면은 여기다가 중간에 뭐 추가하는 데이터도 생길 수가 있을 텐데 이 추가하는 순서를 잘 지키지 않으면 예를 들면은 ID 다음에 HP가 오는데 이 사이에 뭔가를 낑겨넣어야 되는데 반대로 이쪽에서는 그 순서를 지키지 않았다거나 한다고 하면은 프로그램이 아예 그냥 깨져가지고 이상하게 동작을 하는데 그걸 한참 후에 눈치챈다고 하는 일도 발생할 수 있을 거예요 근데 , 사실, 그건 엄밀히 말하면은 뭐 그렇게 큰 문제는 아니라고 볼 수가 있는 게 나중에 실무에 가면은 이런 것들은 다 자동화를 해서 처리를 합니다 , 이렇게, 반복된 코드를 우리가 일일이 만들고 있지는 않아요 그래서 이제 원본 패킷 자체를 설계를 어디서 들고 있느냐가 좀 중요한데 우리는 지금 이거를 제가 간단한 예를 들기 위해서 이게 우리의 원본 패킷 설계다 라고 , 이렇게, 보여드리고 있기는 한데 근데 , 이렇게, 만들면은 또 다시 한번 , 예를 들어, 가지고 우리가 서버는 simple pull로 만드는데 클라이언트는 뭐 C sharp unity를 붙인다 라고 하면은 조금 아쉬워지는게 유니티에서는 요 벡터랑 더블 리스팅이라는 개념이 없다 보니까 이게 환경을 타는 표현 방법이긴 하죠 그래서 일반적으로 만약에 프로토 버프 같은 구글 것을 사용하지 않고 자체적인 패킷 포맷을 만드는 경우에는 대부분 XML이나 JSON 둘 중 하나를 골라서 사용합니다 제가 일했던 프로젝트 중에서 XML을 사용하는 데도 있었고 JSON을 사용하는 데도 있었어요 XML, JSON에 대한 개념이 아직 없을 수도 있으니까 잠시 보여드리자면 구글에서 잠시 , 이렇게, 찾아보자면 이 왼쪽이 XML이고 오른쪽이 JSON입니다. JSON은 자바스크립트 언어문법에서 파생된 데이터 표현 방법이고 지금 이 둘의 차이를 딱 보시면 느끼겠지만 얘가 훨씬 더 간략해 보인다는 걸 알 수가 있어요. 간략하고 그렇다 보니까 당연히 파싱 속도도 빠르고 그냥 더 빠르게 동작을 합니다. 근데 왼쪽 같은 경우에는 조금 더 지저분해 보이긴 하지만 단점만 있는 건 아닌 게 , 이렇게, 계층 구조가 굉장히 확연하게 표현이 된다는 장점이 있어요. 근데 우리가 패킷 설계를 할 때 만약에 리스트 안에 리스트가 들어가고 이런 식으로 중첩이 여러 번 일어난다고 하면 , 사실, 이런 XML 형태로 표현하는 게 조금 더 가독성이 좋을 수 있기는 합니다. 그래서 XML을 , 일단은, 사람이 읽기에 가독성이 조금 더 좋을 수 있다는 게 장점이라고 볼 수 있는 거고 그 외에 속도 라거나 나머지 부분은 JSON이 훨씬 더 우월하다고 , 일단은, 볼 수가 있겠어요. JSON에서 이건 자바스크립트 문법이랑 연결이 되는 건데 이 첫 번째 모양, 이렇게, 된 모양이 리스트라고 생각하시면 됩니다 이게 일단 배열의 의미라고 생각하시면 되는 거고 즉 유저라는 거는 유저가 여러 개짜리로 , 이렇게, 리스트가 있는데 각각 데이터는 , 이렇게, 과로로 지금 표현을 하고 있고 얘가 일종의 스트럭트라고 보시면 되는 겁니다 이 부분이 리스트, 이 부분이 스트럭트라고 분석을 하면 굉장히 잘 읽혀요 코드가 각각의 데이터가 , 이렇게, 들어가 있습니다 라고 볼 수가 있는 거죠 John 22 Mary 21 이런 식으로 똑같은 데이터를 양옆에서 표현하고 있는 거예요 그래서 이제 둘 중 하나를 표현해 가지고 원본 패킷에 대한 그 정의를 이제 관리를 한 다음에 요런 부분을 이제 파싱 해 가지고 툴을 만들어 가지고 이런 식으로 자동화 되는 그런 코드를 이런 코드들 자동화 처리를 하게 되면은 아까 얘기했었던 혹시라도 오타를 내면 어떡하지 이거 잘못 만들면 어떡하지 라는 문제들을 싹 날릴 수가 있다는 얘기가 되는 겁니다 그래서 간단하게 그냥 뭐 xml 파일을 하나 만드는 실수만 해보자면 여기서 추가 세 항목에 간 다음에 , 일단은, 그냥 더미 클라이언트 쪽에만 간단하게 한번 보여드리도록 할게요 여기서 웹 쪽에 가면은 xml 파일이라는 게 있죠 xml 파일에서 대문자로 pdl 이라는 이름으로 만들어 보도록 할게요 이게 제가 예전에 얘기했던 프로젝트에서 사용하던 이름이었는데 마음에 들어가지고 packet definition list라는 약자였습니다 , 자, 이렇게, 일단은, 만들어 주고 처음에 시작하는 거는 그냥 이 xml 파일에 대한 정보를 요렇게 표시를 하고 있는데 이건 그냥 냅두시면 됩니다 그래가지고 이제 이런 식으로 , 사실, 딱히 설명을 안 드려도 그냥 보다 보면 이게 익숙해서요. pdl이라는 걸 이제 사용할 것인데 이게 약간 계층 구조를 잘 표현한다고 했었죠. 패킷이라는 걸 우리가 만들 것인데 잠시 이걸 오른쪽에다 놔서 살펴보면 지금 이 형태를 우리가 예를 들면 xml로 표현한다고 가정해봅시다. 패킷 이름은 sunderbar-test 이거 Description은 그냥 뭐 테스트 용도다 라고 , 이렇게, 하고 , 이렇게, 닫아 주도록 할게요 그럼 이게 이제 하나의 Packet 이다라는 정의를 나타내는 거고 여기서 나오는 Packet, Name, Description은 그냥 우리가 임의로 정해 준 것이고 나중에 요런 애들을 우리가 툴에서 파싱 해가지고 인지를 해가지고 만약에 이 Packet 이라는 단어가 등장하면 얘는 Packet을 의미한다라고 그냥 이해를 하고 툴을 만들어주면 됩니다 , 자, 그 다음에 뭐 예를 들면 그 다음에 이 패킷 하나는 요런 식으로 각각 정보들을 다 포함하고 있죠 예를 들면은 name은 id 이 필드는 그 다음에 type은 uint64. description, 뭐 옵션으로 우리가 뭐 이런저런 주석이나 설명을 하기 위해서 , 이렇게, 만들 수 있고요. 그 다음에 , 이렇게, 닫으면 되는데 만약 여기 안에 데이터가 없다고 하면은 얘를 이런 식으로 닫아도 되지만 그냥 얘를 한 방에 그냥 , 이렇게, 닫아도 됩니다. 네, 이런 문법도 이제 똑같이 유유해요. 그래가지고 안에는 필드가 있는데 필드에 대한 정보를, 속성을 지금 , 이렇게, 놓고 있습니다. name은 id고 type은 uint64짜리다. 그래서 이런 식으로 , 일단은, 만들어 줄 수가 있습니다. 그래서 이런 식으로 계속 추가를 해 줘 가지고 name과 hp 그리고 attack이라는 게 있고 uint 얘는 32, 얘는 uint 16짜리다. 여기 있는 내용들도 역시나 우리가 임의로 정한 그런 이름들이기 때문에 이 규약에 맞게끔 툴을 만들어주면 되겠습니다. 그 다음에 리스트가 등장하는데 리스트를 만들어줄 것인데 리스트의 이름은 지금 우리가 버프라는 이름으로 만들어놨고 그 다음에 디스크립션은 그냥 비워두도록 할게요. 그 다음에 리스트는 또 버프데이터라는 요 정보를 이용해 가지고 만들어진 거니까 얘 둘을 복붙한 다음에 , 자, 버프 아이디랑 그리고 리메인 타임이라는 게 있다 근데 버프 아이디는 uint 64짜리 타입이고 그 다음에 얘는 리메인 타입 아이고 리메인 타입이 아니라 float죠 타입은 float다 라는 이런 식으로 우리가 패킷을 표현할 수가 있을 거에요 이런 식으로 하나의 패킷을 묘사하는 걸 만들어 주면은 이게 설명 c샵이건 c++이건 이 정의 자체는 변하지 않다 보니까 이걸 이용해 가지고 c샵 환경 코드와 c++ 환경의 코드가 생성되게끔 이제 유도를 해주면 됩니다 그런 식으로 만약에 만들어 준다고 하면은 아까 얘기한 그런 복붙과 관련된 문제 아니면 실수할 여지 등등은 다 날라간다고 일단 볼 수가 있겠어요 그러니까 결국에는 뭐 실수의 여지 자체는 딱히 신경 쓸 필요 없다라는 결론을 내릴 수가 있는 거고 , 자, 그러면 그 다음에 이제 와 가지고 그 다음 단계에 대해서 고민을 해볼게요 이걸 자동화할 수 있다고 그냥 가정을 하고 그 부분은 일단 생략하지 않을 것이고 그러면 이 부분에 대해서 또 추가적으로 우리가 만약에 좀 진지하게 게임을 만든다고 했을 때 처리해야 될 부분이 무엇인지 또 고민을 해봅시다 제가 이전에도 잠시 언급을 드린 적이 있지만 나중에 가면 특히 서버 쪽은 보안이 굉장히 중요하다고 말씀을 드렸었죠 왜냐하면 지금 이 패킷 사이즈를 통해 가지고 그거를 조립을 해가지고 패킷 세션 이라는 데서 우리한테 일단 넘겨주고 있죠 요 부분에서 어 이게 다 조립이 되었다고 얘가 인지를 하면은 그 다음에 on receive 패킷을 호출해 줘 가지고 넘겨주고 있는데 요기 있는 사이즈라는 거 자체는 항상 100% 신용할 수 없다고 했습니다. 그래서 그거를 어딘가에서 즉 여기 패킷 핸들링 하는 쪽에서 이게 진짜 정상적인 패킷인지 걸러줄 수 있다고 했었죠. 그런데 지금 이 상태에서 그 부분을 만약에 우리가 걸러야 된다고 하면 어떻게 할까 고민인데 , 사실, 뚜렷한 방법이 없습니다. 왜냐면 만약에 이런 가변 데이터가 없었다고 하면은 이 S-Underbar 테스트라는 패킷 자체가 크기가 얼마인지가 딱 한 번에 개선이 되죠 지금 여기 int u24가 8바이트 얘가 4바이트 그리고 얘가 2바이트다 보니까 총합 14바이트입니다 라는 결론을 얻을 수가 있고 그걸 이제 여기서 if모드로 그냥 한 번만 체크하면 통과가 되겠지만 이제 이런 식으로 가변 데이터가 등장하는 순간 그런 과정이 살짝 꼬이기 시작을 합니다 우리가 지금 이 방법으로 만들어주게 되면 유일하게 우리가 할 수 있는 방법은 그냥 순서대로 하나씩 하나씩 파싱을 해보는 방법밖에 없어요 그래가지고 우리로 치면 지금 여기까지 쭉 파싱을 한 다음에 이제 이 부분에 대해서야 이 버프 카운트를 추출해야지만 해야지만 이 버퍼라는 애가 몇 개의 데이터를 지금 들고 있는지를 알기 때문에 걔를 추출할 수 있고 그 얘가 완전히 파싱이 끝나야지만 그 다음 데이터인 이 네임이라는 걸 우리가 이어서 추출을 할 수가 있었죠 그러니까 미리 이 네임이 얼마짜리 인지를 예상할 수 없다는 문제가 지금 있는 겁니다 그래서 지금 제가 얘기하고 있는 이 방법이 굉장히 간단하고 직관적인 건 맞지만 이게 이런 단점이 좀 있어요 유일하게 지금 그러면 고려할 수 있는 거는 애당초 이 꺽쇠기 표시에서 뭐 이런 식으로 데이터를 빼낼 때 여기서 validation 체크를 해가지고 우리가 read를 할 때 예를 들면 이 read 버전에서는 항상 true, false를 반환해가지고 얘가 지금 공간이 충분한지 아닌지를 , 이렇게, 판단하는 식으로 작업을 하고 있었죠 그거와 마찬가지로 얘를 데이터를 뽑을 때마다 이게 지금 가능한지 데이터가 초과되지 않았는지를 체크하는 식으로 , 일단은, 만들 수가 있기는 할 거예요 근데 이게 굉장히 딱 봐도 좀 그렇게 우아한 방법은 아니라는 생각이 들죠 왜냐면 , 이렇게, 데이터를 밀어넣고 파싱하는 부분은 이제 두고두고 온라인 게임에서 정말 정말 정말 자주 일어날 텐데 데이터를 하나 추출할 때마다 그 사이즈가 유효한지를 매번마다 체크하는 거는 너무나도 낭비가 심한 일이 될 겁니다 이런 부분을 우리가 우아하게 처리해가지고 좀 빠르게 처리할 수 있다면 굉장히 큰 성능 향상을 우리가 볼 수가 있겠죠 , 자, 그래가지고 좀 서론이 길었는데 이제부터 연구할 부분은 , 이렇게, 다양한 시뮬레이션 기법들에 대해서 , 일단은, 알아보는 게 일단 주제라고 일단 볼 수가 있겠어요 , 자, 그럼 이제 다시 돌아와 가지고 오늘 이제 약간 발상의 전환을 한번 해 보도록 할 건데요 일단 여기 가변 데이터는 잠시 주석 처리를 하고 얘가 없다고 가정을 하고 기초부터 다시 한번 고민을 해 보도록 하겠습니다 그냥 s-underbar 테스트라는 패킷을 보내야 되는데 걔가 지금 , 이렇게, 세 가지 데이터만 우리가 보내야 된다고 가정을 해 볼게요 , 자, 그러면은 뭐 지금까지 우리가 하고 있던 요 방식을 이용해 가지고 뭐 팟싱을 해도 되기는 하지만 근데 이걸 좀 발상을 전환해 보면 하나 느낄 수 있는 부분은 애덩초의 S 테스트라는 사이즈를 우리가 단반에 알 수가 있겠죠 그래가지고 여기서 이 사이즈를 한 번에 체크해 가지고 데이터가 초과하지 않는지, 그러니까 데이터가 충분한지 얘를 파싱할 수 있는지를 먼저 판별할 수 있을 겁니다. 게다가 또 하나, 또 재밌는 사실은 생각해보니까 여기서 id, hp, attack을 각각 , 이렇게, 만들어가지고 추출을 해도 나쁘진 않겠지만 왜 , 이렇게, 하면 안 될까라는 생각이 들죠? 그냥 이거를 뭐 예를 들면 packet이라고 한 다음에 막바로 packet이라는 거를 요렇게 추출하면 되지 않을까라는 생각이 듭니다. 아 이게 이름이 겹쳐서 그런 거네요 S 테스트가 지금 , 이렇게, 있으니까 얘를 PK 패킷 S 테스트라고 일단 이름을 바꿔줄게요 그러면 사실상 요 코드랑 요 코드랑 똑같은 의미다 보니까 생각해보니까 얘를 그냥 바로 추천하면 되지 않을까 라는 생각이 일단 1차적으로 듭니다 , 자, 근데 여기서 한가지 조심해야 될 부분이 있는데 잠시 게임 세션으로 돌아가가지고 아이고 여기서 테스트를 해볼게 뭐냐면은 만약에 우리가 이런 구조체가 있다고 가정을 해볼게요. 그럼 과연 얘가 우리가 예상한 대로 8, 4, 2 즉 14바이트를 정확히 차지할 것인가가 굉장히 궁금한데 여기서 하나 조심해야 될 거는 만약에 순서가 , 이렇게, 꼬여있다고 가정을 해볼게요. 이걸 역으로 진행을 해서 이런 순서로 만약에 만들어 준 다음에 여기서 그냥 임의로 Packet 이라는 걸 하나 , 이렇게, 만들어 보도록 하겠습니다. , 자, 그 다음에 packet.hp는 1, packet.id는 2, packet.attack은 3 이라고 아무런 숫자나 놓고 잠시 얘를 빌드 해가지고 여기서 블랙포인트를 잡아보도록 할게요. , 자, 그럼 여기서 실행이 되면 브레이크 포인트가 딱 잡혔고요. 그 다음에 이 패킷이라는 게 1, 2, 3이라는 값이 잘 들어가 있는 건 맞는데 여기서 창 메모리에 가서 주소를 한번 까보도록 합시다. 메모리가 어떻게 들어가 있는지. 패킷 주소. 그 다음에 이거를 1바이트 단위로 지금 , 이렇게, 살펴보면 뭔가 좀 이상하다는 걸 알 수가 있어요. 여기까지는 1이 들어간 건 맞는데 4바이트 짜리로 1이 들어간 건 맞는데 바로 이어서 2라는 값이 들어가는 게 아니라 중간에 ccc라는 이상한 쓰레기 값이 , 이렇게, 들어가 있다는 걸 볼 수가 있습니다 그래서 실질적으로 우리가 sizeof pktest라는 것을 여기다 쳐보면 저는 위에 해봤지만 sizeof 패킷 이라는 걸 쳐 보면은 얘가 24 바이트로 나온다는 걸 알 수가 있어요 아니 이게 왜 순서가 안 맞지 산수가 안 맞지 싶은데 이게 이제 바이트 정렬이랑 관련이 있습니다 컴퓨터가 우리가 64 비트 환경에서 실행을 할 때는 기본적으로 8 바이트 배수의 주소로 접근을 해야지 빠르게 접근을 해서 데이터를 뽑아올 수가 있습니다 그래가지고 가장 큰 애를 기준으로 나머지 애들을 정렬을 시켜주기 때문에 실제로는 얘가 지금 8 8 8 로 요렇게 지금 잡히게 된 거예요 그래서 사실상 얘가 32 비트만 사용하지만 나머지 32 비트는 그냥 사실상 요런 느낌으로 뭔가 더미 데이터를 , 이렇게, 놓은 셈이 되는 겁니다 쓰레기 값으로 정렬을 시켜주기 위해서 그냥 , 이렇게, 구멍을 낸 거죠 여기도 마찬가지로 나머지 데이터들 구멍을 냈고 그러다 보니까 이게 우리가 예상한 대로 정확하게 사이즈가 일치하지 않는다는 문제가 있어요 네트워크 상의 데이터를 흘려 보낼 때는 우리가 이런 식으로 직렬을 해서 밀어주게 되었다고 하면은 처음에 우리가 예상한 요 순서대로 4바이트 8바이트 2바이트가 들어가야 되는데 그게 아니라는 거죠 근데 이거는 뭐 큰 문제는 아니라는 게 뭐냐면은 우리가 컴파일러한테 힌트를 줄 수가 있어요 프레그마 팩 1 이라고 해가지고 1바이트 단위로 데이터를 우리가 나열할 것이다 그래가지고 사실상 요렇게 만약에 만들어주면은 아이고 여기서 프레그마 팩 , 이렇게, 일단 만들어주면 아까 일어났었던 그 구멍이 뚫리는 현상이 , 일단은, 없어지게 될 겁니다. 그래서 이 환경에서 똑같이 다시 한번 진행을 해보면 이제는 사이즈 오브 패킷이 14로 정상적으로 우리가 예상한 대로 출력이 되는 걸 볼 수가 있어요. 그래서 항상 패킷을 만들 때는 만약에 우리가 맨 위에다가 프레그마 팩 1과 끝낸다고 해가지고 얘를 , 이렇게, 양옆으로 감싸주게 되면은 , 일단은, 아까 일어났던 그 메모리가 우리가 예상한대로 개선이 되지 않는 문제는 , 일단은, 해결이 될 겁니다. 그래서 1차원적으로 , 자, 이렇게, 일단은, 어찌됐건 만들어놨어요. 그래가지고 얘를 추출할 때 , 이렇게, 한방에 추출할 수 있다 라는 결론을 얻을 수가 있는거죠. 만약에 여기서 패킷에다가 이 패킷 헤더까지 만약에 같이 포함한다고 가정을 해볼게요. 그러면은 여기서 이제 정보가 모든 애들이 공통적으로 들고 있는 정보도 Packet Size랑 Unit 16, Packet ID 즉 요 아이는 공용 헤더가 될 것이고 얘까지 만약에 포함해준다고 하면은 요 부분도 날릴 수가 있겠죠? 요렇게 한번에 테스트를 빵 해가지고 추출할 수가 있을 겁니다 , 자, 그러면은 이제 요 상태라고 하면은 벨리데이션 체크가 굉장히 단순하죠 우리가 처음에 데이터를 , 이렇게, 핸들 테스트를 실행할 때 딱 한 번만 이 렌스 우리가 지금 들고 있는 요 버퍼의 크기가 최소한 사이즈 오브 PK 패킷 테스트보다는 갖거나 커야지 말이 되는건데 그게 아니라고 하면은 그냥 데이터가 뭔가 불충분하게 끊겨서 갖고 뭔가 이상한 상황이라는 얘기가 되는거니까 요 사이즈 자체가 뭔가 거짓말을 쳤다고 가정을 할 수 있겠죠 그러다보니까 이걸 , 이렇게, 그냥 바로 리턴을 때려주고 나머지는 그냥 , 이렇게, 파싱을 하면 될겁니다 뭐 굉장히 재밌는 그런 현상이죠 , 자, 그리고 그 다음으로 이제는 그러면 여기까지는 , 사실, 뭐 그렇게 크게 어려운 부분이 없었지만 이제 이 버퍼를 다시 등장시켜 보도록 할게요 이런 식으로 만약에 어떤 버퍼가 등장을 했다 가변 길이의 버퍼가 등장했다라고 하는 거죠 즉 PDL로 치면 마침 PDL에서 여기 이름은 빼놨네요 그래서 지금 딱 요 상황이 되었다고 , 일단은, 가정을 해 보도록 할게요 , 자, 그러면은 여기서 우리가 이전에 만들었던 요 방식 버퍼 카운트를 먼저 밀어 놓고 그 다음에 데이터를 밀어 놓는 방식으로 만들어 주면은 이제 정확하게 사이즈 계산이 한 번에 되지가 않는다는 문제가 있어요 , 자, 그래서 이거를 어떤 식으로 어 좀 굉장히 재미있는 아이디어이긴 한데 어떤 식으로 응용할 수 있냐면은 먼저 , 자, 이렇게, 공용 데이터를, 그러니까 고정된 크기의 데이터들을 , 일단은, 다 몰빵을 시켜 놓을 겁니다 그래가지고 처음에는 pk-s 테스트가 일단 들어가게 될 거예요 그리고 원래 요 버퍼라는 어... 가변 길이의 데이터가 있는 자리에는 당장 데이터를 밀어 넣지 않을 것이고 그 해당 위치에는 우리가 이 가변 길이의 버퍼의 정보를 나타내는 헤더를 우리가 여기다가 놓을 겁니다 예를 들면 버퍼의 offset 그 다음에 버퍼의 count라고 일단 이름 지을게요 이 버퍼는 이 데이터 버퍼로 의미하는 게 아니라 진짜 이 디버프 할 때 그 버퍼를 얘기하는 겁니다 즉 이 아이를 묘사하고 있는 정보를 두 개를 , 이렇게, 놓을 건데 uint16 두 개로 , 일단은, 세트를 묶어 가지고 일단 , 이렇게, 놓도록 하겠습니다 이게 일단 굉장히 재밌는 아이디어예요 그래서 이제는 어떻게 하는 거냐면 이 PKS 테스트는 무조건 , 이렇게, 고정적인 사이즈임은 변함이 없고 그 다음에 가변적인 데이터들은 그 뒤에다가 여기다가 이제 밀어 넣어줄 겁니다 이게 , 일단은, 첫 번째 차이라고 보시면 되겠어요 즉 여기다가 우리가 지금은 세션에서 보낼 때 데이터를 아마 3개 보냈던 걸로 기억을 하는데 그럼 지금 구조상으로는 , 이렇게, 되는 거죠 이런 느낌으로 데이터가 , 일단은, 요렇게 바뀌게 될 겁니다 그래서 요 부분은 , 일단은, 이 코드에 의해가지고 정상적으로 한 번에 파싱이 될 것이고 그 다음에 요게 있는 데이터를 참고해가지고 이제 뒤에 있는 데이터의 크기를 한 번에 빵 개선을 해가지고 이게 진짜로 맞는 얘기인지를 판별하면 된다는 얘기가 되는 거죠. 그래가지고 지금 예를 들면 이 상태가 있다고 가정하고 그리고 이 버퍼 데이터라는 거는 어찌됐건 이 패킷에 속해 있는 애죠. 지금 이 구조상으로 이런 느낌이기 때문에 , 일단은, 여기 안쪽에다가 , 이렇게, 넣어주도록 할게요. , 자, 이런 상황이라고 , 일단은, 가정을 해보도록 할게요 , 자, 그러면은 여기서 만약에 우리가 밸리데이션 함수를 맞는다고 가정을 해봅시다 지금 우리가 얘기하고 있는 패킷의 내용이 지금 정상적으로 처리가 되고 있는지 밸리데이션 체크를 한다고 하면은 사이즈 계산을 먼저 해보면 되겠죠 사이즈를 계산할 것인데 최종적으로 우리가 예측한 상황이 맞는지를 테스트를 해볼 겁니다 먼저 어떤 사이즈가 있어야 되냐면 패킷 S 테스트라는 아이의 사이즈만큼을 먼저 추가해 주도록 하겠습니다. 그 다음에 이어가지고 가변 데이터의 길이가 요만큼인데 이거는 어떻게 알 수 있냐면은 여기 있는 버프 카운트라는 걸 이용해가지고 우리가 알 수가 있을 거예요 그러니까 역시나 버프 카운트에다가 사이즈 오브 버프 데이터를 , 이렇게, 더해주면 되겠죠 , 자, 근데 이 이름이 버프 데이터라고 하니까 조금 헷갈릴 수 있으니까 버프 리스트 아이템이다라는 의미로 좀 이름을 수명해 보도록 합시다 버프 리스트 아이템 이걸 나중에 자동화 처리한다고 하면은 요런 네임 컨베이션이 중요하니까 요렇게 , 일단은, 네임 컨베이션을 정해 주도록 할게요 그래서 이게 뭐 요런 느낌으로 되는 거죠 이제 , 자, 그래가지고 요 사이즈를 두 개를 더하면 요 크기에다가 가벼운 길이의 크기는 요기 버프 카운트에다가 각각의 얘가 3개 있다는 걸 알고 그 다음에 각각의 크기를 사이즈오브 버프리스트 아이템으로 계산할 수 있으니까 요렇게 사이즈를 한 번에 뾰롱 계산을 해줄 것이고 이게 만약에 처음에 얘기한 패킷 사이즈랑 다르다고 하면은 뭔가 문제가 있는 상황이니까 return false를 때려주면 될 겁니다 그 다음에 요 offset은 무엇을 의미하냐면은 이 offset은 이 0번 시작 기준점을 패킷 시작점 위치를 기준으로 해당하는 이 가변 데이터가 언제 등장하는지를 나타내는 겁니다 그러니까 지금으로 치면은 이 패킷 s 테스트 다음에 요 공간이 이제 버프 리스트 아이템이 시작하는 그 인덱스다 보니까 그 인덱스가 이 버프 옵셋으로 , 일단은, 들어가게 될 거예요 그래서 요 숫자도 일단 체크를 해봐 가지고 지금 이 옵셋 범위가 정상적으로 지금 들어가 있는지를 체크하자면 여기서 또 한번 체크를 하면 되겠죠 버프 옵셋이 요기 있는 데이터 가변 데이터의 시작 위치라고 했으니까 여기서 역시나 버프 카운트에다가 사이즈오브 버플리스트 아이템을 더해준게 얘가 우리 패킷 사이즈 범위 안에 들어가 있는지를 체크하면 되겠죠 얘를 초과해가지고 엉뚱한 곳으로 간다고 하면은 애당초 여기 옵셋이라는 것 자체가 거짓말 해가지고 이상한 어 인덱스를 가리키고 있다는 얘기가 되는 거니까 그러면은 문제가 있다는 얘기로 이제 인지를 하면 될 겁니다. 그래서 얘가 만약에 패킷 사이즈보다 크다라고 하면은 어 문제가 있네 뭔가 이상한데 라고 , 이렇게, 리턴 펄스를 빵 때려주면 된다는 얘기가 되는 거죠. , 이렇게, 하면은 우리가 순차적으로 데이터들을 , 이렇게, 긁을 필요가 없이 가변 데이터들은 뒤로 밀어주고 공용으로 , 이렇게, 고정적인 부분을 , 이렇게, 만들어 줌으로 인해서 만약에 여기서 뭐 추가적으로 다른 가변 데이터가 막 , 이렇게, 추가가 된다고 해도 요런 두 쌍이 헤더 쌍이 계속 늘어나긴 하겠지만 결국에는 밸리데이션을 할 때는 , 이렇게, 한 번에 체크를 할 수 있게 된다는 장점이 생기게 됩니다 근데 물론 아직까지는 리스트 안에 리스트가 들어가는 상황까지는 지금 고려를 하지 않았어요 좀 단순하게 하기 위해서 단계별로 하기 위해서 , 이렇게, 일단 표현하고 있는 거고 일단 이 아이디어부터 , 일단은, 이해를 해주시면 되겠어요 진짜로 고정적인 데이터를 먼저 , 이렇게, 놓고 가변 데이터가 있으면 가변 데이터의 일종의 정보를 나타내는 헤더 값을 offset이란 카운트라는 거로 , 이렇게, 넣어준다 카운트는 말 그대로 가변 데이터의 개수고 offset은 가변 데이터가 시작하는 위치를 우리가 넣어줄 것이다 라는 규약을 , 이렇게, 만들어 준 겁니다 그래가지고 얘를 이제 만약에 정상적으로 다 만들어놨다고 하면은 이제는 이제 흐름이 어떻게 되냐면은 패킷을 , 이렇게, 긁어온 다음에 패킷의 밸리데이션을 체크해가지고 얘가 만약에 실패했다고 하면은 그냥 문제있는 상황이니까 요렇게 바로 빠져나올 수가 있을 겁니다 그러면 이 벡터 버프를 추출하는 것은 지금 우리가 이름을 PK 테스트에 버프 리스트 아이템이라고 했으니까 PK에다가 버프 리스트 아이템에 버프로 , 일단은, 추출해주면 될 거고 이 버프 카운트는 이제 여기서 들어가는 건 아니고 아까 우리가 추출한 이 패킷 테스트에 헤더 값으로 들어가 있겠죠? 요 아이로 그러다 보니까 여기서는 리사이즈를 바로 버프 카운트를 이용해 가지고 요렇게 할 수 있을 거고 이제 나머지 버프 카운트는 얘로 , 일단은, 바꿔치기를 해주면 되겠습니다 이런 식으로 그러면은 나머지 버퍼들도 , 이렇게, 하나씩 하나씩 긁어줄 수가 있겠죠 그리고 요 아이도 마찬가지로 이런 식으로 버프 아이디랑 리메인 타임을 뭐 하나씩 긁어도 되기는 하지만 애당초 우리가 버프리스트 아이템이라는 요 구조체 자체도 지금 프레그마 팩을 적용시켰기 때문에 얘도 마찬가지로 그냥 이런 식으로 그냥 한 번에 빵 만들어줄 수가 있을 거예요 요런 느낌으로 , 자, 그래서 이런식으로 , 일단은, 처음으로 뭔가 좀 개선을 해본 느낌이고 , 일단은, 스트링은 좀 나중에 다루기 위해서 얘는 일단 당장 사용하지 않고 일단 없애주도록 할게요 여기까지는 일단 날려주도록 합시다 요렇게 , 일단은, 1차적으로 바뀔 수가 있다는 얘기가 되는 겁니다 , 자, 일단 클라이언트는 빌드를 해보도록 하고 그럼 이제 거꾸로 서버쪽에서 보낼 때 요 부분에 맞춰가지고 보내줄 필요가 있겠죠 , 자, 그래서 요 부분을 맡겨줄건데 일단 여기 인자로 네임을 받는 부분은 귀찮으니까 그냥 냅두도록 하고 그냥 여기 내부에서만 수정해보도록 하겠습니다 이것도 나중에 가면 좀 바뀔 필요가 있겠지만 지금은 간단하기 위해서 이 포맷을 pdl xml을 봐가지고 지금 이 그림을 잘 그려보자면 데이터 3개를 넣어주는 부분은 , 일단은, 똑같죠 여기까지는 똑같죠 그 다음에 가변 데이터를 넣어주는 이 부분에서 달라지는데 이제는 reserve를 해가지고 사실상 이 버프에 헤더를 먼저 밀어넣을 겁니다 근데 아직까지는 그 버프에 정보라는 게 딱히 존재하지 않으니까 , 이렇게, 리스트 헤더라는 걸 , 이렇게, 간단하게 만들어가지고 offset이랑 count라는 정보가 있다라고 가정하고 이 리스트 헤더를 , 일단은, 이렇게, 밀어넣어 조정할게요 이런 느낌으로 그 다음에 이 리스트 헤더의 포인트를 갖고 와가지고 이게 버퍼라는 아이의 헤더다 라는 걸 우리가 , 이렇게, 알 수가 있을 겁니다 그러면 이제 나중에 채워도 되고 고정적인 데이터가 다 들어갔다고 하면은 그 다음에 채우는데 뭐 지금은 고정적인 데이터가 이거밖에 없으니까 바로 채울 수 있긴 하겠죠? 여기서 이제 그 다음에 카운트를 채워야 되는데 카운트 같은 경우에는 버프의 개수를 얘기한다고 했었고 그 다음에 버프의 옵셋을 채워야 되는데 얘는 이제 뭐가 될까요? 옵셋 같은 경우에는 이 가벼운 데이터가 등장하는 시작 위치라고 했었죠? 근데 우리가 지금까지 여기 있는 정보를 꽉 채웠고 그 다음에 이 헤더까지 채운 상태입니다. 그러니까 아까 그림으로 치면은 여기까지 , 일단은, 다 채운 상태이기 때문에 바로 지금까지 쓴 바이트 개수가 곧 가변 주소의 시작 위치가 되겠죠. 그러다 보니까 BW의 라이트 사이즈를 그냥 바로 여기다가 , 이렇게, 넣어주면은 얘가 시작 위치가 될 겁니다. 그래서 뭐 , 이렇게, 일단은, 넣어줄 수가 있다 그 다음에 뭐 데이터를 사이즈는 , 일단은, 넣어줄 필요 없고 나머지 버프 아이디랑 리메인 타임을 뭐 , 이렇게, 일단은, 밀어 넣어주고 있고요 네 요 부분은 , 일단은, 그냥 그대로 냅두도록 할게요 일단 받는 거 위주로 실습을 하기 위해서 이 부분은 , 이렇게, 놓도록 하고 그 다음에 어... 이름은 생략하기로 했으니까 요렇게 , 일단은, 만들어 줄 수가 있을 겁니다 , 자, 그래서 게임 서버도 , 일단은, 빌드를 해서 문제가 없는지 체크를 하고 , 자, 이제 그래서 클라 쪽에다가 여기서 브레이크 포인트를 잡아가지고 실행되는 걸 한번 살펴보도록 할게요 , 자, 그러면 , 일단은, 이렇게, 브레이크 포인트가 잡힌 상태이고 여기서 먼저 일체적으로 테스트를 해가지고 최소한 내가 고정 부분인 이 PKS 테스트의 크기보다는 더 커야 된다는 걸 지금 , 이렇게, 체크를 하고 있죠 렌스가 지금 58mm이니까 얘보다는 훨씬 크니까 통과를 했고 그 다음에 여기서 한 번에 뾰병 해가지고 추출하게 되면 굉장히 재밌게도 우리가 일일이 꺼낼 필요 없이 이런 고정적인 크기가 , 일단은, 고정적인 부분에 대한 모든 부분들이 다 , 이렇게, 채워져 있다는 걸 볼 수가 있습니다. 그 다음에 validation 코드를 실행할 텐데 여기서 사이즈 계산을 해주게 되겠죠. 먼저 이 pks-test라는 고정 부분에 대한 사이즈 계산을 한 다음에 그 다음에 가변 길이에 대한 크기 개선을 또 해가지고 얘가 만약에 진짜 패킷 사이즈랑 같은지를 체크해서 일단 사이즈는 통과를 했고 그 다음에 Offset이 말이 되는 값인지 얘가 너무 큰 값이어가지고 엉뚱한 주소를 가리지 않는지를 2차적으로 요렇게 테스트를 해가지고 통과를 시킨다는 것도 볼 수 있습니다 그 다음에 여기까지 통과했으면 이제 validation 체크를 통과했으니까 return true를 해가지고 바로 빠져나온다는 걸 볼 수가 있어요 뭐 그 다음에 나머지 부분은 뭐 이런 식으로 하나 둘 셋 추가될 것이고 얘를 이제 고지곳대로 다시 출력을 해보면은 기존과 마찬가지로 버프가 다 출력이 되는 것도 볼 수가 있습니다 , 자, 이렇게, 해가지고 이 첫 번째 아이디어가 , 사실, 이어서 진행할 부분에 대해서 굉장히 중요한 아이디어라고 보시면 되겠어요 그리고 이게 참고로 구글 플랫 버퍼가 만들어지는 그런 원리이기도 합니다 그래가지고 이런 식으로 가변 데이터가 등장한다고 했을 때 가변 데이터랑 그 아이의 크기를 같이 섞어가지고 우리가 처음에 넣어 놨는데 그러다 보니까 이제 크기가 가변적인 부분이 섞여 들어가다 보니까 우리가 뒷부분에 오는 그 가변 데이터를 한 번에 파싱할 수가 없었죠 근데 , 이렇게, 만들어 주게 될 경우에는 고정적인 부분이 먼저 앞에 오고 그 다음에 가변적인 부분이 데이터가 뒤에다가 , 이렇게, 오고 그리고 옵셋으로 내가 다음 위치가 해당 데이터 위치를 , 이렇게, 따로 들고 있기 때문에 얘가 파싱이 훨씬 더 빨라진다 밸리데이션을 그냥 바로 , 이렇게, 때려줄 수 있다라는 굉장히 큰 장점이 생기게 된 겁니다 이 밸리데이션 체크까지 통과를 했다고 하면은 어찌됐건 이 데이터가 세부적인 내용은 엉뚱한 값이 있을 수는 있겠지만 최소한 이 버퍼 크기 내에서 우리가 파시행을 할 수 있다는 게 보장이 된다고 볼 수가 있겠어요 , 이렇게, 해가지고 조금 어려운 내용이 등증을 하는데 일단 1차원적으로 , 이렇게, 일단은, 개선을 해보고 여기서 일단 한번 끊어주고 넘어가도록 하겠습니다.