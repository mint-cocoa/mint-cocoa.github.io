우리가 지난 시간까지 굉장히 단순하게 클라랑 서버를 구동시켜서 서로 연결이 맺어지는 역사적인 순간을 목격을 했는데 이제 이어서 간단하게 서로 데이터를 송수신을 하는 그런 실습을 해보도록 하겠습니다 일단 주석이 너무 지저분하니까 지저분한 걸 삭제를 하고 진행을 해보도록 할게요 여기까지 , 일단은, 이 코드는 이제 좀 많은 복습을 통해 가지고 이 흐름을 제가 이해하는 게 굉장히 중요하다고 말씀을 드렸는데 그 부분을 , 일단은, 복습을 하시고 진행을 하시기를 추천을 드립니다 그리고 , 이렇게, 사실, 에러메시지 이런 거 처리하는 것도 어차피 계속 반복되다 보니까 이런 것도 뭐 하나의 함수로 묶어주는 것도 일단 좋은 생각이긴 한데 , 일단은, 그냥 간단하게 하기 위해서 진행을 해보고 나중에 우리가 서버 코어에다가 핵심적인 네트워크 기능을 집어 넣을 때 그때는 좀 깔끔하게 정리를 해보도록 할게요 , 자, 그럼 이제 이어서 , 사실, 요 부분에서 연결이 성공한 다음에 우리가 to do라고 해서 데이터를 여기서 보내줄 것이다 라고 했었죠 여기다가 이제 뭔가 실질적으로 코드를 추가를 해보도록 합시다 근데 뭐 당연한 얘기지만 데이터를 보내는 것 자체는 그냥 함수 하나를 사용하면 되는데 샌드라는 함수가 있습니다 샌드 그리고 얘 같은 경우에는 뭔가 , 이렇게, 인자만 봐도 어떻게 사용해야 될 것인지가 살짝 감이 오는 느낌이 듭니다 소켓이라는 걸 받아주는데 , 사실, 얘가 휴대폰이죠 어떤 휴대폰을 이용해 가지고 우리가 메시지를 전송할 것이냐를 얘기하고 있는데 우리 , 사실, 여기서 만들어준 소켓이 하나밖에 없죠 이 소켓을 당연히 넣어주면 될테고 그 다음에 콘스트 캐릭터 포인터 버퍼 렌스라는 걸 받아주고 있는데 이게 왠지 우리 데이터가 들어간 그 바이트 버퍼를 받아주고 있는 걸로 일단 예상이 됩니다 실질적으로 그런지는 항상 이런식으로 MSDN을 살펴보는 습관을 드리는게 중요하다고 했었죠 그래서 뭐 역시나 소켓과 버퍼의 포인터와 실제로 보낼 데이터를 두가지를 받아주고 있고 FLAG 같은 경우에는 조금 더 얘를 특이하게 뭔가 설정할 때 사용할 수 있지만 기본적으로는 그냥 0을 입력해가지고 해도 상관없습니다 이런 부분은 딱히 사용할 일이 많이 없을 거에요 , 자, 그래가지고 나머지 부분들 이제 궁금하면은 요런 사용 예제를 살펴보면 , 사실, 굉장히 직관적이죠 여기서 Connect, Sand를 한 다음에 아하 Sand를 할 때는 이런식으로 소켓과 버퍼를 만들어주고 버퍼의 크기와 버퍼 그리고 0을 , 이렇게, 입력을 하는구나 라는 걸 알 수가 있습니다. 그러니까 우리도 그대로 만들어주면 되겠죠. 일단 보낼 데이터를 버퍼라는 것에다가 , 이렇게, 넣어 줄 것인데 데이터를 저장하고 있는 그런 배열을 버퍼라고 하는 겁니다. 여기다가 뭐 그냥 대충 hello world 라는 거를 상대방에게 보내 보도록 할게요. 물론 얘가 12바이트, 13바이트, 널까지 체크 포함해가지고 크기가 100바이트를 다 채우진 않겠지만 뭐 , 일단은, 요렇게 버퍼를 만들어 준 다음에 여기다가 샌드를 그냥 호출해 주도록 합시다 샌드 버퍼, 그 다음에 여기서 두 가지 옵션이 있는데 진짜로 이 100바이트를 다 보낼 것인지 아니면 딱 데이터가 있는 요 크기만 보낼 것인지는 고민할 수 있는데 지금은 일단 이 버퍼의 크기만큼을 그냥 통으로 다 보내도록 할게요 나중에 실습할 거랑 좀 연관이 있어가지고 백파이트를 , 일단은, 다 , 이렇게, 보내주도록 하겠습니다 마지막 인자는 그냥 , 이렇게, 0으로 넣어주면 된다고 했었고 샌드가 뱉어주는 거는 요런 식으로 result 코드를 뱉어주는데 역시나 우리가 이제까지 사용하던 거랑 굉장히 유사하게 이 result 코드를 체크해가지고 얘가 만약에 socket error다 라고 하면은 이런 식으로 또 error 처리를 해주면 되겠죠 socket error라고 하면은 요 부분을 또 이런 식으로 복사해가지고 error 코드를 출력을 하는 식으로 만들어주면 되겠습니다 만약에 소켓 에러가 아니라 넘어왔다고 하면은 정상적으로 뭔가 데이터가 보내졌다라고 , 일단은, 예측을 할 수가 있을 테니까 간단하게 로그를 또 찍어 보도록 하겠습니다 샌드 데이터 데이터 보냈다 사이즈는 샌드 버퍼만큼을 보냈으니까 로그를 , 이렇게, 찍어 보도록 하겠습니다 , 자, 그 다음에 데이터를 보내줬으면 상대방쪽에서 그 데이터를 뭔가 받아줘야지 되겠죠? 그래가지고 이제는 서버쪽으로 가가지고 서버 쪽에서 여기서 얘가 하는 부분은 루프를 돌면서 accept를 해 줘 가지고 어떤 클라이언트가 접속이 된 다음에 입장 로그를 찍어 주고 그 다음에 여기서 이제 뭐 데이터 송수신이 들어가면 될 것 같은데 여기도 , 일단은, 무한 루프로 돌아 가지고 지금은 1대 1로 한 명만 붙어 가지고 계속 데이터를 서로 주고 받는 부분을 여기 양쪽에다가 , 이렇게, 한번 만들어 보도록 할게요 그래서 이 부분에서 이제 추가를 해줄 건데 거꾸로 받아주는 쪽에서는 샌드와 대칭적인 Receive라는 함수가 있습니다 그리고 얘도 왠지 아까 우리가 만들어준 샌드랑 굉장히 유사하게 인자들을 받아주는 걸 알 수 있고 역시나 MSDN을 살펴보고 여기서도 이제 뭐 문서를 살펴보면 거의 비슷한 방식으로 되어 있다는 걸 알 수가 있습니다 근데 아까랑 살짝 달라지는 점은 이제는 그 Receive 버퍼라는 게 상대방이 보내준 데이터를 담아주는 그런 공간이지 미리 채워가지고 걔를 사용하는 그런 개념은 아니죠 이 샌드버퍼 같은 경우에는 보내는 쪽에서 이 버퍼를 채워가지고 거기 있는 결과물을, 내용물을 여기다가 보내준 거라고 하면 리시브 할 때는 상대방이 몇 바이트를 보내줄지 예측을 할 수가 없습니다 그렇기 때문에 버퍼 크기를 일반적으로 넉넉하게 잡아주는 게 좋긴 하겠죠 뭐 어쨌든 Receive 버퍼를 만들어줄 건데 일단 한 1000바이트 정도로 만들어 보도록 할게요. 그 다음에 Receive 할 때는 여기다가 소켓을 넣어줘야 되는데 우리가 서버 쪽에서 지금 만들어준 소켓이 두 개가 있습니다. 처음에 만들어준 Listen 소켓이랑 그 다음에 Accept 통해 가지고 얘가 뱉어준 Client 소켓이라는 게 있었는데 이 부분을 헷갈리시면 안 되고 전에 식당 PPT를 보여드리면서 얘가 이제 약간 영업, 문지기처럼 안내원의 그 기념이라고 했었죠 안내원이 들고 있는 그 휴대폰이고 얘는 말 그대로 처음에 접속을 할 때만 사용하는 그런 말 그대로 안내를 담당하는 아이지 실질적으로 서로 데이터를 주고 받을 때는 요 아이를 사용하는 게 아니라 실질적으로 이 더미 클라이언트랑 연동이 되어 있는 요 클라이언트 소켓을 이용해야 됩니다 요 부분을 헷갈리시면 안 돼요 괜히 여기다 리슨 소켓을 넣어주면 이제 오동작하게 된다는 얘기가 되는 거죠 그래가지고 이제 클라이언트랑 통신할 때는 항상 요 클라이언트 소켓을 사용한다고 했었죠 그래서 얘를 이제 넣어준 다음에 데이터를 어디다가 받아줄 것이냐를 리시브 버퍼에다가 넣어주고 그 다음에 이 리시브 버퍼의 크기를 요렇게 , 일단은, 전달을 해주고 마지막 인자는 역시나 0으로 , 이렇게, 넣어주도록 하겠습니다 어 그러면은 지금 우리가 왼쪽에서 100바이트를 보내준 상태에요 그러면은 얘가 이제 뭐 어느 정도 크기의 데이터를 받아줄 것인데 얘가 실질적으로 받은 실제 데이터의 크기는 그럼 어디 있느냐 여기 유심히 보면 Receive를 반환할 때 Int라는 걸 뱉어주고 있는데 얘가 조금 다르죠? Return Value를 보면 Receive가 반환하는 것은 실질적으로 그 아이가 받은 Receive한 Byte 크기를 뱉어준다라고 , 이렇게, 나와 있습니다 만약에 이 return value가 음수로 떨어진다거나 소켓 error가 마이너스 1인데 마이너스 1을 뱉어줬다고 하면은 그냥 뭔가가 문제가 일어났다는 얘기가 되는 거죠 그래서 결국에는 이런 식으로 ReceiveLength를 반환하는 걸 체크를 해준 다음에 요 값이 얼마인지를 봐가지고 만약에 얘가 0보다 작다고 하면은 그냥 문제가 있는 상황이라고 우리가 인지를 할 수 있다는 거죠 , 이렇게, 에러를 또 찍어 보도록 할게요 여기까지 넘어왔으면은 일단 성공적으로 데이터를 받아줬다는 얘기가 되는 거니까 음 여기다가 뭐 대충 로그를 또 찍어 보도록 할게요 ReceiveDataLength는 얼마 얼마 받았다 , 자, 그리고 여기서 헬로월드를 보냈는데 이 정확히 헬로월드가 진짜로 왔는지 보기 위해서 얘를 복붙한 다음에 이 리시 버퍼에 있는 내용을 그냥 한번 출력을 해보도록 합시다 근데 이건 사실상 만약에 얘가 보는 게 이런 ASCII 문제열이 아니라고 했으면 , 사실, 큰 의미는 없겠죠 나중에 가면 얘가 그냥 정수가 들어가 있을 수도 있고 뭐가 들어가 있을지는 알 수가 없는 겁니다 이제 나중에 패킷 설계를 해가지고 데이터를 알맞게 추출해야 되는데 지금은 그냥 간단하게 체크를 하기 위해서 이 내용물을 그대로 다시 한번 출력을 해보도록 할게요 그래가지고 요 부분까지 이제 실행이 되면은 상대방이 보낸 정보를 내가 받아준 다음에 출력을 요렇게 할 수가 있겠습니다 , 자, 근데 , 이렇게, 뭐 얘가 어 보내준 거를 출력만 하면 재미없으니까 우리가 소위 에코 서버라고 해가지고 상대방이 보내준 정보를 그대로 다시 토스하는 그런 서버를 한번 만들어 보도록 할게요 그래가지고 여기서 그냥 그대로 다시 요 코드를 똑같이 붓붓 해가지고 상대방한테 그대로 다시 얘를 전달을 해 주도록 하겠습니다 지금 들어가 있는 정보는 리시브 버퍼에 들어가 있고 그 다음에 상대방이 보내준 크기는 리시브 렌스에 들어가 있으니까 얘를 코데로 여기다가 , 이렇게, 해가지고 토스를 다시 해주는 거죠 무지개 반사처럼 너가 보내준 데이터를 그대로 다시 너한테 보내주겠다라고 딱 토스를 , 이렇게, 해준 상태라고 , 일단은, 볼 수가 있겠어요 그거를 그냥 매번 , 이렇게, 무한 루프를 돌도록 할게요 그러니까 상대방이 뭔가 데이터를 보내주자마자 걔를 긁어가지고 다시 반환을 할 것이고 그러면 상대방 쪽에서도 똑같이 데이터를 보내준 다음에 이제 대칭적으로 , 이렇게, 받아주는 작업을 똑같이 해줘야 되겠죠 그러니까 이 받아주는 부분을 여기다가 이제 거꾸로 복붙을 하면은 약간 대칭적으로 보내고 받고 보내고 받고가 이제 완료가 된다고 보시면 되겠습니다 그래서 요게 , 이렇게, 해주고 받아주게 되면은 요 코드를 똑같이 여기다가 복붙 해가지고 상대방이 다시 반납한 데이터를 출력을 하고 리스플렌스를 출력하고 그거를 1초마다 요렇게 반복을 해보도록 합시다 , 자, 이렇게, 해가지고 , 일단은, 뭐 클라랑 서버가 동시에 켜져있게 둘 다 시작으로 되어있는걸 확인한 다음에 그대로 다시 한번 시작을 구동을 F4로 눌러가지고 실행을 해보도록 할게요 , 자, 그러면은 지금 요렇게 서버랑 클라 오른쪽에 각각 있는데 서로 붙어준 다음에 정상적으로 데이터가 잘 오고 가는걸 볼 수가 있습니다 얘가 보내고 받고 다시 얘가 받은 걸 그대로 보내고 얘가 그걸 출력하고 그래가지고 이 hello world라는 데이터 및 여기 , 사실, 추가적으로 온갖 쓰레기 값이 100바이트만큼 이제 추가가 되어 있겠죠 전체로 그래서 이런 데이터가 정상적으로 지금 오고 가는 것까지 , 일단은, 확인을 할 수가 있었습니다 네 그래가지고 어 그러면 뭐 send, receive은 그냥 , 이렇게, 하면 되는 거니까 굉장히 단순한 거 아닐까라고 생각할 수 있겠지만 , 사실, 여기서 이게 완전체가 아니에요 약간 이런저런 고찰을 해야 되는 그런 문제들이 여러 가지가 섞여 있습니다 가장 먼저 샌드랑 리시브가 동작하는 방식에 대해서 몇 가지 테스트를 해볼 건데요 소위 말해서 나중에 우리가 온라인 게임을 만들다고 하면 이런 기능들 샌드 리시브를 이용해서 게임을 실질적으로 만들 수 있는지를 곰곰히 생각을 해봐야 됩니다 항상 어떻게 응용할지를 고민을 해보면서 공부를 해야 된다는 얘기가 되는 거죠 지금은 순서상으로 클라가 샌드를 한 다음에 서버에서 리시브를 해주고 그 다음에 3단계가 서버에서 다시 샌드를 해주고 그걸 다시 받아주는 요런 1, 2, 3, 4 흐름으로 지금 동작을 하고 있을 거라는 우리가 예상을 할 수가 있는데 그렇다는 것은 만약에 여기 있는 부분을 싸그리 주석 처리해가지고 서버가 아무 행동도 하지 않고 즉 리시브를 해주지 않는다고 하면은 이제 과연 동작이 어떻게 될지가 고민입니다 첫번째로는 얘가 샌드를 해줬는데 뭔가 공을 던졌는데 받아주는 쪽이 없으면 이게 왠지 완료가 되지 않고 여기서 대기를 타지 않을까라는 예상을 해볼 수도 있고 여러가지 가정을 할 수가 있겠죠 근데 , 사실, 우리가 여기서 사용하고 있는 샌드랑 리시브가 소위 블록킹 함수라고 우리가 부릅니다 블록킹이라는거는 뭔가 막힌다라는 그런 뜻이 있죠 그러다보니까 역시나 방금 예상한대로 얘가 여기서 누군가가 데이터를 성공적으로 받아주지 않으면 블록킹이 되가지고 그냥 기다리지 않을까라고 또 예상을 할 수가 있지만 실질적으로 테스트를 해보면 , 자, 이제 어떻게 로그가 뜨는지를 보면은 따잔 하고 보면은 클라가 데이터를 보내서 send data 성공까지 , 이렇게, 뜨는 걸 볼 수가 있습니다 그래서 지금 딱 요 상태에서 여기까지 send는 성공적으로 된 거고요 여기까지 넘어왔고 그 다음에 receive를 하는 요 공간까지는 여기서 로그가 안 찍혔으니까 요기 어딘가에서 지금 대기를 타고 있는 거 아닐까라고 예측할 수가 있는 거죠 잠시 중단을 살짝 해가지고 살펴보면은 , 자, 여기서 게임 서버 말고 클라이언트 쪽을 살펴보면 역시나 리시브를 하다가 여기서 지금 , 이렇게, 블록킹이 되어가지고 그냥 멍때리고 있는 상태라고 , 일단은, 결론을 내릴 수가 있겠습니다 , 자, 그래가지고 이게 블록킹 함수인데 얘는 왜 그러면 실질적으로 누군가가 받아주지도 않았는데도 불구하고 성공을 했냐 이거 약간 사기치는 거 아닌가 싶긴 하죠 그래가지고 이제 이런 상황이 왜 발생했는지 알기 위해서 잠시 ppt를 하나를 보고 오도록 하겠습니다 , 자, 그래가지고 우리가 가장 기본적인 네트워크 통신을 하면서 send랑 receive를 하고 있었는데 도대체 어떤 사기를 쳤길래 실질적으로 상대방이 데이터를 받지도 않았는데 걔를 이제 성공적으로 보냈다고 우리한테 뻥을 치는지 굉장히 궁금하죠 그래서 그 원리를 알기 위해서는 소켓 입출력 버퍼에 대한 내용을 어느 정도 이제 이해를 하고 있어야 됩니다 그리고 이 내용이 이제 두고두고 계속 반복해서 등장하게 될 겁니다 , 일단은, 지금 , 이렇게, 왼쪽에 클라이언트 오른쪽에 서버가 , 이렇게, 떠 있는 상태고 둘이 커넥션이 맺어져 가지고 소켓이 다 성공적으로 만들어진 상태까지 일단 진행이 됐다고 가정을 해볼게요 그러니까 이제 서버 쪽에서 소켓을 만들고 그 다음에 뭐 바인드하고 리슨 억셉트까지 해가지고 억셉트해서 결과물로 클라이언트 소켓이 튀어나오고 그걸 이용해 가지고 이제 상대방이랑 통신을 할 수 있게끔 하는 그 단계까지 이제 완료가 된 상태라고 보시면 되는 거죠 그러면 , 사실, 그렇게 뭔가 소켓이라는 게 만들어졌을 때 우리한테는 보이지 않지만 내부적으로 커널 레벨이라고 해가지고 이제 운영체제가 관리하고 있는 이 영역을 선을 찍어가지고 이제 이제 코어 레벨이라고 생각을 하면은 이제 커널 레벨이라고 운영체제가 관리해주는데 거기서도 요런 식으로 소켓과 관련된 송순심 버퍼가 하나씩 마련이 됩니다 리시브 버퍼, 샌드 버퍼 , 이렇게, 쌍이 있어요 상대방도 마찬가지로 소켓을 만드는 순간에 , 이렇게, 송수신 버퍼가 같이 만들어지게 됩니다 그래가지고 우리가 사실은 아까 우리가 클라이언트에서 서버 쪽으로 뭐 헬로 같은 어떤 패킷을 만들어 가지고 요 데이터를 지금 보내기 위해서 샌들을 빵 때렸었죠 사실은 우리는 마치 이게 막바로 서버한테 가는 것처럼 아무것도 신경을 쓰지 않고 이 함수만 빵 후출을 했었지만 당연한 얘기지만 우리가 유저 레벨에서 막 하드웨어를 조작하고 할 수는 없기 때문에 모든 것들은 다 우리가 운영체제한테 부탁을 해가지고 간접적으로 사실은 이게 호출이 되고 있는 거예요 그래가지고 이 헬로우를 딱 해가지고 샌드를 때리는 순간에 사실상 이러한 일은 뭐냐면은 요 샌드 버퍼에다가 얘를 복사를 하려고 , 이렇게, 딱 시도를 합니다 지금은 여기 모든 버퍼들이 다 텅텅 비어있는 상태이기 때문에 자리가 있으니까 얘를 그냥 여기다가 , 이렇게, 복사를 하게 되는 거고 복사를 했으면 , 사실, 유저 레벨에서는 자기 임무는 끝난 거니까 여기서 바로 샌드가 완료가 되었다고 인지를 하는 거죠 그래서 아까 우리가 실질적으로 상대방이 뭔가 데이터를 받지 않았음에도 불구하고 이런식으로 샌드가 성공적으로 완료가 되었던 이유는 바로 이 이유입니다 그냥 샌드 버퍼, 커널 버퍼에다가 복사를 해가지고 복사를 할 수 있으면 , 사실, 샌드는 그냥 이 함수는 성공적으로 바로 빠져 나와가지고 진행이 된다고 보시면 되는 겁니다 우리가 소위 블록킹 함수라고 해도 그게 100% 확률로 무조건 항상 블록킹이 되어 가지고 대기를 타야 된다는 얘기가 아닌 거죠 , 이렇게, 경우에 따라 가지고 정말로 커널 버퍼에다가 복서만 할 수 있으면 그냥 쿨하게 계속 다음 일을 진행하러 갈 수 있고 심지어 상대방이 아직 데이터를 이 데이터를 받지 않았음에도 얘가 완료가 된다라는 그런 얘기를 하고 있는 겁니다 그러면은 실질적으로 이제 우리의 입문이 여기서 완료가 되는 거고 이제 내부적으로 운영체제끼리 열심히 작업을 해가지고 상대방쪽 컴퓨터한테 이 데이터를 어떤식으로든 보내주게 될겁니다. 그거는 우리가 신경쓸 필요 없어요. 상대방이, 그니까 우리가 사용하고 있는 운영체제, 윈도우드나 리뉵스가 알아서 해줄것이기 때문이죠. 그럼 결국에는 뭔가 , 이렇게, 이런저런 과정을 걸쳐가지고 우리가 보내준 이 데이터가 상대방쪽 리시브 버퍼에 요런식으로 복사가 되어가지고 여기 안에 이제 들어가게 될거에요. 그러면은 요 상태에서 다시 서버 쪽에서 Receive를 빵 때리면 Receive는 거꾸로 대칭적으로 Receive Buffer에서 데이터를 끄집어서 가져오려고 합니다 지금은 정말 운 좋게 뭔가 자기가 사용할 만한 데이터가 , 이렇게, 있다는 걸 알 수가 있죠 그러다 보니까 여기서 Receive를 하면 Receive가 딱 완료가 되면서 정확히는 여기서 Receive한 크기를 얘가 뱉어줬었죠 이 헬로라는 데이터를 거꾸로 우리가 전달해준 그 유저 레벨에 있던 Receive Buffer의 복사를 함과 동시에 얘가 완료가 되면서 끝나게 될 겁니다. 요런 흐름으로 지금 진행이 되고 있다고 보시면 되겠어요. 그러면은 어느 정도는 직관적이긴 하죠 보낼 때는 항상 샌드 버퍼에 받을 때는 리시 버퍼에 있던 거를 , 이렇게, 받는다라는 걸 우리가 알 수 있는 거고 거꾸로 서버 쪽에서 샌드를 할 때도 마찬가지입니다 서버 쪽에서 뭔가를 보내려고 하면은 먼저 서버 쪽 샌드 버퍼에다가 걔를 , 이렇게, 복사를 해줄 것이고 그 다음에 클라이언스 쪽에서 받기 위해서는 샌드버퍼에 있던 거를 뿅 보내가지고 상대방 쪽 리시프 버퍼에 보낸 다음에 여기는 내용물을 얘가 꺼내 쓴다는 얘기가 되는 거죠 그럼 이제 조금 얘기를 상황을 바꿔가지고 좀 꼬아서 살펴보면은 만약에 이미 샌드버퍼가 꽉 차있는 상태라고 하면은 어떤 일이 발생할까요? 지금 요 상태에서 똑같이 클라이언트에서 나는 서버한테 샌드를 보내고 싶어 뿅 하고 호출을 했으면 이제는 약간 문제가 되는 상황인게 에랑초 요렇게 커널 쪽에 있는 샌드버퍼에다가 얘를 데이터를 복사해가지고 진행을 하려고 하는데 지금 데이터가 꽉 차 있어가지고 더 이상 여유분이 없기 때문에 이런 상태라고 하면은 , 사실, 샌드가 어... 블록킹이 되어가지고 여기서 진행을 하지 못하고 그냥 계속 기다려야 됩니다. 만년 기다리는 거죠. 물론 기다린다고 해가지고 얘가 뭐 CPU 소문을 엄청나게 막 하면서 기다리는 건 아니고 그냥 요 프로세스 자체가 그냥 잠들어가지고 실질적으로 얘가 완료가 되어가지고 뭔가를 진행할 수 있을 때까지 얘는 그냥 잠든 상태가 되는 거죠 쿨쿨 잠들게 될 것이고 결국에는 여기 공간이 있어야서 확보가 돼야 되지만 이어서 진행할 수 있다라는 결론을 낼 수가 있습니다 그러면은 이어서 진행하려면 어떻게 해야 되느냐 결국에는 언젠가는 요런 식으로 데이터가 뭔가 , 이렇게, 뽑혀가지고 상대방 쪽 리시프 버퍼에 성공적으로 전송이 되어야지만 이제 , 이렇게, 공간이 확보가 될 것이고 그래야지만 다시 우리가 요청했던 그 데이터를 밀어 넣어 가지고 얘가 , 이렇게, 샌드가 완료가 될 수 있다는 얘기가 되는 거죠 , 자, 그러면은 거꾸로 이제는 다른 케이스를 들어볼 건데 이제 또 데이터가 텅텅 빈 상태라고 가정을 해봅시다 완전히 서로 아직 데이터가 아무것도 없는 상태인데 이때 갑자기 서버가 뜬금없이 receive를 하겠다라고 함수를 호출했다고 하면은 이제는 어떤 일이 발생할까요 이게 어느 정도 대칭성이 있다고 했었죠? Receive는 거꾸로 여기 Receive 버퍼에 있는 데이터를 꺼내가지고 사용하려고 하는데 애당초 이 Receive 버퍼가 텅텅 비어있다고 하면은 우리가 Receive를 호출하는 순간에 얘도 역시나 블록킹이 되어가지고 그냥 대기를 하면서 뭔가 데이터가 올 때까지 그냥 얘는 멍때리면서 기다리게 될 겁니다 그래가지고 결국에는 결론을 내리자면 , 이렇게, 네트워크 통신이 일어나고 우리가 Send, Receive를 할 때는 어느 정도 서로 뭔가 눈치 싸움처럼 상대방이 보낸 데이터를 어느정도 받아줘야지만 상대방도 계속 데이터를 보내줄 수 있는 것이고 내가 리시브를 한다고 해도 상대방이 데이터를 보내주지 않았다면 그게 리시브를 할 수 없고 반드시 뭔가 데이터가 와야지 그걸 꺼내가지고 쓸 수 있다는 얘기가 되는거죠 그래서 거의 극단적인 시나리오라고 볼 수 있는데 이번에는 이런 식으로 얘가 뭔가 데이터를 보내려고 하는데 하필이면 샌드 버퍼가 꽉 차 있는 상태인데 또 하필이면 상대방도 리시프 버퍼가 꽉 차 있어가지고 더 이상 데이터를 여기다가 복사할 수 없는 그러니까 옮겨받을 수 없는 상태라고 하면 이제는 이 샌드각 전혀 진행이 되지 않고 여기서도 계속 기다려야 되는 상황이 되는 겁니다 그럼 언제까지 기다려야 되냐면 여기 서버 쪽 유저 레벨에서 리시브를 호출해 가지고 여기 있는 데이터를 하나 까먹어서 , 이렇게, 복사를 할 때까지 계속 이 클라이언트 쪽도 샌드가 지연이 되면서 블록킹이 된다는 얘기가 되는 거죠. 그래가지고 우리가 소위 이 샌드랑 리시브의 기본 형태를 우리가 이제 블록킹 함수라고 할 때 얘가 항상 블록킹이 되고 항상 기다려야 된다는 얘기가 아니고 , 이렇게, 특수한 상황에 의해 가지고 경우에 따라 가지고 이제 블록킹이 발생한다고 결론을 내릴 수가 있는 겁니다. 즉 샌드를 할 때는 항상 이 커널 버퍼 샌드 버퍼에다가 복사를 하려는 습성이 있는데 이 버퍼가 꽉 차 있다고 해가지고 더 이상 얘가 여기 있는 내용물을 여기다가 복사할 수 없을 때 얘는 이제 블록킹이 일어나는 거고 반대로 Receive를 할 때는 Receive는 기본적으로 여기 있는 Receive 버퍼에 있는 데이터를 꺼내 먹으려고 하는데 이 Receive 버퍼가 비어 있을 때 얘는 블록킹이 된다라고 대칭성 있게 지금 동작을 한다라는 걸 알 수가 있는 거였죠 그래가지고 아까 케이스에서 우리가 실습을 해봤을 때는 실질적으로 상대방이 이 서버 쪽에서 뭔가 아무것도 하지 않고 그냥 서버 쪽에서 멍때리고만 있었음에도 불구하고 샌드가 성공적으로 일어났던 이유는 애상초 , 이렇게, 커널 버프에다가 데이터를 복사하는 것까지는 성공적으로 할 수 있었기 때문에 얘가 바로 완료가 되었다는 걸 , 일단은, 알 수가 있는 겁니다 , 자, 이렇게, PPT를 보고 오니까 이제는 아까 얘가 샌드를 했고 얘가 리셉을 하지 않았는데 얘가 바로 완료가 되고 계속 진행을 한 것까진 이제 이해가 가죠 그리고 여기서 리셉을 한 다음에 얘는 더 이상 진행이 되지 않는 이유는 상대방 쪽에서 뭔가 데이터를 샌드를 해서 보내주지 않았다 보니까 데이터를 안 보내줬다 보니까 이쪽에 있는 커널에 리셉 버퍼는 텅텅 비어있기 때문에 얘가 지금 여기서 대기를 타고 있는 그런 상황입니다 그래서 여기서 이제 뭔가 우리가 미리 머리를 굴려보면서 유추할 수 있는 거는 이런 식으로 가장 기본적인 형태의 샌드 리시브, 즉 이걸 소위 블록킹 함수라고 하는데 이런 블록킹 방식으로 우리가 만약에 게임을 구현을 한다고 하면 굉장히 골치 아픈 일이 많이 생길 거라는 걸 벌써 예측할 수 있습니다 샌드를 했는데 상대방이 당장 리시브를 해주지 않는다고 하면은 어느 순간부터는 우리 커널의 레벨에 있는 버퍼가 꽉 차가지고 여기서 대기를 타게 될 것이고 반대로 상대방 쪽에서 빨리빨리 데이터를 보내주지 않으면 리시브도 충분히 대기를 탈 수 있는 상황이 발생할 수 있다는 얘기가 되는거죠 그러면 우리가 예전에 스피락을 만들 때처럼 계속 CPU를 소모하면서 대기를 타는 건 아니고 그냥 우리가 일드 이런 슬립을 하는 것처럼 진짜로 더 이상 CPU는 소모하지 않지만 컨택스위칭이 일어나면서 자기 점유권을 내려놓고 그냥 멍때리고 있는 대기상태가 컨디션 Variable처럼 완전히 대기상태가 된다는 건 우리가 알 수가 있는 겁니다. 근데 그래도 문제가 되는 게 뭐냐면은 이제 만약에 이걸 게임을 우리가 Send, Receive로 만드는 과정을 해볼게요. 그럼 얘가 언제 완료가 될지는 온전히 상대방의 의존이 좋은 것이기 때문에 만약에 어떤 특정상에 의해가지고 서버가 좀 바빠가지고 처리가 늦게 된다고 하면 얘가 아예 진행이 안 되겠죠. 진행이 안 되면은 , 사실, 클라이언트도 열심히 열심히 동작을 계속 바쁘게 하면서 뭐 그래픽스와 관련된 연산도 처리를 하고 UI도 그려주고 뭐 굉장히 할 일이 많은데 , 이렇게, 네트워크 코드 때문에 목통이 되면서 대기를 탄다는 건 , 사실, 말이 안 되는 상황이 되는 겁니다 물론 이제 이거를 그러면 스레드를 하나를 더 만들어 가지고 이런 네트워크만 처리하는 애들을 배정해야 되느냐라는 뭐 그런 생각을 할 수도 있지만 클라라면은 뭐 그게 어느 정도는 말이 되지만 서버는 똑같이 그게 문제가 되는 게 나중에 접속할 클라가 몇천 명이 될 수도 있는데 그 애들마다 하나씩 스레드를 배정해 줘 가지고 이런 식으로 언제 대기탈지 모르는 샌드랑 리시브를 하면서 그 스레드가 먹통이 되는 것까지 감안하고 만드는 건 말이 안 되겠죠 그래가지고 결국엔 제가 미리 드리는 이런 힌트는 요런 거는 우리가 처음에 공부할 때 흐름을 알기 위해서 공부를 하고 있지만 나중에 가면 어차피 , 이렇게, 어 블록킹 방식의 그런 샌드랑 리시브는 사용할 수 없다라는 걸 이제 미리 힌트를 드리고 있는 거고 언젠가 이제 강의가 진행이 되면서 다른 버전에 대해서도 이제 알아보긴 할 겁니다 , 자, 그건 그렇고 이제 이어서 하나만 더 실습을 해보고 싶은 건 뭐냐면요 , 자, 일단은, 여기서 잠시 주석을 풀어주고 , 자, 이것을 리시브를 해주기는 해줄 거에요 샌드는 일단 안하고 얘는 다시 주석 처리를 하고 , 이렇게, 리시브만 해줄 것인데 이제는 조금 입장을 바꿔가지고 이쪽에서 샌드를 할 때 백바이트를 보내고 바로 처리를 하는 게 아니라 이쪽에서 잠시 대기를 타도록 할게요 디스 스레드 슬립 한 1초 동안 쿨쿨 잠들고 이어서 리시브를 해줄 것이고 이쪽에서는 거꾸로 지금 얘가 샌드를 100바이트를 해주고 있는데 이거를 굉장히 빠르게 뭐 한 10번을 보내주도록 하겠습니다. 100바이트를 10번 보내줬다는 것은 결국에는 1000바이트가 실질적으로 빠바바박 하고 갔다는 얘기가 되는 거겠죠. 그 다음에 리시브는 뭐 나머지 부분은 얘도 그냥 잠시 주석을 처리해 줘 가지고 이 부분까지는 실행을 안 하도록 주석 처리를 해주도록 할게요. 이 실험에서 제가 이제 테스트 해보고 싶은 건 뭐냐면은 이제 다음과 같은 문제입니다 얘가 지금까지 보낼 때는 우리가 100 바이트를 보냈다면 상대방에서 100 바이트를 보낸다고 뭔가 알게 모르게 가정을 하고 진행을 했어요 근데 사실은 우리가 지금 작업하고 있는 TCP라는 아이가 그렇게 동작을 하지 않습니다 그래서 지금 테스트라는 것은 얘가 엄청 빠르게 데이터를 누적해 가지고 1000 바이트를 꽉 채운 상태에서 상대방 쪽에서 뒤늦게 잠에 깨 가지고 리시브를 때리는 순간에 과연 여기서 리시브가 완료가 될 때 몇 바이트를 받을 것인가가 두 번째 문제입니다 이 그림을 봤을 때 제가 마치 PPT를 간단하게 만들기 위해서 데이터가 뭔가 , 이렇게, 분할이 되어 가지고 들어가는 것처럼 표현을 했었죠. 이 헬로라는 걸 다섯 번 보냈더니만 헬로 헬로 헬로 헬로 헬로 이 다섯 개의 블록이 만들어진 것처럼 표현을 했지만 사실상 그렇지 않고 이 데이터들은 , 사실, 경계선이 엄밀히 말하면 없습니다. 그게 TCP의 특징이기도 해요 나중에 다음 시간에 TCP랑 UDP의 차이에 대해서 알아보고 UDP도 실습을 하고 뭐 그럴 건데 , 일단은, 간단하게 요거에 대해서 예습을 하기 위해서 얘가 어떻게 동작하는지를 한번 체크를 해보도록 하겠습니다 그래서 얘를 이제 한번 실행을 해보면 굉장히 놀랍게도 , 자, 이제 한번 실행을 해보도록 할게요 100바이트를 계속 보내고 있는데 상대방 쪽에서는 어떤가요 얘는 100바이트를 빠바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바바� 지금 사실상 헬로월드가 여러 번 들어가 있지만 문자열을 딱 널 만날 때까지 한 번만 출력을 하니까 얘가 헬로월드 한 번만 출력이 되고 있는 거지 실질적으로 이 렌스 자체는 1000바이트가 들어왔다는 걸 우리가 확인을 할 수가 있는 겁니다 따라서 아까 ppt로 치면은 이런 식으로 데이터가 뭉쳐있는 상태에서 얘를 이제 하나씩 하나씩 꺼내 가는 게 아니라 정말로 요런 데이터들이 뭉뚱 그려가지고 1000바이트가 한 번에 요렇게 지금 넘겨받을 수가 있다는 얘기가 되는 거죠 그래서 얘가 receive를 하면은 하나만 딱 꺼내 쓰는 게 아니라 얘가 설령 100바이트를 10번에 걸쳐서 보냈다고 하더라도 실질적으로 이 모든 데이터가 한 번에 합쳐진 상태로 1000바이트 짜리로 인식이 되어서 올라갈 수 있다는 얘기가 되는 겁니다 그럼 이제 그 다음에 발생하는 문제는 우리가 분명히 100바이트 짜리를 쪼개서 보냈는데 얘는 한 번에 1000바이트라는 걸로 밖에 인식을 못한다고 하고 얘가 몇 바이트 짜리로 쪼개서 보냈다는 거는 전혀 알 수가 없죠 사실상 얘가 , 이렇게, 막 합쳐진 상태로 지금 , 이렇게, 하나의 큰 덩어리로만 지금 받아줄 수 있는 겁니다 그렇다는 것은 애당초 클라 쪽에서 보내준 이 100바이트 짜리라는 크기 자체는 이제 어떻게 아느냐 그거는 서버 쪽에서는 알 수가 없고 그거를 언젠가는 우리가 이 내용물에 기입을 해줘 가지고 서버 쪽에서도 처음에 클라가 보낼 때 이 데이터를 어떻게 쪼개서 보냈었는지를 어떤 식으로든 판별할 수 있는 수단을 마련해줘야 된다는 얘기가 되는 겁니다 물론 이건 지금 당장 신경쓰면 너무 복잡한 얘기고 참고 삼아서만 알아주시면 되겠어요 TCP의 특징 중 하나는 어떻게 이런 식으로 바운더리의 개념이 없다 , 이렇게, 정해진 크기라는 게 존재하지 않고 데이터가 , 이렇게, 합쳐져 가지고 크게 갈 수도 있고 아니면 내가 설령 여기서 100바이트를 보냈다고 해도 얘가 100바이트가 한 번에 가는 게 아니라 쪼개져 가지고 갈 수도 있다라는 얘기가 되는 겁니다 예를 들면 지금 만약에 이 데이터가 가다 보면 데이터가 아주 조금 일부만 , 이렇게, 지금 공간이 남은 상태였다고 가정해 볼게요 이 상태에서 우리가 샌드버퍼 헬러가 들어가고 얘를 보내려고 하는데 지금 이 사이즈가 여유 공간이 조금밖에 없죠 얘가 다 들어갈 공간은 없다고 하면은 진짜로 요 부분만 이 일부분만 요렇게 잘라가지고 일부분만 지금 얘가 , 이렇게, 전송이 될 수 있다는 얘기가 되는 겁니다 그래서 애당초 TCP에서 가장 흥미로운 부분 중 하나 그리고 우리가 이걸 반드시 처리를 해줘야 되는 부분은 100바이트를 보냈다고 해도 그게 진짜 받는 쪽에서는 100바이트가 도착한다라는 보장이 전혀 없다라는 걸 알 수가 있는 거죠 그래서 이 실험을 통해 가지고 우리가 보낸 데이터들이 막 서로 쪼개지고 뭉쳐 가지고 , 이렇게, 도달할 수 있다라는 것도 확인을 해봤습니다 이게 이제는 뭐 간단한 TCP 서버에 대한 뭐 그런 개론이라고 볼 수 있겠어요 , 자, 그 다음에 뭐 이어가지고 TCP, UDP는 그래서 뭐 어떤 차이가 있는지에 대해서 알아보고 UDP 서버도 뭐 우리가 MMORPG를 만들 때는 사용하지 않을 것이지만 그래도 어찌됐건 기본기 차원에서 한번 언급을 하고 넘어가야 될 것 같아가지고 이어서 UDP 서버도 간단하게 알아보도록 하겠습니다.