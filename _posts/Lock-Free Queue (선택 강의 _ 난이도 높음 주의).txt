자, 이제 이어서 이번 시간에는 락프리 큐에 대한 내용에 대해서 간략하게 실습을 해볼 건데요 이 강의를 할지 말지 좀 고민을 했습니다 왜냐하면 락프리 스택도 쉽지는 않았지만 락프리 큐는 거기서 한 단계 더 어려워지기 때문에 뭐 굳이 실질적으로 우리가 활용하지도 않을 걸 이렇게까지 뭐 어렵게 공부를 해야 되나 싶어서 스킵을 하려다가 뭐 그래도 어찌됐건 스택을 했는데 Q를 안하기도 뭐해가지고 그냥 간략하게 한번 알아보고 넘어가도록 하겠습니다 근데 좀 생각보다 좀 어렵기 때문에 혹시라도 뭐 이해가 안 가신다고 해도 크게 뭐 신경 쓰실 부분은 아닙니다 나중에 가서 우리가 요런 락프리 구조를 사용하진 않을 거예요 락프리 Q는 사용하지 않을 겁니다 뭐 그건 그렇고 락 프리 큐를 , 이렇게, 만들어 볼 건데 , 일단은, 멀티 스레드를 생각하지 않고 간략하게 싱글 스레드 환경이라고 가정을 하고 코드를 만든다고 한번 가정해 봅시다 , 자, 그러면 , 일단은, 여러가지 방법이 있겠지만 노드 방식으로 , 일단은, 만들어 볼 거고요 그래야지 이걸 나중에 락 프리 구조로 변환시키는데도 유용하기 때문에 노드 기반으로 만들어 볼 겁니다 그래가지고 노드에 , 일단은, 어떤 데이터를 , 이렇게, 들고 있을 거고요 데이터 자체는 그냥 Shadow Pointer가 아닌 그냥 일반 T형태로 들고 있어도 되고 아니면은 포인터 형태로 들고 있어도 되는데 , 일단은, 나중을 위해서 Shadow Pointer 형태로 , 일단은, 들고 있도록 하겠습니다 이유는 조금 이따가 다시 나올 테니까 뭐 넘어가도록 하고 그 다음에 이 다음 Node를 , 이렇게, Next로 들고 있을 겁니다 , 자, 그래가지고 이제 스택이랑 조금 달라져야 될 점은 뭐냐면은 , 이렇게, 데이터가 여러개가 , 이렇게, 들어가 있을 것이고 요 데이터가 그 다음 넥스트로 계속 서로 , 이렇게, 물고 있는 형태이지만 헤드랑 테일 , 이렇게, 두개가 등장해야 되겠죠 원래 스택 같은 경우는 데이터를 넣는 쪽에서 맨 먼저 빠지기 때문에 헤드 하나만으로도 충분했지만 이제는 첫번째 데이터랑 마지막 데이터를 , 이렇게, 관리해가지고 데이터를 밀어넣을 때는 여기 테일에다가 밀어넣고 데이터를 뽑아올 때는 요 헤드에 있는 앞에 있는 데이터를 뽑아쓰는 형태로 만들어 줄 겁니다 그래가지고 뭐 한마디로 뭐 이런식으로 헤드랑 뭔가 테일을 , 일단은, 만들어 가지고 사용하는 거를 고려할 수 있다는 얘기가 되는 거죠 , 자, 그리고 뭐 여기서 이제 하나씩 만들어 볼 건데 락 프리 큐 같은 경우 복사하는 거를 우리가 금지하기 위해서 이런 코드들을 기본적으로 넣어 놓도록 합시다. lock-free-queue 복사도 할 수 없도록 operator도 lock-free-queue를 , 이렇게, 막아보도록 할게요. 참고로 스타일 개선은 하지 않았지만 이제 소멸자에서도 나머지 데이터를 쫙 정리하는 코드를 넣어줘야 되겠죠 그 부분은 잠시 생략하도록 하고 , 자, 그 다음에 이 부분에서 처음에 만약에 데이터가 없을 때를 가정해봅시다 그럼 데이터가 없으면 양쪽에 다 넣을 포인터인 상태로 일단 , 이렇게, 들어가 있을 거예요 , 자, 근데 , 이렇게, 만들 경우에는 이제 조금 까다로운 부분이 나중에 우리가 헤드에다가 뭔가 데이터를 뽑아서 쓰거나 테일에다가 데이터를 밀어넣거나 하는 식으로 우리가 만들어줘야 되는데 그게 이 헤드랑 테일이 양쪽에 있는 데이터가 , 이렇게, 쪼개져 있어 가지고 따로 따로 관리를 하게 되면 나중에 이걸 락FREE로 변환하기가 조금 어렵습니다 그래가지고 다른 방법을 사용할 건데 , 일단은, 기본적으로 항상 이게 빈 큐라고 하더라도 , 이렇게, 더미 노드를 하나를 만들어 준 다음에 헤드랑 테일이 이 더미 노드를 참조하게끔 해서 시작을 할 거예요 이 상태가 빈 데이터, 그러니까 데이터가 없는 상태가 이 상태가 될 겁니다 그래가지고 실질적으로 데이터가 있냐 없냐를 판별할 때는 헤드랑 테일이 이 같은 노드를 가리키고 있느냐를 우리가 판별해가지고 데이터가 비어 있다로 판별을 해주게 될 겁니다 그래서 어찌됐건, 락프리큐 생성서에서는 이 더미 노드를 처음에 만들어줘야 되기 때문에 이런식으로 헤더에다가 새로운 노드를 만들어줄 것이고 테일에다가는 방금 우리가 만들어준 이 노드를 가리키게끔 헤드를 , 이렇게, 그냥 그대로 넣어주도록 하겠습니다. , 자, 이렇게, 일단은, 시작을 해보도록 할게요. 헤드랑 테일이 같은 데이터를 지금 가리키고 있는 상태입니다. , 자, 그 다음에 뭐 푸쉬를 만들어 줄 건데 뭐 여기서 이제 뭐 데이터를 어떻게 받아 줄지는 여러가지 버전을 만들어 주면 되겠지만 , 일단은, 이렇게, const t 레퍼런스로 하나를 받아 줄 것이고 데이터를 우리가 셰어드 포인트로 , 일단은, 관리하고 있으니까 뭐 이런 식으로 새로운 데이터를 만들어 준 다음에 Make Shared를 호출해가지고 Value를 넣어주고 이제 이 데이터를 만들어 준 거를 넣어주기 시작을 해야 되겠죠 새로운 데이터를 추가할 때는 새로운 노드를 만든 다음에 여기다가 데이터를 추가하는 게 아니고 기존에 있던 지금 사용하지 않고 있던 이 더미 노드에다가 , 일단은, 데이터를 집어 넣은 다음에 새로 만들어 준 더미 노드를 이어서 , 이렇게, 갖다 붙일 겁니다 이런식으로 데이터가 추가가 될거에요 그래가지고 , 일단은, 기존에 있던 더미노드를 갖고 올거구요 새로 추가할 더미노드를 먼저 만들어 줄것이고 그 다음에 올드테일이라고 해가지고 기존에 원래 우리가 테일로 사용하고 있던, 즉 원래 , 이렇게, 비어있던 요 데이터를 올드 테일로 , 이렇게, 추출을 해온 다음에 거기다가 우리가 데이터를 기입을 해줄 겁니다 뭐 이런 식으로 얘가 스마트 포인터이다 보니까 뉴 데이터를 뭐 이런 식으로 넣어줄 수 있겠죠 그냥 복사를 해도 상관없고 이런 식으로 넣어주고 그 다음에 Next를 Dummy로 바꿔치기 해줄거에요 데이터를 여기다가 여기다가 , 이렇게, 넣어주고 그 다음에 이 Dummy node라는 거를 뒤에다가 , 이렇게, 오려 붙여준 다음에 그 다음에 최종적으로 테일이 우리를 새것 추가한 이 Dummy node를 가리키게 만들어주면 되겠죠 그래서 테일을 Dummy로 , 이렇게, 바꿔주면 일단 Push가 완료가 되겠습니다 , 자, 그 다음에 비슷하게 이제 팝을 만들어 줄 건데 팝도 뭐 여러가지 버전을 만들어 줄 수 있겠지만 , 일단은, 트라이팝이라고 해가지고 셰어드 포인터로 이 데이터를 뱉어주는 형태로 우리가 스택, 락프리 스택도 만들어 놨으니까 똑같은 인터페이스로 만들어 주도록 할게요 , 자, 그리고 잠시 여기다가 중간 과정인 pophead라는 함수를 일단 만들어 줄 건데 얘가 하는 역할은 말 그대로 첫번째 head에 해당하는 데이터를 긁어오는 그런 함수를 일단 만들어 주도록 하겠습니다 굉장히 뭐 어려운 부분은 없구요 , 일단은, 원래 있던 head를 갖고 온 다음에 데이터가 있는지 없는지를 확인할 거에요 그걸 확인하기 위해서는 이 헤드값이랑 테일값이 같은지를 확인해가지고 둘다 서로 같은 데이터를 가리키고 있다고 하면은 데이터가 , 이렇게, 없는 상태라고 인지를 할 수 있으니까 그냥 똘포인터를 뱉어줄 것이고 그게 아니라고 한다면은 , 일단은, 헤드를 뭐 이런 상태가 되는 거죠 데이터가 원래 하나가 있는 상태였으니까 얘를 꺼내 쓰기 위해서 헤드를 원래의 헤드의 Next로 즉 이 다음에 있는 헤드로 헤드를 바꿔치기 해준 다음에 얘는 이제 꺼내가지고 사용하니까 얘를 뚝 떼주면 되겠죠 그래가지고 올드 헤드를 , 이렇게, 일단은, 뱉어줄 겁니다 즉 첫번째 헤드를 지금 꺼내 오는 함수를 , 이렇게, 만들어 놨어요 그러면은 트라이팝에서는 올드 헤드를 먼저 , 이렇게, 팝 헤드를 이용해가지고 추출을 해준 다음에 만약에 데이터가 있는지 없는지를 확인하기 위해서는 널 포인터라고 하면은 데이터가 없는 거니까 , 이렇게, 빈 시야드 포인터를 뱉어줄 것이고 그게 아니라고 한다면 아싸 데이터가 있다라는 상황이 되는 거니까 어 샤드 포인터를 이제 반환을 해주도록 합시다 올드 헤드의 데이터를 잠시 , 이렇게, 저장을 해준 다음에 그 다음에 올드 헤드를 밀어 가지고 요 노드가 이제 툭 떼 가지고 우리가 이제 빼야났으니까 얘를 날려준 다음에 데이터를 정상적으로 , 이렇게, 반환을 해주면 되겠습니다 , 자, 요게 만약에 이제 뭐 멀티스레드 환경이 아니거나 아니면은 푸쉬랑 팝을 하나씩만 해주는 상황이라고 한다면 대충 요렇게 만들어주면 , 일단은, 처리가 될 겁니다 그런데 이제 불행하기도 이거를 멀티스레드 환경에서 우리가 만들어 준다고 하면은 지금 경합이 붙는 부분이 생각보다 많죠 하나씩 살펴보면은 일단 푸쉬라는 부분에서도 여러가지 문제가 있는데 이게 스택보다 큐가 조금 더 어려운 이유가 뭐냐면은 Q 같은 경우는 이제 스택 같은 경우는 푸쉬는 간단하지만 팝이 어렵다고 우리가 할 수가 있는데 그 이유는 푸쉬를 하는 동안에는 우리가 , 이렇게, 데이터를 먼저 만들어 준 다음에 다시 이 스택 코드를 보면 여기 데이터를 만들어 준 다음에 경합을 통해 가지고 내가 만든 데이터를 밀어넣는 작업을 서로 경합을 해서 하기 때문에 어찌됐건 요 데이터 자체는 나만 건드리고 있으니까 얘는 당장 경합이 붙지 않았었죠 근데 Q같은 경우에는 그게 아니라 애장초 양쪽에서 데이터가 만약에 지금 이런 식으로 여러 개가 들어가 있다고 하면은 헤드는 얘를 가리키고 테일은 얘를 가리키고 있는 상태다 보니까 푸쉬를 할 때도 공용으로 갖고 있는 이 더미노드를 우리가 건드리려고 할 것이고 팝을 할 때는 공용으로 사용하고 있는 첫 번째 값을 사용할 테니까 양쪽에 다 지금 경합이 붙는 그런 상황이라고 볼 수 있겠어요? 그래가지고 결과적으로는 여기서 테일을 건드리는 요 순간이 이제 위험하게 위험하고 팝하는 경우도 마찬가지로 해당 쪽에 헤드를 긁어 가지고 사용해서 , 이렇게, 하는 부분 자체가 멀티셋 환경에서 경험이 붙어 가지고 여러 명이 한다고 하면 당연히 정상적으로 동작을 할 수가 없을 겁니다 그래가지고 이 코드를 기반으로 이제 조금씩 코드를 바꿔줄 예정인데 혹시 이 코드를 참고하고 싶을 수도 있으니까 이걸 잠시 복붙을 한 다음에 아래에다가 우리가 고칠 버전으로 만들어주고 위에서 사용했던 이 버전을 일단 주석처리를 해서 같이 이따 올려드릴게요. 그래서 , 이렇게, 일단은, 주석처리를 해가지고 우리가 뭔가 의사코드로 스택, 그니까 Q를 사용할 그 의사코드를 일단 , 이렇게, 한번 만들어봤고 이제 이어가지고 얘를 고쳐볼 겁니다. 근데 결국에는 고치는 방법은 또 여러가지 알고리즘이 있을 수 있겠지만 우리가 지난번에 맨 마지막으로 알아본 레퍼런스 카운팅을 관리하는 방법을 이용을 또 해볼 거에요 그래가지고 느낌적인 느낌으로는 , 사실, 지난번에 스택을 했던 거랑 좀 비슷한데 추가적인 부분에서 또 경험이 붙기 때문에 그 부분을 추가로 처리해줘야 됩니다 근데 이거는 말로 하긴 너무 어려우니까 , 일단은, 코드를 만들어 본 다음에 이제 천천히 설명을 해보도록 할게요 카운티노드 ptr 여기까지는 지난번에 했던 거랑 크게 다르지 않구요. external count라고 해가지고 얘가 우리가 이전에 말한 참조건에 해당하는 그 카운트였었죠. 그 다음에 다음 포인터를 , 이렇게, 현재 PTR을 가리키고 있을 겁니다. 즉, 그냥 노드를 그냥 포인터로 들고 있는 게 아니라 이 노드에다가 그 카운팅을 같이 , 이렇게, 1 플러스 1으로 낑겨 넣는 작업을 우리가 , 이렇게, 하고 있다고 보시면 되겠어요. , 자, 그 다음에 이어서 노드 카운터라는 걸 만들어 줄 것인데 얘는 internal count 30 유인트 엑스터널 카운트 리메이닝 2 라고 일단 만들어 줄 겁니다 이게 유인트 32 유인트 32 이지만 진짜로 32 비트가 다 필요하지 않기 때문에 , 이렇게, 30 비트만 쪼개 가지고 우리가 활용할 것이고 2 비트만 차지하게끔 요렇게 유도를 해주게 되면 사실상 이 둘이 32 비트 즉 사바이트 안에 딱 들어가게 됩니다 그래가지고 얘를 , 이렇게, 만들어 준거구요 , 자, 이거는 인터널 카운트는 지난번에 우리가 스택을 사용할때도 등장했었지만 뭔가 참조권을 반환하는거랑 관련이 있구요 얘는 이제 새로 추가되는 애인데 이거는 푸쉬랑 팝에서 다중으로 서로 참조권을 사용하기 때문에 등장하는 애인데 이거는 나중에 코드에서 보면은 좀 이해가 갈겁니다 지금은 왠지는 모르겠지만 그냥 , 이렇게, 만든다고 가정을 하고 그 다음에 우리 노드를 만들 때 , 자, 원래는 , 이렇게, 데이터가 있었고 그 다음에 노드 카운터가 , 이렇게, 있었는데 얘가 일단 좀 날라가고 이걸 , 이렇게, 바꿔주도록 할게요 , 일단은, 데이터를 아토믹 타입으로 아토믹 타입으로 , 이렇게, 바꿔줄 것이구요 그 다음에 노드 카운터도 , 이렇게, 들고 있을 거고 카운트 그 다음에 카운티드 노드 ptr , 자, 이거 원래 이전에 스택에서는 얘랑 얘는 있었.. 얘는 비슷하게 있었는데 요 카운트가 , 일단은, 추가되었다고 보시면 되겠습니다 그 이유는 역시나 푸시팝을 할 때 다시 알아보도록 하고 뭐 기본적으로 노드를 처음에 만들어 줄 때는 , 자, 노드 카운터를 이제 세팅을 해줄건데 newCount newCount에 internalCount 같은 경우에는 0으로 밀어버릴거고 newCount에 externalCount remaining은 2로 밀어버릴겁니다 그 다음에 카운트에다가는 우리가 만들어준 newCount를 뿅 넣어줄것이구요 , 이렇게, 스토어 로드를 하지 않고 그냥 이런식으로 코드를 넣어줘도 상관없는데 이게 아토믹 타입이라는걸 좀 강조하기 위해서 스토어 함수로 , 이렇게, 만들어주도록 하겠습니다 그 다음에 초기 값으로 external count는 0으로 , 이렇게, 밀어 주도록 할게요 , 자, 그 다음에 나중에 여기서 release reference가 추가 될 건데 이거는 좀 나중에 작업을 하도록 하고 일단 노드의 정의는 그냥 , 이렇게, 일단은, 마련이 될 겁니다 그래가지고 어 다시 쭉 내려가지고 여기에 우리가 노드로 헤드랑 테일을 사용하고 있었는데 , 이렇게, 사용하는 게 아니라 아토믹 타입으로 카운티드 노드 카운티드 노드 ptr 타입으로 헤드를 만들어 줄 것이고 그 다음에 테일도 똑같이 이제 요 버전으로 관리를 하도록 할 거예요 이게 우리가 이전에 스탁에서 사용하던 거랑 비슷한 느낌이죠 뭔가 참조 횟수를 관리해가지고 동시다발적으로 삭제할 수 없도록 유지하기 위한 그런 힘겨운 노력이라고 볼 수가 있겠습니다 , 자, 그럼 이제 뭐부터 만들어 볼까 좀 고민 되는데 , 일단은, 푸쉬부터 작업을 해보도록 할게요 푸쉬에서 지금 요 로직을 , 일단은, 수정을 해볼 건데 여기서 지금 여러가지 문제가 있습니다 그래가지고 이거를 뭐 잠시 주석처리를 하고 새 코드를 만들어 볼 것인데 , 일단은, 데이터를 저장하기 위해서 뉴 데이터라고 유닉 포인터를 일단 만들어주도록 하겠습니다. 이게 코드가 굉장히 어렵기 때문에 , 일단은, 전체적으로 만들어진 다음에 그걸 분석해야 이해가 하기 쉬울 건데 그 다음에 카운티드 노드 PTR을 , 이렇게, 더미를 다시 만들어 줄 거예요. 우리가 푸쉬를 한다는 얘기는 이 버전을 다시 한번 긁어와서 생각을 해보면 아까 마찬가지로 새로운 더미를 만들어주고 원래 있던 데에다가는 우리가 , 이렇게, 데이터를 새로 밀어 넣어준 다음에 교체 작업을 하는 식으로 우리가 작업을 할 거니까 , 일단은, 더미노드를 , 이렇게, 새로 세팅을 해줍니다 그래서 External Count는 일단 1로 시작하는 상태이고요 , 자, 그 다음에 여기서 이제 경합을 붙어가지고 내가 진짜로 이 테일에다가 밀어넣기 위한 경합을 이제 시작을 할 겁니다 그래가지고 여기서 무한 루프를 돌 건데 , 일단은, 올드 테일을 요렇게 로드를 해주도록 할게요 지금 이 테일에 있는 값은 만약에 경합이 붙지 않았다고 하면은 이 더미노드에 해당하는 애고 더미노드는 시질 쪽으로 널 포인터를 지금 가리키고 있습니다 얘가 지금 널 PTR이 널 PTR인 상태이고요 그 다음에 여기다가 무한 루프를 계속 뺑뺑이를 돌면서 참조권을 획득하려고 할 겁니다 참조권을 획득하기 위해서는 external count를 현시점 기준 플러스 2를 한 애가 이제 승리자가 되는 거예요 이거는 우리가 이전에 만들었던 concurrent stack이랑 별로 다를 바가 없는데 이걸 이제 함수로 빼가지고 관리를 해주도록 할 겁니다 그래가지고 increaseExternalCount란 함수를 만들어 준 다음에 tail과 oldTail을 요렇게 넣어줄 것이고 이제 이 increaseExternalCount는 바로 이어가지고 쭉 내려가지고 이 아래쪽에다가 만들어 주도록 할게요 , 자, poppad은 이제 안 쓸 거니까 얘는 일단 잠시 날려주고 요 부분도 잠시 주석 처리하고 그 다음에 여기서 increaseExternalCount를 만들어 줄 것인데 , 일단은, 두 개의 인자를 받아주고 있어요. countedNodePtr을 먼저 하나를 , 이렇게, 받아주고 그 다음에 countedNodePtr을 두 번째 인자로 , 이렇게, 받아주는데 원래 우리가 스택을 만들 때는 헤더를 다시 한번 살펴보면은 얘를 잠시 왼쪽 오른쪽으로 밀어 가지고 보면은 비슷한 작업을 우리가 하긴 했었죠 여기다가 엑스널 카운트를 늘리는 작업을 푸쉬를 하는 순간에 여기서 하고 있었는데 지금은 이제 아까 말씀드린대로 이제 양쪽에서 이 참조권을 획득을 하려고 할 겁니다. 왜냐면은 헤드에서도 얘를 건드리고 테일에서는 얘를 참조하고 있고 푸쉬가 동시다발적으로 일어날 수도 있고 헤드가 동시다발적으로 일어날 수 있기 때문에 양쪽에서 서로 참조권을 , 이렇게, 각자 사용하고 있기 때문에 그거를 동시에 양쪽에서 다 사용을 할 수 있게끔 , 이렇게, 첫 번째 인자로 얘를 받아주고 있는 거예요. 얘가 이제 헤드랑 테일 둘 중 하나로 넘겨오게 될 겁니다. , 자, 이렇게, 해가지고 , 일단은, 뭐 지금은 당장 조립 단계니까 좀 어려울 수 있는데 어 , 이렇게, 카운터를 새로 만들어 줄 것이고 그 다음에 newCounter는 externalCount를 , 일단은, 1 증가시킨 상태로 우리가 유도를 해주고 있는 거예요 이 코드는 요 당장 요 코드 자체는 우리가 지난 시간에 했던 거랑 굉장히 비슷합니다 그래가지고 카운터에다가 compareExchangeStrung을 해가지고 올드 카운터와 뉴 카운터를 , 이렇게, 넣어 줘 가지고 올드 카운터 점 엑스널 카운트가 뉴 카운터 점 엑스널 카운트랑 만약에 같다고 하면은 브레이크를 때려 줄 겁니다. 즉 내가 얘를 참조하기 위해서는 이 1을 증가시킨 애를 내가 , 이렇게, 먹어야지만 내가 승리자가 된 거니까 빠져나올 것이고 그게 아니라고 한다면은 다시 루프를 돌아 가지고 경험에서 승리자가 될 때까지 얘를 계속 시도를 하는 거죠. 그래서 Increase External Count는 , 이렇게, 만들어질 것이고 얘는 말 그대로 참조권을 획득하기 위해서 내가 예상한 그 1을 증가시킨 수제를 테일에다가 성공적으로 밀어넣을 때까지 얘를 뺑뺑이로 돌고 있는 겁니다 나중에 팝을 할 때도 이 참조권을 똑같이 획득하기 위해서 경쟁을 할 건데 걔는 테일이 아니라 헤드를 대상으로 경합을 할 거예요 그러니까 지금 테일 따로 헤드 따로 , 이렇게, 참조권을 발급하는 티켓이 두 개가 있다고 생각하시면 되겠습니다 그건 그렇고 그래서 , 이렇게, 해가지고 여기까지 왔으면 그 다음에는 역시나 소유권을 획득해야 되겠죠 이건 어디까지나 이 노드를 사용할 수 있다는 얘기지 이 데이터를 내가 건드릴 수 있.. 그니까 내가 진짜 차지하겠다는 얘기는 아니니까 그 다음에는 데이터를 먼저 교환한 애가 승리가 승리자가 됩니다 교환한 애가 승리자 그래가지고 또다시 요렇게 경합을 붙을건데 , 일단은, 지금까지 데이터가 아무도 없었다고 하면은 이게 널포인터인 상태일겁니다 그래서 여기서 다시 2차 경쟁을 시작할건데 올드테일을 우리가 이제 참조권을 획득했으니까 얘를 사용할 수 있다고 했었죠 얘를 체크해가지고 컴퓨터 엑스텐지 를 통해 가지고 올드 데이터랑 뉴 데이터를 이제 교체를 하려고 시도를 할 거에요 , 자, 이를 개수로 , 이렇게, 만들어 주도록 합시다 네 , 이렇게, 해가지고 여기 안에 있는 데이터를 꺼내 가지고 지금 올드 데이터가 밀어 넣고 있는 건데 우리가 결국에는 이 데이터를 지금 , 이렇게, 포인터 타입으로 한 이유가 이것 때문입니다. 데이터를 내가 먼저 , 이렇게, 넣어준 애가 이긴다고 하는데 만약에 이거를 포인터가 아니라 이 내부에 있는 데이터 자체를 우리가 그냥 포인터 타입이 아닌 그냥 일반 데이터로 만약에 관리를 했다고 하면은 내가 진짜로 차지해가지고 그 값이 들어간 건지 아니면 원래 초기 값이 그 값이었는지 알기가 굉장히 힘들겠죠 반면 포인터로 하게 되면은 널 포인터가 아직 없다는 상태를 우리가 상태로 받아줄 수가 있으니까 내가 얘를 차지했는지 안했는지를 구분을 할 수가 있게 되고 그래가지고 우리가 이제 데이터를 포인터 타입으로 갖고 있다고 보시면 되겠어요 그래서 여기서 경합을 통해가지고 내가 만약 여기 들어왔다고 하면은 내가 성공적으로 소유권을 획득한 상태가 되는 거니까 아싸리 하고 이제 데이터를 설정해주기 시작합니다 , 자, 이 포인터의 덱스트를 일단 더미로 그니까 원래 내가 바라보고 있었던 요 테일에서 내가 만들어준 더미노드를 추가를 해주는 작업이 들어가고 있구요 그 다음에 올드 테일에다가 테일 엑스체인지를 통해가지고 더미 값을 여기다가 이제 넣어주는 거 테일을 이제 새 더미에다가 , 이렇게, 연결을 시켜주고 있습니다 네 그래서 요렇게 올드테일이 이제 바꿔치기가 된 상태이구요 그 다음에 , 자, 여기다가 이제 뭐 여기까지 했으면은 이제 빠져나올 수 있으니까 여기다가 빠져나올 건데 그 전에 어 뉴 데이터 점 릴리즈를 해가지고 지금 이 유니크 PTR 자체를 우리가 여기다가 관리하고 있는데 얘를 지금 다 사용했다고 여기서 만약에 승제가 되었다고 하면은 이미 데이터가 여기 데이터 안에 들어간 상태니까 얘는 더 이상 이제 활용할 필요 없습니다 그래서 이 릴리즈를 해주게 되면은 데이터에 대한 유니크 PTR의 소유권을 포기할 수가 있는데 두 번 괜히 이미 사용하고 있는 데이터를 괜히 딜리트하지 않게끔 얘를 밀어넣어주는 작업이 들어간다고 보시면 되겠어요 아이고 여기 하나가 빠졌네요 그래서 잠시만 줄이 안 맞는 거였고 , 자, 그 다음에 여기까지 와가지고 이제 데이터를 뭐 다 사용했다고 하면은 다시 이제 소유권을 줄여주기 위한 노력을 해야 되겠죠 소유권을 내주기 위한 노력을 해야 되는데 어 , 일단은, 여기까지 왔으면은 소유권을 획득하지 못한 상태 얘는 이제 경쟁에서 패배한 경쟁 패배한 애가 실행을 할 코드고 여기다가 PTR을 Release Reference를 , 이렇게, 호출해줄 겁니다. 그리고 소유권을 획득한의 기준으로는 Free External Count라는 이 묘한 함수를 , 이렇게, 호출해줄 건데 얘도 이어가지고 바로 작업을 해보도록 할게요. 쭉 내려가지고 여기 바로 아래다가 하나를 더 만들어 줄 건데 Free External Count를 , 이렇게, 만들어 줄 것이고 인자로는 Counted Node PTR을 받아주고 있습니다 그 다음에 얘가 하는 것은 이제 말 그대로 external count 횟수를 줄여주는 역할을 하고 있어요 그래가지고 , 일단은, 코드를 살펴보시면 node 에다가 old node ptr 에다가 ptr 을 , 이렇게, 갖고 오고요 그 다음에 우리가 이전에 락 프리스택에서 했던 거랑 비슷한 공식을 활용할 겁니다 그래가지고 카운트 인크리즈를 먼저 개선하고 있고요 여기다가 엑스널 카운트에서 2를 빼준 값만큼을 우리가 인크리즈를 해줬었죠 이게 이전에 사용하던 거랑 똑같습니다 그래서 올드 카운터를 다시 개선을 하려고 시도를 하고 있고요 PTR 카운트에다가 로드해가지고 이 카운터를 갖고 온 다음에 이제 1을 줄여주려고 노력을 하긴 할 건데 이게 뭐 항상 100%를 나 혼자 작업하는 그룹이 아니기 때문에 얘도 마찬가지로 계속 뺑뺑이를 돌면서 컴퓨터 수업 연산으로 해주게 될 겁니다 그래서 내가 지금 정리하고 싶은데 그 정리할 때 공식은 원래 , 이렇게, 올드 카운터가 있다고 하면은 새로운 카운터 같은 경우에는 , 일단은, 얘를 하나를 줄여 주고요 , 자, 얘는 계속 얘기가 나오고 있는데 얘는 왜 사용하는지 일단 이어서 말씀 드릴 거고 그 다음에 인터널 카운트를 우리가 계산한 카운트 인크리즈만큼을 증가시킬 겁니다 요 부분은 우리가 지난번에 프리스택에서 했던 거랑 똑같은 이유로 얘를 이제 , 이렇게, 더해주고 있는 거에요 그래서 이 공식을 이제 최종적으로 , 이렇게, 왔으면 체크를 해볼 건데 만약에 ptr 카운트에다가 compare exchange를 해가지고 올드 카운터와 뉴 카운터를 , 이렇게, 넣어준 다음에 우리가 예상한 여기서 꺼내온 카운터가 , 이렇게, 우리가 다른 값으로 계산할 때 동안 바뀌지 않았다고 하면 중간에 끼어든 애가 없다는 얘기가 되겠죠 끼어든 애가 없으면 성공적으로 우리가 계산한 뉴 카운터를 카운터에다가 대입을 해주겠다라는 코드가 시행이 됩니다 이런 식으로 경합에 붙을 때 내가 나만 지금 얘를 건드리고 있는지를 체크할 때 이런 연산을 우리가 계속 지금 반복해서 이런 흐름이 반복되고 있었죠? 그래서 , 이렇게, 해가지고 나만 만약에 얘를 지금 건드리고 있다고 하면 , 이렇게, 성공적으로 컴폐니션 수합 연산이 성공이 될 거고요. 그 다음에 여기까지 왔으면 이제 내가 얘를 해제할 수 있는지를 체크해볼 겁니다. InternalCount도 0이고 그 다음에 여기서 ExternalCountRemaining도 0이라고 하면은 내가 삭제할 수 있다는 얘기가 돼가지고 얘를 밀어 넣을 거예요. , 자, 그런데 이 ExternalCountRemaining의 의미는 무엇이냐 애당초 우리가 요 코드를 보면은 지금 참조권을 요렇게 여기서 획득을 하고 있어서 그래가지고 어 얘를 이제 사용할 수 있었는데 마찬가지로 나중에 팝을 할 때 헤드에서도 똑같이 첫 번째 데이터 같은 이 OI를 기준으로 똑같이 인스턴트 엑스턴트 카운트를 해가지고 참조권을 획득하려고 할 거예요 근데 이제 여기서 묘한 상황이 발생할 수 있는 게 뭐냐면은 우리가 여기까지 소유권까지 획득해서 이 부분으로 넘어왔다고 가정해 볼게요 그러니까 지금 푸쉬라는 입장이니까 만약에 , 이렇게, 있다고 , 이렇게, 있는 상황에서 데이터를, 얘를 , 일단은, 데이터를 밀어 놓고 그 다음에 여기다가 데이터를 추가하는 요 작업을 해야 되는데 이 간발의 차이로 내가 여기다가 푸쉬를 하려고 해서 이 올드테일을 막 장난치고 있는 순간에 데이터를 누군가가 꺼내가 가지고 이 데이터를 날려 버린다고 하면은 그럼 이제 dangling pointer 상태가 되겠죠 여기서 이 데이터는 누군가가 건드리고 있기 때문에 , 사실, 얘는 삭제하면 안 되는데 그런 상황이 지금 , 이렇게, 발생할 수 있다는 얘기가 되는 겁니다 그래가지고 두 번째 카운트를 하나를 도둬 가지고 이 external count remaining은 2에서 시작을 해가지고 얘가 0이 된다는 얘기는 뭐냐면은 이 푸쉬를 하는 쪽에서도 다 사용했고 팝을 하는 쪽에서도 다 사용을 했다라고 해가지고 순서를 이제 확실히 보장을 해주게 됩니다 그래가지고 혹시라도 내가 푸쉬를 하는 동안 얘를 이제 사용하고 있는데 혹시라도 얘를 팝해가지고 이 데이터를 날려 버릴까봐 공유해서 사용하는 이 데이터에 대한 레퍼런스 카운팅을 지금 따로 하고 있다고 보시면 되겠습니다 그래가지고 이 external 아까 얘기한 요 변수가 그래서 등장하게 되는 거고 둘 다 0이 아니면, 자, internal count 같은 경우는 내가 이제 볼일 받고 나간다라는 입장에서 얘를 0으로 만들 수 있었지만 혹시라도 이 external count remaining이 아직 0이 아니라고 하면은 어 딴 쪽에서 push나 pop 양쪽에서 동시에 건드리고 있을 수가 있기 때문에 걔를 아직 삭제하지 않고 나중으로 미루게 됩니다 그래서 얘를 진짜로 0으로 밀어주는 애가 실제적으로 삭제까지 담당을 하게 된다는 그런 얘기가 되겠습니다 이 코드가 , 사실, 굉장히 이해하기가 힘들어요 솔직히 말씀드리면 이거를 한 번에 딱 이해하시면 진짜 천재적인 거고요 이 코드가 완성된 코드를 계속 반복해서 봐야지 아마 이해할 수가 있을 겁니다 그건 그렇고 이제 노드에서 릴리스 레퍼런스 하는 거는 패배자들이 실행하는 그 코드였었죠 이것도 락프리스택에서 똑같이 패배자가 그냥 울면서 1 감소시키는 그 코드를 여기서도 똑같이 해줄 건데 얘도 마찬가지로 노드 카운터를 , 이렇게, 갖고 와가지고 , 자, 올드 카운터를 , 일단은, 갖고 올 겁니다 카운트 점 로드를 해가지고 , 일단은, 요 아토미 타입의 카운터를 갖고 온 다음에 얘는 굉장히 단순하게 그냥 1을 줄여 주고 싶어요 사실상 얘가 하고 싶은 거는 1을 줄여 주고 싶은 건데 이 릴리즈를 줄이는 행동도 누군가가 동시에 들어와 가지고 할 수 있기 때문에 얘를 고지곳대로 할 수는 없습니다. 이 노드 카운터라는 것 자체가 두 개의 값으로 , 이렇게, 이루어져 있기 때문에 설령 얘가 아토믹이라고 해도 얘를 그냥 고지곳대로 우리가 건드릴 수는 없고 이런 식으로 컴페어 수업 연산을 통해 가지고 건드리고 있는데 이거는 나중에 우리가 다음 시그널에 알아볼 리드라이트 락을 할 때도 이런 패턴이 등장하게 될 겁니다. 그래가지고 노드 카운터를 만들어주고 뉴 카운터를 올드 카운터로 해준 다음에 우리가 해주고 싶은 거는 뉴 카운터 인터널 카운터를 1 줄이고 싶은 거죠 근데 요 상황에서 유심히 보면은 노드 카운터의 인터널이 아닌 이 엑스터널 카운트 리미닝도 그대로 들어가 있습니다 혹시라도 이 순간에 누군가가 엑스터널 카운트 리미닝을 줄여가지고 얘가 바뀐다고 하면은 최종적으로 우리가 예상한 요 값도 같이 바뀌게 될 거니까 컴퓨터 수업을 실패하게 됩니다 즉 여기서 중간에 끼어들 수 있는 상황도 우리가 예측해가지고 요런 코드를 만들고 있는 거고 그래서 컴페어 스왑을 해준 다음에 올드 카운터를 넣어주고 뉴 카운터도 , 이렇게, 넣어주도록 하겠습니다 , 자, 그래가지고 여기서 끼워둘 수 있긴 한데 여기까지 해서 컴퓨터 수업을 성공했으면 내가 예상한 값으로 내가 , 이렇게, 넣어준 셈이 되는 거니까 내가 지금 여기서 릴리스하는 그 1을 줄여주는 이 코드에 대한 승리자가 된 거죠 근데 여기서 한 번 더 체크할 거는 뭐냐면은 newCounter의 internalCount가 진짜 0이고 그리고 newCounter의 externalCount remaining도 둘 다 0이라고 하면은 어 아까 얘기한 대로 동시에 푸쉬 팝을 동시에 해가지고 동시에 같은 노드를 건드리고 있는 상황에 대해서 의해 처리를 또 해주고 있습니다 내가 얘를 괜히 건드리는 바람에 아까 푸쉬하는 쪽에서 만약에 얘를 삭제를 못했다고 하면은 마지막으로 나가는 애가 얘를 더 이상 아무도 건드리는 애가 없을 때 얘를 딜리트를 같이 해주고 있습니다 그래서 요 부분에서도 체크가 들어가고 아까 요 인 어 어딨나요 요기 프리 엑스터널 카운트라는 요 부분에서도 코드가 두 번 등장하게 되는데 결국에는 두 코드가 결국 같은 의미입니다 최종적으로 마지막에 건드리는 애가 즉 방에서 마지막으로 나간 애가 불을 꺼주세요 라는 코드가 지금 , 이렇게, 들어가고 있는 상황이라고 보시면 되겠습니다 아리달송 하죠 , 자, 이게 약간 멘탈의 우주로 갈 수도 있는데 뭐 그래가지고 결국에는 요 코드가 요렇게 실행이 되면은 이제 , 일단은, 푸쉬에 대한 코드는 완료가 된다고 보시면 되겠어요 그 다음에 이제 이어가지고 , 자, 이제 트라이 팝도 비슷한 로직으로 만들어 볼 건데 그나마 다행인 건 이미 이제 중간 부품들은 다 우리가 공용으로 사용할 것이기 때문에 이 코드를 기반으로 다시 한번 생각을 해보도록 할게요 헤드테일이 있고 여기 더미 노드는 비어있는 이 상태에서 우리가 팝을 해줄 건데 팝을 할 때는 이 헤드가 가리키고 있는 이 데이터를 우리가 꺼내줄 겁니다 그래가지고 역시나 카운티드 노드 PTR을 올드 헤드를 갖고 올 것이고 헤드점 로드를 해서 , 일단은, 헤드를 갖고 올 것이지만 얘를 내가 꺼내가지고 사용하는 순간에 누군가가 이미 팝을 해서 더이상 내가 얘를 사용할 수도 없는 상황도 충분히 발생할 수 있기 때문에 역시나 마찬가지로 참조권을 획득을 해야 되겠죠 참조권 획득 , 자, 그리고 역시나 참조권 획득 조건은 우리가 푸쉬 할 때랑 마찬가지로 external count를 처지점 기준 정확히 플러스 1을 한 애가 승리자가 됩니다 여기서 말씀을 드린 바와 같이 여기 위에서 푸쉬에서 경합하고 있는 이 참조권 획득이랑 팝에서 하고 있는 이 참조권 경쟁이랑은 별개라고 보시면 되겠어요. 이 값과 이 값은 지금 따로따로 , 일단은, 관리를 하고 있을 겁니다. 그래가지고 , 일단은, 얘도 increase external count를 통해 가져갈 건데 얘는 이제 헤드를 통해 가지고 이 올드 헤드를 지금 , 이렇게, 사용을 하려고 시도를 할 거예요. 그래서 이 헤드의 참조권을 얘는 경쟁을 하고 있는 겁니다. 참고로 여기 헤드 참조권을 유심히 보면은 다시 위에 코드를 올려보면은 이 부분을 우리가 아직 처리를 안 해놨는데 여기 락 프리 큐를 초기화하는 코드에서 이제는 이런 식으로 뉴 노드를 하는 게 아니라 애당초 헤드랑 테일이 다른 타입으로 바뀌었었죠 여기 초기화 부분을 , 이렇게, 세팅을 해줄 거에요. 이 노드를 만들어 줄 것이고 노드의 PTR은 새 노드를 만들어 준 다음에 기본적으로 External Count는 서로 1로 만들어 줄 것이고 헤드에다가도 이 노드값을 저장하고 테일에다가도 , 이렇게, 노드값을 저장할 겁니다. 그러면 결국에는 이 아이 자체의 지금 값도 1로 세팅이 된 거고 테일에 대한 값도 1로 세팅이 된 거지만 우리가 설령 이 테일에 대한 첨조권을 획득해가지고 External Count가 1 증가했다고 하더라도 그게 당장 이 헤드에 대한 External Count에는 영향을 미치지 않는다는 걸 볼 수가 있습니다 그래가지고 얘랑 얘를 지금 아예 우리가 따로따로 지금 , 이렇게, 카운팅을 해가지고 관리를 하고 있다는 걸 유심히 보셔야 돼요 그래가지고 결국엔 돌고 돌아서 얘 때문에 이 External Count Remaining까지 카운트를 해가지고 진짜로 이 우리가 푸쉬팝을 동시에 하는 상황까지도 염두에 둔 코드가 그래서 들어가게 된 겁니다 이게 말이 전달이 될지 모르겠네요 워낙 어려운 부분이어가지고 아마 이게 제 서버 강의를 지금 만들면서 아마 이 부분이 그냥 역대급으로 가장 어렵지 않을까 생각을 합니다 , 이렇게, 어려운 락프리코드는 , 사실, 다해서 만들 필요가 없기 때문에 그래가지고 , 이렇게, 참조권을 획득을 했고요 그 다음에 이제 이어가지고 올드헤드의 PTR을 갖고 온 다음에 여기서 이제 데이터가 있는지를 체크할 겁니다. 테일에다가 데이터를 꺼내 봐가지고 PTR을 똑같이 비교했더니만 어? 같네? 같은 상황이라고 한다면 지금 요 상황이 된거죠. 데이터가 없고 공용 노드만 요렇게 사용하고 있고 이 상황에 대해서는 둘이 같은 PTR을 참조하고 있을 테니까 그 상황이라고 한다면은 여기서 릴리스 레퍼런스 해가지고 난 더 이상 사용하지 않을 거니까 이 참조권을 줄여주고 참조권에 대한 처리를 해주고 그 다음에 리턴 유닉PTR을 그냥 요렇게 고질고질로 뱉어줄 겁니다 , 자, 요렇게 뱉어줄 것이고 음 그 다음에 어... 이제 이어가지고 아 얘를 뭐 Shared PTR로 해도 되고 유닉 PTR로 해도 되고요 네 이거 Shared PTR로 바꿔줘도록 할게요 그 다음에 이제 이어가지고 여기까지 왔으면은 내가 참조권을 획득했으니까 이 데이터를 꺼내가기 위해서 또 경합이 붙겠죠 그래서 Compare Exchange Strung을 해줄 것인데 Old Head랑 PTR의 Next랑 , 이렇게, 경합을 해줘가지고 얘는 이제 말그대로 소유권 획득을 시도하는 거고 그거를 하기 위한 조건은 Head를 PTR Next로 먼저 다음 애로 바꿔치기한 애가 승자가 되겠습니다 만약에 , 이렇게, 데이터가 있는 상태에서 얘를 꺼내기 위해서는 이 다음 데이터로 헤드를 세팅한 애가 승리자가 된다고 , 일단은, 볼 수가 있겠죠 여기까지 왔으면 내가 승리자가 된 거니까 이제 뭐 데이터를 진짜로 빼내주면 되겠습니다 수단과 방법을 가리지 않고 이제 내가 완전히 소유권이 있는 거니까 데이터를 이제 null로 밀어 줘 가지고 사용하지 못하게 한 다음에 Free External Count를 해가지고 , 자, 올드에다가 External Count를 1 줄여줌과 동시에 Unique PTR 아이고 Shared PTR로 하기로 했었죠 Shared PTR에다가 요 Less 값을 요렇게 갖고 오면 되겠습니다 그리고 ptr의 release reference를 여기서 최종적으로 취해줄 건데 얘는 소유권 획득에 실패해가지고 패배한 애가 뒷정리를 하고 있는 그 상황이라고 보시면 되겠습니다 그러니까 전체적인 느낌은 결국에는 우리가 lock-free-stack을 만들 때랑 비슷한데 헤드랑트 양쪽에서 경험을 하고 있기 때문에 생각보다 코드가 복잡해졌다는 걸 , 일단은, 알 수가 있는 거죠 , 자, 이렇게, 해가지고 어느정도 코드가 완성이 됐구요 이제 이거를 뭐 지금 빌드를 해보면은 , 이렇게, 에러가 나오고 있는데 아 여기다가 제가 코드를 하나 빼먹었네요 딜리트 PTR을 해줘야 되겠죠 , 이렇게, 해가지고 , 일단은, 코드가 만들어지구요 음 이걸 일단 간단하게 테스트 한 다음에 잘 돌아가는지 한번 체크를 해 보도록 하겠습니다 , 자, 일단은, 여기 락 프리 큐를 락 프리 락큐를 락프릭큐로 사용하게끔 바꿔준 다음에 여기 있는 부분만 큐로 바꿔치기를 해주면 일단 문제없이 나머지 부분이 통과가 될 것이고 이 코드를 실행해 보면은 현실적으로 뭐 , 일단은, 이게 진짜 100% 잘 동작하는지는 모르겠지만 일단 확실한 것은 메모리 리그는 없고 크래시도 나지 않고 , 일단은, 잘 실행이 되고 있는 걸 볼 수가 있습니다 , 이렇게, 해가지고 뭐 지금 아마 당장 이해가 안 가실텐데 그래서 다시 복습을 해보자면 , 사실, 락프리 스택을 잘 이해하셨으면 거기에다가 이제 플러스 알파로 기능이 더 추가되었다고 볼 수가 있는 건데 우리가 , 이렇게, Q라는 자료 구조가 스택과는 다르게 스택은 같은 곳을 우리가 계속 푸쉬 팝으로 건드리고 있기 때문에 여기서 경험이 붙는 부분이 있었다고 하면은 지금 같은 경우는 테일과 헤드를 우리가 따로따로 관리하고 있죠 그래서 푸쉬는 , 사실, 테일이랑 연관성이 있고 헤드는 팝이랑만 연관이 있기는 한데 예외적으로 문제가 일어날 수 있는 상황은 우리가 여기다가 데이터를 밀어 넣자마자 바로 걔가 데이터를 꺼내 가가지고 그래가지고 이제 양쪽에서 서로 동일한 노드를 중간에 건드릴 수 있는 상황이 있을 수도 있기 때문에 추가적으로 그 상황을 방지하기 위해서 External Count Remaining 이라는 걸 , 이렇게, 넣었다고 볼 수가 있겠습니다. 그거를 제외하고 , 사실, 독립적으로 생각을 해보면 우리가 Lock Free Stack을 만들었던 것처럼 참조권을 획득을 하고 그 다음에 참조권을 다시 놓아주고 하는 부분이 들어가는데 참조권을 놓아줄 때도 혹시라도 다른 애가 건드릴 수 있기 때문에 그거를 내가 삭제해도 되는지 아니면 다른 애가 삭제해야 되는지를 체크하기 위해서 이런 식으로 레퍼런스 카운팅을 인터널 카운트를 체크해 가지고 얘가 최종적으로 0이 돼서 진짜로 삭제할 애만 얘를 삭제를 하도록 유도를 해준 코드가 양쪽에 들어가게 됩니다 그래가지고 푸쉬를 할 때 요 부분이랑 요 부분이 결국에는 내가 지금 소유하고 있는 참조권을 놔주면서 진짜 이 노드가 필요없는지 삭제해도 되는지를 체크를 하는 부분이구요 이게 똑같이 대칭적으로 이쪽에서도 똑같이 들어가죠 트라이팝을 할 때도 얘가 들어갑니다 근데 엄밀히 말하면 여기서 헷갈릴 수 있는 부분이 노드를 삭제하는 거는 , 사실, 팝에서만 해야 되는 거 아닐까라는 생각이 들 수도 있습니다. 예를 들면 지금 여기서 데이터를 뽑아가지고 꺼내 온 다음에 이 데이터를 삭제하는 게 이제 팝을 하는 역할이었고 푸쉬하는 입장에서는 데이터를 밀어 넣은 다음에 비어있는 더미 노드를 추가하는 게 원래 푸쉬의 역할이었죠. 그럼에도 불구하고 왜 얘가 이런 식으로 프리 엑스터널 카운터를 통해 가지고 여기서도 잠재적으로 삭제를 할 수 있냐면은 아까 얘기한 대로 이 헤드랑 테일이 정말 정말 정말 절묘하게 타이밍이 맞아떨어져가지고 이 테일이 지금 , 이렇게, 데이터를 추가함과 동시에 이 데이터를 지금 추가해가지고 뭐 요 상황이라고 가정해볼게요 빈 데이터를 여기다가 , 이렇게, 밀어넣어준 다음에 더미 노드를 추가하고 이제 테일을 이제 이쪽으로 옮기려고 하는 요 로직을 지금 실행하고 있는 찰나 누군가가 팝을 해가지고 이 데이터를 꺼낼 수가 있으니까 이 상황이 된다고 하면 설령 팝을 했다고 하더라도 얘를 당장 삭제하면 안되겠죠 왜냐면 푸쉬하는 코드에서 얘를 참조해가지고 사용하고 있으니까 그럴 수는 없기 때문에 당장은 여기서 삭제가 되지 않고 이 레퍼런스 카운팅에서 이제 걸러지게 됩니다 그래가지고 결국은 이 상태가 되면은 어 요 코드를 보면은 결국에는 엑스터널 카운트 리메이닝이 0으로 안 떨어지기 때문에 여기서 삭제를 하지 않고 뒤늦게 자기 작업 룰루랄라 하면서 자기 작업을 마쳐가지고 이 테일이 그 로직을 끝나게 되면은 그제서야 다시 한번 레퍼런스 카운팅을 체크하다가 어 뭐야 얘가 이미 꺼내가지고 헤드가 이미 꺼내가지고 필요가 없는 애네라는 생각이 들면은 여기서 간접적으로 프리 엑스터널 카운트를 호출하면서 이 노드를 날려줄 수가 있다는 얘기가 되는 겁니다 그런 흐름들이 같이 들어가기 때문에 굉장히 어렵고요 이것도 당연한 얘기지만 제가 갑자기 어느 날 생각해서 만들어 볼까 해서 만든 건 아니고 책에 등장하는 코드를 그대로 옮겨왔습니다 제가 드리고 싶은 말씀은 락프리에 대한 자료 구조를 만드는 거는 진짜로 어려운 일입니다 여기서 혹시라도 제가 뭔가 오타를 냈거나 강구한 부분이 있어가지고 이게 정말 극악의 확률로 한 번씩 크래시가 난다고 하면 그 로직을 굉장히 찾기가 어려워집니다 그럼에도 불구하고 심지어 이 코드가 , 사실, 좀 더 개선 사항이 있긴 해요 책에 이거에 대해서 푸쉬를 더 개선하는 방법 등등이 나와 있는데 여기서 더 이상은 진행하지 않을 것이고 여기서 딱 봐도 알 수 있는 게 뭐냐면 일단 락3 프로그래밍에 대한 느낌적인 느낌이 일단 알 수가 있었습니다 그래서 데이터를 바로 세팅을 막 하는 게 아니라 혹시라도 누군가가 동시에 접근할 수 있었기 때문에 이런 식으로 루프를 돌면서 내가 뭐 내가 늘린 값을 , 이렇게, 차지할 때까지 내가 참조권을 획득하고 소유권을 획득하고 하는 루프를 돌고 있는데 이 상황에 대해서 누군가가 같이 경험이 붙어 가지고 건드렸다고 하면은 얘를 이제 루프를 다시 도는 그런 상황이 종종 발생할 수 있다는 얘기가 되는 거죠 , 이렇게, 해가지고 제가 개인적으로 굉장히 싫어하는 락프레이 스택이랑 락프레이 큐를 구현하는 부분에 대해서 간략하게 알아봤고요 이 코드가 제가 올려드리긴 할 거지만 이걸 완벽하게 이해가 안 간다고 하면 그냥 느낌적인 느낌으로만 살짝 보고 넘어가셔도 되겠습니다 이 코드는 다음에는 더 이상 사용하지 않을 것이고 이런 식으로 뭔가 락프레이가 일어나는구나 그리고 어떤 부분이 , 사실, 문제가 되는지만 잘 기억을 해주시면 되겠어요 결국에는 락프리에서 , 이렇게, 일어나는 문제가 특히나 C++같이 메모리를 우리가 직접 관리해야 되는 언어에서는 동시다발적으로 누군가가 접근을 할 수 있기 때문에 걔를 내가 괜히 건드리거나 로드를 딜리트를 함부로 할 수 없는 부분 때문에 , 이렇게, 더러운 코드가 만들어진다는 걸 알 수가 있었죠 그리고 제가 예전에 게임 프로그래머 면접을 볼 때 종종 락프리에 대한 질문들을 받은 경우가 꽤 있습니다 그리고 락프리에 대해서 물어보다가 이런 락프리 Q 같은 거 혹시 구현해 본 적이 있냐 라는 질문도 받아본 적이 있기 때문에 , 사실, 이런 것도 필수적이지는 않지만 안다고 딱히 뭐 손해 볼 부분은 없으니까 , 이렇게, 뭔가 우리가 지금 작업하던 Q랑 스택과 관련된 부분을 얼음풋 기억을 해주시면 , 일단은, 도움이 된다고 보시면 되겠어요 , 자, 이렇게, 해가지고 완전히 100% 만족할 수 있는 완성된 코드는 아니지만 락프리 스택과 Q에 대한 내용을 쭉 알아보고 , 일단은, 이번 강의를 마치도록 하겠습니다.