자, 이어서 이번 시간에는 , 이렇게, 간단한 락 기반의 스택 즉 락 베이스드 스택이 아니라 락 프리 스택이라고 해가지고 락을 사용하지 않는 버전으로 하나를 더 만들어 줄 겁니다 이걸 락 프리 프로그래밍이라고 하는데 참고로 저는 개인적으로 락 프리 프로그래밍을 굉장히 싫어하는 편이에요 이게 약간 호불호가 갈리는데 왜냐하면 이게 굉장히 복잡한 반면 생각보다 성능 테스트를 해보면 그냥 락을 걸어 가지고 하는 것만 못한 경우가 굉장히 많기 때문에 이거 뭐 , 사실, 어떻게 보면 굉장히 멋있고 간지나는 그런 방법이긴 하지만 실질적으로 굉장히 많은 혼동을 유발하는 것 같아요 락 프리라고 해가지고 락 없이 뭔가 스택이 돌아가니까 이게 더 빠르게 동작할 것 같지만 실상은 동기화를 맞춰주기 위해서 굉장히 끔찍한 작업들을 많이 해야 합니다 그래서 제가 C샵 강의에서는 락프리를 다루지 않았었는데 개인적인 쪽지로 이번 C++에서는 그래도 좀 다뤄줬으면 좋겠다 궁금하다라는 분들이 계셔가지고 이제 이거를 그래도 , 일단은, 알아보도록 하겠습니다 좀 서론이 길었는데 , 자, 그래서 , 일단은, 스택 여기 컨퀴런스 스택 쪽에서 아래에다가 이어가지고 이쪽에다가 락프리 스택이라는 걸 만들어 줄 거고요 락프리 스택 얘 같은 경우에는 그냥 뭐 기존에 사용하던 stl 스택을 랩핑하는 형태가 아니라 진짜 우리가 처음부터 다시 만들어야지 그래야지만 우리가 락프릭 구조로 얘를 바꿔줄 수가 있어요 그래가지고 , 일단은, 노드 기반으로 , 자, 이렇게, 노드 기반으로 바꿔줄 것이고 여기에 데이터가 있을 것이고 그 다음에 다음 노드를 , 이렇게, 넥스트로 가리켜 주도록 할게요 자료 구조 알고리즘을 아예 모르신다고 하면 좀 따라가기 힘들 수도 있습니다 참고로 그거는 염두에 두시고 , 자, 그 다음에 여기다가 뭐 이런 식으로 어떤 값을 받아가지고 그 값을 저장하는 그런 생성자를 , 이렇게, 미리 만들어 놓도록 할게요. 그 다음에 , 자, public private 영역을 미리 잡아주고 어, 이제 이어가지고 이 stack이라는 클래스 안에서는 , 이렇게, atomic type으로 head라는 걸 이제 들고 있을 겁니다. 그러니까 stack이라는 자료 구조를 유심히 생각을 해보면 결국에는 , 이렇게, list와 마찬가지로 , 이렇게, 리스터와 마찬가지로 일련의 데이터들이 막 , 이렇게, 있는 거고 거기다가 head라는 변수를 통해가지고 이 첫 번째 데이터를 얘가 가리키고 있는 형태로 냅두면 되겠죠 그러면은 데이터를 새로 밀어 넣을 때는 여기 이 head가 가리키고 있는 이 앞에다가 , 이렇게, 계속 밀어 넣고 데이터를 꺼낼 때는 head가 가리키고 있는 애를 꺼내가지고 데이터를 빼서 쓴 다음에 이 노드를 날리는 식으로 작업을 해주면 되겠습니다 그래가지고 이제 이 head라는 변수가 있는 거죠 뭐 이렇게까지 , 일단은, 만들어놨구요 그 다음에 굉장히 간단하게 이쪽에서 Push부터 만들어 보도록 하겠습니다 뭐 이런식으로 Value를 , 일단은, 받아주도록 할게요 물론 나중에 가면 이거를 뭐 오른값으로도 받아주고 여러가지 버전으로 받아주는게 좋겠지만 , 일단은, 간단하게 하기 위해서 그냥 , 이렇게, 왼값 참조로 , 일단은, 받아주도록 할게요 그 다음에 어 이제 그러면 다시 복습을 해보면 이제 그림을 다시 한번 그려가지고 이제 우리가 여기서 뭘 해야 될지 곰곰히 생각을 해봅시다. 푸쉬를 한다는거는 어떤 값을 넣어준다는건 우리가 일단 새로운 노드를 만들어 준 다음에 이 값을 안에다가 , 이렇게, 넣어줄 것이고 그 다음에 얘를 이제 연결을 시켜줘야 되겠죠 기존에 여기 헤드로 가리키고 있던 애가 대장이라고 한다면 이제 왕이 계승을 시켜줘야 되겠습니다 그래서 요 노드에 다음 노드를 원래 헤드가 가리키고 있던 요 아이로 만들어 준 다음에 그 다음에 이 노드를 다시 헤드에다가 넣어주게 되면은 이제 요런 상태가 되겠죠 그래가지고 이제 왕위 계승을 완전히 , 이렇게, 받은 그런 상황으로 우리가 유도를 해줘야 돼요 결국에는 이걸 세 스텝으로 나눌 수가 있는데 새 노드를 , 일단은, 만들고 물론 여기서 데이터를 같이 넣어주고 그건 생략을 할 건데 그 다음에 새 노드의 넥스트를 어 이제 원래 가리키던 헤드값을 가리키게끔 , 이렇게, 유도를 해준 다음에 그 다음에 헤드를 새 노드로 , 이렇게, 바꿔치기를 해주면 됩니다 뭐 말로 푸니까 그렇게 어렵지는 않죠 그래서 이거를 뭐 지금 , 이렇게, 코드로 해보자면 뭐 , 이렇게, 일단은, 노드를 만들어줄 수가 있습니다 새 노드를 만들어줘서 데이터를 연결을 하고 이게 1단계였죠 그 다음에 그 노드에 넥스트를 원래 헤드값 헤드값이 가리키고 있던 애로 , 이렇게, 넣어줍니다. 만약에 헤드가 널이라고 해가지고 데이터가 없는 상태였다고 해도 얘가 알아서 널 포인터로 되기 때문에 상관이 없어요. 그래가지고 데이터가 있건 없이 상관없이 얘를 요렇게 넣어주면 되구요. 그 다음에 헤드를 이제 새로 만든 애로 계승을 시켜줍니다 왕위 계승을 하는 그런 아름다운 상황이 되는 거죠 이게 싱글스레드 코드라고 하면은 뭐 , 이렇게, 끝내주면 되는데 이제 멀티스레드 환경이다 보니까 이게 약간 문제가 생깁니다 어 이제 이런걸 좀 바라보는 눈이 슬슬 길러지셔야 되는데 일단 요 1,2,3번 중에서 새 노드를 요렇게 만드는 요 단계는 뭐 아무런 문제가 없어요 이 데이터 자체는 힙에 있긴 하지만 이 노드를 참조하고 있는 이 포인터 자체는 스택 영역에 있기 때문에 다른 애들이 똑같이 현재 힙에 만들어진 이 노드를 건드릴 수 없기 때문에 얘는 아직 아무런 상관이 없습니다 근데 이제 여기부터 문제가 되는 것인데 이 헤드라는 것 자체는 만약에 이 락 프리 스택을 공용으로 여러 명이 사용해 가지고 푸쉬를 하고 있다고 하면은 이 헤드는 동시에 여러 명이 접근할 수 있겠죠 그러다보니까 내가 헤드를 추출해가지고 그걸 넥스트에다가 넣어놨는데 얘가 이제 왕위 계승을 준비하는 단계이고 실질적으로 왕위 계승을 여기서 하고 있습니다 근데 요단계랑 요단계랑 , 이렇게, 나눠져 있기 때문에 내가 넥스트에다가 원래 있던 헤드를 넣어줬는데 그 사이에 이 간발의 사이에 이 사이에 새치기에 당할 수가 있는 문제가 생기는 거죠 다른 애도 똑같이 이 로직을 실행해가지고 그 헤드를 넥스트로 한 다음에 노드 헤드를 실행하게 되면은 이제는 이 헤드가 원래 있던 그 값이 아니라 딴 애가 될 수도 있다는 얘기가 되는 겁니다 그러니까 1번은 얘를 실행하고 2번은 얘를 실행하는데 2번이 간발의 차이로 먼저 얘를 이제 딱 요렇게 넣어주게 되면은 얘가 실행하던 코드는 , 사실, 깨진 셈이 되는거죠 왜냐면 이 헤드 자체가 두번째 애를 가리키니까 엄밀히 말하면 걔가 왕좌에 앉은 애가 아니기 때문에 바꿔치기라도 아무런 의미가 없게 되는 겁니다 그러니까 요런 부분들을 신경을 써줘야 된다고 보시면 되겠어요 그럼 이제 이거를 어떻게 신경을 써야 되느냐 말 그대로 요렇게 고지고때로 그냥 한번에 넣는게 아니라 이것도 우리가 열심히 배운 compare and swap 연산을 이용해가지고 얘를 체크를 해줘서 넣어줘야 됩니다 그래서 바로 코드를 보여드리자면 헤드에다가 compare exchange를 해가지고 여기다가 node의 next가 헤드랑 같다면 node를 넣어주세요 라는걸 이제 할건데 얘가 실패를 하면 성공할 때까지 계속 뺑뺑이를 돌아줄 겁니다 , 자, 요코드가 이제 좀 어리달송 하죠 이게 왜 나온거지 싶은데 이거를 이제 뭐 혹시 익숙하지 않으실까봐 다시 한번 풀어 쓰자면 원래 요런 코드라고 했었죠 노드의 넥스트랑 지금 비교를 해주고 있는거고 어 엑스펙티드랑 비교를 해주고 만약에 엑스펙티드 값이랑 같다고 하면은 그러면은 우리가 디사이어드라고 여기 두번째로 넣어준 L을 이용해가지고 요 L을 바꿔치기를 해주고 그 다음에 리턴 트루를 해줍니다 근데 반면 그 값이 같지 않다고 했으면은 원래 있던 헤드값을 여기 node-next 즉 엑스펙트드에다가 넣어준다고 했었죠 사실상 요 부분이 , 이렇게, 실행이 된다고 볼 수가 있어요 이거를 아토믹하게 한 번에 빵! 시켜주는 그런 함수가 이 컴퓨어 엑스행지라고 했었죠 그러다 보니까 이 버전으로 만약에 실행하게 되면 , 일단은, 우리가 넥스트에다가 헤드값을 먼저 넣어놨지만 혹시라도 그 사이에 누군가가 바꿔치기를 했는지를 크로스체킹을 할 수 있게 된다고 보시면 되겠어요 여기서 , 이렇게, 체크를 하고 있죠 만약에 실패했으면 그 정말 간발의 사이에 누군가가 새치기를 한 상황이 됐으니까 다시 한번 시도를 해야 될 것이고 그게 아니라 내가 성공했다고 하면 트롤을 리턴하면서 원래 우리가 의도했던 이 노드값이 헤드 안에 들어가게 되겠습니다. 이 코드로 , 일단은, 분석을 해주시고 이게 한 번에 일어난다고 , 일단은, 받아주시면 되겠습니다. , 일단은, 주석처리를 해드릴게요. 이런 느낌 , 자, 그래가지고 만약에 실패했을 때는 뭐 원래는 우리가 예전에 락을 만들 때는 초기 값을 다시 세팅을 해줬죠 이 코드를 여기다가 다시 , 이렇게, 넣어 놨었는데 얘는 정말 운이 좋게도 우리가 원하는 코드 자체가 엘스문에서 같이 , 이렇게, 해주기 때문에 뭐 얘를 굳이 두 번 해줄 필요는 없어서 얘는 일단 생략할 수가 있어요 그래서 정말로 , 이렇게, 와일문 하나, 안에는 텅텅 빈 와일문으로 만들어주면 이제 이 단계를 락프레이를 이용해 가지고 우리가 만들 수가 있게 된 겁니다 여기서 , 일단은, 한 가지를 눈치채셔야 되는데 결국에는 락프리 프로그래밍이라고 하더라도 경합에 경합 없이 진짜 모든 일감을 다 처리할 수 있다는 얘기는 아닙니다 말 그대로 우리가 명시적으로 락을 잡지 않았다는 의미이지 여기서 이제 문제라 하긴 뭐하고 여기서도 이제 좀 느리게 작동할 수 있는 확률은 만약에 너무 경합이 심해 가지고 막 스레드 몇백 개 해서 서로 막 푸쉬 하려고 난리를 친다고 가정을 하면은 내가 이 단계에서 헤드를 꺼내서 넥스트를 만들어 준 다음에 여기서 이제 컴퓨터 앤 스왑을 하는 순간에 새치기를 당했다고 하면은 요 단계가 실패라면서 이제 다시 한번 새로운 시도를 해야 되겠죠 그래서 정말 운이 나쁘면 물론 이런 확률은 거의 없겠지만 다른 애들한테 계속 새치기를 당해 가지고 어떤 스레드가 계속 트라이를 해도 통과를 못하는 그런 상황도 발생할 수 있다는 얘기가 되는 겁니다 그런걸 이제 우리가 데드락은 아니고 라이브락 상황이라고 하는데 거꾸로 결국에는 이제 락프리 프로그래밍이라고 하더라도 , 이렇게, 대기 상태가 완전히 없는 경우는 없다고 보시면 되겠어요 뭐 어쨌든 , 이렇게, 해가지고 푸쉬에 대한 간단한 실습을 해봤는데 , 이렇게, 해가지고 푸쉬를 구현을 해봤습니다 푸쉬는 그나마 좀 간단한 편이에요 왜냐면은 이 노드 자체를 내가 먼저 내 것만 만들어 가지고 따로 관리하고 남들은 아직까지는 이 노드를 접근해서 사용할 수 없기 때문에 생각보다 경합이 많이 없었고 유일하게 신경 쓸 부분이 이 헤드를 접근해 가지고 넥스트를 연결하는 이 부분이었습니다 근데 이제 팝 같은 경우에는 여기서 좀 내용이 더 복잡해집니다 , 일단은, 팝을 한번 대충 이런 인터페이스로 만들어 볼게요 밸류를 뱉어줄 것이고 아 이걸 트라이팝이라고 할까요? 기존에도 트라이팝이라고 했으니까 성공 여부를 뱉어주고 그 다음에 밸류를 여기다가 넣어서 반환하는 그런 형태를 만들어 봅시다 , 자, 그럼 얘도 똑같이 이제 뭘 해야 되는지 곰곰이 생각을 해보면 지금 헤드가 요 아이를 가리키고 있으니까 어 요 노드에 지금 맨 이 노드에 있는 데이터를 꺼내야 하는 게 일단 우리 미션이죠 그러면은 , 일단은, 얘를 읽어 가지고 , 이렇게, 꺼내와야 되는데 얘를 꺼내오기 위해서는 원래 얘 다음에 있던 애를 이제 왕위로 계승을 시켜줘야 됩니다 얘는 이제 은퇴를 하는 거죠 안녕 그래서 얘를 삭제를 하기 위해서 얘를 먼저 다음 애를 헤드로 인정을 해 준 다음에 그 다음에 원래 여기 안에 있던 데이터를 이제 밸류에다가 넣어주고 얘는 이제 삭제를 뿅 해주게 되면은 이제 , 이렇게, 지도세도 모르게 요 데이터가 , 이렇게, 날라간 셈이 될 거예요 근데 여기도 이제 여러가지 문제가 있게 됩니다. 일단 이거를 스텝별로 나눠보자면은 뭐 요런 느낌이겠죠? 1번은 먼저 기존에 있던 헤드를 읽는다. 그 다음에 헤드의 넥스트를 읽는다. 그래야지만 요아이와 요아이에 대해서 알게 될 것이고 요아이를 이제 새 헤드로 인정을 시켜줘야 되겠죠? 그래서 3번이 헤드를 어... 원래 있던 head의 next 즉 여기서 추출한 값을 이용해가지고 얘를 이제 , 이렇게, 바꿔치기를 해줘야 될 겁니다 그래야지 얘가 두번째 애를 이제 가리키는 상태가 될 것이기 때문이죠 그러면은 여기까지 성공했으면은 첫번째 애는 더이상 이제 head가 아니니까 얘는 이제 우리가 데이터를 추출해서 반환을 해줄 것이구요 이제 여기는 값을 value에다가 넣어줄 것이고 그 다음에 최종적으로 이제 더이상 필요없는 노드니까 추출한 노드를 이제 삭제를 하면 될 겁니다 즉 요 아이의 데이터를 꺼낸 다음 얘를 삭제를 하는 거죠 근데 요 부분도 , 일단은, 조금 애매해지는게 푸쉬도 , 이렇게, 헤드를 공용으로 사용해서 문제가 됐던 것처럼 얘는 시작부터 헤드를 읽고 있는데 이 헤드라는 것 자체가 여러 명이 동시에 접근을 해가지고 사용하고 있는 것이기 때문에 첫 단계부터 이제 약간 난관이 있는 거죠. 이거 내가 접근하고 있는데 딴 애도 접근하면 어쩌지? 라는 걸 끊임없이 생각을 해야 되겠습니다. , 자, 그래가지고 일단 결론부터 말씀을 드리자면 이제 코드를 작성해보자면 얘도 마찬가지로 컴퓨터 앤 스왑 연산을 해야 되는데 일단 여러가지 한번 시도를 해보겠습니다. 일단 헤드를 갖고 와가지고 헤드를 갖고 왔는데 이제 2번, 3번을 하려는 순간에 또 새치기를 당할 확률이 있기 때문에 얘도 마찬가지로 컴퓨어 앤 수업 연산으로 해야 되겠죠 그러니까 헤드 컴퓨어 엑스체인지를 할 건데 , 일단은, 올드 헤드라는 우리가 원하던 값, 원래 최초에 꺼내왔던 이 헤드 값을 이용을 할 것이고 그게 헤드랑 같다고 하면은 그제서야 올드 헤드의 넥스트로 , 이렇게, 바꿔치기를 해달라고 하면 될 겁니다 그럼 얘도 이제 뭐 풀어 쓰자면 결국에는 헤드가 올드 헤드와 같다면 그러면은 헤드를 올드 헤드의 넥스트 즉 우리가 desired를 넣어준 두번째 값으로 바꿔치기를 해주세요가 될 것이고 그게 아니라 누군가가 중간에 끼어들었다고 하면은 얘가 자동적으로 oldhead라고 넣어준 expected 값을 다시 , 이렇게, head로 밀어준 다음에 falsehold를 리턴한다고 했습니다 요 코드가 실행이 되기 때문에 실질적으로 우리가 일바라고 가정을 하고 추출한거를 다시 크로스체킹 해가지고 요렇게 만들어 주기 때문에 , 이렇게, 하면 , 일단은, 1,2,3 단계가 그래도 어느정도 안전하게 , 일단은, 커버가 된다고 볼 수 있겠어요 , 자, 여기까지 , 일단은, 1,2,3 단계를 , 이렇게, 해준 상태가 되는거죠 그리고 얘도 마찬가지지만 여기서 올드헤드를 , 이렇게, 해주는 부분을 굳이 안해도 되는게 실패를 했으면 얘가 이제 알아서 해주기 때문에 운 좋게 우리 조건이 맞아떨어져서 다시 해줄 필요가 없다고 보시면 되겠습니다 어 요런 상황이고 , 자, 그 다음에 여기서 왔으면 이제 이 올드헤드라는 거에다가 데이터를 추출해가지고 반환을 해줄 겁니다 참고로 여기서 지금 익셉션 같은 복사를 하는 요 순간에 뭐 메모리 고갈 등으로 인해 가지고 뭐 그게 문제 일어날 수 있는 상황 우리는 신경 쓰지 않을 겁니다 이게 라이브러리를 만들 때는 요런 것 같이 신경을 써 가지고 어 막 머리를 굴려야 되기 때문에 더 복잡한데 뭐 솔직히 게임에서는 지난번에 말씀드렸지만 여기서 만약에 복사하는 과정에서 문제가 있어서 터지면 그냥 터지게 냅두고 그 버그 원인을 잡는게 훨씬 더 좋습니다 우리가 뭐 원자력 프로그램 만드는 것도 아니기 때문에 그렇게 이 익센션 자체를 신경 쓰지 않을 것인데 이제 책에서는 Concurrency in Action 이라는 책에서는 요런 부분에서 신경쓰기 위해서 얘를 아예 그냥 일반적인 , 이렇게, T 레퍼러스로 뱉어주지 않고 얘를 또 Shared 포인터로 만들어가지고 뱉어주고 하는 식으로 만들더라구요. 근데 일단 우리는 거기까지는 하지 않을 필요가 없고 그 다음에 이제 뭐 4번 단계까지 일단 끝났으니까 5번 단계가 추출한 노드를 삭제를 하는 거니까 이제 이 올드헤드는 더이상 필요 없으니까 삭제를 하고 return true를 해주면 되겠죠 , 자, 근데 여기서 , 일단은, 문제가 여러가지가 있는데 어 데이터가 없을 때를 우리가 챙기지 않았죠 데이터가 없다고 하면은 애당초 여기 헤드에서 얘를 추출할 때 얘가 널 포인터로 리턴이 될 것이고 널 포인터에서 넥스트를 막 접근하려고 하면 요 부분에서 크래쉬가 날 수가 있으니까 이제 예외처리를 한번 해줘야 되겠습니다 그래서 올드헤드가 null인 상태를 따로 예외를 줄 것이고 그래서 여기서 while문에다가 null 체크를 한번 해주도록 할게요 얘가 null이 아닐 때만 실행을 할 것이고 만약에 어떤 상황에 의해 가지고 올드헤드가 null이라고 한다면 데이터가 없다는 얘기니까 return first를 여기서 때려주도록 하겠습니다 , 이렇게, 일단은, 처리를 해줄 수가 있겠죠 근데 여기서도 문제가 끝나지 않는게 유심히 보면은 여기서 딜리트를 해주고 있습니다 거기까지 로직에서 보면 아무런 문제가 없는데 여기서 다시 멀티스레드로 생각해서 살펴보면은 거의 동시에 얘네 둘을 누군가가 실행을 한다고 가정해볼게요. 그래서 헤드웨어를 읽어가지고 여기 있는 컴포넌트 스왑을 누군가가 실행을 하려는 순간 옆에 있던 애는 , 사실, 여기까지 쫙 끝내가지고 추출한 노드를 이미 삭제를 해버렸다고 가정을 해봅시다. 그러면 문제가 되는 게 여기서 딜리트를 해가지고 이 메모리를 빵 날려버리면 기존에 그 메모리를 참조해 가지고 요 부분을 실행하려던 애는 이제 벙찐 상태가 되는 겁니다 왜냐면 그 메모리가 날아갔다는 건 더 이상 접근을 하면 안 되는데 얘는 이제 이미 삭제된 오염된 메모리에다가 접근을 하는 use after free 상황이 되는 거죠 그러다 보니까 여기서 이제 클래시가 날 수 있다는 얘기가 되는 겁니다 이제 머리가 굉장히 복잡해지죠 그러면 누군가가 여기서 똑같이 트라이팝을 할 때 그 노드를 삭제를 하면 문제가 일어나는 상황이 된다고 하는 거니까 이제 이거를 처리해주기 위해서 또 여러가지 알고리즘을 중 하나를 선택을 해야 합니다 참고로 말씀을 드리면 이제 락프리 프로그래밍은 비교적 최근까지도 계속 꾸준히 연구가 되고 있는 학문이기 때문에 여기서 굉장히 다양한 방법이 있기는 해요 그리고 심지어는 논문뿐만 아니라 특허로도 걸려있는 그런 기법들이 굉장히 많습니다 그래서 우리가 막 어떤 기법을 알아보더라도 그걸 진짜 실전코드로 사용할 수 있는지는 또 별개의 문제라고 보시면 되겠어요 굉장히 치사하지만 이런 코드의 알고리즘 자체도 특허대상이라는 것도 굉장히 신기합니다 , 자, 그래서 결국 여기서 추천한 노드를 , 이렇게, 고지곳대로 삭제를 할 수 없다는 문제가 발생을 하는 겁니다 잠시 삭제를 보류를 해주도록 할게요 잠시 삭제 보류 근데 물론 이게 만약에 C샵이나 뭐 자바 같은 그렇게 어 GC가 있어가지고 가베지 컬릭터가 알아서 메모리를 해제시켜주는 그런 애라고 하면은 , 사실, 여기서 끝나는 거죠 더 이상 신경 쓸 필요도 없이 메모리 삭제는 언젠가 알아서 일어날 것이니까 어 굳이 신경을 쓸 필요도 없었을 거예요 하지만 우리는 정말로 불행하게도 그런 C샵이나 자바카 아니기 때문에 이 부분을 어떻게든 신경을 써줘야 된다고 보시면 되겠습니다 , 자, 그건 그렇고 결국에는 지금 여기 삭제를 보류하는 코드를 잠시 , 이렇게, 주섬을 처리를 해주면 삭제를 보류해주면 , 일단은, 이 로직 자체는 , 일단은, 뭐 그래도 그럭저럭 실행이 될 겁니다 근데 물론 노드를 삭제를 안하다 보니까 메모리가 계속 증가를 하긴 하지만 그래도 뭐 1차적으로 우리가 뭐 푸쉬랑 팝을 이게 진짜 잘 동작하는지 테스트는 할 수 있다고 보시면 되겠어요 여기서 락 프리 스택으로 다시 바꿔준 다음에 요 부분을 스택으로 바꿔치기를 해봅시다 트라이 밥 네 요렇게 , 일단은, 바꿔줘서 그 다음에 정말로 극한의 상황까지 가기 위해서 3,4를 잠시 주석처리 해가지고 실행을 해보면 아 그런데 코드를 보다 보니까 오타를 하나를 냈는데요 여기 지금 컴퓨전 스택에서 팝을 할 때 성공을 할 때 계속 뺑뺑이를 도는 게 아니라 false일 때 계속 뺑뺑이를 돌아야죠 실패를 할 때마다 무한 루프를 돌겠다 그리고 성공하면 바로 빠져나가겠다니까 얘가 이제 false로 , 이렇게, 바꿔줘야 되겠습니다 오타가 하나 있었네요 나머지 부분은 뭐 , 일단은, 문제가 딱히 없는 것 같고 어쨌든 요 상황에서 다시 한번 실행을 해보면 뭐 , 일단은, 크래쉬는 당장 나지는 않기는 하는데 어 , 이렇게, 잘 뭐 출력이 되고 있는데 당연히 우리가 노드를 삭제를 안 하고 있으니까 메모리가 그냥 무한정으로 지금 계속 늘어나고 있는 상황입니다 그래서 뭐 1차적으로 대충 낙프리에 대한 느낌은 보긴 했지만 이제 다음 시간부터 그래가지고 그러면 여기서 추출한 노드를 삭제를 하는 방법에 대해서 , 일단은, 알아봐야 되겠죠 근데 뭐 당연한 얘기지만 이거를 그냥 고지고때로 , 이렇게, 삭제를 할 수는 없고요 누군가가 참조를 하지 않을 때까지 기다렸다가 나중에 삭제를 하게끔 유도를 하는 게 이제 핵심입니다 근데 이제 뭐 여러가지 기법이 있는데 그런 기법들에 대해서 일단 다음 시간에 알아보도록 할게요.