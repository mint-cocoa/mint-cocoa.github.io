자, 이렇게, 해가지고 지난 시간에 처음으로 셀렉트 모델에 대해서 공부를 해봤구요 뭐 잠시 간단한 복습을 해보자면 결국에는 우리가 요걸 연구하는 이유가 논블록킹 함수를 그냥 막 사용하면 오히려 더 안좋다 왜냐면 어차피 진행이 안되는 상황에서 계속 진행해봤자 의미가 없으니까 그냥 막 진행하기보다는 조금 더 우아한 상황에 진행을 하자라는 컨셉이었죠 다양한 소켓 입출력 모델이 있는데 그 중에서 처음으로 알아본 게 Select 모델이라고 해서 Select라는 함수가 대표로 동작을 시키는 그런 모델이라고 말씀을 드렸습니다. 얘를 사용하는 법은 굉장히 단순한데 , 이렇게, 소켓 셋을 만들어서 관찰 대상을 지정하고 원하는 그 상황이 딱 오면 이제 셀렉트 함수가 반환이 된다 예를 들면 뭐 수신 버퍼에 데이터가 있다거나 아니면 송신 버퍼가 비어 가지고 데이터를 넣을 수 있다거나 하는 등등의 상황을 인지해 가지고 그거를 진행한다고 했었죠 , 자, 그리고 여기서 몇 가지만 더 언급을 드리자면 셀렉트 함수 자체는 , 사실, 동기 함수입니다 함수도 결국에는 비동기 방식이랑 동기 방식, 싱크로런스 방식으로 구분할 수가 있는데 그걸 구분할 때는 이제 이걸 보면 되요 이 셀렉트한 함수를 호출을 할 때 실질적으로 결과물이 나올 때까지 대기를 했다가 그 다음에 우리가 원하는 결과가 하나라도 나오게 되면 얘가 이제 리턴하면서 얘를 계속 진행할 수 있게 됩니다 그렇기 때문에 얘는 이제 기본적으로 동기방식의 함수다라는 걸 일단 알 수가 있고요 , 자, 그리고 이제 셀렉트 방식의 단점을 꼽아보자면 , 일단은, 가장 아쉬운 점은 요거입니다 , 이렇게, 매번마다 소켓셋을 초기화하고 등록을 매번마다 다시 해야 되겠죠 네 그래가지고 이것도 결국에는 우리가 , 이렇게, 초기화하고 등록을 하고 하는 그런 이런 일련의 행위들이 당연히 전체적인 그런 코드 자체의 성능에도 어느정도 영향을 미칠 수 밖에 없습니다 그래서 셀렉트 모델이 굉장히 단순하게 만들기엔 좋긴 하지만 이게 뭐 최고의 성능을 보인다라고 하기엔 좀 어렵다고 볼 수가 있는 거죠 그래서 엄청 많은 접속과 그리고 송소신 요청을 처리하기엔 조금 아쉽다라는 그런 단점이 있구요 어... 이제 그래가지고 요렇게 초기화하고 등록하는 것 자체가 좀 부담이 되니까 이거를 조금 더 개선한 다른 방법이 하나가 더 있습니다 두 번째 모델에 대해서 알아볼 건데 , 자, 일단은, 뭐 지난번에 했던 요기서 여기까지 내용은 싸게 삭제를 하고 여기부터 이제 다시 진행을 해보도록 하겠습니다 오늘 새로 등장하는 요 아이는 WSA Event Select 이라는 모델이고 얘는 이제 윈도우즈에 있는 그런 기능입니다. Event Select 이라고 그냥 줄여서 부르기도 하는데 얘도 결국에는 이 Event Select 이라는 함수가 핵심이 되어서 동작을 하는 그런 입출력 모델을 얘기를 합니다. 그리고 얘는 특징이 , 일단은, 소켓과 관련된 네트워크 이벤트를 이제 이벤트 객체를 통해 감지한다라는 특성이 있어요. 우리가 이전에 이벤트에 대해서 공부를 해봤죠 wait for single object 등등 create event를 이용해서 이벤트를 만들고 결국 이벤트가 약간 커널에 있는 그런 분류형 같은 느낌으로 우리가 길을 껐다 켰다 할 수 있으면서 상태를 시그널 상태로 바꾸고 끌고 하면서 뭔가 서로 수신호를 주고 받을 수 있는 그런 아이였죠 그 이벤트랑 굉장히 유사하다고 생각하시면 되겠습니다 기본적으로 그래서 그 이벤트를 통해 가지고 우리가 전달을 받는다라는 특징이 생기게 되는 거고 전체적인 사용방법은 우리가 이전 시간에 배웠던 셀렉트 모델이랑 은근히 비슷합니다. 다만 이 셀렉트하는 이 부분, 얘는 동기 방식으로 했다면 우리가 오늘 배울 이 이벤트 셀렉트에서는 얘가 이제 비동기 방식으로 바뀌어가지고 말 그대로 우리가 이벤트를 통해서 통지를 받는다라는 차이가 생긴다고 보시면 되겠어요. , 자, 그래서 이제 오늘 뭐 사용할 요 모델에 대한 준비를 몇 개를 해볼 건데 일단 이벤트 객체 관련 함수들 몇 개를 일단 알아보고 넘어가도록 합시다 이제 이벤트 객체를 만들어 가지고 소켓이랑 연동을 시켜 줘야 되는데 우선 이벤트를 만들 때는 wsa-create-event라는 요 아이를 이용하면 되고요 얘는 이제 기본적으로 우리가 기존에 사용하던 그냥 기본적인 이벤트에서 수동 리셋 즉 매뉴얼 리셋 방식에다가 논 시그널드 상태로 시작을 하는 특징을 갖고 있습니다 그리고 이걸 굳이 우리가 바꿔줄 필요는 없기 때문에 그냥 얘를 이용해가지고 이벤트를 만들어 주면 된다라고 보시면 되는 거고 삭제할 때는 wsacloseevent라는 함수를 이용해 주면 되겠습니다. 그 다음에 신호 상태를 감지하고 싶다 라고 할 때는 wsawaitformultipleevent라는 함수를 이용하게 될 거고요. 구체적인 네트워크 이벤트 알아내기 소위 이제 뭐 리드였냐 라이트였냐 커넥트였냐 등등을 알아보고 싶을 때는 wsa-enum-network-events , 이렇게, 4가지의 함수가 , 일단은, 등장해 가지고 이 이벤트 객체를 다루게 됩니다. 물론 사용 예제는 아래 보면 더 얘기가 쉬우니까 자세히 얘기를 어떻게 사용하는지는 조금 이따가 말씀을 드릴 거고요. 이런 위에 있는 함수들을 이용해서 이벤트 객체라는 걸 만든 다음에 얘를 소켓이랑 이벤트 객체를 연동을 시켜줍니다. 그래가지고 여기서도 결국에는 우리가 이런 이전 방식에서도 이런 Descriptor Set 이라는 요 아이를 만들어 가지고 설정을 한 다음에 우리가 원하는 리드인지 라이트인지 따라 가지고 구분해서 만들어 준 다음에 걔를 셀렉트 할 때 넘겨주면서 , 이렇게, 등록을 해줬었는데 얘도 이제 굉장히 유사하게 소켓과 이벤트를 1대1로 붙여가지고 연결을 시켜줘야 됩니다. 소켓 개수만큼 이벤트를 만들어줘야 된다는 특징이 있어요. 그래가지고 얘가 이제 연동을 시켜줄 때는 wsa-event-select 이라고 한 다음에 여기다가 소켓을 넣어주고 두번째로 이벤트를 넣어준 다음에 여기다가 network-event라는 요 아이를 이용해가지고 우리가 어떤 상태를 탐지, 감지하고 싶은지를 이제 입력을 해주게 될 겁니다. 그니까 무엇을 그러니까 관찰 대상은 소켓인데 우리가 이 이벤트를 통해 가지고 나중에 통지를 받을 것이고 어떤 이벤트를 관찰하고 싶냐를 , 이렇게, 삼총서로 입력을 해준다라고 , 일단은, 볼 수가 있는 거죠 그래서 여기서 여기서 말하는 소위 관심을 가지는 즉 관찰할 네트워크 이벤트는 또 여러가지가 있을 수 있는데 예를 들면 accept, read 그리고 write 또 뭐가 있을까요 close 그 다음에 Connect 그리고 뭐 이전 시간에 잠시 알아본 요 OOB라는 애도 등록할 수가 있습니다. 얘는 접속한 클라가 있는지를 체크하고 싶은 거죠 즉 억색 탐수를 호출을 하는 상황이고요 얘는 데이터 수신 가능한지 여부를 보고 있는 거고 receive랑 receive from을 때리기 전에 얘를 이제 이용해서 판단을 하면 되는 거고 데이터 송신이 송신 가능한지를 체크하는 거고 얘는 send랑 send to를 호출하기 전에 이제 이 아이를 체크해주면 되겠습니다 그리고 얘는 뭐 상대가 접속 종료했는지 Connect는 통신을 위한 연결 절차 완료가 되었는지 등등을 체크한다고 보시면 되겠어요. 그래서 이 Event Select를 이용해 가지고 내가 어떤 것을 관찰할지를 , 이렇게, 세팅을 해준다고 , 일단은, 볼 수가 있는 겁니다. 그리고 몇 가지 주의사항이 있는데요. 얘를 사용할 때 주의사항 몇 개를 적어드리자면 WSA Event Select라는 이 함수를 호출하면 해당 소켓은 일단 자동으로 non-blocking 모드로 전환이 됩니다 그러니까 혹시라도 내가 어떤 소켓을 만들어 놨는데 분명히 blocking 소켓으로 만들어 놨는데 얘를 호출을 했다 근데 갑자기 동작이 바뀌었다 라고 하면은 요걸 이제 기억을 해주면 되겠습니다 물론 요런 상황은 자주 없겠죠 우리가 어지간하면 얘를 이제 non-blocking 방식으로 사용을 할 때 얘를 이제 이용할 테니까 그 다음에 두번째로 만약에 우리가 accept 함수를 이용할 때 accept 함수가 return 하는 그 client 소켓은 우리가 처음에 이 accept를 한 그 리스너 소켓과 동일한 속성을 갖게 됩니다. 그렇기 때문에 따라서 클라이언트 소켓 같은 경우에는 우리가 별도로 fd-lead나 fd-write 등을 다시 등록할 필요가 있어요 왜냐면 우리가 리스닝한 소켓 같은 경우에는 accept를 이용하기 위해서 걔를 사용하니까 관심있는 이벤트에서 요 아이를 넣어주게 되겠죠 fd-accept를 먼저 넣어주게 될 건데 그 다음에 반환하는 애들은 이제 추가적으로 fd-lead랑 fd-write를 , 이렇게, 넣어줘야 된다라는 얘기를 하고 있는 겁니다 그리고 또 뭐가 있을까요? 드물게 WSA EWB 오류가 뜰 수 있으니 예외 처리 필요하다 정도만 , 일단은, 주의하면 될 것 같네요 , 자, 그리고 또 하나 이거 좀 중요한 부분이 하나 더 있는데 이벤트가 발생할 때 이벤트 발생 시 적절한 해당 소켓 함수 호출해야 한다 만약에 그러지 않으면 다음번에는 동일 네트워크가 이벤트가 발생하지 않는다 라는 특징이 있어요 이게 무슨 말이냐면 예를 들면 우리가 이 FD 리드라는 이벤트를 관찰했고 얘가 실질적으로 FD 리드 우리가 관찰하고 있는 애가 완료가 되었다고 막 통지가 왔다고 가정해볼게요 그럼 그 상태에서 리시브를 반드시 해줘야지만 그 다음 턴에 또 FD 리드를 관찰을 할 수 있는 거고 그것을 하지 않으면은 독이라는 네트워크 이벤트가 이제 두 번 연속해서 발생하지 않는다라는 얘기가 되는 겁니다 통지를 해줬으니까 우리가 이제 꺼냈으라 이거죠 그리고 꺼냈을 때까지는 또다시 통지를 해주지 않을 것이다 라는 차이가... 어 그런 문제가 생기는 거니까 반드시 요 이벤트가 발생했으면 그 짝에 맞는 애를 한번 호출해 줘야지만 또다시 그 이벤트를 받을 수 있다라는 결론을 얻을 수가 있습니다 어... 이 정도까지만 , 일단은, 알면 될 것 같아요 이것도 한번 적어드릴까요? fdread 이벤트 떴으면 receive 호출을 해야 하고 만약에 안 하면은 fd read 두 번 다시 발생하지 않는다 라고 일단 볼 수가 있겠어요 , 자, 그리고 , 이렇게, 해가지고 우리가 이제 만든 이벤트랑 속캐시랑 연동을 시켜주고 우리가 관심있는 이 네트워크 이벤트 관찰의 이벤트를 , 이렇게, 등록을 해가지고 사용하는 것 까지는 일단 되는데 WS Event Select는 말 그대로 이 소켓이랑 이벤트 객체를 연동하는 것만 하지 우리가 여기서 이전에 사용했던 Select처럼 뭔가 결과물을 , 이렇게, 뱉어주는 애는 아닙니다 그래가지고 사실상 이 Select가 이제 약간 두개로 쪼개졌다고 생각하시면 되겠습니다 Select는 동기방식의 함수여가지고 진짜로 끝장을 볼 때까지 여기서 대기를 탔다가 그 결과물이 하나라도 나올 때까지 , 이렇게, 대기를 타는 애였다면은 얘 같은 경우에는 wsaeventselect만 호출해가지고 등록을 하고 실질적으로 통지를 받는거는 우리가 별도의 함수로 이제 해주게 될건데 그 아이가 바로 wsawaitformultipleevent입니다. 이거 어디서 많이 본 함수 같죠? 우리가 이전에 이벤트 시간에 waitforsingleobject라는 singleevent라는 함수를 이용해가지고 이벤트를 기다렸었는데 그거랑 굉장히 비슷한 느낌이라고 생각하시면 되겠어요. 뭐 얘같은 경우에는 , 자, 여기서 뭐 한번 찾아볼 만한 가치가 있죠 요런 애를 한번씩 살펴보시면 도움이 되구요 이런식으로 여기 참용으로 아까 얘기한 네트워크 이벤트에서 얘를 여러개를 동시에 넘겨줄수도 있습니다 그건 이제 나중에 살펴보도록 하고 이게 약간 비트플래그처럼 or문을 이용해가지고 나중에 넘겨주면 되구요 그 다음에 wait for multiple event라고 해가지고 여기서 인자가 여러가지가 있는데 첫 두 인자에 우리가 넘겨줄 이벤트 개수랑 그 이벤트 배열의 이제 그... 포인터를 요렇게 넘겨주게 됩니다 그 다음에 wait all 이라는 요 아이는 무엇을 하는 거냐면은 모두 다 기다릴지 아니면은 딱 하나만 완료되어도 바로 리턴을 할지를 정해줄 거구요 그 다음에 타임아웃은 말그대로 타임아웃 특정 시간까지 기다려가지고 빠져나올지 등등을 입력을 하면 되고 그 다음에 Alertable 얘는 그냥 지금은 그냥 false로 켜주면 됩니다. 얘는 지금은 딱히 사용을 하지 않을 거예요. 네, 이거는 다른 용도로 사용하는 것이기 때문에 그래서 뭐 이런 인자들을 활용한다라는 게 , 이렇게, 나와 있습니다. 그래서 이걸 이제 이용해가지고 그러면 WaitForMultipleEvent를 빵 때려주게 되면 우리가 동시에 관찰할 이벤트 개수를 여기다 입력을 하면서 예를 들면 10개를 우리가 관찰하겠다라고 등록을 해주게 될 것이고 그 중에서 맨 처음으로 완료가 된 아이의 인덱스를 뱉어주게 됩니다 그걸 이제 디워드로 , 이렇게, 뱉어주게 될 거예요 이 부분인데 이게 좀 말로 하니까 좀 어려운 것 같네요 그래서 일단 코드로 보여드리는 게 좀 나을 것 같고요 그래서 결국에는 얘를 이제 잠시 요약을 해보자면 첫 두 인자로 이벤트 개수랑 이벤트 포인터를 넘겨줄 것이고 wait all 같은 경우에는 모두 기다릴지 아니면 하나만 완료되어도 빠져나올지를 입력을 한다 그리고 3번은 뭐 타임아웃 그냥 말그대로 타임아웃 시간을 얘기하는 거고 4번은 지금은 false로 한다 이건 ws의 이벤트 셀렉트랑은 무관하다 그리고 최종적으로 리턴되는 값은 완료된 첫번째 인덱스이다 라는걸 , 일단은, 기억을 해주시면 되겠습니다 , 자, 그리고 첫번째 애가 완료가 되었다 완료된 첫번째 인덱스가 딱 리턴이 될건데 그러면 우리가 이제 누가 완료되었는지는 알았지만 그 해당 이벤트가 무엇이었는지는 또 우리가 모를 수 있겠죠 그래가지고 최종적으로 또 다시 이제 진짜 마지막이네 wsainnumnetworkevent라는 함수를 이용해 가지고 여기다 1번으로 대상 소켓을 넣어 줄 것이고 2번으로는 이벤트 객체 우리가 연동한 이벤트 객체를 옵션으로 넣어 줄 수가 있습니다 소켓과 연동된 이벤트 객체 핸들을 핸들을 넘겨주면 이벤트 객체를 자동으로 non-signaled 상태로 바꿔준다는 특성이 있고요. 그 다음에 마지막으로 네트워크 이벤트를 입력을 받아가지고 여기서 우리가 처음에 감시하고 있던 네트워크 이벤트 혹은 오류 정보가 저장이 될 겁니다. , 자, 이렇게, 해서 여러가지 일단 함성에 대해서 알아봤는데 이제 이것만 봐서는 이게 뭐 어떻게 사용하는지 잘 이해가 안갈테니까 이걸로 한번 이제 한번 다시 한번 사용을 해보도록 할게요 , 자, 일단은, 어 오늘은 여기 벡터 세션 위에다가 wsaevent라는 또 하나의 벡터를 만들어 주도록 하겠습니다 wsaevent라고 해가지고 그리고 얘네 둘은 이제 1대1로 대응이 됩니다 세션 개수만큼 우리가 이 wsaevent도 만들어 주도록 할 거예요 네 그 다음에 이어가지고 처음에 리스너 소켓부터 우리가 만들어주도록 하겠습니다. 그렇기 때문에 wsaevent를 하나를 만들어줄 것인데 listenevent라고 하도록 할게요. listensocket을 위한 이벤트이다 라고 해서 wsacreateevent를 , 이렇게, 빵! 호출해주면 이벤트 객체가 , 이렇게, 만들어졌고요. 그 다음에 만들어주자마자 얘를 pushback 해가지고 이 wsaevent를 listenevent를 여기다가 , 일단은, 넣어주도록 할게요. 그 다음에 여기 위에까지 , 일단은, 공통적인 부분에서 보면 우리가 리슨 소켓을 이미 만들어 준 상태고 리슨 한 다음에 원래 accept 순서로 지금 실행해야 되는 그 차례입니다 여기까지는 변함이 없어요 그렇기 때문에 여기서 다시 내려와 가지고 sessions 에다가 pushback을 해줄 건데 여기다가 , 일단은, 리슨 소켓을 여기다가 등록을 해주도록 할게요 물론 얘는 엄밀히 말해서 클라이언트에서 연결해주는 그 세션은 아니긴 한데 이건 왜 , 이렇게, 해줬냐면은 이 WSA 이벤트랑 실제 소켓이랑 1대1 대응을 시켜주고 걔가 동일한 인덱스를 활용하게끔 만들어줘야지 관리하기가 쉽기 때문에 첫번째에는 비록 엄밀히 말해서 클라이언트가 연결해준 소켓은 아니지만 우리가 사용하던 이 리슨 소켓 자체도 그냥 , 이렇게, 첫번째 소켓으로 , 일단은, 밀어 넣어주도록 할게요 그래야지 얘네들이 이제 1대1로 지금 개수가 맞기 때문이죠 , 자, 그 다음에 이벤트가 준비되었고 지금 소켓도 준비가 되었으면 이제 연동을 시켜줘야 되는데 ws의 이벤트 셀렉트란 함수로 둘 사이를 연동을 해준다고 했습니다 얘가 지금 위에 보면은 이거라고 했었죠 ws의 이벤트 셀렉트라고 해서 소켓과 이벤트 캡치를 연동하는 요 부분 옵션은 우리가 어떤걸 사용할지를 골라가지고 적절히 넣어주면 되는데 여기서는 우리가 Listen Socket이랑 Listen Event 두개를 이제 짝지어서 연동을 시켜줄 것이고 FD Accept랑 그리고 FD Close를 우리가 관찰을 해주도록 하겠습니다 이게 만약에 실패했다 소켓 에러를 뱉어주면 문제가 있는 거니까 그냥 리턴을 때려주도록 하고 , 이렇게, 해가지고 계속 둘둘 맵핑을 해준다고 보시면 되겠어요 짝을 지어주는 거죠 리슨 이벤트랑 이 리슨 소켓이랑 이제 , 이렇게, 연결을 시켜줘 가지고 결국에는 이 이벤트가 이 리슨 소켓에 이 accept나 close와 관련된 네트워크 이벤트가 발생을 하면은 우리가 이 리슨 이벤트를 통해 가지고 이제 나중에 통보를 받을 수 있다라고 일단 결론을 내릴 수가 있겠습니다 , 자, 그 다음에 기존에 사용하던 요 아이들을 , 일단은, 싹을 날려주도록 할게요. 그냥 새로운 마음으로 , 자, 여기부터 그냥 다 날리고 그냥 진행을 해보도록 합시다. , 자, 그 다음에 여기서 하는 거는 , 일단은, 기본적으로 나중에 가면은 여기에 이벤트랑 세션이 늘어나게 되겠죠 클라이언트에서 접속할 때마다 얘가 1 늘러나게 되겠지만 지금은 , 사실, 리슨업 관련된 소켓이랑 리슨 이벤트 밖에 없는 상태입니다 그런데 이걸 이제 이용해 가지고 wsawait for multiple event 를 호출해 가지고 여기서는 말 그대로 얘를 이제 관찰하겠다 라고 선언을 한 거고 그 결과물 자체를 진짜로 통지가 왔는지를 우리가 보기 위해서는 wait for multiple event 를 호출해줘야 됩니다 왜냐면 나중에 가면은 요 이벤트가 뭐 엄청 많이 늘어날 수가 있겠죠 막 10개, 20개, 30개가 될 수 있는데 그거를 매번마다 루프를 돌면서 하나씩 하나씩 하나씩 어... Wait for single object 같은걸 막 호출해가지고 하나씩 기다리는게 아니라 그냥 여러개를 한 번에 빵 입력해가지고 그 중 하나라도 완료가 되었으면 반환을 하게 만들어 주도록 하겠습니다 그래가지고 요 함수를 이제 유심히 보면은 첫번째 인자로 갯수를 받고 있죠? 예를 들면 우리가 지금 이벤트의 갯수를 벡터로 지금 관리하고 있으니까 이벤트의 갯수를 요렇게 뭐 추출할 수 있을 것이고 그 다음에 원래 이벤트 객체가 그니까 이벤트가 시작하는 포인터를 이제 입력을 해주게 됩니다 0번 데이터의 주소를 그냥 뱉어주면 되겠죠? 어차피 벡터가 동적 배열이니까 그 다음에 어.. 여기서 세번째 인자가 모든 애들을 기다릴 것이냐 즉 모든 우리가 넣어준 모든 갯수가 다 완료가 되어야만 얘가 어 이제 완료가 되는 건지 아니면 딱 하나라도 완료가 되면 얘가 바로 빠져나올지를 결정해 줄 건데 다 기다리는 건 말이 안 되겠죠 모든 애들이 동시에 완료가 되는 일은 현실상 없을 테니까 false를 해서 하나라도 완료가 되면 빠져나오라 라고 하는 거고 timeout은 그냥 무한정으로 기다려 주도록 합시다 ws의 infinite를 만들어주고 마지막은 그냥 false로 , 이렇게, 해주면 된다고 했습니다 그러면 우리가 이 세번째 인재를 false로 냈으니까 여기서 처음으로 뱉어주는 뱉어주는 애가 이제 인덱스를 , 이렇게, 뱉어주게 되는데 문서를 다시 살펴보면은 여기서 뱉어주는 인덱스가 왠지는 모르겠지만 이 ws의 weight event 0에다가 어떤 숫자를 더해준 요런 값을 뱉어준다고 , 이렇게, 문서에 나와 있습니다 그래가지고 실질적으로 인덱스를 사용할 때는 여기다가 ws-weight-event-0 라는 걸 빼주면은 정확히 우리가 처음에 넣어준 이 배열의 인덱스를 이제 반환해주게 됩니다. 예를 들면 이 ws-event-vector에 데이터가 3개가 있는데 그 중에서 예를 들면 , 이렇게, 이 ws-event라는 데이터가 3개가 있는 상황에서 요 두번째에 해당하는 애가 사실상 완료가 되어가지고 이 완료통지가 왔다고 하면은 인덱스가 1이 여기서 반환이 된다라고 볼 수가 있는거죠 그래서 이거 인덱스는 그런 의미고 여기서 예외체크를 그냥 간단하게 한번 해보도록 할게요 wsaewaitfailed 뭔가 문제가 있다라고 하면은 뭐 그냥 continue를 때려주도록 하겠습니다 return을 때려도 되고 이런 예외는 진짜 뭔가 문제있는 상황에서만 일어나게 될거고 , 자, 그 다음에 어 요 이제 이벤트 통지를 받았으면은 얘가 뭔가 어떤 상황이 일어났다는 것까진 알았는데 우리가 , 사실, 등록할 때 이런 식으로 관찰할 대상을 관찰할 네트워크 이벤트를 여러 개를 합쳐 넣을 수가 있었기 때문에 정확히 어떤 애 때문에 지금 이 아이가 완료가 되었는지는 우리가 알 수가 없습니다 그거를 체크하기 위해서는 wsainnumNetworkEvent라는 함수를 이용한다고 했었죠 , 자, 여기서 우리가 소켓을 다시 꺼낼 건데 인덱스번에 소켓을 , 이렇게, 꺼내줄 것이고요 그래가지고 여기서 이 이벤트랑 세션의 개수를 맞춰준 이유가 그거였습니다 이 소켓과 이벤트를 짝지어 가지고 지금 관리하고 있기 때문이죠 이 인덱스로 그 다음에 WSA 이벤트의 인덱스가 이제 해당하는 이벤트 오브젝트의 핸들이라고 볼 수가 있는 거고 마지막으로 여기서 넣어주는 거는 결과물을 무엇으로 받냐면은 WSA 네트워크 이벤츠라는 이런 구조체로 받고 있다는 걸 볼 수가 있습니다 그래서 여기다가 이런 식으로 네트워크 이벤츠를 넣어주게 되면은 우리가 관찰하려고 했던 애가 아예 그 결과물이 요 이제 구조체에 채워지게 될 거예요 근데 만약에 얘가 실패했다 소켓 에러라고 하면은 역시나 그냥 컨티뉴를 때려 보도록 합시다 , 자, 그리고 원래는 이벤트를 , 이렇게, 우리가 통지를 받은 다음에 애당초 얘가 유시민 보면은 매뉴얼 리셋이라고 했었죠? 매뉴얼 리셋이다 보니까 우리가 수동으로 리셋을 시켜줘야 되긴 합니다 그래서 요렇게 WSA 리셋 이벤트라는 걸 요렇게 호출을 해줘가지고 얘를 초기화를 해주긴 해야 돼요 이런 식으로 WSA 이벤트 그런데 요 함수 아까 다시 설명을 읽어보면은 만약에 우리가 이 두번째 인자에다가 이벤트 핸들을 넣어주게 되면은 걔를 자동으로 어 다시 자동으로 리셋을 같이 해준다고 했었습니다 그렇기 때문에 굳이 리셋 이벤트를 여기 위에서 하지 않더라도 결국에는 이 기능 자체가 이 함수에 포함이 되어있다고 일단 생각하시면 되겠어요 그래서 이걸 넣어도 되고 안 넣어도 되고 어차피 똑같이 동작을 하게 된다고 , 일단은, 볼 수가 있겠습니다 그래서 이 함수를 이용해가지고 , 일단은, 이 이벤트가 다시 꺼진다 즉 이 상태가 시그널 상태로 바뀐 것을 다시 논 시그널 상태로 바꿀 수 있다 라고 , 일단은, 말씀을 드린 거고 그 다음에 이제 이어서 해야 되는 것은 여기서 결과물을 이제 추출하긴 했는데 얘를 살펴보면은 좀 복잡하게 되어 있습니다 여기다가 에러 코드랑 네트워크 이벤트라는 요 두가지 정보를 있는데 이걸 이용해 가지고 지금 에러가 일어났는지 그리고 어떤 네트워크 이벤트가 완료가 된건지를 체크하면 됩니다 근데 이건 예제로 보는게 훨씬 더 이해하기가 쉬워요 일단 리스너 소켓부터 체크를 해볼건데 네트워크 이벤트의 LNetworkEvent라는 요거를 체크해줄건데 비트플래그를 이용해서 체크하는 것이기 때문에 FDAccept랑 얘랑 요렇게 End로 비교를 해주게 될겁니다. 만약에 FDAccept가 얘랑 이 결과물이 0이 아니라고 하면은 애당초 우리가 넣어준 여러가지 사유들 중에서 요 i 때문에 지금 이 네트워크 통지 완료가 , 일단은, 발생했다라는 걸 알 수가 있는 거죠 물론 여러 개일 수도 있어요 사유가 그렇기 때문에 여기서 먼저 일단 에러 체크를 해줄 건데 에러 체크도 이런 식으로 네트워크 이벤트에 IERROR 코드라는 걸 판별하는데 얘는 거꾸로 FD, ACCEPT, BEAT 이 BEAT가 붙은 애를 이용해가지고 요 값이 0이 아닌지를 체크하면 됩니다 이게 그냥 어떤 패턴처럼 그냥 보시면 돼요 그리고 이걸 뭐 엄청 자주 사용할 일은 없기 때문에 그냥 흐름만 보면 되지 이게 뭐 세세히 막 어떤 숫자인지 아니면 어떤 기능을 하는 건지를 다 이해할 필요는 없습니다 그냥 대충 , 이렇게, 해가지고 네트워크가 발생했는지를 체크하고 , 이렇게, 해서 에러가 있는지 없는지를 체크한다는 그 패턴만 이해하시면 됩니다 여기까지 왔으면 , 일단은, Accept라는 게 발생했다는 얘기가 되는 거니까 우리가 안심하고 이 accept를 호출할 수 있다라는 얘기가 되는 거죠. 그래서 우리가 accept를 항상 호출할 때는 여기다가 sock address in, 아니고 sock address in을 이용해가지고 client address를 받아줬었죠, 항상. , 이렇게, address length는 size of client address. 그 다음에 여기다가 속 address 포인터로 클라이언트 어드레스를 넣어주고 어드레스 렌스를 , 이렇게, 입력하는 식으로 항상 만들어 놨습니다 얘가 뱉어주는 게 클라이언트 소켓 이었죠 그러면은 만약에 클라이언트 소켓이 어... invalid 아이고 이건 또 왜 넣었나요 , 자,... invalid 소켓이 아니다 정상적인 상황이라고 하면은 그러면 클라이언트 커넥티드라는 로그를 그냥 간단하게 찍어 보도록 할게요 , 자, 그 다음에 이어가지고 해야되는 것 중 하나가 이제 얘같은 경우에는 지금 이벤트가 달라지게 되겠죠? ws-event-slack을 이제 바꿔줘야 됩니다 다른 이벤트랑 연동을 시켜줘야 되죠? 그렇기 때문에 ws-event를 하나를 더 만들어 줄 것인데 client-event를 , 이렇게, ws-event... 아이고 create-event로 일단 이벤트 객체를 하나를 만들어 줄 것이고 위에서 했던 거랑 이제 똑같이 하는 거죠? 요 아이를 일단 복붙을 해서 다시 , 이렇게, 넣어 주도록 할게요 근데 리슨 소켓이 아니라 우리가 방금 만들어준 클라이언트 소켓이랑 클라이언트 이벤트 이 두개를 연동을 시켜주기 위해서 ws-event-select을 한 번 더 호출해주고 있다고 보시면 되겠습니다. 그럼 여기서는 클라이언트 이벤트 여기서는 클라이언트 소켓이랑 이 소켓이랑 이 이벤트를 우리가 연동을 시켜주겠다라는 얘기를 하고 있는 거고 여기서 우리가 원하는 어떤 네트워크 이벤트가 발생하면 이 이벤트 객체를 통해서 통지를 받겠다라고 우리가 선포를 하고 있습니다. 여기서는 이제 얘가 리스너 소켓이 아니니까 여기서 이제 받을 거는 리드랑 라이트 그리고 클로스 , 이렇게, 3개를 우리가 통지를 받도록 하겠습니다 , 자, 이렇게, 해가지고 여기서 추가가 되었으니까 다음에 다음 턴에서 루프를 돌 때는 이 WaitForMultiple 이벤트에서 이제 개수가 하나 늘어난 상태로 우리가 처음에 넣어준 이 리스너 소켓 뿐만 아니라 우리 클라이언트 소켓도 같이 얘가 포함이 되어 가지고 이제 통지를 받게 될 겁니다 그러니까 이제는 이 이벤트가 여러 개가 될 것이고 그 중 항상 맨 처음으로 완료가 된 애가 , 일단은, 이 인덱스로 딱 튀어나오게 될 거예요 그래서 이걸로 무한 루프를 돌고 있는 거죠 만약에 여기서 나중에 어떤 상황이 되어 가지고 객체가 막 10개씩 있다고 해도 결론적으로 그 중에서 맨 먼저 완료되는 이 인덱스가 여기로 이제 결국 튀어나오게 될 거예요 그래서 그걸 우리가 이용해 가지고 이 리슨 소켓이랑 클랜 소켓을 같은 코드를 이용해 가지고 우리가 지금 작업을 하고 있는 거죠 물론 얘는 일단 기본적으로 이 억셉트 자체는 딱 한 애만 , 이렇게, 등록을 해놨기 때문에 이쪽에 걸리는 애는 결국에는 한 명밖에 없긴 할 거예요. 리슨 소켓만 걸리게 되겠죠. 그럼 이제 나머지 같은 경우에는 나머지 실제로 클라이언트 세션과 관련된 소켓을 체크해주면 됩니다. 여기도 비슷하게 네트워크 이벤트를 체크할 것인데 L 네트워크 이벤트에 리드나 라이트 상태가 있다고 가정해봅시다. 그리고 네트워크 이벤트에 L 네트워크 이벤트 FD 라이트 요렇게요 , 자, 그러면 우리가 위에서 했던 대로 에러체크 코드를 똑같이 하나씩 하나씩 넣어 주도록 할 거고 어 둘 중 하나인데 이제 리드일 수도 있고 라이트일 수도 있겠죠 그니까 , 이렇게, 만들어 보도록 합시다 여기서 만약에 에러체크를 할 때 리드 때문에 얘가 들어왔는데 들어왔다고 하면은 우리가 네트워크 억셉트 비트를 체크를 할 때 리드를 체크를 해 보도록 합시다 여기서 이제 예를 리드 비트를 체크해 가지고 리드인데 진짜로 리드가 에러 났는지를 체크할 것이고 그 다음에 라이트인데 라이트 때문에 들어왔는데 이 라이트 비트가 켜져 있다면 뭔가 문제가 있는 상황이니까 역시나 컨티뉴 를 때려 주도록 할게요 , 이렇게, 에러 체크 두 번을 해줬구요 , 자, 그 다음에 여기까지 왔으면 , 일단은, 이 인덱스를 이용해가지고 우리가 실제로 어떤 이벤트가 네트워크 이벤트가 발생한 그 소켓을 꺼내 쓸 수 있겠죠 그래서 그 Session에 접속을 해보도록 합시다 Sessions에 Index Funnel을 , 이렇게, 접근해가지고 요 Session 정보를 꺼내 쓸건데 이제 리드를 하는 상황이다 라고 하면은 만약에 Receive Byte가 이건 지난번과 마찬가지로 똑같이 만들어 보도록 할게요 만약에 Receive Byte가 0이다 아직 우리가 아무것도 받지 않은 상태라고 하면은 , 자, Receive Arms를 호출해 줘가지고 여기다가 뭐 Socket이랑 Receive Buffer 그리고 버프 사이즈를 우리가 만들어놨어 마지막은 0으로 , 이렇게, 해주고 여기서 만약에 Receive Length가 소켓 에러라 에러인데 근데 ws-getLastError가 ws-eWoodBlock이 아니다 라고 하면 진짜로 뭔가 문제가 있는 상황입니다 그러니까 아까 얘기한 대로 이게 경우에 따라서 가끔 가다가 소켓 에러가 뜨긴 했는데 eWoodBlock 에러가 뜨는 경우도 가끔 있을 수 있다고 했었죠 그렇기 때문에 , 이렇게, 얘가 동시에 만족하는 상황이 Get Last Error가 만약에 이웃 블럭이라고 하면은 그건 심각한 상황이 아니라고 인지를 할 것인데 그게 아니라고 하면은 진짜로 뭔가 문제가 있는 상황이니까 나중에 가가지고 투두에다가 뭔가 이 세션을 제거를 해라 라는 부분을 이제 실행시켜주면 되겠죠 근데 오늘은 뭐 그런 부분까지는 신경쓰지 않을 것이고 그냥 이 리무브는 그냥 또 스킵을 하도록 할게요 나중에 가면은 뭐 이거 우리가 벡터에다가 관리하던 거에서 이제 해당 인덱스를 찾아가지고 걔를 제거하는 부분이 들어가야 될 겁니다. 근데 어쨌든 그 부분은 스킵하고 , 이렇게, 해가지고 여기서 예외 체크를 한 다음에 그 다음에 여기서 receive Byte를 ReceiveLength로 바꿔치기하고 그 다음에 로그를 찍어 보도록 할게요 ReceiveData는 얼마 얼마이다 ReceiveLength는 얼마 얼마이다 라고 , 이렇게, 찍어주고 그 다음에 이어가지고 리드가 아니라 만약에 라이트까지 라이트도 해야된다 if-else가 아니라 그냥 if-if입니다 처음에 데이터를 받은 다음에 그 다음에 여기서 똑같이 ReceiveByte가 만약에 sendByte 보다 크다 지금 아직 보낼게 남아있다고 하면은 이어가지고 데이터를 보내주도록 할게요 이런식으로 sendLength는 socket 그 다음에 receiveBuffer의 sendByte 인덱스에 접근해가지고 그 주소를 넘겨줄 것이고 바이츠 마이너스 샌드 바이츠 만큼을 보내주도록 합시다 요 상황은 , 사실, 잘 일어나지 않는다고 했었죠? 우리가 샌드를 해줄 때 , 사실, 한 번에 다 보내주지 얘를 부분적으로만 보내주는 경우는 거의 없기는 한데 뭐 어쨌든 안전 삼아 , 이렇게, 그냥 만들어주도록 할게요 그 다음에 샌드 랜슨은 만약에 마찬가지로 소켓 에러인데 근데 그 에러가 get last error를 봤더니만 ws-e-boot-block도 아니다 라고 하면 진짜로 뭔가가 이상한 상황이니까 여기서도 뭔가 to-do-remove-session을 호출해줄 것이고 그게 아니라고 했으면 여기까지였으면은 이제 우리가 데이터를 성공적으로 보내줬다 라고 send-length를 더해준 다음에 지난번에도 똑같이 만들었지만 receive-byte랑 send-bytes가 정확하게 일치한다고 하면은 데이터를 다 보냈으니까 send-bytes도 0으로 만들고 receive-byte도 다시 , 이렇게, 0으로 밀어 보도록 할게요. 그 다음에 신나게 로그를 찍어 주도록 합시다. send data. 얼마를 보냈나요? send length만큼 보냈습니다. 로그를 찍어 주도록 할게요. 그러면 여기서도 이 부분에 의해서 이제 클라이언트 소켓 체크도 이제 끝난 거죠. read랑 write. 그리고 마지막으로 진짜로 뭔가 어떤 상황에 의해 가지고 커넥션이 끊겼다고 하면 그것도 이제 ft-close가 이쪽에서 우리가 처리를 할 수가 있게 되겠죠. 이런 식으로 만들어주면 됩니다. 네트워크 이벤트에 L 네트워크를 체크할 건데 FD 클로즈랑 비트 플래그 체크를 해가지고 여기서도 ToDo, Remove, Socket 등등을 이어서 처리를 해주면 되겠습니다. , 자, 이렇게, 해가지고 어 결국에는 뭐 함수가 좀 다르고 처음에는 조금 헷갈릴 수가 있지만 지난번에 했던 셀렉트 함수랑 뭐 크게 크게 많이 엄청 다르지는 않다는 걸 우리가 알 수가 있어요 함수가 조금 다르긴 했죠 , 자, 그래가지고 여기서 , 일단은, 서버를 빌드를 한 다음에 , 일단은, 잘 실행이 되는지는 한번 체크를 해봅시다 그래서 빌드를 한 다음에 한번 실행을 해보면 별다른 문제가 없다고 하면은 , 자, 이런 식으로 뜰 수가 있는데 아 근데 지금 여기서 , 이렇게, 잘못 뜨는 거는 서버가 뜨기 전에 클라가 먼저 접속을 시도해서 그런 것 같으니까 여기서 클라가 뜰 때 잠시 대기 시간을 주도록 할게요 Sleep for 한 1초 정도 기다렸다가 서버가 먼저 뜬 다음에 얘가 이어가지고 실행하도록 한번 유도를 해줍시다 , 자, 그러면은 이제 이런 식으로 정상적으로 잘 데이터를 주고 받고 주고 받고 하는 부분이 실행이 된다는 걸 볼 수가 있어요 그래가지고 두번째 입출량 모델에 대해서 간략하게 알아봤구요 여기서 , 일단은, 뭐 결론을 내릴 수가 있는거는 셀렉트랑 비슷하긴 한데 셀렉트와 다르게 매번마다 전체 리셋을 할 필요가 없다는 장점이 있었죠 우리가 셀렉트 모델에서는 항상 여기서 우리가 세팅했던 그 소켓 셋을 다 날려버린 다음에 하나하나씩 다 세팅을 하고 그 다음에 셀렉트를 빵 때렸어야 되는데 이건 그게 아니라 이벤트를 일단 객체를 한번 만들어 준 다음에 서로 요렇게 연동을 잘 시켜주면은 그 다음부터는 매번 마다 알아서 걔네들이 다 맵핑이 되어 있기 때문에 뭐 별도로 이벤트를 다시 맞춰주거나 할 필요는 없고 잘 동작을 한다는 걸 알 수 있었습니다 물론 , 이렇게, 리셋 이벤트를 통해 가지고 우리가 매뉴얼 리셋을 해주긴 돼야 되지만 그거는 여기 이너업 네트워크 이벤트에 같이 딸려가지고 얘가 간접적으로 해줄 수도 있기 때문에 , 사실, 크게 신경 쓸 필요가 없었고 요렇게 해가지고 이벤트를 통해 가지고 어떤 객체의 네트워크 이벤트 완료 통제를 우리가 받겠다라는 그런 얘기가 되는 겁니다 그리고 설령 소켓이랑 이벤트가 늘어난다고 해도 , 이렇게, ws의 waitForMultipleEvent를 이용해 가지고 이 애들을 한 번에, 뭉쳐있는 애들을 한 번에 관찰할 수 있다는 얘기도 할 수 있는 거죠. 근데 여기서 살짝 조심해야 되는 게 뭐냐면 셀렉트랑 마찬가지로 얘도 개수에 한계가 있습니다. 그래서 waitForMultipleEvent 문서를 살펴보면 어 여기 어딘가에 이제 최대 개수에 대한 얘기가 나올 거에요. 여기 있네요. 최대 개수는 SS의 맥시멈 웨이트 이벤트를 넘으면 안 된다고 하고 실질적으로 개를 먼저 한번 , 이렇게, 살펴보면 얘가 64로 되어 있던 걸로 기억을 하는데 64입니다 그렇기 때문에 얘도 셀렉트랑 마찬가지로 이거 한 번에 너무 많은 애들을 같은 함수로 , 이렇게, 만들어 줄 수는 없다는 단점이 있긴 합니다 그러니까 애당초 만약에 우리가 클라를 서버랑 연동을 시키고 클라 쪽에서 만약에 만든다고 하면은 이 이벤트 셀렉트 방식으로 만드는 것도 나쁘진 않아요 근데 우리가 굳이 MMO 서버를 만드는데 나중에 배울 IOCP를 냅두고 셀렉트 모델이나 아니면은 이 이벤트 셀렉트 모델이 유행해가지고 굳이 서버를 만들 필요 없다는 얘기가 되는 거죠. 당초 , 이렇게, 세션마다 이벤트를 만들고 그 다음에 연동을 하는 요런 부분들도 솔직히 나중에 가면 좀 귀찮은 일입니다. 그래가지고 일단 부분적으로는 굉장히 훌륭하고 클라쪽에서는 사용할 만한데 서버 자체에서 , 이렇게, 이벤트 모델을 이용해가지고 이벤트 셀렉 방식으로 하는 거는 조금 그렇게 깔끔하지 않다라는 결론을 내릴 수가 있겠습니다 하지만 늘 그렇지만 여러가지 모델이 있다는 건 알아야 되니까 , 이렇게, 해가지고 이벤트 셀렉트 모델에 대해서도 , 일단은, 간략하게 알아봤고요 이 코드 흐름을 잘 살펴보시기를 바라겠습니다 근데 뭐 크게 어려운 부분은 많이 없을 거라고 생각이 돼요 특히나 이 셀렉트 모델 다음으로 했기 때문에 굉장히 대칭성이 있다고 볼 수가 있겠어요 네 그래서 이 이벤트 통지를 받은 다음에 어떤 이벤트 때문에 지금 얘가 완료가 된 건지 체크 체크 체크 해가지고 , 이렇게, 꺼내 먹는 걸 볼 수가 있습니다 네 그래가지고 , 이렇게, 해가지고 , 일단은, 간단하게 조금 지루한 내용이긴 하지만 살면서 한 번씩을 해본만한 이벤트 셀렉트 앤 대항을 내용을 마치도록 하고, 아마도 나중에 클라를 서버에 붙일 때는 이 이벤트 셀렉 모델을 아마도 활용할 예정입니다. 참고하시면 될 것 같아요. , 자, , 이렇게, 해서 이벤트 셀렉 내용을 마치도록 할게요.