자, 이제 진짜 진짜 마지막으로 말이 나온 김에 프로시저 부분까지 자동화 해가지고 처리하는 부분까지 , 일단은, 만들어 드리도록 하겠습니다 혹시라도 진짜 db 작업 연동이 당장 필요하실 수도 있으니까 이 부분만 보여드리도록 할 건데 결국에는 여기 있는 프로세저라는 부분을 파싱 해가지고 우리가 DB Synchronize 에서 만들었던 이런 클래스들을 자동 생성해서 만들어주면 됩니다 그게 , 일단은, 지금의 목표라고 보시면 되겠어요 툴을 만들 때는 이왕이면 언어를 통일해서 툴을 만드는 게 좀 더 관리하기 편리하니까 , 일단은, Packet Generator 와 마찬가지로 일단 Python 으로 계속 만들어 보도록 할게요 그래서 새 프로젝트를 만들어 준 다음에 Python 어플리케이션을 눌러 주시고 그 다음에 프로세저 제네레이터라고 이름을 짓도록 하겠습니다 그리고 이왕이면 위치는 우리가 계속 만들고 있었던 여기 툴스 한 하에다가 여기다가 , 일단은, 만들어 주도록 할게요 그래서 , 이렇게, 새로운 프로젝트를 만들어 주신 다음에 그 다음에 이제 오늘 등장할 아이들을 추가를 해 줄 것인데 추가 3 항목에 가 가지고 , 일단은, xml 디비 파서라는 클래스가 아니라 파이썬 파일을 만들어 주도록 하겠습니다 그 다음에 뭐 기존과 마찬가지로 항상 우리가 추가 세 폴더에 간 다음에 템플릿을 여기다가 , 이렇게, 넣어 놨었죠 진자 툴을 똑같이 이용할 것이기 때문에 , 이렇게, 만들어 주고 여기다가 추가 3항목에 가가지고 뭐 Python 파일은 아니지만 gen procedure.header 를 , 이렇게, 만들어 줄 것이고 그 다음에 하나를 더 추가를 할 것인데 이번에는 procedure.h 라고 , 이렇게, 일단은, 만들어 주도록 하겠습니다 , 자, 여기서 이제 코드를 작업을 하면 되겠어요 근데 뭐 이미 패켓 제네레이터를 만드는 걸 보여드렸으니까 굳이 일일이 타이핑 해가지고 시간 낭비를 하긴 싫어서 이번에도 복붙을 하는 식으로 빠르게 빠르게 , 일단은, 작업을 해보도록 하겠습니다. , 자, 그래가지고 여기 프로세저 제네레이터 쪽은 , 이렇게, 코드를 복붙할 것이고 그 다음에 xmldb 파서도 코드를 복붙할 것이고 다 복붙을 한 다음에 이제 분석하는 식으로 진행을 해보도록 할게요. gen 프로세저도 , 이렇게, 만들어 줄 것이고 아 그리고 이거 복붙을 하면 , 이렇게, 스페이스바가 자동 완성되는데 Ctrl-Z로 다시 붙여주시면 되겠습니다. 이거 꼭 붙여주셔야 돼요. 그리고 마지막으로 Procedure Header도 복부트 한 다음에 컨트롤 Z 한 번으로 , 이렇게, 다시 복구를 시켜서 저장을 해 보도록 하겠습니다 , 자, 그럼 이제 코드를 한 번씩 분석을 해 드리도록 할 건데 진짜 툴을 사용하는 거니까 기본적으로 시작하는 부분은 똑같습니다 , 자, 프로세이저 제네레이터 여기서 이제 메인 함수가 등장을 하고 아귀먼트 파서를 이용해 가지고 , 이렇게, 인자를 받아주는 부분까지는 똑같아요 디폴트 값은 여러분들의 그 경로에 맞게끔 , 이렇게, 맞춰 주시면 되겠고 뭐 이런 식으로 , 일단은, 아귀모트를 받아 가지고 아귀모트를 받았는지 확인을 한 다음에 그 다음에 xmldb 파서를 만들어 가지고 여기다가 path xml을 합니다 이거 뭐 지난번에 우리가 패킷 제너레이터랑 만든 거랑 약간 비슷한 느낌이죠 xml 파서를 만들어 가지고 이제 우리가 넘겨준 경로로 xml을 파싱하겠다 라고 얘기를 하고 있는 거죠 그래서 이 xml 파서는 말 그대로 xml을 분석하는 그런 클래스라고 보시면 되겠습니다 그래서 얘가 내부적으로 xml-e-tree-element-tree라는 아이를 사용해가지고 , 일단은, xml을 parsing 할 것이고요 코드는 뭐 굉장히 간단합니다 , 일단은, 여기 , 이렇게, 테이블이랑 프로세저 목록을 지금 , 이렇게, 들고 있다는 걸 볼 수가 있고요 얘는 이제 약간 리스트 형태고 얘는 일단 딕셔널 형태라고 보시면 되겠습니다 , 자, 그 다음에 여기다가 이제 parse xml을 호출하면은 요 부분이 실행이 되는데 , 사실, xml 파싱하는게 우리가 simpleflow도 해봤으니까 굉장히 단순하죠 여기 루트 노드를 기반으로 하나씩 파고 들어가면서 테이블을 쫙 파싱을 하고 그 다음에 테이블을 파싱할 때 한 번 더 컬럼이랑 인덱스를 파싱하고 이런 식으로 했던 거랑 마찬가지로 근데 우리는 지금 당장은 테이블은 필요 없고 , 일단은, 프로세저가 일단 더 핵심이긴 하죠 그래서 정확하게 컬럼까지는 다 알 필요는 없습니다 그래가지고 필요한 정보만 일단 쏙쏙 뽑아가지고 분석을 할 거예요 그래가지고 일단 테이블이랑 프로세저를 분석을 하는데 테이블이라고 해가지고 완전히 인덱스나 이런 부분까지 다 풀로 파싱하지는 않을 것이다 라고 , 일단은, 이해를 해주시면 되겠습니다 파스 XML을 보면 먼저 XML 루트 노드를 추출하는 걸 볼 수가 있고요 그 다음에 로드를 하나씩 하나씩 돌면서 테이블이 있는지 혹은 프로세저가 있는지를 , 이렇게, 두 번에 걸쳐 가지고 지금 스캔을 하고 있습니다 그래가지고 만약에 테이블이 있다 어 테이블이다 라고 하면은 여기 이걸 약간 오른쪽에다 보는게 좀 분석이 쉽겠네요 테이블 이다고 하면은 테이블을 만들어 가지고 그 해당 차일드 노드를 건네주고 있습니다 그럼 이제 테이블 쪽으로 넘어가 가지고 요 부분을 이제 분석을 해주시면 되겠어요 그래서 이게 약간 simple blue 치면 생성자라고 썼죠? 그래서 해당 노드를 건네주게 되면 얘도 역시나 , 이렇게, 타고 가면서 컬럼이 대략적으로 어떤 애가 있는지도 분석을 하고 있는데 다만 여기서 상세적으로 우리가 identity, not null 이런 것까지는 분석하지 않고 그냥 대략적으로 필요한 정보만 , 이렇게, 쏙쏙 뽑아 가지고 분석을 한다고 , 일단은, 볼 수가 있겠습니다. 필요한 정보만 진짜로 만들어 주는 거죠. 그 다음에 이제 이어서 procedure도 마찬가지로 이런 식으로 프로세저를 만들어 주게 되는데 거기서 이 부분이 이제 실행이 되어 가지고 내부적으로 그냥 코드가 굉장히 정직합니다 그래서 뭐 딱히 설명을 드릴 건 없을 것 같고 여기 저 프로세저를 보면서 네임을 추출한 다음에 여기 파라미터랑 바디 부분을 각각 쫙 스캔을 해주는 부분이 이제 여기 들어가 있어요 네 그리고 뭐 Parts Column 이라고 해서 이 부분이 조금 더럽게 되어있는데 여기서 이제 뭘 하고 싶은 거냐면은 우리가 Query 문을 , 이렇게, 만들어 줬죠 여기 안에다가 Select 뭐시기뭐시기뭐시기라고 해서 했는데 이 부분에서 우리가 필요한 부분을 추출할 겁니다 여기 Select 안에 있는 이런 인재들 개수를 알아야지만 우리가 이제 그거를 Column 값으로 빼가지고 관리를 해줄 수가 있겠죠? Column Input을 해야 되는 애들을 넣어줘야 되기 때문에 그런 애들을 받아주고 있고 여기 파라미터에 해당하는 애들이 실질적으로 우리가 이 SP를 실행할 때 입력해야 되는 인자 개수라고 볼 수가 있겠습니다. 그래서 이 부분이랑 이 부분을 잘 추출하기 위한 노력을 하고 있는 겁니다. 그리고 마찬가지로 여기 뒷부분 인자 개수도 몇 개가 필요한지 그리고 어떤 테이블을 해당 어떤 테이블 대상으로 내가 지금 뭐 얘를 호출하고 있는지 등등을 뭐 , 이렇게, 열심히 추출하고 있어요 그래서 뭐 파이썬 코드를 간단하게 그냥 읽을 줄 알면은 , 사실, 그렇게 크게 어려운 부분은 , 일단은, 없다고 보시면 되겠습니다 어 이런식으로 알파인드라고 해가지고 지금 어떤 문자열에서 내가 원하는 이 글자가 등장하는 인덱스를 찾는 요런 기능들을 이용하고 있어요 그래가지고 예를 들면은 지금 여기서 셀렉트 인덱스랑 프럼 인덱스를 뽑아주는 이유는 뭐냐면은 셀렉트가 있는지를 먼저 찾아서 셀렉트를 찾아서 있으면은 요 첫번째 인덱스가 걸릴 것이고 from 같은 경우에는 여기까지 와 가지고 from을 찾았다고 하면 이 인덱스를 뱉어 줄 거니까 그 사이에 있는 애들을 스캔해 가지고 여기 있는 애들이 몇 개짜리 인지를 하나씩 하나씩 긁기 위해서 지금 , 이렇게, 노력을 하고 있는 겁니다 그래서 여기서 하고 싶은 얘기는 만약에 select가 있고 그리고 from 인덱스도 0이 아니다 즉 진짜 select랑 from이 있다고 하면은 이런식으로 테이블 이름도 열심히 추출을 해주고 그 다음에 각각 단어들이 안에 무엇이 들어있는지도 추출할 것이다 라는 부분이 여기서 지금 호출이 된다고 보시면 되겠어요 그리고 참고로 이제 이 부분은 이런식으로 어떤 문자열에다가 뭔가 접근을 할 때 , 이렇게, 뭔가 잘라가지고 만드는 부분이 지금 반복해서 등장하고 있는데 이런 느낌입니다 1 2 이런 1 3 이런 식으로 지금 이런 패턴이 자주 등장하는데 이게 파이썬에서 C++은 C샵으로 치면 substring에 해당하는 부분이에요 1번 인덱스에서 3번 인덱스까지 잘라서 문자를 쪼개서 사용하겠다는 의미입니다 그래서 그런 부분들이 계속 반복해서 들어간다고 볼 수 있겠어요 , 사실, 굳이 파이썬을 당장 공부할 게 아니라면 그렇게 깊게 볼 필요는 없고요 어쨌든 건 툴은 그냥 동작만 잘하면 장땡입니다 그래서 크게 어려운 부분은 없고 여기서 이제 테이블 이름에서 우리가 이런 식으로 괄호에다가 dbo 모시기까지 붙어줬다고 하면은 그 부분을 일단 제거하기 위해서 열심히 노력도 하고 있구요 뭐 굉장히 다양한 부분이 일단 들어간다고 보시면 되겠어요 근데 요 코드가 아주 완전체는 아닙니다 제가 모든 그런 쿼리 대상으로 테스트 해본 건 아니기 때문에 그냥 간단한 간단하게 테스트 하기 위해서 몇 가지만 만들어 봤어요 그러니까 여러분들이 뭐 혹시라도 다른 쿼리를 만들었는데 그런 기능들이 제대로 작동하지 않는다고 하면 그 부분을 뭐 따로 만들어 주시면 되겠습니다 네 그래가지고 요 쿼리를 대상으로 지금 열심히 뭐 이런저런 정보들을 긁어 온다라는 부분을 일단 해석을 해주시면 되겠고요 , 자, 그 다음에 어 여기 make questions 부분은 결국에는 우리가 나중에 호출할 때는 요 부분들을 인자 값으로 이제 물음표 물음표 형태로 우리가 처음에 만들었던 것처럼 물음표 형태로 만들어야 되기 때문에 그 부분을 일단 만들어 준다고 보시면 되겠습니다 네 그래서 뭐 그 부분 대략적으로 그렇게 까지만 , 일단은, 간단하게 설명하고 넘어가도록 할게요 그래서 결국에는 여기 있는 내용을 XML 파싱을 한다 근데 이제 Python 문법이니까 처음 보시면 가독성이 좀 떨어질 수 있겠지만 이런 식으로 여기 있는 군문들을 분석해가지고 최대한 내가 필요한 정보를 추출하려고 하고 있다고 일단 요약을 할 수가 있겠습니다 그래서 , 이렇게, 해가지고 , 일단은, XML DB 파설을 통해가지고 여기 해당 DB 내용을 싹 긁었다고 하면 그 다음부터는 Jinja2 라이브러리로 넘어가가지고 하는 거니까 훨씬 더 쉽겠죠? 말 그대로 이 코드를 보시면 되겠습니다. Procedure 템플릿을 , 이렇게, 만들어 줬는데 이 템플릿에 해당하는 내용이 결국에는 우리가 이전 시간에 DB Synchronizer에서 만들었던 이 부분이랑 굉장히 유사하다고 보시면 되겠어요. 이런 느낌의 코드를 만들어주기 위한 자동화된 부분이 일단 들어가 있다고 보시면 되겠습니다. 그래가지고 여기 진자 문법 중에서 이런 식으로 내부적으로 우리가 함수를 정의할 수 있어요 이제부터 lower first라는 이름의 함수를 우리가 , 사실, 매크로라고 했는데 매크로를 지정했는데 얘가 하는 역할은 이 부분입니다 즉 이 아이로 치환이 될 것이고 어떤 텍스트를 입력했을 때 텍스트 0번 캐릭터를 뽑아가지고 걔는 lowercase로 소문자로 만들어주고 나머지 애들 1번부터 끝까지는 그냥 원래대로 그냥 냅두겠다라고 하는 거니까 이 lower first라는 걸 호출하게 되면은 어떤 이름 대상으로 첫 번째 문자만 소문자로 바꾸게 되는 기능입니다 그래서 이런 부분들이 이제 lower first가 여러번 등장한다는 것도 볼 수 있고 그 외에는 뭐 그렇게 크게 어려운 부분은 없어요 그냥 말 그대로 지금 요 코드를 생성하기 위해서 그냥 케이스별로 , 이렇게, 나눠준 겁니다 아까 우리가 xmldb 파서를 통해 가지고 파싱을 한 내용을 그대로 다시 건네 준 다음에 프로세저를 하나씩 하나씩 지금 수뇌를 하면서 파라미터가 무엇인지를 분석해 가지고 각기 알맞는 코드를 지금 만들어주고 있습니다 물론 이게 완전체는 아니기 때문에 여러분들이 뭐 더 필요한 거 원하는 게 있다고 하면 여기다가 이제 추가를 해주시면 되겠어요 그리고 몇 번 몇 가지 신기한 거는 여기 루프 인덱스라고 해 가지고 이 포문에서 내가 지금 몇 번째 인덱스에 해당하는지 등을 추출할 수 있고요 이건 이제 진자2에서 지원하는 기능이고요 그 다음에 이런 식으로 파람새에다가 짝대기를 긁고 랜스를 하면은 이 파라미터의 개수 숫자를 여기다가 그냥 박아줍니다 그래가지고 우리가 dbbind를 할 때 이런 식으로 0, 13과 같이 파라미터 개수와 컬럼 개수를 우리가 각각 넣어 줘야 되는데 그런 부분을 , 이렇게, 처리했다 라는 것도 , 일단은, 뭐 흥미로운 부분이긴 합니다 근데 그 외의 부분은 뭐 그게 딱히 어려운 부분은 없으니까 , 일단은, 뭐 , 이렇게, 대략적으로 만들어 주시면 되겠습니다 그리고 툴은 성능을 뭐 그렇게 엄청 숙고해가지고 생각할 필요는 없어요 이거 어차피 한 번만 실행해서 실행하면 되는 거니까 그리고 데이터가 뭐 몇 만개가 되는 게 아니다 보니까 이건 좀 비효율적이라고 하더라도 어찌됐건 결과만 잘 나오면 일단 장땡이라고 생각하시면 되겠습니다 그래서 , 이렇게, 프로세저를 만들어 줄 것이고 여기 젠 프로세저를 이용해가지고 결국에는 만들어 주긴 하는데 , 사실, 그냥 하나의 파일로 관리해도 되긴 합니다 근데 이제 좀 간혹성 차원에서 , 이렇게, 두 개로 , 일단은, 구분을 해놨고요 여기서도 매크로를 만들어 가지고 GenProcedure라는 일종의 함수를 만들어 놨는데 걔가 하는 역할은 여기 ProcedureH라는 이 아이를 , 일단은, 여기 안에다가 , 일단은, 그냥 복붙을 해서 박아준다고 보시면 되겠습니다 그래서 최종적으로는 이 형태로 나오게 된다고 , 일단은, 보시면 되겠어요 , 자, 이렇게, 해가지고 요 코드가 , 일단은, 실행이 된다고 치면은 이제 어떤 결과물이 나올지가 이제 살짝 궁금한데 어 뭐 이거는 그냥 얘를 이제 실행해서 테스트를 해보셔도 되고 아니면 우리가 기존에 했던 것처럼 여기서 우리가 원래 잠시 열어서 예전에 어떻게 했는지 살펴보면은 make.exe 파일을 만들어 가지고 실행 파일로 만든 다음에 그거를 여기 커먼 쪽에다가 배치해 가지고 만들어 놨었죠 그냥 그렇게 편하게 관리를 하도록 얘도 똑같이 일단 만들어 보도록 합시다 그래서 Procedure Generator 쪽에서도 얘를 잠시 열어준 다음에 방금 우리가 사용하고 있던 메이크 EX를 여기다가 , 일단은, 복붙을 해놓은 다음에 요 코드만 살짝 수정을 해보도록 할게요 뭐 아무데나 , 이렇게, 열어가지고 살짝 수정을 이제 해볼 건데 여기서 이제 몇 가지가 달라져야 되는데 얘가 아니라 이제 메이크 EX에서 여기 보면은 패킷 제너레이터고 된 부분만 , 일단은, 우리 이름에 맞게 Procedure Generator 라고 , 일단은, 이렇게, 바꿔치기를 해주면 되겠죠? 이 부분도 바꿔주고 이 부분도 바꿔주고 마지막 최종 이름은 그냥 여러분들이 원하시는 대로 전 ZenFrox 라고 , 일단은, 이름을 짓겠습니다 요렇게 일단 만들어가지고 이제 얘를 실행시켜주면은 잘 실행이 된다고 치면 이런 식으로 열심히 열심히 빌드를 하면서 이제 exe 파일이 딱 만들어지게 될 겁니다 그럼 이제 exe 파일이 만들어졌으면 얘도 이제 똑같이 우리가 기존에 하던 거와 마찬가지로 별도의 경로에다가 얘를 옮겨가지고 관리해주면 되겠죠 , 사실, 이 코드는 많이 바뀌지 않는다고 가정할 수 있으니까 이 genprocedure를 복사한 다음에 우리가 command쪽에다가 여기다가 관리를 하고 있었으니까 여기다가 procedures라는 폴더를 만들어 준 다음에 여기다가 일단 복붙을 해가지고 관리를 해 보도록 하겠습니다. 그러면은 여기다가 , 일단은, 관리를 한 다음에 마찬가지로 템플릿도 갖고 와야 되겠죠 템플릿을 빼놓고 왔네요 다시 찾아보면은 툴스 프로시저 제네레이터 템플릿을 긁어 가지고 아까 경로 2개 아래 프로시저 쪽에다가 , 일단은, 이렇게까지 복붙을 해오도록 할 것이고 그 다음에 마지막으로 배치 파일을 만들어 가지고 이걸 좀 편하게 관리할 수 있게 만들어 주도록 하겠습니다. 프로토버프 쪽에서 우리가 만들었던 배치 파일을 긁어 가지고 똑같이 복붙한 다음에 조금 수정을 해 보도록 합시다. , 이렇게, gem패킷을 만들어 놨고요. 뭐 이런 부분 같은 경우에는 이제 우리 비주얼 스튜디오 안에다가 그냥 복붙을 해 가지고 관리해도 뭐 괜찮겠죠. 그래 가지고 지금 db라는 이 폴더를 이제 좀 내용이 많아질 수 있으니까 이걸 그냥 밖으로 , 이렇게, 빼 주도록 합시다. 해준 다음에 그 다음에 어 다시 이제 아까 작업하던 곳으로 가 가지고 GenPacket 배치 파일을 , 이렇게, 넣어준 다음에 여기서 수정을 해보도록 합시다. , 자, 여기 좀 내용이 지금 뭐 굉장히 많이 들어가 있는데 , 사실, 우리가 모든 내용을 다 필요하지는 않으니까 거의 모든 내용을 날려도 되겠죠? 요기 필요 없고 요 부분에서 GenPackets가 아니라 GenProcedure.procs를 실행할 것이고 경로 같은 경우는 이제 뭐 상대 경로를 맞춰주면 되는데 한 칸 뒤로 두 칸 뒤로 그 다음에 게임 서버에다가 gamedb.xml 이란 파일을 긁어주세요 그 다음에 아웃풋은 뭐 이건 여러분들이 원하는 이름으로 만들어주면 되는데 그냥 genprocedures.h로 그냥 그대로 냅두도록 할게요 나머지 부분은 삭제하고 그 다음에 카피하는 부분 싹을 다 날려주고 그냥 카피할 파일이 딱 하나만 있습니다. 여기 genprocedure.h라는 파일만 긁어가지고 그거를 게임 서버에다가 넣어놓으면 되는데 지금 하나를 , 일단은, 없애주면 됩니다. 한 칸 뒷칸에서 게임 서버가 있을 것이고 그 다음에 뭐 요런 삭제하는 부분은 냅둬도 되고 뭐 어떻게 하셔도 되는데 이건 일단 , 이렇게, 날려주도록 할게요 아니 그냥 냅두도록 할까요? 네 요렇게까지만 , 일단은, 만들어주도록 하겠습니다 , 자, 그러면은 이제 Gen 패키지 실행이 빵 되면은 요기 메인 함수... 아 그니까 메인이라 게임 서버 쪽에다가 어... Gen Procedure 헤더가 추가가 되겠죠 이건 , 사실, 지금 미리 만들어 놔도 됩니다. 어차피 덮어 써지기 때문에 여기다가 gen procedures.h를 , 이렇게, 일단 만들어 놓고 이제 배치 파일을 실행해서 얘가 정상적으로 만들어지는지를 보도록 합시다. , 자, gen procedures.h를 , 이렇게, 빵 호출해가지고 살펴보면은 gen procedures가 짜잔 하고 , 이렇게, 만들어지는 걸 볼 수가 있습니다. 굉장히 이쁘게 잘 만들어 놨다는 걸 볼 수가 있어요. 그래서 프로세저를 그냥 호출할 때는 , 이렇게, call 뭐시기뭐시기라는 이름으로 그냥 호출하면 됩니다 인서트 골드 자체 정의는 굉장히 장황했는데 훨씬 더 짧아졌다는 걸 볼 수 있는 거죠 그래서 일종의 데이터베이스 안에 있는 함수라고 , 일단은, 생각할 수가 있는 겁니다 그래서 모든 인자들을 , 이렇게, 넘겨주고 호출하는 부분도 있고요 그 다음에 조금 더 재밌게 이제는 오름값도 그냥 넘겨줄 수 있게 , 이렇게, 만들어 놨어요 경우에 따라 가지고 오른 값을 넘겨주게 되면은 해당 값을 여기다가 , 일단은, 복사를 해서 , 일단은, 저장을 시켜 준 다음에 요 아이의 주소를 넘겨 줘 가지고 처리를 하는 부분도 뭐 그냥 , 이렇게, 만들어 봤구요 여기다가 추가적으로 뭐 다른 기능들 넣고 싶으면은 아까 그 자동화 툴에 가 가지고 템플릿을 수정하는 식으로 이제 만들어 주시면 되겠습니다 그래서 이제 앞으로는 이런 식으로 sp 를 굉장히 편리하게 자동화 생성해 가지고 얘네들이 이제 만들어 주면 된다고 보면 되겠어요 , 자, 그리고 우리가 늘상 했지만 여기 게임 디비 XML이 수정이 되면은 요 부분이 , 일단은, 자동으로 인지해가지고 수정이 되게 만들어주는게 좋겠죠 , 일단은, 여기 속성에 가가지고 이전에 하던 빌드 이벤트를 간 다음에 , 자, 여기다가 편집을 해가지고 하나를 더 만들어 주도록 합시다 지금 같은 경우에는 빌드 이벤트가 딱 하나만 걸려 있기는 한데 여기다가 편집에 가서 얘를 일단 복붙한 다음에 이제는 커먼에다가 이게 경로가 좀 바뀌었죠? 프로시저스에다가 빈은 아니고 젠프로스.밷으로 , 일단은, 이렇게, 만들어주면 되겠습니다 그러면 아까 우리 배치 파일이 실행이 되어가지고 자동으로 파일을 만들어줄 것이니까 적용 OK를 눌러준 다음에 그 다음에 XML DB가 변한 걸 인지해가지고 요 부분이 이제 이벤트가 자동 실행되게끔 만들어주면 되겠죠 아 그리고 참고로 더미 클라이언트랑 게임서버 양쪽에다가 얘를 다 등록시켜 놓으니까 너무 빈번하게 제 컴파일이 일어나는 것 같아가지고 이쪽에 있는 프로토콜은 그냥 날려주도록 할게요 얘는 더이상 사용 안 하도록 , 자, 그 다음에 잠시 파일 탐색기에서 폴더 열기에 가가지고 , 이렇게, 살펴본 다음에 잠시 비주얼 스튜디오를 닫아 주도록 합시다 모든 애들은 다 저장을 해주고 그 다음에 이제 등록하는 부분만 처리를 해주면 되겠죠 , 일단은, 여기 더미 클라이언트 프로젝트 파일에 가가지고 그냥 메모장이건 아무거나 , 이렇게, 넣어 주신 다음에 여기서 살펴보면은 원래 우리가 넣어 놨던 요 부분 있었죠 업데이트 투 첵 인풋을 , 일단은, 삭제를 하고 저장을 해주도록 할게요 얘를 인지해가지고 자동으로 빌드를 하는 걸 양쪽에 넣어 놓으니까 너무 빈번하게 갱신하는 것 같아가지고 얘는 일단 없애주고 반대로 게임 서버 쪽에 여기 프로세저, 그니까 프로젝트 파일에 가가지고 얘도 이제 똑같이 수정을 해줄 것인데 얘 같은 경우에는 방금 우리가 추가한 그 폴더 경로를 이제 입력을 해주면 되겠죠 그래가지고 얘를 , 일단은, 하나를 추가해준 다음에 지금 실행되고 있는 경로 기준으로 game.db.xml 이라는 걸 인지해가지고 얘를 이제 인지해가지고 얘가 뭐가 변화가 있으면은 알아서 제 빌드를 해라 라고 , 일단은, 이렇게, 만들어 주면 되겠습니다 그래서 이렇게까지 , 일단은, 완료가 되었으면은 거의 모든 준비가 끝난 거니까 얘는 다시 닫아주고 뭐 이거는 뭐 필요없고 이거 닫아주도록 할게요 이거 굉장히 귀찮게 꾸는데 닫아주고 , 자, 그 다음에 다시 게임 서버를 , 이렇게, 실행을 해보도록 합시다 뭔지 모르겠는데 닫아주고 , 자, 이렇게, 해가지고 굉장히 오랜 길을 걸어놨는데 이제 여기까지 완료가 되었으면은 정성적으로 툴이 작동하는지만 테스트를 해보면 되겠습니다 아 그리고 아까 여기 배치 파일을 zen prox로 , 일단은, 바꿔 놔야 되는데 이 부분을 , 일단은, 까먹지 않고 , 이렇게, 바꿔 주도록 할 것이고 이제 이 상태에서 게임 서버를 시작 프로젝트로 설정한 다음에 얘를 이제 빌드 해가지고 정상적으로 실행이 되는지를 살펴 보도록 합시다 그래서 별다른 문제가 없으면 이제 뭐 통과가 될 것이고 그러면 이제 최종적으로 진짜 진짜 진짜 최종적으로 얘를 이제 어떻게 활용하면 되느냐 게임 서버에 가 가지고 얘를 이제 마지막 최종 테스트를 해 보도록 할게요 여기 Gen Procedure 같은 경우에는 그냥 전역으로 사용할 수 있게 PCH에 넣어놔도 되긴 하는데 그러면 너무 빌드 양이 많아질 수 있으니까 그냥 필요할 때 그냥 추가를 해주도록 합시다 그래가지고 여기다가 예를 들면은 우리가 사용하겠다고 하면은 Include Gen Procedure를 헤더를 추가한 다음에 이제 여기 아래에 살펴보면은 우리가 , 이렇게, 지금 Game DB Synchronize까지 끝냈다고 치면은 여기다가 간단하게 SP Store Procedure Insert Gold를 사용해 보도록 할게요. 인서트 골드를 사용할 것이다. db 커넥션을 이미 뽑아왔으니까 얘를 그대로 , 이렇게, 전달해주고 그러면 알아서 이제 뭐 리셋하는 부분이 실행이 빵 될 거고 그 다음에 인서트 골드에다가 input 골드, 골드를 설정할 수 있죠. 예를 들면 우리가 100 골드를 설정하겠다고 하면 이제는 오른값도 , 이렇게, 건네줄 수 있습니다. 그 다음에 인서트 골드에다가 네임같은 경우에는 그냥 바로 넣어줄 수 있기는 안해놨고 이거는 너무 많은 복사가 일어날 수 있으니까 그냥 , 이렇게, 직접적으로 간접적으로 네임을 요렇게 만들어가지고 전달해주도록 하겠습니다 근데 나중에 가면 어차피 요런 애들은 그냥 메모리상에서 등장 이미 들고있는 애들을 넘겨줄 확률이 굉장히 높기 때문에 이 부분까지는 신경쓸 필요 없을 것 같아요 근데 만약에 필요하다고 하면은 뭐 이거 자동화 툴을 적당히 고쳐주시면 되겠고 그 다음에 인서트 골드에 뭐 크레이트 데이트 같은 것도 타임 스탬프 스트럭트를 뭐 , 이렇게, 적당하게 넣어 줄 수 있을 겁니다 예를 들면 6월 8일 오늘 날짜로 , 이렇게, 넣어 보도록 할게요 , 자, 이렇게, 일단은, 넣어 줄 수 있고 그 다음에 어 이제 이어 가지고 인서트 골드에 엑세큐트를 , 이렇게, 때려 가지고 실행을 해 줄 수가 있겠습니다 , 자, 이렇게, 만들어 주면 되고 아이고 0을 빼 주도록 할게요 6월 8일 , 이렇게, 자, 그 다음에 이제 앞으로 가가지고 또 하나 더 실행해보자면 이건 이제 인서트하는 부분이 실행이 됐으니까 Get Gold도 마찬가지로 똑같이 해주면 되겠죠? SP의 Get Gold 얘를 만들어줄 것인데 얘도 마찬가지로 DB Connection을 넣어주면은 알아서 초기화를 해줄 것이고 그 다음에 Get Gold에서 우리가 긁어오고 싶은 골드는 100 골드 짜리인 애들을 다 보여달라고 만들어진 게 이 Stop Procedure니까 뭐 , 사실, 왠지는 모르겠지만 그 다음에 이제 변수들을 각각 만들어 놔가지고 꺼내올 준비를 하도록 합시다. name은 100개짜리, 그 다음에 timestampstruct를 만들어가지고 날짜를 추출해 주도록 할게요. 그러면 getgold에다가 outid를 이용해가지고 이런 식으로 아이디를 건네주고 그 다음에 이어서 Out Gold를 여기다가 , 이렇게, 입력을 해줄 것이고 Get Gold에 Out Name도 전달해 줘서 네임에다가 너의 이름을 긁어와 달라고 하고 마지막으로 Create Date도 , 이렇게, 건네주면 되겠죠 뭐 , 사실, 요 아웃은 굳이 넣을 필요 없습니다 제 습관상 항상 요렇게 어.. 레퍼런스로 전달 받는데 값이 고쳐지는걸 아웃으로 넣어주기를 선호해서 그런거구요 그 다음에 Execute를 빵 때려서 성공하면은 여기서 Get Gold에 Fetch를 해가지고 하나씩 추출해주면 되겠죠 , 자, 콘솔 로고를 만들어 본 김에 요기다가 Write std 아웃에다가 추출해보도록 할게요 컬러는 뭐 블루로 만들어주고 , 자, 그 다음에 포맷은 id는 d 골드도 정수니까 이게 printf 스타일입니다. 이름은 , 이렇게, 까지만 넣어둘게요. 날짜는 좀 귀찮으니까 , 이렇게, 까지만 만들어주고 id, 골드, 네임을 각각 , 이렇게, 입력을 해주면 되겠습니다. 그 다음에 여기까지 정상적으로 실행이 되는지를 보기 위해서 여기다가 브레이크 포인트를 잡고 윗부분만 일단 실행을 해보도록 합시다. 그래서 F5를 눌러가지고 실행을 하게 되면은 저는 , 일단은, 이미 얘를 몇 번 실행했기 때문에 이미 정보가 여러 개가 들어가 있을 수가 있습니다. 그래서 실질적으로 제 환경에서는 지금 여러 개가 뜨고 있는데 그거는 이 아이디를 여러 개 넣어서 그런 거고 , 자, 이런 식으로 정상적으로 뭐 해당하는 ID와 골드 등등에 대한 정보가 , 이렇게, 추출이 되는 걸 일단 확인할 수가 있습니다 , 자, 이렇게, 해가지고 이제 진짜 진짜로 데이터베이스를 좀 편리하게 우리가 작업을 할 수 있는 그런 토대를 마련했다고 볼 수가 있는 거고 이제 앞으로 좀 큰 프로젝트라고 하더라도 이런 식으로 XML 파일을 기준으로 버전 관리를 하면서 여기다가 이제 모든 DB에 대한 정보를 관리하고 걔를 이용해 가지고 자동화된 툴을 이용해 가지고 이런 식으로 스톱 프로세저를 호출할 수 있는 그런 기반을 마련하면 이제 앞으로 굉장히 쉽게 사용할 수 있겠다라는 생각이 듭니다. , 자, 이렇게, 해서 제가 준비한 Part4 전체 커리큘럼에 대한 내용이 이제 완료가 되었고요 그리고 제가 아까 실수로 더미 클라이언트 프로토컬에 있는 내용을 전체를 삭제했는데 여기 있는 걸 다 삭제하면 안 되고 프로토 파일이랑 배치 파일만 삭제를 해야 되겠죠 여기 header랑 cc 파일은 있어야지만 얘가 프로토컬 인식해서 빌드가 될 테니까 얘는 다시 복원을 시켜줬습니다 다운받은 파일에는 바뀐 버전으로 같이 올려 드릴 것이고 , 자, 이렇게, 해가지고 이제 뭐 좀 장난을 쳐보시면 되겠습니다 이게 한 명이 아니라 500명으로 , 이렇게, 바꿔서 뭐 다시 실행을 해도 정상적으로 채팅 프로그래밍 잘 실행이 되는 걸 확인할 수가 있고 이제 뭐 전반적으로 우리가 걸어온 길을 다시 한번 간략하게 한번 복귀를 해보는 시간을 가져보도록 하겠습니다 , 자, 일단 완성된 우리 프로젝트의 실행 모습만 놓고 보면은 , 사실, 아직 언리얼 엔진을 뭐 딱히 연동을 해가지고 그래픽 쪽으로 뭔가를 보지는 않고 있기 때문에 딱히 뭐 어마어마한 내용이 들어가 있는 것 같지는 않습니다 그냥 500명의 유저가 서버에 접속해 가지고 같은 방에 들어간 다음에 헬로 월드를 막 서로 뿌리고 하는 브로드캐싱 하는 실습을 막 해보고 있어요 이 상태에서 클라가 막 나간다고 해도 서버가 크래쉬가 나지 않고 안전하게 잘 처리가 되는 부분까지 , 일단은, 확인을 할 수가 있습니다 그래서 이것만 놓고 보면은 아 뭐야 그냥 채팅 프로그램에 지나지 않나 라고 할 수 있겠지만 그럼에도 불구하고 지금 우리가 이 과정을 거치면서 굉장히 많은 내용들에 대해서 , 일단은, 학습을 해왔습니다 순차적으로 다시 한번 복귀를 해보자면 맨 먼저 했던 것은 여기 스레드와 관련된 내용에 대해서 쭉 학습을 해봤습니다 지금 서버 엔진 상에서는 뭐 클래스가 많이 없기는 하지만 기본적으로 C++ 표준에 들어간 굉장히 많은 내용들에 대해서 알아봤습니다. 스레드 생성은 어떻게 하는지, 아토믹 타입은 무엇인지, 락은 어떤 기념인지, 그리고 락을 구현하는 여러가지 방법에 대해서 알아봤고요. 데드락 현상은 왜 일어나는지, 그리고 락을 실질적으로 우리가 구현하는 연습도 해봤었죠. 스핀 락을 이용해보고, 슬립, 그리고 이벤트 방식으로 여러가지에 대해서 만들어본 다음에, 그 다음에 표준에 등장하는 컨디션 베리어블, 퓨처 같은 것들도 쭉 알아봤습니다. 그 다음에 TLS에 대해서 간략하게 알아보고 스택을 만들 때 락을 기반으로 만드는 스택 큐 같은 자료 구조 실습도 해봤고 락 프리 구조로 스택과 큐를 만드는 실습도 쭉 해봤습니다. 그 다음에 이제 스레드 관리에 관한 부분에 대해서 언급을 해봤고 이런 식으로 데드락 프로파일러라는 걸 만들어 가지고 데드락 상황을 디버그 상황에서 빠르게 탐지할 수 있고 문제 해결을 하기 위한 여러가지 그런 방안들을 , 일단은, 마련하는 방법에 대해서 , 일단은, 쭉 알아봤습니다 그 다음에 스레드와 관련된 부분이 이제 완료가 되었고 그 다음 순서로 이제 메모리 쪽으로 넘어갔었죠 기본적으로 뉴 딜리트 방식으로 기본 할당기를 사용하는 게 아니라 우리만의 커스터마이징 된 그런 할당자를 붙여가지고 메모리 관리하는 기법에 대해서 알아봤었구요 그 다음에 뭐 각종 할당자를 만들어 가지고 이를테면 스톰퍼 얼로케이터 같은 걸 붙여가지고 메모리 오염이 일어났을 때 그걸 100% 확률로 한번에 잡아보는 그런 실습도 해봤습니다 그리고 이어서 메모리 풀링을 해본 다음에 메모리 풀링된 할당기를 붙여가지고 메모리가 항상 자동으로 관리되게끔 그리고 옵체트 풀링도 적용되게끔 실습을 쭉 해봤고요 다이나믹 캐스트 대신 빠르게 사용할 수 있는 타입 캐스트에 대한 개념도 알아봤고 실습을 해봤습니다. 그 다음에 섹션 3 네트워크 프로그래밍을 넘어가 가지고 네트워크 프로그래밍이란 무엇인지 소켓 프로그래밍의 기초에 대해서 쭉 알아봤고 TCP UDP 개념에 대해서 알아보고 실습을 해본 다음에 블록킹 소켓, 논 블록킹 소켓 그리고 각종 네트워크 입출력 모델에 대한 실습을 쭉 해봤습니다. 그 다음에 본격적으로 네트워크 라이브러리 제작을 IOCP 모델을 이용해 가지고 쌓아 올리기 시작을 했고요. 아까 테스트한 대로 안정적으로 몇백 몇천의 유저가 들어오고 끊어도 전혀 문제없이 잘 처리가 되는 것을 확인할 수가 있었습니다. 그 다음에 본격적으로 패킷 직렬화에 관한 내용에 대해서 쭉 다뤘고요 패킷 직렬화란 무엇인지 그리고 어떠한 기법들이 있는지에 대해서 쭉 실습을 해본 다음에 그 다음에 프로토버프라는 구글에서 만든 방식으로 붙여가지고 실습을 쭉 해봤습니다 그래서 프로토버프 연동까지 지금 정상적으로 잘 되어 있는 걸 , 이렇게, 확인을 할 수가 있고요 그 다음에 이제 자동화 코드를 만들어가지고 우리가 컨텐츠를 편리하게 작업할 수 있는 여러가지 방식에 대해서 알아봤습니다 그래가지고 지금 실질적으로 요런 코드들 이 자동화되서 처리가 되고 있고요 이 프로토 파일만 살짝 바꿔가지고 다시 빌드를 해보면은 요런 클라이언트 패킷 핸들러가 다시 재상성이 되는 것도 우리가 확인을 할 수가 있었습니다 그래서 실질적으로 실무에서 사용하는 그런 온갖 자동화 기법들에서도 쭉 알아봤고요 본격적으로 패킷 직렬화에 대한 내용이 끝난 다음에 이제 락 방식이 아니라 잡 방식을 사용하는 이유 그리고 잡큐를 만들 때 어떠한 이슈들이 있는지 어떠한 방법들이 있는지에 대한 내용을 쭉 다뤘고 그게 바로 이 잡과 관련된 부분이었습니다 그 다음에 마지막 최종적으로 db 연동과 관련된 실습을 해봤는데 그냥 odbit을 이용해서 db를 붙이는 것 뿐만 아니라 db를 편리하게 래퍼 클래스를 만들어 가지고 관리하는 여러가지 기법들에 대해서 알아봤구요 그 다음에 db 버전 관리에는 어떠한 이슈들이 있는지에 대해서 언급을 한 다음에 간단한 실습을 해보기 위해서 데이터베이스를 그냥 코드로만 관리하는 게 아니라 이런 식으로 XML로 관리해 가지고 데이터 베이스 버전 관리를 편리하게 할 수 있는 방법에 대해서 , 일단은, 알아봤습니다 그래서 지금 이 상태에서 우리가 이를테면은 이런 식으로 칼럼을 만약에 하나를 추가한다 뭐 이런 느낌으로 칼럼을 추가하고 다시 이제 빌드를 해보면은 자동화된 코드에 의해 가지고 편리하게 데이터빅스를 관리할 수 있는 그런 여러가지 실습을 해봤습니다 그래가지고 지금 이 상태에서 다시 서버를 띄우면은 실질적으로 우리가 만든 이 DB까지 갱신이 되어가지고 우리가 원하는 구조에 따라서 만들어지는 것도 확인을 할 수가 있고요 그 다음에 우리가 겸사겸사 같이 만들어준 요런 프로세서 같은 경우에도 자동화된 툴을 이용해가지고 편리하게 요런 느낌으로 코드가 만들어지고 편리하게 우리가 활용할 수 있는 실습을 까지 , 일단은, 맞춰봤습니다 그리고 뭐 마무리 짓기 전에 그냥 간단하게 서버만 다시 실행해 봐주고 DB가 정상적으로 바뀌는지만 확인을 해보도록 할게요 , 자, 이렇게, 서버가 뜬 다음에 다시 닫아주고 그 다음에 다시 이제 DB가 열이 어떻게 되는지 확인을 하면은 우리가 방금 추가한 테스트라는 컬럼이 정상적으로 DB에도 잘 추가가 돼 있는 것을 , 이렇게, 확인할 수가 있었습니다 , 이렇게, 해가지고 이 전반적인 과정을 쭉 이해하시게 된다면은 어떤 프로젝트 MMO이건 말건 상관없이 어떤 프로젝트에 입사를 하시더라도 서버 프로그래머가 기본적으로 알아야 될 교양에 해당하는 모든 내용들을 다 학습을 하게 됐기 때문에 굉장히 쉽게 프로젝트에 적응할 수 있는 그런 기본기를 , 일단은, 쌓을 수 있게 될 겁니다 , 이렇게, 해가지고 굉장히 긴 내용을 쭉 다루는데 이 전반적인 과정을 다시 한번 복습을 해보시고 이제 앞으로 많은 그런 도움이 되기를 , 일단은, 바라겠습니다.