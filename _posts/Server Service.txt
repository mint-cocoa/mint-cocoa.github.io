자, 이렇게, 지난 시간까지 네트워크 라이브러리를 조금씩 이제 쌓아 올리고 있었는데요 그냥 간단하게 요렇게 억셉트만 받는 부분까지 , 일단은, 만들어놨습니다 그리고 오늘도 그냥 전체적인 흐름 상으로는 뭐 엄청나게 많은 진전을 하진 않을 것이지만 요 코드를 몇 가지를 일단 수정을 해볼 겁니다 지난 시간에 제가 또 언급을 드렸지만 요 지금 우리 코드가 살짝 문제가 있다고 했었죠 결국에는 우리가 , 이렇게, 키값으로 등록한 애가 실질적으로 GetQueueConfigurationStatus를 해가지고 추출해가지고 여기서 지금 키값이랑 우리가 넣어준 오버랩트를 상속받은 요 구조체를 두개를 정보를 이용해가지고 복원을 시킨 다음에 그걸 이용해가지고 디스패치를 때리고 있는데 근데 요 아이 자체가 과연 아직까지 살아있는 것이 맞는 것일까가 , 사실, 굉장히 큰 의문이 듭니다 그리고 우리가 이전 시간에 컴플리션 포트 모델에 대해서 실습을 할 때 , 사실, 얘를 뭔가 등록을 해 가지고 리시브나 샌드 같은 것을 예약을 한 상태에서 그 객체를 삭제해 버리면 당연히 오염된 그런 포인터를 접근하는 문제가 생겨서 여기서 크래시가 날 수 있다고 했었죠 , 자, 그래서 이제 가장 중요한 부분이 그 부분을 수정하는 것이 오늘의 목표구요 그럼 이제 이것을 어떻게 수정할 것이냐 , 사실, 방법은 여러가지가 있습니다 결국에는 다시 한번 복귀를 해보면 여기서 우리가 키값을 하나를 요렇게 넣어놨구요 그 다음에 오버래프트 구조체 , 이렇게, 두개를 넘겨주는거고 두개가 다 살아있어야 된다는 보장을 해줘야 되겠죠 근데 뭐 일반적인 그런 케이스로 치면은 우리가 요 오버랩토로 넣어주는 요 아이 같은 경우는 , 사실, 실질적으로 IOCP랑 통신을 할 때 등록하고 꺼내고 하는 용도로만 사용하기 때문에 , 사실, 얘는 뭐 크게 문제가 있다고 보기는 힘들어요 근데 진짜 문제가 되는 아이는 요 키값으로 넣어준 요 오브젝트 자체였었죠 지금 같은 경우는 우리가 리스너랑 세션 이 두가지가 사실상 등록을 할 때 넣어주는 IOCP 객체로 볼 수가 있는 건데 그러면은 얘를 이제 어떻게 유지를 시켜 줄까가 오늘의 주제라고 볼 수가 있어요 첫번째 방법은 , 일단은, 기본적으로 레퍼런스 카운팅을 하는 겁니다 그래가지고 예를 들면은 요 Iocp 옵젝트를 랩 카운터블을 상속 받아 가지고 우리가 이런 랩 카운팅 같은 거 만들어 놨었죠 요런 애를 상속을 받아 가지고 랩 카운팅을 할 수 있게끔 만들어 준 다음에 우리가 실질적으로 여기다가 뭐 어떤 행동을 하기 전에 예를 들면은 우리가 리스너에서 이런 비동기 입출력 함수를 호출하기 전에 이 아예 레퍼런스 카운트를 1 증가시키는 형태로 만들어 주면 되겠죠 그 다음에 혹시라도 문제가 있거나 아니면은 완료가 되었다고 하면 이쪽에서 다시 레퍼런스 카운트를 1 줄여주는 방법으로 , 일단은, 만들어 줄 수가 있기는 합니다 , 자, 근데 그 방법에 살짝 문제라고 한다면은 만약에 우리가 진짜로 그 레퍼런스 카운팅 방법으로 만든다고 가정해볼게요. 그러면 사실상 우리가 요 레프 카운팅이라는 걸 이용해가지고 이제 레퍼런스 카운팅을 하게 되는 건데 만약에 외부에서 요 세션을 Shared PTR이나 뭐 다른 수단으로 또 이중으로 레퍼런스 카운팅을 하기 시작한다면 약간 모순이 생길 수가 있습니다. 외부에서는 레퍼런스 카운팅이 0이어가지고 걔를 날리려고 하는데 종작 우리는 또 다른 우리만의 방식으로 랩컨팅을 하고 있다거나 하는 식으로 이중으로 권리가 되면 굉장히 복잡해진다는 문제가 생기겠죠 그리고 만약에 우리가 이걸 아예 그럼 Shared Pointer로 그냥 관리를 한다고 치면은 Shared Pointer는 우리가 직접적으로 Add Reference를 1 추가하는 방법이 딱히 존재하지 않습니다 물론 여러가지 꼼수를 이용해 가지고 멤버 변수로 자기 자신의 Shared Pty를 물고 있다거나 하는 식으로 뭔가 오해할 수 있긴 하지만 그렇게 깔끔한 방법은 아니라고 볼 수 있겠죠 그래서 가장 , 일단은, 직관적이고 그리고 제가 좋아하는 방법 중에 하나는 , 일단은, 킷값을 사용하지 않고 모든 애들을 다 우리가 만들어준 이 이벤트에다가 물려주는 겁니다 여기 iocp-event라는 이 아이에서 자기 자신을 실질적으로 걸어준 주인님을 기억을 해준다는 얘기가 되는 거죠. 그래서 , 일단은, 그 방식으로 설정을 수정을 해보도록 할게요. , 일단은, 등록을 할 때 , 자, 여기서 이제 iocp-core에서 우리가 iocp-object를 , 이렇게, 지금 등록을 하고 있습니다. 근데 이제 앞으로는 이 키값을 사용하지 않을 거라서 얘를 , 일단은, 원래 키값 영역이었는데 얘를 그냥 0으로 밀어 주도록 하겠습니다. 그렇다는 것은 마찬가지로 디스패츠를 할 때도 요 아이를 통해 가지고 이런식으로 복원을 하면 안된다는 얘기가 되는거죠 그래서 뭐 , 일단은, 임시적으로 yulongptr-key 라는 애를 만들어가지고 우리가 넣어준 키값을 그냥 다시 , 이렇게, 받아 조정할게요 근데 딱히 0으로 넣어줬으니까 얘는 사용하지 않을 예정이라는 거죠 네 요렇게 , 일단은, 수정을 하면 될 것이고 그 다음에 결국에는 요런 IOCP 이벤트라는 애들이 자기 자신의 주인님을 주인님의 셰어드 포인터를 이제 물고 있도록 수정을 해보도록 하겠습니다 , 자, 참고로 이제 뭐 우리가 Shared Pointer를 이것저것 사용을 할 건데 이거를 매번마다 타이핑 하기가 은근히 귀찮습니다. 이게 좀 길죠? 예를 들면 Shared PTR, IOCP Object 여기까지 치는 게 사실상 굉장히 힘들기 때문에 제가 사용하던 제가 일했던 몇몇 프로젝트에서는 이걸 항상 이런 식으로 재정의를 해가지고 사용을 했어요. 예를 들면은 REF를 붙은 애들은 이제 Shared Pointer라는 의미라거나 뭐 이런식으로 네이밍 컨벤션을 정해가지고 사용을 하면은 이거보다 이게 훨씬 더 타이핑 하기가 쉽죠 그래서 이런식으로 , 일단은, 작업을 해주도록 하겠습니다 여기다가 이제 전방선언을 해줘가지고 이 IOCP 옵젝트가 뭔지 모르니까 전방선언도 해주고 STD도 옆에 , 이렇게, 붙여주도록 하겠습니다 그래서 얘가 이제 Shared PTR을 이름을 재정의하는 영역이라고 , 일단은, 보시면 되겠어요. 그리고 뭐 하는 김에 , 일단은, 얘를 쭉 복사해가지고 몇 개만 더 만들어 볼 건데 이제 오늘 만들어 줄 애들이 몇 가지가 있습니다. IOCP 코어 같은 경우에도 , 이렇게, 일단은, 등록을 해주도록 할 것이고 , 자, 그 다음에 Session 같은 경우에도 우리가 Shadow Pointer로 통일해서 사용할 것이기 때문에 요런 애들을 다 바꿔줄 것이고 Listener 같은 경우에도 Listener Reference라는 걸 만들어 줘가지고 요렇게 만들어 줄 것이고 그 다음에 아직은 존재하지 않지만 일단 후반부에 만들어 줄 애도 미리 추가를 해도록 할게요 서버 서비스라는 애도 , 일단은, 이렇게, 일단은, 추가를 해주도록 하겠습니다 그리고 뭐 이건 , 사실, 프로젝트마다 조금 다르긴 한데 어떤 분들은 이거를 진짜 칼군무처럼 , 이렇게, 정렬을 하는 걸 더 선호하는 분들이 있어서 뭐 , 이렇게, 맞춰 주셔도 되고 그냥 스킵하셔도 되고 이거는 여러분의 선택입니다 , 자, 이렇게, 일단은, 사용할 준비를 끝냈고요 그 다음에 IoCP 이벤트 쪽으로 돌아가 가지고 이제는 요런 아이들이 IoCP 오브젝트 레퍼런스로 자기의 주인님을 , 일단은, 기억을 하주도록 하겠습니다 그리고 참고로 이 IoCP 이벤트는 이제 두루두루 이것저것 많이 사용을 할 거기 때문에 뭐 이런 식으로 함수를 이용해 가지고 접근을 해도 뭐 안될 건 없지만 그냥 이걸 퍼블릭을 열어주고 직접적으로 얘를 건드리도록 허락을 해주도록 할게요 , 자, Ctrl-R-R 눌러가지고 이름을 그냥 이벤트 타입으로 그냥 수정을 해보도록 하겠습니다. 적용, 오케이. 그리고 Get Type은 일단 없어지고 이제 앞으로 그냥 이벤트 타입이랑 Owner를 막바로 접근해서 사용하도록 일단 허락을 해주도록 하겠습니다. 줄을 맞춰주도록 할까요? 그 다음에 마찬가지로 이 Accept Event 같은 경우에도 이제 Session을 물고 있는데 얘도 마찬가지로 SessionREF라고 자신의 세션을 그냥 퍼블릭으로 열어줘서 그냥 막바로 건드리도록 하겠습니다 네 , 이렇게, 일단은, 수정을 해주도록 하고 , 자, 그 다음에 이제 그러면 요 부분에서 우리가 IoCp 이벤트를 만들어줄 때 항상 자신의 Owner가 누구인지를 이제 연결을 시켜줘야 된다는 뭐 그런 얘기가 되겠습니다 , 자, IoCp 이벤트는 지금 , 이렇게, 받을 것이고 그 다음에 얘가 , 일단은, 없어지고 요 위치에 들어가는 게 아니라 어... IoCp Object Reference를 다시 복원을 여기서 시켜주는 겁니다. iocp-object, iocp-event의 owner가 누구냐, 너를 지금 물고 있는 너의 주인님은 누구냐를 추출해가지고 걔를 다시 dispatch하는 식으로 , 이렇게, 작업을 해보도록 할게요. 마찬가지로 이 부분을 복붙해가지고 아래쪽에서 똑같이 자기 자신의 주인님을 이용해서 복원한다라는 코드로 , 일단은, 다시 맞춰주도록 하겠습니다. , 자, 일단 빌드를 해가지고 지금 뭐 몇가지를 수정했으니까 이제 에러가 나겠죠? 그 부분을 , 일단은, 잡아주고 넘어가도록 할게요. , 자, Get Type 하는 부분을 그냥 이벤트 타입으로 체크하면 될 것이고 그 다음에 얘는 그냥 Session을 이용해서 마찬가지로 Set Session도 Session은 누구누구로 그냥 , 이렇게, 수정을 해주고 다시 빌드를 해서 통과를 시켜주도록 하겠습니다. 그 다음에 일어나는 문제는 이제 세션 레퍼런스로 얘네들을 다 수정해줬으니까 우리가 기존에 괜히 이런식으로 세션으로 물고있던 아이들을 이제 수정을 해줘야 되겠죠 얘도 세션 레프로 , 이렇게, 바꿔치기를 해주고 그러면은 요 부분 , 일단은, 해결될 것이고 그 다음에 얘도 마찬가지로 지금 뉴 세션으로 했는데 이제 New Session이 아니라 이거를 다른 식으로 만들어주면 되겠습니다. Session Wrap으로 , 이렇게, 만들어주고 얘는 , 일단은, Make Shared로 이용해가지고 Session을 잠시 , 이렇게, 만들어주고 다시 통과를 한번 시켜보도록 하겠습니다. , 자, 일단 여기까지는 , 일단은, 잘 통과가 되었습니다. 그 다음에 이어서 여기서 내려보다 보면 리스너에서 Accept Extended라는 사실상 우리가 지금까지는 비동기 입출력 함수를 하나만 지금 사용하고 있는데 이 아이의 , 사실, 주인님 자체로 놓고 보면 Accept Event의 주인님을 우리가 연결을 아직 시켜주지 않았습니다. 그거는 이 Register Accept를 어디서 호출한지 다시 복귀를 해보면 위쪽에서 Start Accept 쪽에서 여기서 하고 있는데 여기서 푸시백을 하기 이전에 accept event에 owner를 자기 자신을 넣어주면 되겠죠 , 자, 근데 여기서 살짝 문제가 되는 부분이 이제 이걸 shared-ptr을 많이 사용을 안 해보셨으면 요 부분에서 살짝 멘붕이 올 수가 있어요 분명히 여기서 shared-ptr를 넣어줘야 되는데 밖에서는 shared-ptr를 우리가 사용할 수 있다고 해도 여기 자체에서는 얘를 어떻게 만들어줘야 되나 싶죠 그래서 흔히 초보들이 많이 한 실수가 여기서 괜히 이런 식으로 뭐 iocp object 라거나 이거를 요기에서 shared ptr 로 만들어 줘 가지고 디스를 이용해 가지고 얘를 만들어 주는 경우가 종종 있는데 이건 이제 난리나는 코드입니다 그래서 이게 simple pre 이런 부분이 조금 까다로운데 이게 왜 문제가 되냐면은 shared ptr 를 다시 처음부터 만들어 주고 그 포인터를 디스 포인터를 넘겨줬기 때문에 실질적으로 레퍼런스 카운트가 1자리인 shared ptr 을 우리가 새로 생성한 셈이 되는 겁니다 그럼 외부에서 만약에 이미 우리가 지금 작업하고 있는 이 리스너를 또 다른 Shared PTR로 관리하고 있었다고 하면은 이제 동일한 포인터를 두 개의 Shared 포인터로 관리하고 있다는 얘기가 되는 거니까 혹시라도 요 아이가 레퍼런스 카운트가 0으로 떨어졌다고 하면은 사실상 절대 지우면 안 되는 그런 애를 우리가 삭제를 할 수 있다는 굉장히 무서운 일이 이제 일어나게 된다고 보시면 되겠습니다 , 자, 그러면은 여기서 요런 경우에는 그러면 우리가 이제 어떻게 해야 되느냐 다시 리스너를 가보면 리스너가 IoCp Object라는 걸 우리가 , 이렇게, 상속을 받고 있는데요 , 자, 이거를 우리가 이런 식으로 자기 스스로 내부에서 SharedPointer를 추출할 수 있게끔 하려면은 자기 상위 클래스나 자기 자신에다가 EnableSharedFromThis라는 굉장히 이름부터 이상한 요 클래스를 일단 상속을 받아야 됩니다 Iocp object로 , 일단은, 요렇게 만들어 주도록 할게요 그럼 얘가 뭘 하는 것이냐 내부적으로 들어가서 살펴보면은 사실상 얘가 내부적으로 요렇게 위크 포인터를 자기 자신에 대한 위크 포인터를 요렇게 들고 있게 됩니다 즉 사실상 요런 코드가 들어간다는 얘기가 되는 거죠 요렇게 그래서 만약에 요 상태에서 우리가 지금 똑같은 상황에서 Shared Pointer를 추출해야 된다고 하면은 이런 식으로 디스를 이용해가지고 어거지로 만들어 주는 게 아니라 자기 자신에 대한 위크 포인터를 통해 가지고 요 아이를 이제 이용해가지고 락을 해서 얘를 이제 셰어드 포인터로 변환을 해가지고 이제 여기다가 넣어주게 되면 아까와 같은 문제가 이제 발생하지 않을 거에요 그래서 요런 원리로 , 일단은, 동작한다는 건 알아두시면 되는 거고 enabled from, shared from this를 추가를 해준 다음에 실질적으로 사용을 할 때는 그냥 여기서 shared from this라는 요 키워드를 이용해 가지고 자기 자신에 대한 그리고 레퍼런스 카운트를 유지한 채로 shared 포인터를 만들어 줄 수가 있습니다 그래서 요 기법을 이제 꼭 Shared Pointer를 사용할 거라면 이제 능숙해지시고 반드시 원리를 이해하시고 생 포인터를 이용해가지고 Shared Pointer를 막 실시간으로 만드는 그런 일은 절대로 이제 앞으로 하시면 안 됩니다 , 자, 그리고 이 상태에서 지금 실행을 하면은 크래쉬가 날 텐데 이런 식으로 우리가 Shared From Dies를 사용하기 위해서는 반드시 이 리스넛 자체를 이제 Shared Pointer로만 활용을 해야 됩니다. 무슨 말이냐면 우리가 게임 서버로 돌아가가지고 이런 식으로 스택 메모리에다가 그냥 사용하고 있었는데 , 이렇게, 하면 안되고 이제는 얘를 항상 Shared Pointer 형태로 이런 식으로 메이크쉐어들을 해가지고 리스너를 만들어 준 다음에 사용을 해야지만 아까 그 코드가 정상적으로 , 일단은, 실행이 된다라고 볼 수가 있겠어요. 그래서 뭐 , 일단은, 이런 식으로 만들어 가지고 실행을 해보면 , 일단은, 클라이언트 커넥티드가 지난번과 마찬가지로 잘 뜬다는 건 볼 수가 있습니다. , 자, , 이렇게, 가지고 지난 시간에 살짝 문제가 되었던 요 레퍼런스 카운팅 관련된 부분을 뭐 , 이렇게, 해결할 수 있다 라는 말씀을 드리고 있는 거고 나중에 뭐 이 리스너뿐만 아니라 세션 같은 경우에도 지금은 , 사실, Session이 별다른 행동을 해주고 있진 않지만 나중에 가면은 우리가 리스너에서 Accept Extended를 하는 것처럼 Session도 마찬가지로 Send를 하거나 아니면 Receive를 하거나 Disconnect 같은 그런 비동기 네트워크 함수들을 막 사용하게 될텐데 그때도 마찬가지로 Session이 자기 자신에 대한 Ownership을 이벤트한테 넘겨주는 식으로 작업을 해주게 될 겁니다 그거는 이제 다음 시간에 할 것이고 참고로 네트워크 라이브러리에서 이 세션이 거의 비중의 50% 이상을 차지할 정도로 굉장히 이제 내용이 많이 들어가게 될 거예요 얘가 사실상 샌드도 하고 리시브도 하고 막 그런 해야 될 일이 굉장히 많기 때문이죠 그래서 이거는 좀 큰맘 먹고 할 것이고 일단 오늘은 여기서 끝내기보다는 하나만 좀 자잘한 부분 하나만 더 고쳐줄 건데 그게 뭐냐면은 , 자, 우리가 지금 여기서 이런 식으로 리스너를 실시간으로 만들어 가지고 억셉트를 하고 있고 게다가 더 좀 마음에 안 드는 부분은 iocp 코어를 , 이렇게, 전역으로 만들어 가지고 얘를 뭐 활용하고 있습니다 근데 뭐 이게 딱히 안 된다는 얘기는 아니고 대부분의 경우는 , 사실, iocp 코어는 즉 컴피션 포트는 하나만 만들어서 활용하는 경우가 많지만 경우에 따라서 이걸 뭐 여러 개를 만들어 가지고 구분을 하는 그런 경우도 생길 수도 있겠죠 그리고 또 하나의 문제는 우리가 서버를 지금 만들어가지고 서버 라이브러리를 만든다고 해서 실질적으로 나중에 우리가 이 게임 서버에서 어 딱 요 아이만 한 번만 사용하는 한다고도 보장을 할 수가 없습니다 이게 무슨 말이냐면 예를 들면 우리가 MMO 서버를 만든다고 했을 때 나중에 가면은 분산 서버를 사용하는 경우가 굉장히 많아요 예를 들면 어떤 서버는 뭐 게임 플레이 서버고 AI 서버는 따로 분리하고 DB를 관리하는 서버는 또 빼고 이런 식으로 서버를 2개 혹은 3개로 분리하는 경우가 굉장히 많은데 그렇게 되면은 요 서버도 다른 서버랑 통신을 하기 위해서는 서버끼리도 한쪽 서버에서 다른 쪽 서버로 붙어야 되기 때문에 하나는 클라이언트의 역할을 해야 되고 또 다른 애는 진짜로 서버의 역할을 또 해야 됩니다. 그러니까 네트워크 통신이 꼭 클라이언트랑 서버만 게임 클라이언트랑 서버만 이루어지는 게 아니라 서버끼리도 서로 통신할 필요가 생길 수 있다는 얘기가 드는 거죠 그래가지고 , 이렇게, 서로 막 연결하고 하는 부분을 조금 더 편하게 사용할 수 있게끔 묶어주는 게 굉장히 좋은데 지금 같은 경우에는 리스너라는 클래스에다가 뭐 IOCP 코어를 우리가 강제로 밀어넣었고 세션도 막 이리저리 서로 따로 돌아다니고 있다는 문제가 있죠 게다가 심지어 또 다른 문제가 뭐냐면은 이건 나중에 코드를 작업하다가 나중에 좀 깨닫게 되는 문제 중 하나인데 지금 우리가 이런식으로 작업을 하다가 Accept를 하면은 여기서 우리가 MakeShared로 Session을 , 이렇게, 만들어주고 있습니다 근데 이게 사실은 약간 문제가 있어요 왜냐면 이 Session이라는 것 자체는 어디까지나 우리가 서버 코어 라이브러리에서 관리하고 있는 클래스죠 근데 나중에 가면은 컨텐츠 단에서는 얘를 어떻게 활용할지는 아직 정해지지가 않았습니다 예를 들어서 여기 게임 서버에서는 뭐 얘를 상속받아가지고 게임 세션이라거나 다른 애로 확장을 한 다음에 자기가 놓고 싶은 정보라던가 뭐 여러가지 기능들을 뭐 추가하고 그 다음에 그 세션들을 뭐 세션 매니저에서 관리해 가지고 풀링을 한다고 하는 식으로 동작하게 하고 싶을 수도 있는데 지금은 우리가 그냥 네트워크 코어 라이브러리에서 강제로 이 기본의 세션 형태로 만들어 버리고 있습니다 이런 부분도 , 사실, 정상적인 라이브러리가 볼 수가 없는 거죠 이런 부분도 외부에서 커스터마이징 해 가지고 이 세션을 어떻게 만들어 줄지를 결정할 수가 있어야 된다고 보시면 되겠습니다. 그래가지고 뭐 이런저런 기능들을 이제 한 곳에 모아두어가지고 그걸 서비스라는 하나의 단위로 관리하면 굉장히 편한데 그 부분을 일단 오늘 간단하게 작업을 해주도록 할게요. 이거 메모리가 아니라 여기 네트워크 쪽에다가 , 일단은, 추가를 할 건데 , 자, 서비스라는 이름으로 , 일단은, 이렇게, 만들어 줄 것이고 클래스가 추가가 되었으면 얘네 둘을 네트워크 쪽에다가 옮겨주고 이 부분에 대해서 일단 작업을 이어주도록 할게요. 이제 서비스 같은 경우에는 그래가지고 얘가 네트워크 서비스는 맞지만 얘가 클라이 역할을 하는 서비스도 있고 서버 역할을 하는 서비스도 있고 심지어 같은 서비스라고 하더라도 정책이 또 갈릴 수가 있습니다 예를 들면 한번 연결을 시도했는데 실패하면은 뭐 반복해가지고 5초마다 계속 연결을 시도하게끔 한다거나 아니면은 서버는 서버인데 연결이 끊겼다고 하면은 그냥 거기서 끝나는 게 아니라 재접속을 시도하게 한다거나 하는 식으로 다양한 정책을 이용해가지고 우리가 나중에 구현을 하게 될 겁니다. 지금은 간단하게 서버랑 클라이 역할을 하는 두 개만 , 일단은, 만들어주도록 할게요. , 자, 오늘 일단 사용할 여러가지 애들을 , 일단은, 여기다가 추가를 해줄 것이고 리스너 그리고 Functional까지도 , 이렇게, 추가해주도록 하겠습니다. 얘는 이제 Standard Function이라는 기능을 사용하기 위한 아이인데 조금 이따가 나올 겁니다. 그래서 , 일단은, 기본적으로 서비스 타입 같은 경우에는 그냥 두 개만 , 일단은, 놓을 건데 그냥 서버 역할과 클라이언트 역할 일단 두 개로만 구분을 해줄 것이고요. 그 다음에 제가 늘 하는 이 선 긋기도 , 일단은, 해주고 넘어가도록 할게요. 서비스. , 자, 그래가지고 , 일단은, 여기 위에다가 SessionFactory라고 해가지고 Session을 만들어주는 함수를 정의를 해 줄 건데 Session의 레퍼런스를 뱉어 줄 것이고 그 다음에 입력은 그냥 아무것도 안 받는 형태의 함수를 만들어 주도록 하겠습니다 이 함수의 형태를 우리가 정의를 해준 거죠 그 다음에 서비스 같은 경우에 지난번과 마찬가지로 enable share from this를 얘도 , 일단은, 사용해가지고 혹시라도 나중에 Shared Pointer로 얘를 넘겨줄 수 있게 만들어 줄 것이고 그 다음에 오늘 추가될 애들은 , 일단은, 굉장히 다양하게 있는데 서비스를 만들어 줄 때 얘가 필요한 정보가 몇 개가 있는데 , 일단은, 어떤 서비스 타입인지 얘가 클라이언트 역할을 할 것인지 아니면은 서버 역할을 할 것인지를 먼저 , 이렇게, 지정을 해 줄 것이고요 그 다음에 네트워크 어드레스를 받아 줄 것입니다. 이게 서버라고 하면은 자기 자신의 그 어드레스고 클라이언트 서비스라고 한다면은 상대방 쪽 내가 붙어야 될 대상이 되겠죠. 그 다음에 이어가지고 iocp 코어 레퍼런스를 받아 줄 것입니다. 경우에 따라서 iocp 코어를 하나만 만들어 준 다음에 옵젝트가 아니라 코어입니다. 코어를 하나만 만들어 준 다음에 공유해서 사용할 수도 있을 것이고 경우에 따라 가지고는 iocp 코어를 분리해 가지고 q를 여러 개를 사용할 수도 있을 것이고 이건 약간 뭐 취향대로 이기 때문에 , 일단은, 좀 광범위하게 만들어 줄 것이고 그 다음에 sessionFactory 라고 해 가지고 얘는 이제 세션을 만들어 주는 함수를 여기다가 전달해 주게 될 겁니다. 마지막으로 맥스 세션 카운트를 해가지고 최대 세션은 얼마인가 최대 동접수를 여기다가 , 이렇게, 입력을 받아줄 겁니다 1대1로 그냥 다른 서버들끼리 통신하려고 하는 거면 그냥 한 개만 있으면 되지만 그게 아니라 동접을 몇 천명씩 받는 서버라고 하면 이 숫자를 조정해주면 될 겁니다 , 자, 요렇게 해 줘 가지고 요 서비스라는 애를 만들어 줄 것이고 그 다음에 소멸자도 , 일단은, 버추얼로 요렇게 만들어 주도록 할게요 그 다음에 얘는 , 이렇게, 구현부를 먼저 만들어 주고 시작을 해 보도록 하겠습니다 , 자, 그 다음에 이제 좀 내려가지고 어... 먼저 얘가 들고 있어야 되는 이런저런... 그런 멤버 변수들부터 정의를 해보도록 할게요. 일단 뭐가 있어야 되냐면은 일단 락을 사용할 거니까 useRack을 요렇게 사용을 해줄 것이고 서비스 타입을 받아주기로 했으니까 요 타입을 받아줄 것이고 네트워크 어드레스도 받아주기로 했었죠. net address 상대방 것일 수도 있고 내 것일 수도 있고 이거는 뭐 서비스 타입마다 다르겠지만 그 다음에 iocp-core 내가 어떤 IoC 페다가 일감을 등록을 할 것인지를 뭐 , 이렇게, 만들어 줄 것이고 그 다음에 세션 들을 여기 얘가 그 지금까지 연결된 세션들을 얘가 들고 있도록 할 것이고 그 다음에 이런 저런 로그를 찍기 위해서 세션이 몇 개 있는지를 , 이렇게, 따로 관리를 해 주도록 하고 맥스 세션 카운트 최대 세션은 얼마인지 그 다음에 마지막으로 섹션 패터리 세션 패터리라고 해가지고 얘는 말그대로 이제 세션을 생성해주는 그 함수를 , 이렇게, 받아주도록 할게요 일종의 함수 포인트를 받아주는 거죠 , 자, 이렇게, 해가지고 좀 이쁘게 줄을 맞춰주고 시작을 해보도록 하겠습니다 , 자, 이렇게, 일단은, 만들어주고 소멸자도 뭐 딱히 안 만들어줄 이유는 없으니까 , 이렇게, 일단은, 정리를 해주도록 할게요 , 자, 그 다음에 어... 여기서 결국에는 서비스가 만들어진 다음에 다음줄에다가 이어가지고 타입도 받아주고 네트워크 어드레스도 받아주고 그 다음에 iocp 코어도 받아주고 session factory도 받아주고 , 이렇게, 모든 내용을 다 받아주도록 할게요. 마지막에 maxSessionCount도 maxSessionCount라고 , 이렇게, 받아주도록 하겠습니다. , 자, 이렇게, 좀 내용이 긴데 모든 내용을 다 멤버 변수로 저장한다 라고 볼 수가 있는 거죠. , 자, 그 다음에 이런 걸 이제 세부적으로 설정하거나 아니면 기타 등등의 함수들을 이제 또 만들어 줄 것인데 먼저 virtual boolean start 라고 해가지고 얘는 abstract 함수로 만들어 주도록 할게요 이제 얘를 상속받는 서비스를 상속받는 애들이 이 start를 무조건 구현해야 된다고 우리가 만들어 주고 있는 거고요 그 다음에 혹시 모르니까 can start라고 해가지고 시작할 수 있는지는 체크를 하도록 합시다. 뭐 지금은 , 일단은, 어... Session Factory가 반드시 있어야 된다는 조건만 요렇게 넣어주도록 할게요. , 자, 그 다음에 이어가지고 얘도 Virtual로 Close Service 만약에 이 서비스가 끝났다고 하면 얘도 이제 어떻게 만들어 줄지는 알아서 정해줘야 될 것이고 뭐 요런 저런 내용들을 다 만들어 주도록 하겠습니다. 그 다음에 Set Session Factory 이거는 뭐 생성전에서 넣어주긴 했지만 혹시라도 나중에 마음이 바뀌어가지고 다른 애로 넣어주고 싶다고 하면은 이건 알아서 넣어줄 수 있게끔 , 이렇게, 만들어 주도록 합시다 , 자, 얘를 이제 Session Factory도 넣어줄 수 있고 그 다음에 Session Ref에서 Create Session 얘는 말그대로 Session을 새로 만들어 준과 동시에 이 ISP 코에다가 등록하는 역할을 담당하게 될 거고 Add Session, 그냥 이미 만들어진 Session을 추가하는 그런 기능들도 만들어 줄 것이고 그 다음에 Release Session이라고 해가지고 얘는 거꾸로 Session이 더 이상 사용하지 않겠다고 할 때 걔를 꺼내주는 역할을 맡게 될 겁니다 그 다음에 뭐 이런저런 필요한 함수들을 다 만들어주면 되겠죠 getCurrentSessionCount 현재 세션은 몇 개입니까? 세션 카운트를 봐도 받아주도록 할게요 이건 락을 안 걸어주니까 뭐 정확한 수치는 아니지만 굳이 그렇게까지 정확할 필요는 없으니까 대략적으로 현재 동접은 얼마인지를 알아내도록 하고 최대 세션 카운트는 우리가 처음에 받은 이 맥스 세션 카운트로 알아주면 될 것이고 그 다음에 이어가지고 또 뭐가 있을까요? 서비스 타입 현재 서비스 타입은 무엇입니까? getServiceType returnType 그리고 네트워크 어드레스도 받아주고 getNetworkAddress returnNetAddress 그 다음에 마지막으로 IocpCoreReference도 받아줄건데 얘는 일단 참조값으로 넘겨주도록 할게요 이거는 굳이 외부에서 꺼내가지고 레퍼런스 카운트를 늘리기보다는 그냥 참조값으로 넘겨줘가지고 굉장히 자주 사용할 거니까 혹시라도 부하를 너무 많이 줄까봐 , 이렇게, 참조값으로 넘겨주도록 하겠습니다 , 이렇게, 해가지고 얘는 그냥 잠시만 사용을 할 예정이기 때문에 , 이렇게, 만들어주면 대략적으로 필요한 기능은 다 들어간 것 같네요 이제 앞으로 추가할 애들이 있으면 여기서 추가해주면 되겠죠 구현부를 만들어주도록 하겠습니다. session도 만들어주고 그 다음에 add session도 뭔가 만들어주고 release session도 만들어줄 것이고 그래서 오늘 당장은 클로즈 서비스는 여기서 투두로 놓고 여기서 Create Session을 호출하게 되면은 이제 무엇을 해줘야 되느냐 이걸 해주는 거죠 Session Factory를 호출해가지고 빵! 해가지고 이제 Session을 만들어 준 다음에 IOCP Core에다가 Register를 해가지고 이 Session을 등록을 할 겁니다 근데 얘가 만약에 실패했다고 하면은 뭔가 문제가 있는 거니까 Null Pointer를 뱉어줄 것이고 그 다음에 얘를 , 이렇게, 추가를, 아, 뱉어주면 되겠습니다. , 자, 여기서 에러나는 거는 위에서 우리가 헤더 중에서 세션이 없어가지고 그런 것 같네요. 세션도 추가해주고 그 다음에 리스너도 겸사겸사 같이 추가해주도록 할게요. , 자, 그러면 , 일단은, 뭐 요렇게 완료가 되었구요 아 리지스터에서 지금 우리가 얘를 아직 안 바꿔줘서 에러가 나는건데 이거는 이따가 좀 고치도록 하고 라이트 세션을 , 일단은, 애드 세션 같은 경우는 락을 잡아준 다음에 세션 카운트를 1 눌려주고 그 다음에 세션스에서 인서트를 빵 때려주도록 하겠습니다 이제 나중에 뭐... 세션의 id 값을 이용해가지고 관리를 한다거나 할 수도 있겠는데 그건 나중에 생각을 하고 , 일단은, 요 서비스 자체에서는 모든 애들을 그냥 요 포인터의 주소를 이용해가지고 그냥 관리를 해서 물고 있도록 하겠습니다 얘도 마찬가지로 write-lug을 해줄 것인데 어... assert-crash를 해줄 것이고 , 일단은, 그 다음에 sessions의 erase를 통해가지고 얘를 삭제했는데 뭔가 문제가 일어났으면 어... , 일단은, 삭제를 해주도록 하고 그 다음에 세션 카운트를 1 줄여주는 식으로 그냥 간단하게만 , 이렇게, 만들어주고 나중에 수정할 일이 있으면 수정을 해주도록 할게요 , 자, 근데 이제 서비스는 얘가 이제 기본 서비스인데 얘를 당장 기본적으로 막 사용할 순 없고 이제 얘를 상속을 받아가지고 버전을 두개를 더 만들어줄건데 클라이언트 서비스랑 다음에 서버 역할을 하는 서비스를 각각 따로 만들어 주도록 하겠습니다. 얘네들만 들고 있는 그런 추가적인 정보가 있을 테니까 , 이렇게, 구분해서 만들어 줄 것이고 클라이언트 서비스 같은 경우에는 뭐 아직 오늘 뭐 만들진 않을 건데 얘는 뭐 기본적으로 모양만 일단 만들어주도록 하겠습니다. net address는 똑같이 상대방의 주소를 받아줘야 되고 그 다음에 iocp core ref는 똑같이 받아줘야 되고 그 다음에 얘도 마찬가지로 section factory는 받아줘야 되겠죠. section factory는 factory로 받아주고 마지막으로 max session count도 기본값 1로 똑같이 , 이렇게, 받아주도록 하겠습니다. 요런 느낌으로 그 다음에 virtual client service 소멸자는 그대로 만들어주고 virtual pool start override 라고 해가지고 얘를 이제 정리를 해줘서 클라이언트 서비스를 막 스타트하면 상대방 쪽 주소로 연결하는 식으로 나중에 작업을 하게 될 것이고 그 다음에 이 내용을 , 일단은, 복붙해가지고 서버 서비스도 비슷한 느낌으로 , 이렇게, 만들어주게 될 겁니다 인자는 , 일단은, 똑같이 만들어줄 것이고요 근데 얘같은 경우는 이제 서버 역할을 하다보니까 리스너가 추가가 되겠죠? 얘가 문지기를 하나 도와주고 문지기가 accept하는 역할을 해주게 될거니까 그걸 내부적으로 관리해주게 될겁니다. 그 다음에 클로드 서비스도 , 일단은, 얘도 , 이렇게, 일단은, 관리를 해주도록 할게요. , 자, 요렇게 하면은 뭐 대충 필요한 내용은 다 만들어진 것 같구요 뭐 경우에 따라서 줄 맞추는 게 편하다 싶으면 , 이렇게, 줄을 맞춰 주셔도 되고 , 자, 그 다음에 이제 이어가지고 오른쪽에서 뭐 다는 안 만들 것이지만 요 클라이언트 서비스 그리고 start 부분을 정의를 해줄 것이고 서버 서비스도 마찬가지로 정의를 해주도록 합시다. start 그 다음에 close 서비스도 , 이렇게, 일단은, 하나씩 만들어 주도록 할게요. 그러면 이제 넘어와 가지고 client service 같은 경우에도 service service와 마찬가지로 여기 다음 줄에다가 서비스를 호출하는데 얘 같은 경우는 client 타입으로 호출하고 네트워크 어드레스는 그냥 받아주면 되니까 타겟 어드레스는 그대로 받아주고 코어도 그대로 넘겨주고 팩토리도 넘겨주고 맥스 세션 카운트도 그냥 그대로 , 이렇게, 넘겨주는 식으로만 하고 마치면 되겠습니다 얘는 나중에 투도로 넘겨주고 , 일단은, 투로로 바꿔주도록 할게요 서버 서비스도 마찬가지로 , 자, 요 부분을 , 일단은, 복붙 한 다음에 다음 줄에서 , 이렇게, 넣어주고 얘만 서버 타입으로 바꿔주면 , 일단은, 되겠죠 근데 얘는 타겟 아드레스는 아니고 자기 자신의 주소니까 이름만 살짝 바꿔주도록 합시다 그 다음에 어 소멸자도 있고 , 자, 스타트 스타트는 true 클로즈 서비스도 , 일단은, true로 바꿔주고 그 다음에 시작을 만약에 한다고 하면은 서버 서비스 같은 경우는 이제 can start를 먼저 체크해서 얘가 false면은 뭔가 아직 우리가 준비가 덜 된 거니까 리턴해주고 그게 아니라고 한다면 이제 여기서 리스너를 만들어 줄 겁니다 make shared를 이용해가지고 리스너를 만들어 준 다음에 근데 뭔가 문제가 있다 뭐 , 사실, make shared를 했으니까 그럴리 없겠지만 그냥 통일성을 위해서 false를 때려주고 , 자, 그 다음에 어... 이제 이어가지고 리스너의 Start Accept를 때려주도록 하겠습니다 근데 여기서는 지금 우리가 네트워크 어드레스를 받고 있지만 이제는 앞으로는 이 Start Accept를 할 때 우리가 이 서버 서비스를 넘겨주게 될 거예요 그래서 이 서버 서비스에 이런저런 정보들을 참고해가지고 이 리스너가 작동을 해야 되기 때문에 자기 자신의 포인터를 우리가 넘겨주도록 하겠습니다 즉 서버 서비스 레퍼런스로 , 일단은, 만들어줄건데 SharedFromThis를 하고 싶은데 SharedFromThis 자체는 우리가 여기서 보면은 지금 서비스를 반환해주고 있죠? 우리가 애당초 얘를 서비스에다가 걸어놨으니까 EnableSharedFromThis를 뭐 그러니까 얘같은 경우에는 StaticPointerCast를 통해 가지고 한번 캐스팅을 해줘야 됩니다 서버 서비스 형태로 캐스팅을 해주고 싶다 라고 요렇게 , 일단은, 바꿔준 다음에 얘를 스타트 억셉트를 할 때 넘겨주도록 할 거에요 만약에 얘가 실패했다라고 하면 역시나 return false를 때려줄 것이고 그게 아니라고 한다면은 성공적으로 리스너가 일할 준비가 끝난 거니까 여기서 끝내주면 되겠죠 그 다음에 뭐 나머지 부분은 딱히 뭐 건드릴 건 없을 것 같구요 아 이 부분은 역시나 서버 서비스에 클로저 서비스를 똑같이 호출을 해주도록 합시다. 여기 오버라이드가 빠진 것 같네요. 오버라이드를 해주고 얘는 보이드로 했으니까 똑같이 보이드로 맞춰주도록 합시다. 보이드로 그냥 , 이렇게, 되어 있었던 것 같네요. , 자, 그래서 여기서 나중에 뭐 추가할 일이 있으면 여기서 뭐 추가를 해주면 될 것이고 요렇게 , 일단은, 만들어주면 되겠습니다 그럼 이제 리스너 쪽으로 돌아가 가지고 요 부분을 이제 삭제하는 게 아니라 수정을 해주면 되겠죠 네트워크 어드레스를 받아주는 게 아니라 우리가 서버 서비스를 여기서 받아 줄 겁니다 즉 서버 서비스 레퍼런스를 받아 줘 가지고 서비스를 사용할 것인데 어 일단 전방선언을 해주도록 합시다 위에서 서버 서비스 헤더끼리 막 서로 헤더를 막 참조하고 이런 건 위험하니까 최대한 전방선언을 잘 활용해 줄 것이고 그 다음에 얘를 여기서 이제 들고 있도록 할게요 , 자, 이거는 지금 뭐 위크 포인트로 들어도 되고 셰어드 포인트로 들어도 되고 이건 선택의 여부이지만 셰어드 포인트로 들 거면은 서로 순환 구조가 일어날 수 있으니까 그 부분을 신경 써서 어떻게든 끊어줘야 된다는 문제가 생기게 됩니다 그래서 , 일단은, 셰어드 PTR로 만들듯 순환을 끊어주도록 할게요 그래서 이쪽에서 start accept 해서 일단 서버 서비스를 , 이렇게, 사용할 것이고 그 다음에 listen... 이 헤더 쪽에서 서비스 헤더를 일단 여기서 추가를 해주도록 합시다 그럼 이제 서비스를 받아줬으니까 요 아이를 이제 그대로 저장을 해줄 것이고 혹시라도 문제가 있다 서비스가 널이다 라고 하면은 우리가 항상 체크 체크를 해주고 있으니까 리턴 펄스로 바로 끝내주도록 하고 , 자, 그 다음에 요 부분이 이제 바뀌어야 되는데 우리가 기존에는 요 iocp 코어를 전역으로 활용을 했었는데 이 야매를 당장 없애 주도록 할게요 그래서 얘도 마찬가지로 임시로 사용하고 있던 IoCP 코어를 , 일단은, 삭제를 해주도록 하겠습니다. 그럼 삭제를 했으니까 당연히 이 부분에서 이제 빨간 줄이 뜨게 되겠지만 걱정이 없는 게 우리는 이제 아예 서비스에 접근해가지고 Get IoCP 코어를 이용해가지고 우리가 넘겨준 L을 이용해가지고 리지스터를 빵 때려주도록 하겠습니다. , 이렇게, 만들어주면 될 것이고 그 다음에 바인드로 할 때도 마찬가지로 이 네트워크 어드레스가 아니라 서비스에 getnetworkaddress를 통해 가지고 , 이렇게, 넘겨주면 될 것이고 나머지 부분은 딱히 문제가 없을 것 같고 여기 acceptcount 같은 경우도 이제는 서비스에 getmaxsessioncount로 교체를 해주도록 하겠습니다 그 다음에 또 이어가지고 쭉 내려가지고 요 부분 이 부분도 굉장히 중요했죠 여기서 Make Shared Session을 바로 하고 있는데 그게 아니라 서비스에 Create Session 함수를 호출해줘가지고 여기서 사실상 IOCP의 컨비션 포트에다가 등록하는 부분도 처리해줄 것이고 나중에 결국에는 요렇게 하면 장점이 이 서비스를 상속을 받아가지고 원하는 형식대로 만들어준 다음에 여기서 이제 이 팩토리만 마음대로 원하는 형태로 연결해주면 이제 클라이언트 쪽에서 아니 클라이언트가 아니라 나중에 사용할 컨텐츠 쪽에서 얘를 이제 지정해줄 수가 있겠죠 어떤 식으로 나는 세션을 만들어 줄 것인가 그래서 , 이렇게, 일단은, 만들어주면 된다고 보시면 되겠습니다. 이게 잘 안 가셔도, 이해가 안 가셔도 크게 상관이 없는 게 나중에 사용하는 걸 보면 조금 더 이해가 쉬울 거예요. 그래서 , 일단은, 1차적으로 , 이렇게, 일단은, 되었습니다. , 자, 근데 지금 상태로 빌드하면 뭐 아마도 에러가 날 것 같은데 아직 처리 안한게 몇가지가 있어 요런 부분 리지스터 리지스터 하는 부분도 우리가 어 , 자, iocp 코어 쪽에 돌아가서 살펴보면은 IOSP 옵젝트의 포인터를 받고 있는데 우리가 Shared Pointer를 사용하기로 했으면 통일해가지고 모든 애들을 다 Shared Pointer로 받아줘야 됩니다. 이걸 섞었으면 큰일 납니다. 그렇기 때문에 얘는 , 이렇게, 마찬가지로 Shared Pointer 방식으로 우리가 작업을 할 것이기 때문에 , 이렇게, 일단은, 바꿔주도록 하고 , 자, 그러면은 iocp object get handle 까지는 똑같고 , 사실, 뭐 여기서 수정할 내용은 없을 것 같네요 , 자, 여기서 , 이렇게, 일단은, 코드가 완료가 될 겁니다 그래서 한번 더 빌드를 해가지고 또 다른 문제가 있나 체크를 해보면 두 번째 문제는 이제 어디서 발견되냐 아 start accept 를 하고 있는데 리지스터를 하는데 디스 락 해가지고 생 포인터를 넘겨주고 있습니다 이것도 똑같은 문제죠 그래서 요런 경우 이제 두 번째로 얘가 발생을 했는데 어 그냥 우리가 멋대로 디스포인터를 넘겨주면 절대로 안되고 SharedFromDis를 이용해가지고 SmartPointer, 그러니까 SharedPointer로 변환해서 넘겨줘야 된다고 했었죠. 얘를 사용할 수 있는 이유는 리스너가 iocp 옵체트를 상속받고 있고 요 아이가 결국에는 EnableSharedFromDis를 상속받고 있기 때문에 요렇게 변환이 가능했던 겁니다. 그래서 여기까지 한번 또 고쳐보고 또 빌드를 해보도록 하겠습니다. 그 다음에 여기서 불평하는거는 모든 경로에서 제기적입니다 아 이게 서버 서비스가 아니라 서비스에 클로즈 서비스를 해야죠 네 이게 지금 무한 제기를 하고 있다라고 지금 불평을 한거구요 , 자, 이렇게, 해가지고 빌드를 해보도록 하겠습니다 그럼 이제 이거를 어떻게 사용해야 되느냐 다시 우리가 게임 서버로 돌아가가지고 이걸 사용하는 예제를 볼건데 , 일단은, 리스너를 직접적으로 우리가 얘를 사용하지는 않을겁니다 그래가지고 얘네들을 이제 날려줘도 되고 서비스.header 그리고 경우에 따라서 세션도 나중에 이제 재정의를 해주고 하면 이런 세션을 , 이렇게, 만들어주면 될 것이고 리스너를 직접적으로 만들어 주진 않을 거고 여기서 서버 서비스를 직접 만들어 주게 될 겁니다. make-shared 그래서 서버 서비스를 만들어 줄 것인데 여기다가 우리가 생성자에서 뭐 이런 저런 것들도 넘겨주면 되는데 어... 지금 우리가 지난 시간에 간단하게 만들어줬던 이 Make Shader에서는 생각해보니까 인자들을 넘겨주는 부분을 우리가 안 만들어놨네요 기본 생성자만 받을 수 있으니까 요 부분을 수정해주도록 할게요 똑같이 우리가 여기서 위에 사용했던 요 Veredic Template을 그냥 그대로 적용을 해주면 됩니다 그래서 여기다가 복붙해가지고 이 Timename... Argument를 넣어주고 그 다음에 요 Xnew에서처럼 요 부분을 복붙해준 다음에 그 다음에 여기 Forward 하는 부분도 긁어가지고 요 부분을 요렇게 넣어주면 , 일단은, 완성이에요 그러고 보니까 풀 매니저 쪽에서도 뭐 풀 쪽에서도 아마 비슷하게 얘가 있었던 것 같은데 어디 있었나요? Object 풀 쪽에서 요 부분도 만드는 김에 같이 채워주도록 할게요 , 자, Make Shared 쪽에서 얘도 마찬가지로 템플릿, 타임네임, 점점점, 아귀먼트 베레딕 템플릿 문법을 이용할 것이고 그 다음에 , 자, 이렇게, 해서 만들어 준 다음에 Forward까지 해서 , 자, 이렇게, 보편 참조를 전달하는 식으로 만들어 주도록 하겠습니다 그 다음에 다시 문제가 없는지 일단 코어 빌드하고 문제가 없고 서버도 빌드를 해 보도록 할게요 아 서버는 아직 안 만들어 놨네요 , 자, 그렇기 때문에 여기서 이제 Make Shared에서 인자를 넣어주면 되는데 , 일단은, 네트워크 어드레스를 다시 꺼내 가지고 여기다가 넣어 주도록 할 것이고 그 다음에 두번째 인자로 IoCP 코어를 받고 있는데 그냥 여기서 Make Shared IoCP 코어로 만들어 주도록 할게요. IoCP 코어 그리고 마지막으로 이제 세션을 어떻게 만들어줘야 되는지를 얘가 묻고 있는데 그냥 지금은 Make Shared Session이라는 요 아이를 그대로 사용하도록 넘겨주도록 하겠습니다. , 자, 얘는 그냥 어 요 가로가 포함이 되면 안되고 그냥 요 함수를 호출해가지고 이제 어 세션을 만들어달라라고 하고 있지만 나중에 가면은 예를 들면은 이런 식으로 우리가 게임 세션이라는 거를 이 세션을 상속을 받아가지고 요렇게 만들어주면은 이제는 Make Shared Game Session 식으로 다른 애를 우리가 넣어줄 수가 있을 겁니다 네 이래가지고 우리가 여기서 이제 추가적으로 바꾼 상속을 받아가지고 추가한 그 기능을 이제 같이 만들어주기 끔 우리가 유도를 해줄 수가 있을 거예요 , 자, 그 다음에 마지막으로 동접은 , 일단은, 100개를 만들어 달라 100개를 예약해달라 라고 , 이렇게, 만들어주면 되겠습니다 뭐 이런 경우 나중에 가면은 뭐 세션 매니저 등등 다른 애들을 이용해가지고 세션을 만들어주는 식으로 만들어줘도 되겠죠 그 다음에 요 내용을 , 일단은, 여기까지 삭제를 하고 서비스가 만들어 줬으면 얘는 이제 서비스 스타트를 빵 때려주면 됩니다 근데 지금 뭐 문제가 없는지 보기 위해서 어서트 크래쉬를 해가지고 얘가 잘 실행이 되는지를 체크를 해주도록 합시다 그래서 사실상 요렇게 두 코드를 이용해가지고 내부적으로 막 연동해주고 리스너를 만들어주고 하는 부분이 이제 다 정상적으로 동작한다고 볼 수 있는 거죠 마찬가지로 어떤 쪽에 붙을 때도 클라이언트 서비스를 만들어가지고 걔를 스타트 빵 때리면은 걔가 알아서 돌아가게끔 이제 만들어주게 될 겁니다 그래서 사실상 뭐 똑같은 기능인데 이리저리 흩어져 있던 거를 우리가 서버 서비스라는 클래스를 이용해가지고 다 뭉뚱 그려가지고 관리하고 있다라고 결론을 내릴 수가 있는 거죠 요 아이에서 , 자, 런치를 할 때는 얘같은 경우에는 서비스에다가 get-iocp-core를 접근해가지고 디스패치를 요렇게 때려주면 될 것이고 , 자, 문제가 없는지 양쪽 빌드를 해보도록 하겠습니다 , 일단은, 성공을 했고요 , 자, 그 다음에 뭐 별다른 문제가 없으면 기존과 마찬가지로 그냥 접속까지는 정상적으로 돼야 되는데 , 자, 일단은, 여기서 어세트 크래쉬가 났네요 한번 살펴보도록 합시다 , 이렇게, 어셉트로 하면 참 디버깅하기 쉬운게 여기서 실패했다는 얘기니까 들어가서 살펴보면 되겠죠 캔스타트 성공 리스너 성공 스타트 억셉트를 하고 있는데 여기서 이제 타고 들어가서 보면은 성공, 성공. 어디서 실패하는지를 살펴보면 되겠죠? Bind, Listen. 어, 다 성공했는데? 아, 마지막 값이 false로 되어 있어서 그런 거네요. 이거 자동 생성해가지고 그런 거니까 얘만 true로 바꿔치기를 해주고 다시 빌드를 해주도록 하겠습니다. 빌드, 빌드. 그러면은 모든 애들이 다 성공이 되었으니까 다시 한 번 실행을 해서 보면은 넘어가면 통과 그 다음에 이제 아 지금 브레이크 포인트를 잡는 바람에 클라가 못 들어왔는데 좀 여유를 둬서 보면은 정상적으로 클라이언트 커넥티드가 날 뜨는 거 볼 수가 있습니다 , 자, 그래가지고 결국에는 지난 시간에 이어가지고 완전히 뭐 진행을 안 했고 그냥 지난 시간에 했던 거를 그냥 고지 곧대로 어 관리를 편하게 할 수 있도록 서비스라는 개념을 도입했다고 볼 수가 있겠어요 여기까지 전형적인 구조가 어느 정도 만들어지게 되는 거고 이제 이어서 결국에는 가장 관건이 되는 애는 이 세션입니다 그러니까 지금 이 흐름을 보면 리스너라는 애에서 우리가 , 이렇게, register accept 해서 session을 만들어 주고 있죠 그리고 참고로 session을 여기서 지금 register 할 때 만들어도 되지만 그게 아니라 여기서 그냥 소켓만 만들어 주고 process accept를 하는 이 순간에 session을 만드는 식으로 구현을 해도 당연히 상관이 없습니다 이건 여러 가지 방법이 있는데 , 일단은, 기본적으로 이 방식으로 , 일단은, 그냥 진행을 하도록 할 것이고 session을 먼저 만들고 걔를 넘기는 방식입니다 그 다음에 두 번째로 이제 여기서 크리에이트 세션을 하는 순간 사실상 우리가 얘도 이제 관찰 대상이라고 IOCP한테 내부적으로 우리가 등록을 해놨습니다. 요 부분 이제 굉장히 중요하죠. 이 코드. 그러다 보니까 이제 나중에 요 세션을 대상으로 우리가 연결이 된 다음에 뭐 리시브를 예약을 하거나 아니면 샌드를 하거나 하는 식으로 리시브 샌드를 호출하는 순간에 걔도 이제 똑같이 IOCP를 이용해가지고 이제 관찰 대상이 되기 때문에 여기서 디스패치를 하는 순간에 이제는 이 IOCP의 디스패치가 Session의 디스패치 이 부분으로 , 일단은, 들어오게 될 겁니다 그래서 여기서도 결국에는 Receive와 Send와 관련된 부분을 처리를 해주는 식으로 우리가 작업을 하게 될 거예요 즉 이 템프 템프로 되어있는 부분이 이제 고쳐줘야 된다고 , 일단은, 볼 수가 있는 거죠 , 이렇게, 해가지고 조금씩 구조를 확장해 나가면서 만들고 있는 게 있는데 이게 뭐 조금 헷갈리실 수도 있지만 어느정도 잘 적응을 하시길 바라고 , 일단은, 이번 시간을 마치도록 하겠습니다.