이렇게, 우리가 지난 시간에 기본으로 사용할 Base Allocator에 대해서 알아봤구요 그 다음에 일단 지난번에 했던 내용을 조금 정리를 하고 이어서 오늘 알아볼 내용은 두 번째 방식을 채택하는 Stomp Allocator에 대해서 알아보도록 할 겁니다 여기 , 이렇게, 적어드리자면 스톰프라고 , 이렇게, 써요 스톰프 얼러케이터 그리고 참고로 제가 굉장히 좋아하는 주제이기도 하고 그리고 나중에 우리가 학습할 얼리얼 엔진에서도 요 스톰프 얼러케이터가 다 마련이 되어 있습니다 그 정도로 이제 광범위하게 사용이 되는 그런 정책이라고 보시면 되겠어요 , 자, 근데 요 아이 같은 경우에는 뭔가를 이제 효율적으로 돌리고 이런 거랑 딱히 상관이 없고 그냥 유일하게 얘가 하는 기능은 버그를 찾는데 굉장히 유용합니다 특히 이제 메모리 오염 버그가 11플에서 가장 우리를 괴롭히는 골칫덩어리 중에 하나인데 제가 예전에 썰을 하나 말씀을 드리자면 제가 처음에 서버 프로그램으로 근무를 했을 때 이런 메모리 관련 이슈들이 하나씩 두 개씩 발생을 했어요 근데 음... 이 메모리 오염 문제가 왜 끔찍하냐면은 메모리가 오염이 되어가지고 잘못 건드리는 순간에 크래시가 나면은 굉장히 감사한 상황이고 그냥 그 부분을 고치면 되는데 이게 그냥 엉뚱한 메모리를 고친게 당장은 터지지 않다가 아주 한참 후에 거의 1-2주 후에 나비효과가 일어나 가지고 이상한 곳에서 엉뚱한 곳에서 크래셔 나는 경우가 굉장히 많습니다 그럴 경우에는 진짜로 그 버그가 왜 일어난지 찾기가 굉장히 어렵다는 얘기가 되는 거죠 최근에 우리가 어떤 코드를 작업했는지를 일일이 체크를 해봐도 아무런 문제가 없는 코드들 밖에 없었는데 아니 왜 이게 지금 발생할까 싶은 굉장히 원망스러운 상황이 되는 거죠 그리고 제가 실제로 일했던 프로젝트에서도 그런 문제가 발생한 이유가 거의 6년 전에 아주 이름도 모르는 다른 누군가가 작업한 코드가 , 사실, 메모리 오염을 유발하고 있었던 코드였고 그게 한참 후에 아직까지는 정말 운 좋게 누군가가 건드리지 않아가지고 다 스쳐갔던 것들이 이제 다른 작업자가 작업하다 보니까 그 지뢰를 밟아가지고 그게 터지는 그런 상황이었습니다 그리고 이제 메모리 오염이 일어나게 되면 이제 코드가 그때부터는 더 이상 예측 범위에서 벗어난다는 거죠 그게 만약에 진짜로 골드와 같이 굉장히 중요한 코드가 실행되고 있었는데 그 메모리도 오염이 될 수 있다는 얘기가 되는 거니까 정말 무서운 상황이 되는 겁니다 , 자, 근데 이게 약간 시플뿌리 처음을 하신다고 생각하시면 뭐 딱히 상관이 없게 느껴지실 수도 있어요 메모리 그냥 조심하면 되지 않을까 싶은데 이게 생각보다 종종 일어날 수 밖에 없는 이유는 이게 여러가지 패턴에 의해가지고 요 버그가 발생을 합니다 , 자, 그럼 스톰프 언럭에 대해서 알아보기 전에 , 일단은, 요 메모리 오염에 대한 뭐 개론에 대해서 살짝 알아보고자 하는데 , 일단은, 가장 뻔한 케이스는 뭐냐면은 메모리를 해제한 다음에 그 다음에 이제 메모리를 사용을 하는 뭐 그런 상황이라고 볼 수가 있겠어요. 예를 들면 지금 우리가 이 나이트에서 HP, MP라는 걸 , 이렇게, 사용하고 있었죠. 그래서 뭐 예를 들면은 HP를 뭐 멋대로 200으로 세팅할 수도 있었고 MP도 우리가 원하는 값으로 세팅할 수 있었습니다. 근데 그 다음에 누군가가 이 메모리를 딜리트 해가지고 날렸다고 가정을 해봅시다. 그러면 원칙상으로는 이 나이트라는 메모리가 더 이상 유효하지 않으니까 여기다가 삭제된 상태에서 HP를 건드린다고 하면은 , 자, 이제 어떤 상황이 발생할지가 궁금합니다 뭐 지금까지 알던 내용을 잘 생각해보면 유효하지 않은 메모리고 , 이렇게, 접근하는 건 금지되어 있다고 했으니까 여기서 바로 크래시가 나지 않을까 라고 생각할 수가 있습니다 근데 실질적으로 여기서 브레이크 포인트를 잡은 다음에 한번 실행을 해 보도록 할게요 그러면은 굉장히 놀랍게도 이 부분을 끌게요. 여기서 딜리트까지 해서 메모리가 날아가 가지고 그 해당 값들이 쓰레기 값으로 지금 들어가 있는 걸 볼 수가 있어요. 이거를 까보고 싶으면은 여기서 디버그 창 메모리에 간 다음에 여기서 지금 우리가 사용하고 있는 K1을 살펴보면은 약간 메모리가 DDDD라는 그냥 쓰레기값으로 컴팔러 그냥 알아서 밀어준 겁니다. 디버그 무드에서만 , 이렇게, DDDD로 해줄 거예요. 근데 그럼에도 불구하고 이 상황에서 K1을 접근해가지고 사용을 하면은 그 메모리를 그냥 , 이렇게, 자연스럽게 지금 사용을 할 수가 있습니다 그러니까 애당초 얘는 사용하면 안 되는 메모리임에도 불구하고 , 이렇게, 사용할 수 있었다는 얘기가 되는 거죠 물론 경우에 따라서 이게 뭐 디버그 모드라거나 하면은 요런 이상한 쓰레기 값을 일부러 넣어준 다음에 그 값이 변조되었는지를 체크해가지고 걸러줄 수도 있긴 할텐데 이게 항상 릴리즈 모드에서는 요런 안전코드가 들어간다는 보장이 없어요 그래서 지금 벌써부터 딱 엉뚱한 메모리를 건드리고 있다는 얘기가 되는 거죠 근데 만약에 진짜로 사용하면 안 되는 메모리를 그냥 , 이렇게, 건드려서 뭐 여기서 그냥 잠시 오동작한 거라고 하면 문제가 없는데 만약에 절묘하게 우리가 여기서 딜리트를 해가지고 이 메모리가 날라간 다음에 다른 누군가가 그 똑같은 메모리 이 공간을 사용해가지고 새 집을 짓기 시작을 했다면은 이제 더 문제가 커지는 겁니다 이미 유효하게 잘 살아있는 데이터를 우리가 엉뚱하게 지금 , 이렇게, 고치고 있기 때문이죠 그래서 이게 가장 첫번째 상황이고 이게 보안에서는 이걸 댕글링 포인터 혹은 유즈 애프터 프리라는 문제라고 하는데 당연히 얘기했지만 딜리트를 한 다음에 얘를 사용했던 게 이 사람의 문제니까 이거는 뭐 솔직히 예방하기 쉽지 않을까 라고 생각할 수도 있습니다 항상 삭제를 할 때 안전하게 롤 포인터로 밀어주는 습관을 들이면 이런 거는 이제 해결할 수 있지 않을까라고 생각할 수도 있는데 이게 그렇게 단순하지 않은 상황들이 꽤 존재합니다 예를 들면은 이 K1 이라는 포인터를 그냥 , 이렇게, 단일 함수해서 사용하는 게 아니라 이제 이 포인터 자체를 뭐 벡터라거나 맵이라거나 다른 컨테이너에다가 저장을 하는 상태로 뭐 작업을 한다거나 아니면은 이 포인터 자체를 다른 애한테 넘겨줘 가지고 걔가 또 멤버 변수로 들고 있다거나 하는 상황이 발생할 수도 있으니까 그런 경우라고 하면은 내가 아무리 여기를 널 포인터로 밀어 맞자 이미 이 포인터를 들고 있던 다른 애는 오염된 포인터 이미 더 이상 사용하면 안 되는 포인터를 들고 있게 된다는 얘기가 되는 거죠 그래서 우리가 지금까지 스마트 포인터에 대한 내용을 알아봤으니까 물론 , 이렇게, 삭제를 한 다음에 사용하는 문제는 , 사실, 스마트 포인터로 어느 정도 해결을 할 수 있기는 해요 그래서 이 문제는 일단 그렇다고 치고 넘어가도록 할게요 근데 이 상황 말고도 굉장히 그럴싸하게 일어날 수 있는 케이스가 여러 개가 있는데 두 번째로 제가 하나 보여드리고 싶은 건 뭐냐면 이제 벡터를 사용할 때 뭐 예를 들면 , 이렇게, 벡터에다가 12345라는 값을 넣었다고 가정해봅시다 이것도 제가 실제로 MMO 프로젝트에서 일할 때 발생한 문제였는데 이번에는 1바이트 오염이었어요 진짜 왠지 모르겠는데 정확하게 딱 1바이트만 오염이 되어가지고 그게 2주마다 한 번씩 크래시가 터졌습니다 평균적으로 그래서 그 1바이트가 정말 절묘하게 어떤 원래 포인터를 가리키고 있는 그 메모리 주소값을 참조하고 있던 그 영역을 딱 건드려 가지고 걔가 이상한 값이 되는 바람에 이제 온갖 코드가 꼬이기 시작을 했었는데 결국에는 그 버그를 제가 있을 때는 못 잡았는데 한참 후에 잡았다고 소식을 들었는데 대략적으로 요런 느낌 때문에 발생했어요 여기서 예를 들면 우리가 밸류를 추출해 가지고 여기서 막 뭔가를 코드를 사용했습니다 근데 이 루프가 그냥 한두줄짜리가 아니라 코드가 좀 복잡해져가지고 이게 막 몇백줄짜리였으니까 엄청 커졌다는 얘기가 되는거죠 근데 여기서 누군가가 실수로 어떤 값을 체크하다가 이게 유효한 값이 아니네라고 하면은 이제 이거를 그냥 , 이렇게, 클리어를 때려버린겁니다 클리어를 때렸으면 이제는 더 이상 이 벡터에 접근하면 안되니까 무조건 루프에서 빠져나가야 됐어야 되는데 여기다가 그냥 그걸 하지 않고 그냥 까먹고 그냥 , 이렇게, 냅둔거에요 그러다보니까 여기서 벡터가 날라갔는데 이미 이 벡터는 더이상 유효하지 않은 벡터인데 루프를 계속 돌면서 엉뚱한 값을 사용하고 그 다음에 엉뚱한 값을 , 사실, 리드만 하는 경우라면 상관없는데 이 값을 또 덮어 쓰는 뭐 그런 행동을 했겠죠 그러니까 이제 그런 버그가 발생했을텐데 요런 상황도 이제 충분히 발생할 수 있는 메모리 오염이라는 얘기가 되는거죠 물론 이거는 지금 실행해보면은 아마도 컴파일러가 실행하는 단계에서 아마도 버그가 크래쉬가 나가지고 잡히기는 할 확률이 높습니다. , 이렇게, 일단은, 잡혔죠. 근데 경우에 따라서 이게 뭐 항상 잡힌다는 보정이 없습니다. 그래서 이런 메모리 오염이 굉장히 위험한 거죠. 그리고 마지막으로 자주 등장하는 그런 버그는 캐스팅 문제 때문에 발생하는 메모리 오염입니다. 캐스팅이라면 예를 들어보면 , 이렇게, 클래스 플레이어라고 해가지고 간단하게 예를 들어볼게요 어 최상위 클래스가 일단 플레어로 요렇게 있다고 가정을 하고 그 다음에 나이트가 요 플레어를 성숙 받아가지고 만든 상태에서 말 그대로 , 사실, 요 나이트를 만들어 줘야 되는데 어 , 일단은, 뭐 플레어를 만들었다고 가정해봅시다 뭐 이런식으로 플레어를 만들었는데 얘를 이제 이 함수 저 함수에 옮기다가 우리가 그런 경우 생기겠죠 어떤 어 컨텐츠 자체가 특정 클래스 대상으로만 뭔가 있어야 된다 어떤 스킬인데 뭐 얘만 있는 그런 스턴기라거나 뭐 하는 경우가 있을 테니까 그럴 때는 얘를 다시 나이트로 변환해 가지고 사용해 보고 싶을 경우가 생길 수도 있겠죠 그러다 보니까 이런 식으로 얘를 캐스팅해 가지고 다시 나이트로 변환을 해줬는데 알고 보니까 이 객체 자체는 플레이어로 처음부터 만들었기 때문에 이런 식으로 캐스팅을 해주면 아예 안 됐었던 문제가 되는 거죠 굳이 캐스팅을 하고 싶으면 안전하게 다이내믹 캐스트를 해가지고 얘가 엉뚱한 대로 캐스팅을 하면 아예 널 포인트로 밀어주게끔 유도를 했어야 되는데 다이내믹 캐스트는 또 성능이 느리기 때문에 일반적으로 그렇게 다이내믹 캐스트를 남발하진 않습니다 그래서 확실할 경우에 , 이렇게, 스태틱 캐스트를 하는 것도 충분히 옳은 행동인데 여기서 문제는 이게 애당초 플레이어였지 이 객체 자체가 나이트가 아니었더니 문제가 되는 거죠 그럼 이 상태에서 역시 똑같이 K에 접근해가지고 여기서 막 HP를 건드리는거는 해당초 오염된 메모리를 엉뚱한 메모리를 지금 건드리고 있는 겁니다 애당초 사용하면 안되는 영역이죠 이건 어떻게 보면 일단 오버프로라고 볼 수도 있는 문제라고 볼 수가 있어요 내가 사용해야 되는 영역보다 더 초과해가지고 건드리고 있다라는 의미가 되는 거니까 이 상태에서도 똑같이 실행하면은 뭐 버그가 터질 수도 있고 안 터질 수도 있는데 지금 이 경우에는 안 터졌죠 이게 안 터지는 게 더 끔찍한 상황이라고 제가 말씀을 드리는 이유가 바로 이런 상황입니다 엉뚱하게 넘어가지고 , 사실, 다른 객체를 내가 건드릴 수도 있다는 얘기가 되는 거죠 그래서 뭐 이런 다양한 이유에 가지고 크래시가 이제 발생하면 다행이지만 크래시가 심지어 발생도 안하고 자연스럽게 넘어가면서 막 이리저리 나비효과를 일으켜는 요런 상황에 대해서 우리가 이제 대비를 할 필요가 있다는 얘기가 되는 거죠 , 자, 그래가지고 서류가 조금 길었는데 이제 오늘 그래가지고 알아볼 요 얼로케이터 자체는 순전히 요런 메모리 오염과 관련된 문제를 잡기 위해서 우리가 넣어줄 기능이라고 , 일단은, 보시면 되겠어요 그렇게 해서 스톰프 얼로케이터에 대해서 알아볼 건데 이걸 또 공부하기 위해서는 그냥 기본적으로 운영체제의 메모리 관리에 대한 그런 기초 지식이 필요해요 근데 뭐 지금 다루고 있는 게 운영체제 시간은 아니니까 너무 깊게 들어가진 않을 것이고 그냥 간략하게 가상 메모리에 대한 기본기에 대해서만 익혀 보도록 하겠습니다 이게 참고로 프로그래밍을 공부하는 학생들 중에서 대학교를 가지 않는 그러니까 일반적인 학원 출신들 프로그래머 분들이 요런 부분에 굉장히 취약한데 제가 느끼기에는 클라이언트 같은 경우는 어차피 얼리얼 엔진이라거나 유니티 엔진에서 이런 메모리 관리까지 잘 해주기 때문에 이런 부분은 크게 신경 쓸 필요 없었고 그러다 보니까 요런 부분에 조금 그냥 가볍게 넘어갈 수도 있겠지만 서버 쪽은 , 이렇게, 메모리를 잘못 건드리면은 진짜 전체 프로젝트에 악영향을 주기 때문에 이게 더 중요한 것 같습니다 그래가지고 이제 보통 서버 프로그램을 뽑을 때 조금 더 보수적으로 뽑고 학원보다는 이제 보통 이제 4년제 대학교 출신들을 더 선호하는 이유가 요런 기본기 때문에 그런 거라고 생각을 합니다 , 자, 그래가지고 일단 첫 번째로 알아볼 건 뭐냐면은 우리가 어떤 가치를 , 이렇게, 뭐 동적할당을 한다고 가정을 해봅시다 그리고 뭐 여기서 딜리트를 해주면 되겠죠 그건 그렇고 여기다가 우리가 어떤 값을 사용할 수 있었어요 근데 여기서 궁금하니까 , 일단은, 여기서 address라고 해가지고 이거를 그냥 강제로 이 숫자 자체를 int64로 , 이렇게, 변환을 시켜보도록 하겠습니다 그래가지고 지금 , 사실, 알아보고 싶은 거는 어... 요... 그니까 이거 , 이렇게, 이 주소 자체가 무엇인지를 우리가 일단 추출해보고 싶은 거에요. 그래가지고 여기다가 , 일단은, 로그를 찍어보도록 하겠습니다. 요런 느낌으로 , 자, 그 다음에 여기서 브레이크포인트를 잡은 다음에 실행을 한번 해보도록 할게요. , 자, 그러면 여기서 address가 뭐 이걸 16진수로 , 이렇게, 보면은 지금 요 주수라는 걸 볼 수가 있습니다 굉장히 묘한데 237DE뭐시기뭐시기로 되어있는 요 주소고 이거를 16진수가 아니라 그냥 일반 10진수로 보면은 요런 숫자라는 걸 볼 수 있고 log에도 , 이렇게, 똑같이 이 숫자가 찍히겠죠 , 자, 그러면 만약에 여러분들이 여기까지 멈춰 놓은 상태에서 이제 다른 프로젝트를 새로 만들어 가지고 정확하게 아까 본 그 주소 요 주소 23 모시기 944로 끝나는 요 주소로 어 포인터를 설정해가지고 데이터를 건드린다고 가정을 해볼게요 그러니까 중간에 뭐 예를 들면 , 이렇게, 하는 거죠 어떤 포인터를 우리가 일부러 만들어 준 다음에 아까 본 그 주소를 그대로 뭐... 이런 주소가 있다고 가정을 하고 그 다음에 그 주소에다가 우리가 딴 값을 , 이렇게, 입력을 한다고 또 가정을 해봅시다. 그리고 이게 인트64죠. 인트... 어... 포인터. , 자, 그러면은 얘까지 실행이 된 다음에 이 어드레스를 보고 이 어드레스를 그대로 다시 다른 프로그램에서 얘를 그 해당 주소를 넣어가지고 정확하게 , 이렇게, 건드린다고 하면은 그러면은 이제 여러분들의 이 값은 100이라는 값이 들어갈까요 아니면 200이라는 값이 들어갈까요가 퀴즈입니다 근데 이제 운영체제에 대한 개념이 없는 분들이라고 하면은 이 메모리를 우리가 딴 데서 건드리고 있으니까 다른 프로그램에서 건드렸으니까 이게 200으로 바뀌지 않을까라고 생각을 할 수가 있어요 근데 , 사실, 전혀 그렇지가 않고 애당초 독립적인 프로그램끼리는 서로 간섭을 기본적으로 할 수가 없습니다 근데 그러면은 어 요 어드레스랑 얘가 지금 고치는 어드레스랑 만약에 일치해가지고 똑같은 주소를 지금 접근해서 고치고 있는데 왜 서로 영향을 줄 수 없느냐라고 생각할 수도 있겠지만 사실은 여기서 함정은 뭐냐면은 우리가 사용하고 있는 요런 주소 자체가 진짜 주소가 아닙니다 그래서 이게 우리가 가상 메모리 라고 하는 이유가 그냥 가상 주소이기 때문이에요 그럼 여기서 가상이라고 하는 것은 진짜 주소가 따로 있다는 얘기가 되겠죠 그래서 실질적으로 나중에 운영체제를 공부하면은 뭐 가상 메모리에 대해서 공부를 하게 되겠지만 실질적으로 이게 물리 메모리라고 해가지고 여러분들의 램이라는 그 기기 자체에 있는 주소는 다른 주소인데 실질적으로 운영체제가 , 이렇게, 가짜 주소를 만들어 줘가지고 이거를 바꿔치기 해가지고 얘가 관리를 하고 있습니다 그러니까 우리가 지금 아까 봤던 그 주소는 그냥 이 가상 주소였던 거고 실질적으로는 그게 , 이렇게, 맵핑이 되어가지고 다른 주소로 변환이 되어서 내부적으로 잘 활용이 되고 있을 거예요 왜 , 이렇게, 귀찮은 짓을 하느냐 결국은 아까와 마찬가지로 우리가 여러 가지 프로그램들을 동시에 켤 수 있겠죠 예를 들면 우리가 유저 레벨에서 메모장도 키고 롤도 키고 우리가 공부하고 있는 서버도 띄우고 , 이렇게, 여러 가지 프로그램을 동시에 띄울 수가 있을 거예요 근데 사실은 얘네들을 관리하고 있는 게 이 아래 있는 커널 레벨에서 다 관리를 하고 있는 거고 이게 실제로 운영체제의 소스 코드가 실행이 되고 있는 그 영역이라고 보시면 되겠습니다 즉 마이크로소프트에서 만든 핵심 코드들이 여기서 실행되고 있는 거죠 근데 만약에 내가 메모장을 켰더니만 롤이 갑자기 크래쉬 난다거나 아니면은 내가 롤을 켰더니만 우리 서버가 갑자기 뭐 이상하게 동작한다고 하는 건 이제 굉장히 위험한 짓거리가 될 겁니다 그렇게 만약에 프로그램을 만들어가지고 서로 메모리를 막 침범할 수 있게 만들어 주면은 이제 완전히 해커들이 신나는 상황이 오는 거죠? 메모장을 하나를 실행을 하자마자 막 탈취해가지고 은행 프로그램이 실행되게 하고 막 엉뚱한 짓을 할 수 있을 테니까 결국에는 운영체제가 선택한 방법은 유저레벨 끼리는 서로 간섭을 할 수 없게 만들어 준 거예요 그래서 이 메모장은 이 세상에 자기 혼자만 존재한다고 생각을 하고 각각 프로그램도 다 마찬가지입니다 나는 그냥 유아 독존 나 혼자만 존재한다고 생각해서 실질적으로 메모리를 사용할 때도 이 가상 메모리 즉 전체 메모리를 다 사용할 수 있다고 그냥 착각을 하게 만들어요 그래서 설령 동일한 메모리가 두 번 등장한다고 해도 실질적으로 내부적으로는 프로세스마다 걔가 사용하는 어떤 특정 메모리는 어디에 맵핑되어 있고 하는 , 이렇게, 화살표로 다 맵핑되어 있는 것처럼 이미 다 다른 주소를 관리를 해주고 있기 때문에 이게 아무리 프로그램에서 두 개의 프로그램에서 동일한 메모리가 겹친다고 해도 뭐 실제로 그런 일은 거의 없긴 하겠지만 겹친다고 하더라도 동일한 영역을 건드리지 않는다는 얘기가 되는 거죠 네 그래가지고 뭐 이런 가상 메모리라는 게 있다라는 게 , 일단은, 오늘 뭐 첫 번째 주제였고 , 자, 근데 뭐 , 사실, 우리가 당장 지금 운영체제를 공부하는 건 아니니까 이런 부분은 뭐 그렇다 치고 그 다음에 이제 , 사실, 우리가 관심을 갖고 있는 거는 이 운영체제를 그러니까 이 메모리를 관리할 때 사용하고 있는 여러가지 기법들에 대해서 관심이 있는데 예를 들면 만약에 우리가 2GB 메모리를 , 이렇게, 사용한다고 가정해봅시다 근데 이 기가바이트 메모리를 사용할 때 추가적으로 옵션을 둘 수가 있어요 여기서 옵션이라는 거는 약간 보안 정책이라고 보시면 되겠습니다 어떤 부분은 접근해가지고 사용할 수 있고 어떤 부분은 접근은 할 수 있지만 거기다가 라이트는 할 수 없고 어떤 부분은 뭐 그냥 아무렇게 접근할 수도 있고 이런 식으로 레벨을 다 정해줘 가지고 관리할 수 있다는 얘기가 되는 거죠 근데 만약에 2GB를 우리가 사용하고 있는데 그 2GB를 우리가 1바이트 단위로 세세하게 설정할 수 있다고 하면 얘를 설정하기 위해서 어디는 접근할 수 있고 어디는 접근할 수 없고 하는 거를 관리를 하기 위해서도 최소한 2GB가 필요하겠죠 그래야지만 이 부분은 접근할 수 있고 여긴 안 되고 여긴 되고 이런 식으로 관리할 수 있으니까 , 이렇게, 똑같은 메모리가 필요할 텐데 당연한 얘기지만 2GB를 관리하기 위해서 추가적으로 2GB 이상의 메모리를 할 때는 당연히 말이 안 되는 소리입니다 그래가지고 실질적으로 운영체제가 메모리를 할당하고 관리할 때는 페이지 단위로 관리를 한다고 보시면 되겠어요. 예를 들면 1KB, 4KB, 1KB 이런 기존적인 페이지에 해당하는 크기 단위가 있는데 그걸 이제 기반으로 관리를 해주게 됩니다. 보통 4KB일 거예요. 그래서 이거를 , 이렇게, 생각하시면 돼요 여러분들 길 가다가 아파트 분양 같은 거 하는 업체에 가보면 전시를 할 때 , 이렇게, 작은 모형을 만들어 가지고 보여주죠 실제로 여기서 전시된 공간에 해당하는 실제 땅은 어딘가에 따로 있을 테고 실제 건물도 다 , 이렇게, 올라가 있을 테지만 그거를 당장 똑같이 지어서 보여줄 수는 없으니까 여기다 , 이렇게, 작게 보여주고 있는 겁니다 마찬가지로 , 이렇게, 작게 작게 어 관리를 해줘 가지고 요 아파트는 이제 더 이상 접근을 할 수 없다고 , 이렇게, 빨간색으로 빵 칠하면은 훨씬 더 관리를 하기 쉬울 거에요 그래가지고 여기서도 결국에는 여기서 여기까지 4kb 라는 어마어마하게 큰 영역을 이제 그냥 하나의 페이지라는 걸로 , 이렇게, 표현을 하고 시작합니다 여기서 여기까지는 요 아이로 설정해가지고 만약에 여기서 리드만 할 수 있다 이 영역은 읽을 수만 있다고 하면 여기서 아까 여기까지는 이제 접근을 할 때 읽을 수만 있다는 얘기가 되고 여기서 뭔가를 값을 쓰려고 하면 바로 크래시가 날 겁니다 이래가지고 , 이렇게, 큰 덩어리 단위로 관리를 한다 이게 , 사실, 페이징의 기본이라고 볼 수가 있는 건데 물론 페이징을 사용하는 이유가 꼭 , 이렇게, 보안 때문에만은 아니고 여러 가지 이유가 있습니다 근데 그건 이제 운영체제를 공부할 때 언젠가 공부를 하시게 될 테니까 스킵을 하고 지금 당장은 우리한테 관심이 있는 분야는 바로 이거예요 , 이렇게, 페이지 단위로 우리가 메모리를 할당해가지고 여기다가 보안 레벨을 설정할 수 있다 그래서 리드만 할 것이냐 라이트만 할 것이냐 둘 다 허용할 것이냐 아니면 아예 접근제처 못하게 막을 것이냐 하는 등등의 옵션을 우리가 켜질 수가 있다는 게 되는 겁니다 , 자, 그리고 이제 여기까지 , 일단은, 알았으면 그 다음에는 뭘 해볼 거냐면 잠시에는 필요 없으니까 날려보도록 하고요 여러분들이 사용하는 환경 따라서 살짝 달라질 수가 있는데 기본적으로 윈도우 환경에서는 이게 4kb로 페이지 사이즈가 고정이 되어 있을 겁니다 그래서 이걸 체크하고 싶으면 getSystemInfo라고 해서 , 이렇게, 일단은, 체크를 해볼 수가 있어요 여기서 info.dwPageSize라는 걸 추출해보면 얘가 이제 운영체제가 사용하는 이 페이지 단위라는 걸 알 수가 있을 건데 기본적으로 4KB로 되어 있을 겁니다 일단 띄워가지고 체크를 해볼 것이고 그 다음에 여기서도 중요한 정보가 여기서 allocation granulty라는 게 있는데 우리가 메모리를 할당할 때 나중에 메모리를 할당할 때 얘가 항상 요 숫자의 배수로 , 일단은, 그 메모리 주소를 반환해주게 된다는 것도 알 수가 있어요 그래서 얘는 보통 64KB로 되어 있을 겁니다 잠시 브레이크폰들 잡아가지고 실행을 해보면 , 자, 여기 , 이렇게, 그래프는 잡혔고요 인포라는 게 딱 세팅이 되었고 여기서 여러가지 숫자들 중에서 아까 우리가 살펴본 페이지 사이즈가 4096 즉 4KB로 , 일단은, 되어있다는 걸 알 수가 있습니다 그리고 역시나 그래뉼리티 이거는 64KB로 6536이라는 값으로 , 이렇게, 잡혀있는 걸 볼 수가 있어요 그래서 , 일단은, 페이지 단위는 일단 4KB로 잡힐 것이다 라는 걸 우리가 지금 체크를 한 거죠 , 자, 그리고 이제 이어가지고 그러면은 무엇을 할 수 있느냐 지금까지 우리가 new랑 malloc같이 , 이렇게, 할당하는 그런 기본 기법을 이용해가지고 메모리를 할당하고 있었죠 malloc이라거나 아니면 new라거나 이런거 근데 그런것들이 엄밀히 말하면은 C++표준에 동작하는 그런 기능들이죠 요런거 자체가 , 이렇게, 우리가 만드는게 자체가 C++표준에 있는 문법입니다 하지만 이건 어디까지는 C++ 표준에 있는 거지 이게 운영체제에서 new를 사용해가지고 뭔가를 만들어 준다는 얘기는 아니에요 무슨 말이냐면 이게 리눅스 운영체제냐 아니면 윈도우스 운영체제에 따라가지고 new가 잘 동작하게끔 내부적으로 뭔가를 잘 만들어 주긴 했겠지만 실질적으로 우리가 운영체제한테 바로 직방으로 야 메모리 좀 줘라고 요청하는 함수는 따로 있다고 생각을 하시면 됩니다 그래서 이거는 이제 내부적으로 힙 관리를 할 때 어떻게 할지는 내부적으로 정해가지고 만들어 줬겠지만 실질적으로 우리가 가장 직방으로 할 수 있는 여러가지 함수들이 있는데 Virtual Unlock이라고 해가지고 여기서 이제 메모리를 할당해줘라고 할 때 이 Virtual Unlock을 사용하면 되고 메모리를 날리고 싶을 때는 Virtual Free라는 함수를 이용해가지고 얘를 , 일단은, 사용을 하면 됩니다 그래서 보통 이런 걸 볼 때는 이제 한 번씩 문서를 MSDN에 가서 이 VirtualAlloc이라는 게 뭘 하는지를 , 이렇게, 살펴보면 되는데 , 일단은, 이렇게, 네 가지 인자를 받고 있는데 그중에서 첫 번째 인자 같은 경우에는 , 일단은, null로 넣어도 됩니다 그냥 알아서 여기서 그 영역을 알아서 네가 잡아줘라 어디서 특정 메모리에다가 잡아주라는 힌트를 주는 게 아니라 그냥 알아서 해달라고 할 때는 그냥 null로 , 이렇게, 하면 된다라는 얘기가 있고요 그 다음에 여기서 두번째로가 이제 우리가 할당할 메모리의 크기를 여기다 넣어줄 것이고 그 다음에 3번에다가 메모리 타입이라고 해가지고 우리가 어떤 식으로 지금 요청을 줄 것인지 그냥 예약만 해줘가지고 나중에 우리가 그 예약된 메모리를 사용할 것이다 라고 그냥 식당을 예약하듯 그냥 예약만 하는 것인지 아니면 예약과 동시에 실질적으로 그 그 메모리를 할당해서 돌려 달라고 하는 것인지 등등 여러가지 옵션이 있다는 것도 알 수가 있어요 만약에 당장 우리가 사용할 거라고 한다면 여기다가 MEM_COMMIT or MEM_RESERVE , 이렇게, 1 플러스 1으로 같이 , 이렇게, 입력을 해주면 된다는 게 나와 있습니다 그리고 마지막으로 쭉 내려 보다 보면은 마지막 인자로는 여기서 뭐 여러가지 정책들을 우리가 여기다가 설정을 해줄 수가 있습니다 말 그대로 그 영역을 우리가 리드만 할 것인지 접근을 하면 안 될 수 있는지 아니면 일반적으로 리드 라이트를 다 허용할 것인지 등등을 , 이렇게, 입력을 할 수 있다고 보시면 되겠어요 , 자, 이번에도 여기 메모리 풀을 다룰 때도 또 등장할 텐데 대략적으로 이런 느낌으로 사용한다는 걸 일단 알아봤으니까 이거를 뭐 간략하게 테스트를 하면은 , 자, 첫인자는 , 일단은, 알아서 메모리 니가 원하는 영역에 일단 할당해줘라고 너를 입력하면 되고 그 다음에 예를 들면 뭐 4바이트를 할당해줘라고 하면은 4라고 입력을 하면 되고 그 다음에 맴 아까 리설프랑 여기다가 mem commit을 하면 실질적으로 우리가 new를 했던 것처럼 그 메모리를 예약과 할당을 동시에 해가지고 진짜로 우리가 그 메모리를 사용할 수 있게 만들어준다고 했었죠. 그 다음에 마지막으로 여기다가 여러가지 옵션 중에서 read, write를 다 사용하겠다라고 , 이렇게, 여러가지 정책을 우리가 정밀하게 넣어줄 수가 있습니다. new, delete나 뭘로 같이 그냥 단순하게 메모리만 할당해주고 반환하는 그런게 아니라 우리가 정말 세부적으로 그 메모리를 어떻게 사용할 것인지까지 여기다가 넣어줄 수 있다는 얘기가 되는거죠. 그래서 예를 들면 얘는 4바이트 짜리니까 뭐 이런 느낌으로 , 일단은, 반환해가지고 얘를 이제 활용해 줄 수가 있을 겁니다 요런 느낌으로 테스트는 뭐 100 그 다음에 버추얼 프리를 할 때는 어 역시나 요 테스트란에를 똑같이 요렇게 넣어준 다음에 , 자, 요기도 이제 여러가지 옵션이 있는데 , 일단은, 지금은 어 그냥 맵 릴리스 해가지고 이 메모리를 날려줄 때는 그냥 무조건 두번째 사이즈를 이제 0으로 넣어줬고 요렇게 만들어주면 , 일단은, 돼요 이건 나중에 이제 문서를 또 따로 찾아보면 되는데 기본적으로 요렇게 , 일단은, 사용한다고 볼 수가 있겠습니다 그래서 얘를 똑같이 실행을 해보면 이 부분을 , 일단은, 다시 날려주도록 할게요 필요 없으니까 쭉 날려주고 여기서 실행을 해보면 브레이크 분자 잡혔고 버추얼 얼럭이라고 해서 메모리 영역이 잡힌 겁니다 여기다가 사용을 한 다음에 프리를 해줘서 메모리 영역을 빵 날려준 거예요 그러면 왜 굳이 뉴 딜리트로 할 수 있는 거를 , 이렇게, 하느냐 이제는 뭐가 달라지면 되냐면 우리가 실질적으로 버추얼 프리를까지 빵 해서 날려줬다는 얘기는 이제 이 영역이 더 이상 사용할 수 없다는 영역이 되는 겁니다. 그렇기 때문에 실질적으로 여기다가 테스트에다가 우리가 뒤늦게 여기다가 200이라는 값을 넣어주려고 하면 이미 해당 메모리가 완전히 날라간 상태이죠. 우리가 운영처지한테 직접적으로 요청까지 해가지고 날려준 상태이기 때문에 실질적으로 이 상태에서 다시 한번 실행을 해보면 빵 하고 크래시가 난다는 걸 알 수가 있어요 이게 이제 아까랑 다른 거죠 그래서 여기서 우리가 거꾸로 알 수 있는 건 뭐냐면은 우리가 아까 그냥 기본적으로 이 버전이 아니라 그냥 new int를 해가지고 메모리를 할당한 다음에 여기다가 딜리트 테스트를 해가지고 메모리를 삭제했을 때는 내부적으로 얘가 어떻게 메모리를 관리하고 있긴 하겠지만 우리가 딜리트를 한다고 해가지고 그 실제 메모리를 운영체제한테 쪼르르 달려가가지고 그 메모리를 날려달라고까지 하지 않는다는 건 우리가 역으로 추적, 유추할 수 있다는 얘기가 되는 거죠 그래서 실질적으로 , 이렇게, 테스트를 해보면 아까는 아무런 문제 없이 얘가 잘 될 수도 있고 안 될 수도 있거든요 케이스로 다릅니다 , 자, 요 경우에는 지금 얘가 알아서 잡아줬는데 이걸 만약에 그러면은 좀 다른 케이스로 아까처럼 뭐 나이트라고 , 일단은, 가정을 한 다음에 나이트의 뭐 HP를 200으로 , 자, 요렇게 , 일단은, 세팅하는 코드를 만약에 만든다고 가정해봅시다 그러면은 에고 여기서 에러 나겠죠? 여기 테스트는 100이 아니라 테스트의 HP는 100, 그 다음에 테스트의 HP는 200으로 , 이렇게, 바꿔주는 상황에서 얘를 똑같이 다시 실행을 해보면 여기까지 날려준 다음에 이제 이 주소는 더 이상 유해하지 않음에도 불구하고 얘를 정상적으로 잘 , 이렇게, 활용을 했다는 걸 볼 수가 있습니다. 즉, 이건 이제부터 예측의 범위를 벗어난다는 거죠. 그래서 우리가 이제 확실히 알 수 있는 거는 뭐냐면 결국에는 , 이렇게, 뉴 딜리트를 하는 것 자체는 딜리트를 한다고 해가지고 무조건 그 메모리를 날리지 않고 얘도 결국에는 이 힘 영역을 자기가 유동적으로 어느 정도 관리를 한다는 걸 이제 알 수가 있는 겁니다 우리가 나중에 메모리 풀을 만들어서 어느 정도 메모리를 재활용해가지고 효율성을 높였듯 얘도 비슷하게 바로 쪼로 달려가서 날리지 않는다가 일단 핵심이 된다고 보시면 되겠습니다 , 자, 그래서 뭐 서론이 굉장히 길었는데 결론적으로 우리가 기본적인 힙 할당기 같은 이런 뉴 딜리트 같은 거나 뭐 멀록 프리를 이용하지 않고 , 이렇게, 직접적으로 윈도우 API를 이용해 가지고 우리가 직접 메모리를 사용하고 해제하는 부분을 , 이렇게, 관리를 하게 되면은 물론 당연히 이제 개발 환경에서만 사용할 것이고 환경과 실행 속도는 당연히 떨어질 수밖에 없지만 무조건 이런 메모리 침범 이슈가 발생하면은 100% 확률로 , 일단은, 잡아줄 수 있다는 굉장히 큰 장점이 생긴다는 거죠 , 자, 그래가지고 오늘 두번째로 추가할 옵션이 스톰프 얼로케이터라는게 요런 이슈랑 관련이 있다라는걸 설명하기 위해서 굉장히 장황하게 , 일단은, 설명을 드린거구요 , 자, 그래가지고 , 일단은, 다시 얼로케이터 쪽 코드로 가가지고 오늘의 두번째 주인공을 만들어 주도록 할게요 , 자, 일단은, class 스톰프 얼로케이터 그 다음에 , 사실, 요 코드는 똑같으니까 복붙하도록 할게요 요렇게 만들어 줄 것이고 그 다음에 얘는 이제 , 사실, 할당을 할 때 이 페이지 사이즈 단위로 배수로 할당을 해주게 될 겁니다 아까 우리가 살펴보면은 요 부분에서 실질적으로 우리가 버추얼 얼럭을 해가지고 4바이트만 요청을 해도 알아서 잘 실행이 되긴 했지만 실질적으로 내부적으로 보면은 어차피 4바이트만 한다고 해서 4바이트만 할당을 해주는 게 아니라 메모리를 무조건 페이지 단위로 관리해주기 때문에 페이지 사이즈의 배수에 해당하는 메모리를 얘가 이제 뱉어줄 겁니다 그래가지고 결국에는 얘를 뭐 사로 입력하나 아니면은 페이지 배수로 입력하나 똑같기 때문에 우린 최대한 실질적으로 할당해줄 그 메모리를 예상해가지고 , 일단은, 잡아줄 것이고요 그래서 이 페이지 사이즈를 일단 기억을 해 둔 다음에 , 자, 그 다음에 이 스톰프 알로케이터의 구현부를 만들어 보도록 할게요 , 자, 여기 cpp로 넘어가가지고 스톰프 얼로케이터 요 부분 귀찮으니까 일단 잠시 복구를 한 다음에 스톰프 얼로케이터로 팝코치기를 , 이렇게, 해주도록 하고 얘는 일단 , 이렇게, 그냥 하는 해주는 건 아닐테고 어 이제 얘가 해줘야 되는거는 일단 연산을 해줘 가지고 요 사이즈 내가 어떤 사이즈를 할당해달라고 했을 때 그거에 제일 가까운 이 페이지 사이즈를 이제 반올림 해가지고 뱉어줄 겁니다 예를 들면 내가 뭐 4바이트를 할당하겠다 라고 했으면은 실질적으로 이 4096의 배수 가장 가까운 애가 4096이니까 4096을 이제 할당을 해주게 될 거예요 요런 코드를 이제 만들 때 뭐 굉장히 단순한 방법이 있는데 이건 이제 보통 알고리즘 문제를 풀 때 자주 등장하는 패턴이죠 여기다가 페이지 카운트를 몇개의 페이지를 계산하면 될지를 체크를 할것인데 페이지 사이즈에다가 1을 빼주고 이 결과물에다가 다시 페이지 사이즈로 나눠주도록 할겁니다. 여기에다가 페이지 사이즈 마이너스 1을 더해준 이유는 뭐냐면 아까 마찬가지로 만약에 얘가 4였다고 하면은 4바이트에다가 4095를 더해줄 테니까 4099가 되겠죠 그러면 얘를 다시 페이지 사이즈로 나누면은 정확히 딱 한 개의 페이지 카운트가 딱 떨어지게 될 겁니다 근데 여기서 마이너스 1까지 해준 이유는 정확하게 우리가 이미 4096이라고 해가지고 이미 이 페이지 사이즈에 배수로 이미 딱 이 사이즈가 운 좋게 되어 있었다고 하면은 여기다가 설령 4095를 곱하더라고 해도 얘가 페이지 2개가 되진 않겠죠? 페이지 1.999가 될 수는 있어도 2개로 딱 떨어지진 않을 테니까 정수에 , 이렇게, 디비전을, 그러니까 나누기를 하게 되면은 애덩초 여기 있는 이 점이 날라가기 때문에 정확하게 이게 1개로 딱 떨어지게 될 겁니다 그래서 요런 페이지 사이즈 마이너스에다가 페이지 사이즈로 , 이렇게, 하는 반돌림 코드가 굉장히 이런 식으로 많이 나온다고 보시면 되겠어요 , 자, 그 다음에 여기다가 아까 마찬가지로 virtual unlock을 , 이렇게, 해주면 되는데 넣어를 해주고 우리가 계산한 페이지 카운트에다가 페이지 사이즈를 곱해준 다음에 여기다가는 mem reserve reserve랑 아까 얘기한 commit을 동시에 해가지고 실질적으로 그 메모리를 예약한 동시에 실제로 사용하겠다라고 지금 아예 사용을 해주고 있는 거고 패지 리드 라이트로 , 이렇게, 만들어주면 되겠습니다. 이거를 나중에 다른 옵션을 테스트 해보시면 만약에 우리가 리드만, 리드 온리로 했다고 하면은 진짜로 그 메모리는 읽기만 할 수 있고 거기다가 뭔가를 쓰려고 하면 바로 이제 크래시가 납니다. 이제 얘가 진짜로 이 보안 정책을 우리가 다양하게 설정할 수 있다는 걸 알 수가 있는 거죠. 그래서 뭐 기본적으로 , 이렇게, 리턴을 해주면 되고요. 그 다음에 프리를 할 때는 뭐 아까랑 마찬가지로 버추얼 프리를 이용해가지고 여기다가 ptr 0 mem release 를 , 일단은, release 요렇게 , 일단은, 넣어주면 가장 기본적인 형태는 완료가 된다는 거죠 그래서 이제 만약에 다시 어디 있었나요 여기 매크로 쪽에 돌아가 가지고 우리가 기본으로 사용하고 있는 이 메모리의 디버그 모드에서는 스톰프 얼로케이터를 기본 상태로 , 이렇게, 넣어주도록 합시다. 근데 물론 이 스톰프 얼로케이터라는 게 단점은 당연히 있겠죠. 우리가 아주 작은 사이즈, 예를 들면 8바이트만 할당을 할 거라고 해도 실질적으로 4096의 배수인 엄청나게 큰 영역이 할당이 된다는 거는 이제 좀 단점이긴 한데 그럼에도 불구하고 이게 개발 단계에서 , 이렇게, 굉장히 끔찍한 메모리 오염 버그를 잡아줄 수 있다는 큰 장점이 있기 때문에 그걸 어느 정도 감수를 하고 이런 걸 하는 겁니다. , 자, 그래가지고 , 이렇게, 스톰포 얼로케이터 버전으로 지금 , 이렇게, 동작을 하게 되면은 이제 다시 돌아와가지고 테스트를 뭐 몇개를 해볼수가 있는데 다시 게임소로 돌아와가지고 어 우리가 사용하고 있는 요 버전 자체가 우리가 자체적으로 만든 Allocator를 사용하게 될 테니까 이제 요걸로 테스트를 해보면 되겠죠 만약에 어... 여기다가 딜리트를 한 다음에 여기다가 똑같이 Knight에 뭐 HIP에 접근해가지고 여기다가 엉뚱한 값을 , 이렇게, 입력을 한다고 가정해봅시다 그러면 지금은 얘가 Stomp Allocator 방식으로 동작하고 있기 때문에 이 메모리가 딜리트할 때는 진짜 진짜 우리가 운영체제한테 요청해가지고 날린 상태이기 때문에 요 코드를 이제 실행을 해보면 , 자, 일단 서버코어를 빌드하고 그 다음에 다시 실행을 해보면 , 자, 여기서 여기 잡혔고 날린 다음에 접근하려고 한 순간 이제 바로 크래쉬가 난다는 걸 알 수가 있습니다 이거를 하기 스톰폼 얼로케이터를 우리가 하기 이전 버전 즉 이거를 다시 베이스 얼로케이터로 해가지고 똑같은 실험을 해보면 멀록 프릴 자체가 , 이렇게, 매번 마다 , 이렇게, 땡깡을 부려가지고 한 번에 프릴까지 하지 않는다는 걸 확실히 알 수 있는 이유가 여기서 똑같이 이 실험을 해보면 이제는 정상적으로 실행이 된다는 걸 볼 수가 있는 거죠 그래가지고 스톰프 알로케이터가 위대한 이유가 , 이렇게, 다른 애들은 잡아주지 못하는 문제를 , 일단은, 잡아줄 수 있다라는 엄청나게 큰 장점이 있다고 , 일단은, 볼 수가 있는 겁니다 , 자, 이렇게, 우리가 만들어 준 스톰프 알로케이터를 이용해가지고 , 일단은, 메모리에서 날라간 객체가 재사용이 되어 가지고 , 이렇게, 사용이 되는 use-after-free 문제는 , 일단은, 잡을 수 있게 되었는데 그럼에도 살짝 아쉬운 점은 뭐냐면은 얘가 메모리 오버플로우 문제는 지금 잡아주지 못하고 있습니다 왜냐면은 애정추 우리가 나이트 객체를 만들어 달라고 했을 때 얘가 지금 예를 들면은 뭐 한 8바이트에서 뭐 어느 정도 사이즈가 된다고 가정을 하더라도 그거보다 훨씬 더 큰 이 페이지 단위로 얘가 잡아주기 때문에 실제로 할당되는 영역은 훨씬 넓겠죠 사실상은 요만큼만 필요했음에도 불구하고 우리가 만들어준 이 버추얼 얼럭 특성상 이거보다 훨씬 더 큰 이 메모리까지 잡아주기 때문에 여기서 초과해가지고 이 메모리를 지금 건드린다고 해도 뭐 딱히 그게 우리 컨텐츠 단위에선 당연히 이상한 얘기가 되겠지만 하드웨어 적으로 봤을 때는 우리가 할당한 메모리를 사용하는 거니까 얘가 이상한 점을 눈치를 못 채게 됩니다 그래가지고 결국에는 여기서 만약에 아까 처음에 얘기한 케이스로 이거를 뭐 , 이렇게, 플레이어로 만든다고 가정해봅시다 플레이어는 생성자가 기본 생성자밖에 없으니까 요렇게 만들어주고 얘를 , 일단은, 이렇게, 나이트로 그냥 귀찮으니까 빨리 캐스팅을 해줄게요 , 자, 요 상황에서 우리가 나이트를 , 이렇게, 접근해가지고 HP를 만약에 세팅한다고 해도 아까 얘기한 대로 이거보다 더 초과된 영역을 우리가 건드리는 걸 딱히 막아준 적은 없으니까 얘는 이제 아무런 문제 없이 실행이 될 겁니다 , 이렇게, 잘 진행되고 있죠? 이게 , 사실, 잘못된 상황인데도 불구하고 그래가지고 이제는 거꾸로 오버플로우 문제는 그럼 이제 어떻게 잡아줄 것이냐를 생각을 하면 되는데 어... 요 스텀프 얼로케이터를 조금 고치면 이 부분을 처리해줄 수가 있는데 그게 뭐냐면은 우리가 아무리 , 이렇게, 큰 영역을 잡아줬다고 해도 이 객체가 할당되는 메모리를 이 제로에서 시작하는 첫 공간에다가 배치를 하는 게 아니라 일부러 여기 끝에 딱 걸리도록 , 이렇게, 일단은, 유도를 해주면 되겠죠 그러니까 거꾸로 이 아래 있는 부분을 비워두고 여기다가 일단 할당을 해주게 되는 겁니다 물론 , 이렇게, 되면 약간 조선 모사 아니냐 이건 약간 거꾸로 언더플로우 문제는 못 잡아주긴 하겠지만 대부분 우리가 발생하는 이런 버그들이 오버플로우 문제가 일어나지 언더플로우는 , 사실, 거의 뭐 딱히 일어날 케이스가 많이 없습니다 거의 없다고 보시면 되겠어요 이걸 인위적으로 마이너스로 우리가 접근해가지고 사용하는 그런 케이스는 없다 보니까 , 사실, 오버플로우를 잡아주는 게 훨씬 더 합리적이라고 볼 수 있겠습니다. 오버플로우는 뭐 포문에서 조건을 잘못 체크한다거나 아니면은 뭐 이런 식으로 캐스팅을 잘못했다거나 해도 충분히 발생할 수 있는 케이스가 되겠죠. , 자, 그러면 이제 이 스톰프 얼로케이터를 조금 수정해가지고 여기다가 객체 자체를 여기 맨 마지막 위치에다가 우리가 낑겨넣기 한번 수정을 해보도록 하겠습니다. 근데 뭐 딱히 내용이 많이 달라지진 않구요 페이지 카운트까지는 영역까지는 똑같은데 이제는 실질적으로 데이터가 배치해야 되는 그 오프셋 자표를 여기서 여기까지 얼마를 띄워야 되는지를 계산을 해보도록 합시다 그러면은 여기서 똑같이 페이지 카운트에서 사이즈만큼을 일단 빼주면 되겠죠 얘가 할당된 영역이고 얘가 실제로 사용할 공간이니까 걔만큼을 빼면은 여기서 여기까지 일단 앞으로 이동해서 정확히 요 위치에 일단 시작을 해줄 수가 있게 될 겁니다 그러면 버추얼 언록을 할 때는 전체 메모리를 할당할 테니까 뭐 이거는 딱히 달라질 필요가 없을 것 같고 얘가 이제 기본 베이스 어드레스라고 한번 해봅시다 , 자, 그 다음에 리턴 할 때는 우리가 그 전체 영역을 사용하는 건 아닐 테니까 여기다가 이 데이터 옵셋만큼을 더해 줘 가지고 그 해당 부분을 우리가 뱉어 주면 되겠죠 그래서 여기다가 , 일단은, 기본적인 인트 파일 포인터로 바꿔줘가지고 계산을 바이트 단위로 할 수 있게 , 자, 이렇게, 일단 더해준 다음에 여기다가 데이터 옵셋을 뭐 요런 식으로 , 일단은, 더해줄 수가 있을 겁니다 네 그래가지고 얘를 다시 반환을 해주면 베이스 어드레스에서 우리가 예상한 이 int64를 더해줄 수가 있겠죠. 근데 이걸 , 이렇게, 캐스팅하는 이유는 이걸 해주지 않으면은 지금 얘가 다른 타입이다 보니까 포인터 계산은 이 크기에 따라가지고 일단 영향을 준다고 했었죠. 그러니까 이걸 확실하게 1바이트 단위로 우리가 바꿔주면은 얘가 더해진 이 뒤에 있는 숫자만큼이 실질적으로 이 베이스 어드레스에 더해주게 될 거니까 , 이렇게, 캐스팅을 해준 겁니다 뭐 혹시라도 여쭤보실까봐 , 자, 그래가지고 , 이렇게, 일단은, 바꿔주면은 아까 얘기한 대로 이 뒷부분에 정확히 여기에다가 위치할 수 있게끔 우리가 유도를 해줄 수가 있겠습니다 그러면 거꾸로 릴리스를 할 때는 여기서 받아준 포인터가 지금 이 포인터를 의미하는 거겠죠 이 주소를 그럼 얘가 다시 , 이렇게, 쪼로로 내려가가지고 이 첫 시작부터 다시 시작을 해야 되는데 이 부분부터 이제 virtual free를 똑같이 맞춰주면 되는데 이건 어디까지나 우리가 페이지 단위가 4kb 단위였다고 했었죠 그리고 얘가 정확하게 우리가 아까 알아본 대로 그 granularity라는 걸 이용해 가지고 어떤 숫자의 배수로 딱 떨어지게 될 겁니다 그리고 그 숫자가 아까 알아본 바에 의하면은 0x1000에 해당하는데 결국에는 거꾸로 말하면은 얘가 4096 단위로도 어느 정도 이제 배치가 되어 있다고 우리가 감안을 할 수 있기 때문에 결국에는 이 숫자를 , 이렇게, 일단은, 계산을 해주면 됩니다. address를 계산을 해줄 것인데 , 일단은, 다시 reinterpret cast를 통해 인트64로 , 일단은, 이 포인터 주소를 바꿔준 다음에 그 다음에 base address를 다시 계산해줄 것인데 address에다가 우리가 강제로 미뤄줬던 이 페이지 사이즈만큼 어드레스 페이지 선을 나눈 이 찌꺼기, 찌그레기 요만큼을 다시 빼줘가지고 앞으로 , 이렇게, 이동을 시켜주면 되겠죠. 그러면 정확하게 이 페이지 사이즈에 지금 정렬된 상태로 이 베이스 어드레스가 나올 테니까 여기로 일단 , 이렇게, 돌아갈 수가 있다는 걸 알 수가 있습니다. 실제로 테스트를 해서 체크를 해보셔도 되고요. 그러면 결국에는 여기에다가 다시 이런 식으로 바꿔치기를 해주면 이제는 아까와는 다르게 똑같이 메모리 영역은 크게 잡는 건 변함이 없지만 오버플로우를 일부러 잡아주기 위해서 실제로 우리가 사용하는 실 공간을 앞으로 당겨가지고 지금 이 포인터를 이 시작 주소로 뱉어주고 있기 때문에 이런 식으로 오버플로우가 만약에 일어났다고 하면은 초과된 메모리를 접근해가지고 요 뒷부분을 사용할테니까 거기는 더이상 유효한 메모리가 아니다보니까 이제 크래쉬를 내주게 될겁니다. 그래서 요렇게 , 일단은, 한번 바꿔보도록 할게요. 그러니까 스톰포 얼로케이터는 결국에는 여러가지 버전이 있다는거죠. 언더플로우를 위주로 잡아줄거냐 오버플로우를 잡아줄것이냐 아니면 그냥 유저 헥터프리만 잡아줄거냐 등등 여러가지 정책이 있는데 지금 요 상황에서 다시 한번 실행을 해보면 이제는 짜잔 하면 이 나이트에서 초과된 메모리를 건드려고 하는 순간에 바로 크래쉬가 나는걸 일단 , 이렇게, 확인을 할 수가 있습니다. , 자, 이렇게, 해가지고 제가 개인적으로 굉장히 처음에 이 개론을 봤을 때 정말 감동을 했어요 굉장히 단순한 아이디어인데 왜 이걸 내가 생각을 못했을까? 지난 시간들이 막 떠오르는 거죠 그 이상한 메모리 오염을 잡기 위해서 코드를 한 줄 한 줄 체크하고 막 이랬던 시절이 있었는데 그런 부분들을 굉장히 우아하게 지금 우아하다긴 좀 뭐하지만 좀 무식하게 어쨌든 잡아주는 그런 스톰 벌로케이터의 개념에 대해서 , 일단은, 알아봤습니다 그래서 나중에 얼리얼 엔진에서도 이 스톰프 얼로케이터를 똑같이 구현을 해가지고 지원을 하니까 혹시라도 막 메모리 오염구 관련된 이슈가 있다라고 하면은 이런 스톰프 얼로케이터 사용을 적극적으로 고려를 해볼만 하다고 볼 수가 있겠습니다. , 이렇게, 해가지고 좀 길었는데 제가 개인적으로 굉장히 좀 신기하다고 생각했던 이 스톰프 얼로케이터에 대한 내용을 일단 마치도록 할게요.