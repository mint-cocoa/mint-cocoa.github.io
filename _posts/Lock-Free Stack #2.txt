자, 이제 , 이렇게, 해가지고 간단하게 우리가 lock-free-stack에 대한 기초에 대해서 알아봤는데 아직 문제가 해결이 되지 않은 상태죠 그래서 이번 시간에는 이어서 문제를 해결을 해 보도록 할 건데 일단 그 전에 너무 주석이 많아 가지고 주석부터 조금 정리를 하고 넘어가도록 할게요 , 이렇게, 좀 필요 없는 주석들을 , 일단은, 잠시 삭제를 해 보도록 하겠습니다 그래서 오늘 해야 되는 것은 , 이렇게, 지금 올드 헤드라는 이 부분을 삭제를 하는 것을 사실상 구현을 해야 되는 그런 상황이 되었는데요. 지난번에도 말씀을 드린 적이 있지만 이 락프리 같은 경우에는 꾸준히 연구되고 있는 학문이어서 요즘에도 계속 새로운 기법들이 막 이리저리 발표가 됩니다. 네 그래서 오늘은 이제 그 중에서 가장 단순하고 직관적인 방법에 대해서 , 일단은, 알아보도록 할게요 아 그리고 여기 에러나는거는 여기 널로 초기화를 안해가지고 그런거니까 요 부분만 일단 , 이렇게, 추가를 해주도록 하겠습니다 , 자, 그래서 음 여기 그래서 이제 결국에는 일어나고 있던 문제가 추출한 노드를 여기서 뭔가 삭제는 하긴 해야지 이제 메모리 누수 현상이 해결이 될 텐데 불행하기도 지금 여기서 막 해제할 수 없었던 이유는 누군가가 얘를 동시에 트라이팝을 같이 동시에 할 경우에 이미 해당 포인터를 참조해가지고 여기서 역참조를 해가지고 막 사용을 하고 있는 상황이 될 수도 있기 때문에 그 메모리를 그냥 고지곳대로 쿨하게 날릴 수 없다는 얘기가 드는 거죠 물론 만약에 우리가 구현하는 거에 따라가지고 정책상 요 스택 자체를 넣는 쪽에서는 여러 명이 넣더라도 빼는 쪽에서는 딱 한 명만 뺄 수 있다는 규칙 같은 거를 세운다고 하면은 , 사실, 문제가 없기는 해요 근데 뭐 일반적으로 자료 구조를 만들 때 항상 그런 상황을 예측할 수는 없다 보니까 이제 좀 일반적인 상황에서 그럼 이게 되려면 결국에는 트라이팝을 여러 명이서 할 때 누군가가 참조하고 있으면 나는 걔를 삭제할 수 없고 얘가 더 이상 사용하지 않을 때에서야 비로소 삭제를 하면 되겠죠 , 사실, 논리적으로 보면 굉장히 단순합니다 그러면 이걸 가장 쉽게 찾을 수 있는 방법은 무엇이냐 그냥 말 그대로 우리가 스마트포인터에서 레퍼런스 카운팅을 해가지고 추적을 하면서 그 메모리를 날렸던과 유사하게 팝 카운트를 계속 추적을 하면 , 일단은, 될 거라는 생각이 듭니다 그래서 오늘 첫 번째로 알아볼 방법 같은 경우에는 이런 식으로 , 일단은, 변수를 하나를 추가해 줄 건데요 팝 카운트라고 해가지고 말 그대로 현재 팝을 실행 중인 뭐 그런 스레드 일단 개수라고 보시면 되겠습니다 그래서 트랙 팝을 들어오는 순간에 각 스레드가 팝 카운트를 1 눌려주고 자기가 볼일 끝났으면 1을 줄여주는 식으로 작동을 하게 될 거예요 그러면은 여기서 이제 일감 자체를, 일감이 아니라 월드헤드를 만약에 나 혼자 지금 이 트라이팝을 사용하고 있으면은 그냥 삭제를 할 것이고 그게 아니라고 하면은 잠시 나중에 삭제를 해달라고 밀어... 어떤 리스트에 넣어 줘 가지고 그걸 나중에 이제 밀어 가지고 아무도 없을 때 이제 삭제를 하게끔 유도를 해주게 될 겁니다 그래가지고 두번째로 , 일단은, 여기다가 펜딩 리스트를 하나를 만들어 주도록 할게요 펜딩 리스트 얘는 이제 말 그대로 삭제되어야 할 노드들을 기록을 하고 있는 건데 정확히는 첫번째 노드만 요 아이로 일단 들고 있을 겁니다 어차피 뭐 지금 노드가 이런 식으로 서로 계속 넥스트로 맞물려 있는 상태이기 때문에 첫 번째 애만 기억을 하고 있으면 나머지 애들도 뭐 , 이렇게, 타고 타고 가가지고 쭉 알 수 있을 테니까 첫 번째 애만 , 일단은, 이렇게, 기억을 하도록 할 거예요 근데 어찌 됐건 이 노드 자체는 결국에는 우리가 삭제해야 될 그 목록을 이야기를 하는 거니까 펜딩 리스트라는 이름으로 , 자, 요렇게 , 일단은, 만들어 보도록 하겠습니다 얘는 , 이렇게, 냅둘까요? , 자, 이렇게, 가지고 오늘 두 개가 , 일단은, 추가가 되었고 이제 이 부분을 추가를 해주면 되겠죠 참고로 팝카운트 같은 경우에는 푸쉬에서는 딱히 개입을 안 해도 되는 게 이 푸쉬에서는 지난번에도 살짝 알아봤지만 이 노드를 만드는 것 자체는 나만 사용하고 있는 상태이기 때문에 아무런 문제가 없습니다 푸쉬는 아무런 문제가 없었는데 팝에서 문제가 됐던 거는 얘 같은 경우에는 자기 신만의 노드를 만들어 가지고 그걸 넣어 주려는 시도를 하는 것 때문에 다른 애가 건드릴 수 있는 그런 가능성이 없었기 때문에 문제가 없는 거였고 얘는 시작부터 헤드를 꺼내 가지고 이 헤드를 장난을 대상으로 막 장난을 치기 때문에 다른 스레드가 동시에 이 헤드를 참조하고 이런 부분이 문제가 되었던 거죠 그래서 결론적으로 이 팝카운트는 말 그대로 이 팝의 개수만 우리가 추적을 하게 될 거예요. 그러면 처음에 들어올 때는 팝카운트를 , 일단은, 이렇게, 1을 늘려주도록 할 겁니다. 그 다음에 얘가 막 자기가 신나게 사용하다가 다 사용했으면 이제 팝카운트를 1 줄여주게 되는 거죠. 예를 들면 지금 이 상태에서 올데드가 널이라고 하면은 더 이상 볼 일이 없으니까 여기다가 이런 식으로 팝카운트를 하나를 줄여주고 리턴을 해주도록 할게요. , 자, 그런데 만약에 이 올드 헤드가 널이 아니라 여기까지 왔으면 , 일단은, 내가 기본적으로 이 노드 자체를 내가 빼낸 상태가 되는 거죠 요 헤드에서 그러니까 우리 스택에서는 빼냈긴 했는데 걔를 삭제할 수 있는지는 아직 모르는 그런 상황이라고 볼 수가 있겠습니다 근데 어찌됐건 그 노드 자체 소유권을 일단 나한테 넘어온 그런 상태라고 볼 수가 있는 거죠 그래가지고 여기에서 우리가 try delete 라는 함수를 만들어 가지고 말 그대로 이 헤드를 삭제를 하려고 시도를 하는 부분을 이제 여기다 넣어 줄 겁니다 , 자, 그래서 바로 아래 이어가지고 try delete 삭제를 해보려고 시도를 한다 뭐 굉장히 어 네이밍 센스가 뛰어난데 , 이렇게, 해가지고 올드 헤드를 받아가지고 얘를 이제 삭제를 해주려고 할건데 , 일단은, 맨 먼저 체크해야 되는거는 나 외에 누가 있는지를 먼저 체크를 해야 할겁니다 그래가지고 pop count를 체크해서 얘가 1과 같은지 아닌지를 체크할 거에요 만약에 1과 같다고 하면은 이걸 체크하는 시점에서는 다른 애가 없고 나만 존재한다는 얘기가 되는 거고 그게 아니라고 한다면 얘가 팝카운트가 1보다 크다 2 3 4 이런 숫자라고 하면은 누군가가 같이 이미 이 팝카운트 트라이팝에 들어와 가지고 팝을 하고 있는 상황이라고 볼 수가 있는 거죠 , 자, 요렇게 , 일단은, 확인을 할 수가 있을 겁니다 그래서 여기 if 안으로 들어오면 , 일단은, 나 혼자네 라고 생각을 할 수 있기는 한데 , 일단은, 나 혼자 접근을 했다고 하면은 여기서 이 올드헤드라는 우리가 빼낸 데이터 자체는 , 이렇게, 삭제를 해줄 수가 있습니다 물론 여기서 이제 멀티스레드에 대한 특히나 락프리 프로그래밍을 처음 하시는 분들이라면 굉장히 혼란이 올 거예요 어 그런데 내가 팝카운트 1일까지는 맞는데 여기까지 넘어오고 이걸 삭제하려는 순간 다른 애가 또 트라이팝에 들어와서 팝카운트를 늘릴 수 있지 않느냐 그건 맞습니다 근데 우리가 지금 요 함수를 호출하는 순서를 유심히 보면요 항상 이런식으로 호출을 합니다 일단 데이터를 분리를 해서 스택에서 빼낸 다음에 그 다음에 카운트 체크를 하고 그리고 나 혼자면 삭제하는 식으로 , 일단은, 작동을 하고 있어요 그래서 , 일단은, 이 데이터가 여기서 올드헤드라는 것 자체가 이미 여기 첫번째 컨페인트 스왑 문에 따라가지고 , 일단은, 이 스택에서 빠져나온 상태입니다 그러니까 이미 누군가가 건드리고 있었다면 문제가 되겠지만 그게 아니라고 한다면 뒤늦게 들어온 애들은 우리가 사용하고 있는 이 올드헤드를 똑같이 발견할 수 없는 상황이 된다는 거죠 그래서 실질적으로 여기서 파카운트가 1이라고 한다면은 볼 것도 없이 나는 나 혼자 얘를 사용하는 건 확실하니까 얘는 일단 무조건 삭제를 할 수 있다는 얘기가 되겠습니다 물론 이걸 이제 데이터를 먼저 빼내고 카운트체크를 했기 때문에 된거고 이게 혹시라도 순서를 뒤바꿔가지고 카운트체크 먼저 하고 데이터를 분리하는 식으로 하면 당연히 안됩니다 순서는 어느정도 이제 보장을 해줘야 돼요 그래서 이런 부분들이 이제 처음에 할 때는 굉장히 헷갈릴 겁니다 그래서 뭐 나 혼자네 라는걸 이제 알았으니까 오케이 그러면은 내 데이터는 삭제를 하는 부분이 일어났고 하는 김에 이왕 혼자 인거 이왕 혼자 인거 삭제 예약된 다른 데이터들도 삭제를 해보고자 합니다 그제 이제 이어서 삭제를 해보려는 거죠 근데 여기서 문제는 다른 데이터 같은 경우에는 아직 여기 펜딩 리셋에서 빠진 상태가 아니기 때문에 아니기 때문에 얘를 철형 팝카운트가 1인 상태에서 들어왔다고 해도 걔네들도 내가 멋대로 지울 수 있는지는 아직 몰라요 그래서 한 번 더 체크를 해야 합니다 어떻게 체크를 할 거냐면 , 일단은, 여기다가 펜딩 리스트에다가 똑같이 데이터를 꺼내올 거예요. Exchange를 통해 가지고 얘가 read랑 write가 동시에 되는 거였죠. 원래 있던 펜딩 리스트는 null로 밀어주고 원래 있던 값은 node로 빼오게 될 겁니다. 그래가지고 원래 뭐 이런 식으로 막 데이터가 있었다고 가정을 하면은 이제는 펜딩 리스트가 null인 상태로 밀리게 될 것이고 요 데이터는 지금 , 이렇게, 사실상 이쪽에다가 우리가 , 이렇게, 꺼내 와가지고 그 첫 번째 데이터를 우리가 노드라는 요 포인터로 지금 가리키고 있는 그런 상황이라고 볼 수가 있는 겁니다 그래서 데이터를 먼저 끄집어 온 다음에 그 다음에 역시나 한 번 더 체크를 해 줄 겁니다 , 사실, 요 스텝을 다시 한 번 지금 밟고 있는 상태라고 볼 수가 있는 거죠 팝카운트를 여기서 이제 더이상 필요없으니까 줄여볼건데 만약에 팝카운트가 0이라고 하면은 내가 데이터를 꺼낸 다음에 팝카운트를 줄여든다 아직도 이제 아무도 없어가지고 팝카운트가 0이라고 한다면 중간에 끼어든 애가 없다는 얘기가 되는거고 그렇다는 것은 우리가 분리한 데이터를 삭제를 진행할 수 있다는 얘기가 되는겁니다 그래서 만약에 여기까지 왔으면은 이제와서 뒤늦게 팝카운트가 0으로 쭌 상태에서 누군가가 다시 이 트라이팝에 들어와서 팝카운트를 늘린다고 해도 어차피 이미 펜딩 리스트에 있는 데이터는 우리가 꺼내와가지고 요 노드에서 지금 들고 있는 상태이기 때문에 아무런 상관이 없습니다 그러니까 이제와서 누군가가 끼어들어도 어차피 데이터는 분리해둔 상태라는 얘기가 되는 거죠 그래서 여기서 이어서 우리가 받은 이 펜딩 리스트를 짝으로 삭제를 해주는 코드가 이런 식으로 호출이 될 것이고 그게 아니라고 한다면 여기로 엘스문화를 들어온다고 하면 누가 끼어들었으니 다시 갖다 놓는 상황이 되는 겁니다 기껏해서 여기 있는 데이터를 꺼내왔는데 아 정말 아쉽게도 간발의 차이로 누군가가 끼어들어가지고 혹시라도 여기 있는 다른 데이터들을 뭐 참조하고 있다거나 아니면은 얘를 뭐 삭제하려고 지금 똑같은 행동을 하고 있다거나 하는 상황이 발생할 수도 있으니까 아쉽게도 그 데이터를 삭제할 수는 없고 잠시 다시 갖다 놓고 다른 애가 또 이어가지고 하기를 바라고 있는 상황이라고 볼 수가 있는 거죠 , 자, 그래가지고 여기서도 이제 어떤 함수를 호출해주게 될건데 어 , 일단은, 함수들부터 헬퍼 함수들부터 일단 만들고 다시 돌아오도록 하겠습니다 요기 딜리트 노드를 비롯해가지고 하나씩 만들어 볼건데 , 일단은, 딜리트 노드 같은 경우에는 요렇게 노드를 하나를 받아줄것인데 이 노드가 맨 첫번째 노드를 가리키는거고 실질적으로 데이터들이 , 이렇게, 리스트 형태로 , 이렇게, 쭉 연결이 되고 있는 상태죠 넥스트로 계속 , 이렇게, 이어져 있습니다 그러기 때문에 걔네들을 싸그리 다 지우기 위해서는 루프를 계속 돌것이고 , 일단은, 다음 노드를 추출을 한 다음에 노드에 넥스트를 추출하고 그 다음에 노드는 삭제를 하고 노드를 넥스트로 바꿔치기를 해주면 되겠죠 얘가 뭐라고 있는 거냐면은 얘를 삭제해야 되는데 얘를 삭제해버리면 그 다음 데이터를 모르니까 , 일단은, 다음 데이터를 넥스트에다가 저장을 해준 다음에 그 다음에 얘는 필요 없으니까 날려주고 이거를 계속 반복하고 있는 상황이라고 볼 수가 있겠어요 그래가지고 이 노드로 시작하는 그 리스트를 싸그리 다 지워주는 그런 기능을 딜리트 노드로 해주게 될 거고 그게 이제 요 부분이라고 보시면 되겠습니다 그리고 반대로 이제 중간에 누군가가 끼어들었으니까 이제 다시 갖다 놓는 함수 시리즈들을 이제 만들어 줘야 되는데 여기 바로 위에다가 만들어 주도록 할게요 , 자, 이거는 체인 펜딩 node list라는 이름으로 만들어 줄 것이고 node를 두 개를 받아 줄 건데 이제 얘가 뭘 의미하는 거냐면은 우리가 다시 갖다 놓을 목록을 여기다가 건네 주게 될 건데 first는 말 그대로 이 리스트의 첫 번째 아이를 말을 하는 거고 last는 맨 마지막 node를 의미하고 있는 겁니다 그래서 first랑 last , 이렇게, 두 개를 동시에 건네 주게 될 것이고요 그 다음에 얘가 실질적으로 이제 하는 거는 코드는 요렇게 됩니다. 마지막 노드를 우리가 Pending List로 , 이렇게, 연결해줄거에요. 원래 Pending List 자체도 지금 이런식으로 뭔가가 들어가 있을텐데 우리가 받은 추가해야 될 요 라스트에다가 얘를 요 애로 , 이렇게, 이어서 연결을 시켜주는 셈이 되는 거니까 사실상 요런 느낌으로 이어지게 된다고 볼 수가 있는 거죠 우리가 추가해야 되는 애들을 애들 뒤에다가 원래 있던 펜딩 리스트를 요렇게 추가하는 상황이라고 볼 수 있겠습니다 , 자, 근데 역시나 Chain Pending Roster 이 함수도 마찬가지로 우리가 여기서 지금 시도를 하고 있기는 한데 또 멀티스레드 특성상 누군가가 끼어들어 가지고 똑같은 작업을 할 수 있기 때문에 얘도 결국에는 Compare & Swap 으로 계속 루프를 돌면서 시도를 해야 됩니다 , 자, 요 패턴은 이제 뭐 계속 자주 등장하니까 어느 정도 이제 익숙해지셨을 것 같은데 결국에는 Compare Exchange Week를 실행을 할 것이고 우리가 예상한 값은 last에 next인 상태에서 desired는 first로 , 이렇게, 넣어 주도록 하겠습니다. 얘가 first라면은 뺑뺑이를 돌겠다라고 , 이렇게, 호출해주게 되는 거죠. 그럼 요크드의 의미는 우리가 , 이렇게, 연결하고 싶은데 중간에 아무도 끼어들지 않았다고 하면은 얘는 이제 정상적으로 붙은 상태가 되는 거고 그 다음에 펜딩 리스트는 원래 얘를 가리키고 있었는데 그게 아니라 우리가 첫 번째로 넣어준 이 first를 가리키게끔 얘로 바꿔치기를 해주게 된 겁니다 그러니까 요 부분을 이어 붙이는 부분이랑 펜딩 리스트가 얘를 가리키게 하는 부분을 동시에 실행하기 위해서 이 컴패안 스왑을 이용했다고 보시면 되는 거죠 만약에 실패를 했다고 하면은 다시 요 코드가 실행이 될 테니까 다시 뺑뺑이를 돌면서 내가 들고 있던 애에다가 현재 펜딩 리스트에 첫번째 I를 연결을 하고 그 다음에 Pending List를 내 첫번째 First라는 I로 바꿔치기 하는 부분을 반복해서 실행해주게 될 거에요 그래서 혹시라도 중간에 끼워둘 수 있으니까 요런식으로 코드를 짜야 된다는 얘기가 되는거죠 요 패턴은 자주 등장하고 있으니까 어느정도 익숙해지셨을 것 같고 그래서 요 함수를 기반으로 여러가지 변종을 만들어 줄 건데 , 일단은, Chain Pending Node List라고 또 하나를 만들어 줄 건데 이번에는 그냥 노드 하나만 헬퍼를 만들어줘가지고 첫번째 노드를 건네주면은 알아서 그 노드 리스트에 이어진 맨 마지막에까지 찾아가지고 윗함수를 호출해주게 될겁니다 그러니까 요 노드는 이 첫번째 아이를 의미를 하는거고 먼저 맨 마지막에 있는 요 아이를 찾아가지고 이 위에 있는 함수 버전을 호출해주는 어떻게 보면 헬퍼 함수라고 보시면 되겠어요 그래서 , 일단은, 레스트 노드 마지막 노드를 찾아줘야 되니까 우한 루프를 돌 것이고 무한 루프를 돌 것인데 만약에 Next가 있다고 하면은 Last는 Next로 계속 이동을 하는 게 되는 거죠 그래서 다음 다음 다음 다음 다음으로 가가지고 더 이상 다음이 없을 때까지 앞으로 쭉 이동한 셈이 되는 거고요 여기까지 Last를 구해줬으면 이제는 Chain Pending Node List를 이용해가지고 방금 구해준 이 Last랑 원래 첫 번째 아이랑 같이 , 이렇게, 건네주는 식으로 호출해주게 될 겁니다 네 그래서 , 이렇게, 일단은, 두 개의 함수를 만들어 놨고 그 다음에 마지막으로 정말 딱 한 개만 예약을 해야 되는 경우도 생기기 때문에 얘는 Chain Pending Node 라고 이름을 지어 주도록 할게요 얘 같은 경우는 좀 특수한 상황인데 , 이렇게, 라스트를 구해줄 필요 없이 하나밖에 없다 보니까 그대로 자기 자신을 , 이렇게, 두 번 건네주게 될 겁니다 그럼 애당초 요 코드가 실행이 되면서 마지막 애를 지금 자기 자신으로 넣어놨기 때문에 그냥 하나짜리로 지금 요 함수가 호출이 되는 뭐 그런 상황이라 되겠어요 그래가지고 , 이렇게, 삼총사를 , 일단은, 만들어놨으면 어느정도 준비가 끝난거고 다시 이제 위로 올라가가지고 이어서 코드를 만들어 보자면 , 자, 내가 혼자이네 이왕 혼자인거 삭제 예약된 다른 데이터들도 삭제를 해보고자 하면서 여기서 만약에 팝카운트가 여전히 1이어서 내가 1을 줄였더니만 0이 되었다고 하면은 이제 노드를 삭제하는 부분이 있고 그렇지 않다면 1로 들어오게 되겠죠 참고로 지금 우리가 팝카운트를 아토믹 , 이렇게, 만들어놨기 때문에 여기서 마이너스 마이너스를 해가지고 값을 추출하는 것 자체가 아톰이 카게 이루어집니다 네 그래가지고 이게 제 빼고 개타는게 아니라 빼면서 그 결과 값을 뱉어주는 게 이제 원자적으로 일어났기 때문에 이 부분은 혹시라도 문제가 있을까 생각하시는 분들이라면 그 부분은 안심하셔도 되고요 그래서 결국에는 이 팝카운트가 0이 아니라 정말 그 간발의 차이로 누군가가 또 들어왔다라고 하면은 이 데이터를 지금 삭대할 수 없는 상황이다 보니까 아쉽게도 다시 갖다 놓을 겁니다 기껏 뽑아놨는데 다시 갖다 놓는 상황이 되는 거죠 그래서 다시 갖다 놓기 위해서 chainPendingNodeList라는 함수를 , 이렇게, 호출해가지고 다시 원상복귀, 다시 펜딩 리스트에다가 넣어주는 상황이 된 겁니다. 이 chainPendingNodeList 함수도 동시에 여러 명이 실행할 수 있으니까 서로 경쟁을 해가지고 다시 반납을 하려고 막 열심히 경쟁을 해서 한 명씩 이제 성공을 하게 되겠죠. 이런 식으로 , 일단은, 작업을 하게 될 겁니다. 그 다음에 결국 나 외에 누가 있는가에서 애당초 얘가 팝카운트가 1이 아니라 다른 값이었다고 하면은 누군가가 벌써 있다는 얘기가 되는 거죠? 누가 있네? 그러면 지금 당장 삭제할 수 없고 삭제하지 않고 삭제를 예약만 하는 코드를 실행해주게 될 겁니다. 그렇기 때문에 Chain Pending Node를 해가지고 올드 헤드를 지금 당장 삭제할 수 없기 때문에 즉 이 상황은 이거죠 내가 여기서 올드 헤드를 획득까지는 했는데 그 간발의 차이를 뚫고 누군가가 이 부분을 , 일단은, 이미 실행하고 있는 상황이어서 지금 당장 이 올드 헤드를 날릴 수 없다는 상황이 된 겁니다 그래서 여기서는 딜리트를 할 수 없고 그냥 다시 반납을 해 줘 가지고 이 펜딩 리스트에다가 우리가 밀어 넣는 부분이 있고 다만 마찬가지로 팝 카운트를 1 줄여주는 부분은 여기서 해야 되겠죠 이제 더 이상 필요 없으니까 , 이렇게, 해가지고 팝 카운트를 줄여주는 부분이 양쪽에서 , 일단은, 들어갔다는 걸 확인할 수 있고 코드가 그래서 이런 느낌으로 , 일단은, 작업이 되게 될 겁니다 다시 분석을 이제 천천히 해보시기를 바라고 이 코드는 이제 올려 놓을 테니까 조금 어렵기는 한데 제가 락프리를 다룬 이유가 여러 가지가 있지만 , 일단은, 궁금해 하시는 분들도 많을 뿐더러 이게 그래도 처음에 이런 CAS 연산 compare swap 연산을 하면서 코딩하는 굉장히 좋은 연산이 됩니다 처음에 할 때는 굉장히 헷갈리는 부분이긴 하지만 그래가지고 이 부분을 천천히 한번 분석을 해보시면 되겠어요 팝 카운트를 늘려가지고 , 일단은, 이 트라이 팝을 사용하고 있는 개수를 카운팅을 하고 끝났으면은 줄여주고 하는 부분이고 여기까지 왔으면 내가 올드 헤드를 , 일단은, 내가 선점한 상태다 아싸 하고 좋은 상태이지만 그럼에도 불구하고 그 와중에 누군가가 얘를 건드릴 수 있기 때문에 당장 삭제할 수 있는지 없는지는 알 수가 없다 그래서 트라이 딜리트를 호출해줬고 여기서 팝카운트를 다시 체크해서 팝카운트가 1이라고 한다면 말 그대로 여기서 올려준 그 자식이 자신만 사용하고 있는 상황이니까 자기가 혼자 사용하고 있는 거니까 이왕 혼자인 거 삭제 예약된 다른 데이터들을 , 이렇게, 삭제를 해보려고 하고 삭제를 할 때는 항상 , 이렇게, 데이터를 먼저 분리를 한 다음에 얘가 아토믹하게 일어나죠 원자적으로 일어나가지고 분리를 한 다음에 진짜 진짜 아직까지도 내가 분리를 한 순간에도 누군가가 들어왔는지 한 번 더 크로스 체킹을 해가지고 진짜 없다고 하면 이제 안심하고 모든 노드를 삭제를 해줄 것이고 그게 아니라고 한다면 울며 겨자먹기로 다시 얌전히 갖다 놓는 코드가 들어가게 된 겁니다 그리고 그와는 별개로 팝카운트가 1이었다고 하면 내 데이터는 삭제할 수 있죠 이미 데이터가 위에서 요 부분에 의해 가지고 , 일단은, 떼낸 상태니까 스택에 더 이상 들러붙지 않는 데이터이기 때문에 , 이렇게, 데이터를 삭제할 수 있고 그게 아니라 애당초 팝카운트가 1이 아니었다고 하면 애당초 처음부터 누가 있었던 거기 때문에 이 올드 헤드를 내가 삭제할 수 없어서 다시 펜딩 상태로 밀어놓고 팝카운트를 1 줄여줬다라고 , 일단은, 결론을 내릴 수가 있겠습니다 , 자, 그래가지고 좀 뭐 굉장히 길었는데 이제 이거를 테스트하기 위해서 어 다시 게임 서버로 가가지고 일단 락 프리 스택으로 우리가 일단 지난번에 바꿔놨었네요 그니까 뭐 별다르게 해줄 건 없을 거 같고 그냥 이 코드가 잘 실행이 됐는지 보면 되겠죠 근데 여기서 이제 살짝 위험한 부분은 뭐냐면은 경합이 서로 너무 심해져가지고 예를 들면은 이거는 , 사실, 비현실적인 상황이긴 한데 이런 식으로 무한 루프를 돌면서 슬립도 하지 않고 그냥 계속 계속 데이터를 밀어 넣고 있다고 하면은 약간 문제가 일어날 수 있습니다 이쪽 팝 같은 경우에 만약에 얘가 조금 더 느리게 처리를 하고 푸쉬가 더 빨리 되고 있는 상황이라고 한다면 정말 운이 나쁘게 데이터가 계속 계속 밀어 넣어지고 얘가 처리하는 속도가 따라가지 못할 수가 있겠죠 그러니까 애당초 이 팝 카운트가 , 이렇게, 0이 되어 가지고 나만 사용을 할 때 이 부분을 삭제를 할 수가 있는데 만약에 지금 우리가 테스트 코드를 만들어 놓은 것처럼 굉장히 여러 스레드가 팝을 정말 실시간으로 계속 한다고 하면은 , 이렇게, 나 혼자 나 홀로만 얘를 접근하는 타이밍이 일어나지 않아 가지고 계속 메모리가 늘어날 수도 있는 그런 극단적인 상황까지도 , 일단은, 생각을 해야 된다고 보시면 되겠습니다 물론 일반적으로 그런 일이 거의 없긴 하겠죠 , 자, 그건 그렇고 , 자, 이렇게, 해서 뭐 마지막으로 지금까지 잘 실행이 되는지만 테스트를 해볼 건데 또 코드를 보다 보니까 이번에도 한 가지가 빼먹었는데요 여기서 널체크가 빠졌습니다 , 자, 여기 체인팬딩 노드 리스트라는 걸 호출할 때 여기 내부에서 지금 널체크를 안 하고 있다 보니까 뭐 여기다가 추가해도 되겠지만 굳이 불필요한 함수 호출을 줄이기 위해서 바깥에서 그냥 , 이렇게, 해주도록 할게요 요 부분에서 널체크를 해줘서 널이 아닌 경우에만 , 이렇게, 갖다 놓는 부분이 들어갈 것이고 애당초 얘가 널이어가지고 더 이상 넣을 것이 없었다고 하면은 뭐 넣을 필요도 없겠죠 그래서 요 부분만 , 일단은, 추가를 해주고 다시 빌드를 한 다음에 , 자, 요 코드를 다시 한번 실행을 해보도록 할게요 매우 극단적인 상황이죠 하나가 무한 루프를 돌면서 계속 푸쉬를 하고 있고 나머지 애들은 무한 루프를 돌면서 팝을 하고 있는 그런 상황입니다 , 자, 근데 우리가 여기 팝을 할 때 C아웃을 했기 때문에 얘가 상대적으로 팝을 하는 속도가 조금 밀리게 될 겁니다 그래가지고 실질적으로 메모리가 지금 계속 증가하는 이유는 뭐 이 버그라고 하긴 뭐하고 말 그대로 얘가 너무 빨리 데이터를 밀어넣고 있기 때문이죠 이거를 조금 시간을 조절해 가지고 뭐 어느 정도 텀을 둬 가지고 데이터를 밀어 넣으면은 이제 아까처럼 메모리가 무한 증직하는 일은 이제 없어지게 될 겁니다 , 자, 이렇게, 해 가지고 , 일단은, 뭐 락프리 프로그래밍의 어떻게 보면 맛보기를 한번 해 봤는데요 이것뿐만 아니라 스택 Q와 같은 락프리 구조체를 어떤 식으로 보호할 것이냐에 관련된 그런 알고리즘들은 굉장히 많습니다. 그 중에서 우리가 가장 직관적이고 간단한 방법에 대해서 , 일단은, 이렇게, 알아본 거예요. , 이렇게, 해가지고 락프리 스택 제 2탄을 , 이렇게, 마치도록 하겠습니다. 코드는 올려놓을 테니까 혹시라도 헷갈리는 부분이 있으시면 코드를 다운받아서 보시면 되겠습니다.