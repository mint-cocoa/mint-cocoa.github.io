우리가 지난 시간까지 락을 실질적으로 우리가 직접 구현을 해 가지고 앞으로 편하게 사용할 그런 간단한 락을 , 일단은, 만들어 놨는데 제가 이전에도 데드락 시간에 말씀을 드린 적이 있지만 락이 서로 순서가 꼬여 가지고 발생하는 데드락이 생각보다 의외로 빈번하게 발생합니다 라이브에서 서버가 나갔을 때 크래쉬가 나는 여러가지 이유가 있겠지만 널 포인터 체크를 누락한게 거의 0순위라고 볼 수 있고 데드락에 의해 상황이 꼬이는 문제도 심심치 않게 발생합니다. 탑5 안에는 무조건 든다고 보시면 돼요. 근데 그 문제가 찾기가 굉장히 까다로운 이유는 일단 개발 단계에서는 일어나지 않다가 꼭 사람이 많아지는 라이브 단계로 넘어가야지 그게 버그가 터지는 경우가 많아가지고 미리 예방을 하기가 힘들다고 보시면 돼요 일단 버그가 터진 다음에 그걸 고치는 건 그렇게 어렵지 않습니다 원인만 판별이 되면은 결국 우리 서버 엔진에서도 데드락을 미리 탐지할 수 있는 여러가지 기법들을 미리 넣어주면 사전 예방이 많은 도움이 되는데 이걸 구현하는 방법이 여러가지가 있습니다 여러가지 알고리즘이 있고 예를 들면 락 하이라키라고 락마다 번호를 둬가지고 일종의 구조를 우리가 직접 정의를 한 다음에 락 번호가 큰 숫자에서 작은 숫자로만 락을 걸 수 있다거나 하는 식으로 규정을 만들어 가지고 사용하는 방법도 있어요 근데 그 방법의 가장 큰 문제는 우리가 애정초 미래에 나올 모든 컨텐츠들을 다 예상해서 구조를 짜기가 힘들기 때문에 언젠가는 그 구조 자체에서 약간 모순이 생기고 그러면 이제 굉장히 고치기가 또 힘들어집니다 그래가지고 이제 제가 제 엔진에서 사용하는 방법은 그래프 알고리즘을 이용해 가지고 그냥 사이클을 판별하는 방법으로 이거를 디버그 단계에서 , 일단은, 잡아 볼 거에요 , 자, 그런데 제가 이제 이 강의를 찍는 시점에서는 아직 자료구조 알고리즘 강의를 만들지 않고 파트 3를 스킵하고 지금 파트 4로 바로 바로 넘어왔기 때문에 뭐 아직 그래프에 대한 내용을 혹시 모르신다면 이 내용은 간단하게 그냥 뭐 이해를 하시면 되겠습니다 그래프에 대한 개념을 깊이 알아보지는 않을 것이지만 일단 간략하게 복습을 해보자면 정점이랑 간선으로 이루어졌다고 보시면 돼요 정점은 말 그대로 어떤 데이터를 표현하는 거고 그 데이터들끼리의 관계를 우리가 간선이라는 선으로 표현하게 될 겁니다 그래프 예시를 들어보자면 이런식으로 정점과 간선의 조합이라고 볼 수 있는 거죠 이걸로 이용해서 표현할 수 있는 상황이 굉장히 많습니다 우리가 일반적으로 선형 자료구조, 리스트 같은 경우를 한다면 , 이렇게, 쭉 이어져 있기 때문에 굉장히 단순하고 직관적이긴 하지만 일상생활에서 모든 것을 다 그런 리스트 형태로 표현할 수는 없습니다 반면 , 이렇게, 그래프로 되어 있는 이런 자료구조 같은 경우에는 생각보다 응용할 수 있는 범위가 굉장히 넓다고 보시면 돼요 예를 들면 소셜 네트워크 관계도 SNS에서 내 친구 관계를 보고 싶다거나 아니면 지하철 노선들을 표현한다고 하는 걸 이런 식으로 그래프로 일단 만들어 줄 수 있을 겁니다 그 중에서 오늘 관심있는 그래프는 방향이 있는 그래프, 방향 그래프에 대해서 알아볼 건데 말 그대로 아까 , 이렇게, 간선에다가 방향까지 추가가 되어 가지고 왼쪽 오른쪽 , 이렇게, 방향에 따라 가지고 지금 여기 보면 왼쪽으로 가는 정보와 오른쪽으로 가는 정보가 이제 의미가 완전히 달라지게 됩니다 그래서 이제 이 방향정보까지 추가된 그래프를 대상으로 우리가 생각을 해볼 거에요 뭐 이것도 이제 뭐 예를 들면은 그냥 도로 일반 도로가 아니라 일방통행이 뭐 추가 포함된 그런 도로망이라고 한다면은 이제 일반 통행 특성상 한쪽으로 밖에 갈 수 없기 때문에 이제 아까랑은 좀 의미가 달라지게 되겠죠 뭐 이런 상황을 예로 들 수 있을 겁니다 그리고 이제 뭐 , 이렇게, 그래프를 표현하는 방법은 뭐 여러가지 방법이 있지만 기본적으로 사용하는 것은 , 이렇게, 행렬 느낌으로 2차원 배열을 이용해 가지고 표기를 하는 게 이제 일반적이라고 보시면 되겠어요 지금 요 샘플을 , 일단은, 보시면은 이게 2차 벡터로 만들어져 있는데 지금 요 상황을 지금 표시를 하고 있는 겁니다 그래서 각각의 정점들 0번에서 5번까지 6개의 정점들로 이루어졌는데 0번에서 1번으로 가는 길이 있고 0번에서 3번으로 가는 길이 있기 때문에 0에서 1이 켜진 거고 0에서 3도 1로 켜져 있는 상황을 , 이렇게, 볼 수가 있는 거예요 그래가지고 이 Adjacent라는 것 자체가 나한테 인접한 정점들을 우리가 표시를 하고 있는 거죠 말 그대로 이 간선들을 지금 , 이렇게, 2차원 벡터로 표현하고 있다라고 보시면 되겠습니다 , 자, 그리고 뭐 DFS에 대한 내용도 잠시 복습을 해보자면 깊이 우선 탐색 이라고 해가지고 어 갈 때까지 그냥 계속 안으로 타고 타고 들어가는 특성이 있습니다 그래가지고 제가 이전에 뭐 C샵 파트2 자료구조 알고리즘에서 설명하기를 굉장히 용감한 용사와 같다 즉 계속 타고 타고 들어가려고 하는 성향이 있다고 말씀을 드렸고 예를 들면 지금 0번 노드에서 DFS를 빡 돌린다고 가정을 하면은 얘가 지금 이제 자신이랑 연결된 즉 길이 트여져 있는 모든 곳에 일단 가려고 합니다 그래서 1번도 있고 3번도 있으니까 일단 1번으로 들어가고 1번에서도 2번이랑 연결되어 있으니까 2번으로 들어가고 이런 식으로 갈 수 있는 모든 곳을 다 , 이렇게, 직접적으로 쭉쭉쭉 가게 되는 게 이제 DFS의 개념이라고 보시면 되겠어요 리스트랑은 다르게 그래프는 , 사실, 우리가 , 이렇게, 순회하는 순서가 굉장히 여러가지가 있겠죠 0번부터 시작을 하는 경우도 있고 아니면 5번부터 시작하는 경우도 있을 거고 그리고 이제 어떤 점을 기준으로 어떤 규칙으로 우리가 서칭을 할 것이냐 등등 굉장히 다양한 규칙이 있을 수 있기 때문에 , 이렇게, 뭐 BFS든 DFS든 일단 일관된 그런 순서를 정해줘 가지고 , 일단은, 접근을 해야 합니다 네 그래가지고 여기서 이제 결국에는 DFS 코드를 간략하게 보면은 전형적으로 , 이렇게, 재귀적인 함수로 만들어지게 되는데요 이 코드를 일단 의사 코드를 보시면은 이제 만약에 DFS를 돌린다고 가정을 했을 때 뭐 일단 이 0번점부터 다시 DFS를 돌린다고 가정을 해봅시다 그러면 여기에 이 0번이란 인덱스가 들어올 것이고 인접한 모든 점을 스네일을 하면서 지금 인접한 점이 1번이랑 3번이 되겠죠? 걔네들을 아직 방문하지 않았다고 하면은 또 재개적으로 요기랑 요기에서도 DFS를 각각 돌려줄 겁니다 그럼 이제 그 다음 턴에서는 이 DFS에 지금 1번이 들어와 가지고 얘를 또 실행할 텐데 얘도 마찬가지로 2번이랑 3번이랑 연결이 되었으니까 어 그리고 아직 방문하지 않은 상태니까 2번이랑 3번을 대상으로 또 DFS를 돌린 식으로 , 이렇게, 제기함수로 이제 이뤄지는 게 일반적이라고 보시면 되겠습니다 이제 뭐 이거는 DFS에 대한 간단한 복습이었구요 , 자, 그 다음에 DFS를 이제 한 바퀴 돌리면은 모든 정점이 이제 그러면 발견되느냐 그거는 아닙니다 예를 들면 지금 뭐 역시나 0번을 대상으로 DFS를 돌리면 연결된 모든 애들 한 대상으로 , 이렇게, 순차적으로 여기서 여기까지 , 이렇게, 완료가 되겠지만 오버는 딱히 연결이 되지 않았으니까 얘는 아직 외딴 섬처럼 아직 발견이 되지 않은 상태가 될 거예요 그래서 모든 정점을 대상으로 다 발견을 했다는 것을 보장하기 위해서는 , 이렇게, 한 번 더 dfs all 이라고 해 가지고 모든 정점을 대상으로 , 이렇게, 체크를 하면서 이제 반복해 가지고 이 dfs 를 실행해야 합니다 0번을 대상으로 우리가 만약에 한번 돌렸으면은 요 그룹 자체가 이제 다 DFS가 스캔이 되가지고 발견이 될 테고 그 다음에 마지막으로 이 5번으로 대상으로도 한 번 더 , 이렇게, 돌려 가지고 이런 식으로 반복해서 돌려야 된다고 보시면 되겠어요 , 자, 그럼 이게 이제 DFS 아마 이제 우리가 어 다음에 제가 언젠가 파트 3를 보충해서 만들면 이런 내용까지는 다 이전 파트에서 알아볼 내용이고 이제 오늘 추가할 내용은 이 그래프 응용에 대해서 알아볼 건데 이제 그래프를 이용해서 알아볼 수 있는 정보가 굉장히 많은데 그 중에서 우리가 관심 있는 분야는 사이클을 판별하는 알고리즘에 대해서 알아보도록 할 거예요 사이클이라고 하는 것 자체는 이제 지금 이런 상황이죠 이쪽으로 갈 수도 있고 이런 쪽으로 갈 수도 있고 뭔가 , 이렇게, 하나의 사이클이 생긴 상황을 얘기를 하고 있는 건데 이거를 이제 왜 연구를 하느냐 결국 데드락 상황이 언제 발생하는지 한번 생각을 해봅시다 이제 이 그래프 자체를 그냥 뜬금없는 그래프가 아니라 우리가 락을 거는 순서를 지금 얘가 표시하고 있다고 가정해볼게요 그래서 우리가 지금 클래스가 6개가 있어 가지고 그 내부적으로 각각 락을 하나씩 잡고 있는 거고요 예를 들면 얘는 플레이어 매니저 얘는 어카운트 매니저 이런 식으로 각각을 하나의 클래스를 지금 얘가 얘기하고 있다고 가정해봅시다 근데 그 상태에서 첫번째 플레이어 0번에 해당하는 락을 우리가 잡은 상태에서 그 상태에서 다시 1번 락을 , 이렇게, 잡는다고 가정을 하면 이거를 지금과 마찬가지로 , 이렇게, 그래프 형태로 우리가 표시를 할 수가 있겠죠 마찬가지로 1번 락을 잡은 상태에서 또 2번 락까지 우리가 잡는다고 하면 이것도 역시나 이런 식으로 그래프로 표현을 할 수가 있을 겁니다 그래서 , 이렇게, 그래프 관계를 만든 다음에 결국에는 데드락이 발생하는 상황은 무엇이냐면 순서가 거꾸로 뒤바뀌는 상황이 문제가 된다고 했었죠 0번에서는 1번 락을 잡으려고 하고 거꾸로 다른 코드에서는 1번 락을 잡은 다음에 0번 락을 잡으려고 하는 요런 상황이 발생을 할 때 결국 데드락이 일어나는 겁니다 물론 이게 꼭 , 이렇게, 두 개를 대상으로만 사이클이 일어나는 건 아니고 예를 들면은 만약에 여기는 2번에 해당하는 아니 이걸로 예를 들고요 이 3번에 해당하는 요 부분에서 1번으로 해당하는 길이 있었다고 하면은 , 자, 이렇게도 이렇게도 지금 사이클이 일어나게 되겠죠 이런 식으로도 일어나고 그러기 때문에 결국에는 이 길까지 추가를 해야 될까요? 뭐 이런식으로 앞뒤로 연결되어 있다고 하면은 삼각형으로도 , 이렇게, 지금 사이클이 일어날 수 있다는 얘기가 되겠습니다. 그래서 결국에는 여기서 이제 중요한 내용은 뭐냐면은 그래프에서 우리가 사이클을 판별할 수 있으면은 결국에는 이거를 똑같이 데드락 락을 판별하기 위해서 락에 대한 그 잡고 있는 요 구조 자체를 우리가 그래프로 표현을 해가지고 정리를 하면은 어찌됐건 이 데드락 상황을 미리 판별해 가지고 예방을 할 수도 있다라는 게 , 일단은, 지금 이 판별하는 알고리즘이라고 생각을 하시면 되겠어요 근데 물론 이거를 항상 하진 않을 거고 디버그 모드에서 우리가 개발을 할 때만 이걸 판별하게끔 유도를 해주면 뭐 성능 부하도 없고 미리 사전에 버그를 예방할 수 있는 그런 좋은 방법이 될 겁니다 그래가지고 그래프 사이클을 판별할 때는 그럼 어떻게 하는 것이냐 이게 , 사실, DFS에서 우리가 추가적인 정보를 남기면 됩니다 DFS라는 게 굉장히 좋은 게 그냥 순회를 할 때만 한 번만 사용하는 게 아니라 DFS를 함과 동시에 이런저런 정보를 남겨주면 거기에 대해서 우리가 많은 정보를 추출할 수가 있는데요 예를 들면은 어떤 박쥐가 동굴에서 음파를 빡 쏘면은 설령 박쥐는 눈이 안 보인다고 해도 그 음파가 동굴을 타고 타고 가가지고 반사되고 이런 정보를 토재가지고 그 동굴에 구조를 박쥐가 예측을 할 수 있는데 지금 딱 그런 상황이라고 보시면 되겠습니다 그래서 우리가 DFS를 빵 돌리면서 그 구조에 대해서 우리가 이제 터득을 하게 되는데 일단 세 가지 용어가 등장합니다 순방향간선, 교차간선, 역방향간선 , 이렇게, 세 가지가 있어요 순방향간선은 뭐냐면 그냥 순방향, 가장 일반적인 상황입니다 우리가 DFS를 돌리는데 일단 0번을 대상으로 우리가 DFS를 돌린다고 가정해볼게요 근데 이걸 잠시 , 이렇게, 이쪽으로 , 이렇게, 한번 표현을 해봅시다 그러면 이게 약간 시냇물이 흐르듯 자연스럽게 , 이렇게, 아래로 내려가는 상황을 우리가 생각하면 되는데 0번을 대상으로 우리가 먼저 DFS를 시작했다고 가정해볼게요 그러면 그 다음에 3번이랑 1번 노드가 발견이 되어 가지고 얘네들을 이제 재규적으로 실행을 하게 될 텐데 얘까지는 0번까지는 , 일단은, 방문이 된 상태이고 그 다음에 이제 1번이랑 3번이 각각 후보인데 얘네들은 아직 우리가 방문을 하지 않은 완전히 처음 방문하는 그런 정점이기 때문에 얘네들도 각각 이제 방문을 하게 될 건데 요 상태에서 요 길과 요 길을 우리가 순 방향 간선 이라고 표현을 합니다 말 그대로 그냥 시냇물이 , 이렇게, 자연스럽게 흐르듯 우리가 방문한 순서를 이제 예를 추적을 하기 시작할 건데 맨 처음으로 요 점을 발견했고 그 다음에 요 점이랑 요 점을 우리가 정점을 발견했다고 하면은 이 순차적으로 이 순서가 뒤바뀌지 않고 작은 숫자에서 큰 숫자로 우리가 향하는 그 길을 발견한 거니까 이게 굉장히 자연스러운 흐름이라고 볼 수 있는 거죠. 그래서 순방향간선 이라는 이름이 붙는 겁니다. 발견 순서를 생각을 해가지고 결국에는 먼저 발견한 내를 방문한 다음에 나중에 발견한 점에 대한 길을 , 이렇게, 이어주는 것을 순방향 간선이라고 한다고 보시면 되겠어요 순방향 간선이 아닌 경우는 그럼 이제 무엇을 얘기를 하는 것이냐 그 나머지 케이스들은 이제 역교차 간선이거나 아니면 역방향 간선이 될 거예요 이 두 개 중 하나라는 얘기가 되는 건데 일단 교차 간선부터 말씀을 드려보자면 , 자, 일단은, 이번에는 만약에 우리가 3번부터 DFS를 돌린다고 가정해봅시다 이 점을 기준으로 그럼 얘는 발견했고 4번을 이제 방문을 하려고 하는데 얘는 아직 처음 방문한 애다 보니까 여기서 여기까지 가는 이 길은 순방향 간선이라고 했었죠 근데 여기까지 한 다음에 4번은 더 이상 연결된 점이 없으니까 이제 여기서 끝나게 됩니다 그래가지고 3번을 대상으로 우리가 DFS를 딱 돌리면 , 이렇게, 3번이랑 4번에 해당하는 그룹이 이제 스캔이 완료가 되고 여기서 끝나게 될 거예요 그럼 이 상태에서 이제 왠지는 모르겠지만 이 5번에 대한 DFS를 이제 이어갈 것인데 얘는 아직 방문하지 않았으니까 방문을 할 것이고 그 다음에 4번이 , 이렇게, 이어졌다는 걸 볼 수 있는데 근데 4번은 이미 누군가가 얘를 발견한 뒤이겠죠 그럼 이미 얘가 발견된 상태이기 때문에 얘는 순방향 간선은 아니고 교차 간선이거나 역병향 간선이거나 둘 중 하나가 되는데 이제 이거를 교차이거나 역방향 중에서 판별하는 방법은 교차 간선 같은 경우에는 이미 , 이렇게, 그룹이 하나의 DFS 사이클이 끝나가지고 얘가 최종적으로 완료가 된 상태까지 , 일단은, 된다고 하면은 즉 다른 그룹에 의해 가지고 발견이 되었으면 교차 간선이라고 합니다 그래서 얘는 이제 교차 간선 상황이 되는 거죠 이미 한바퀴 스캔이 꽝 끝나 가지고 이미 모든 탐색이 완료된 상태이고 그 다음에 우리는 독립적인 다른 그룹을 시작을 했는데 거기서 이제 , 이렇게, 낑겨 가지고 발견이 된 그런 상태가 교차 간선이라고 우리가 표현을 하는 거예요 그러면은 교차간서는 뭐 그냥 그런가보다 하고 그냥 남이 발견한 거를 우리도 같이 발견한 그런 상황이 되는 거죠 그래서 얘는 딱히 사이클이 발생한 상황은 아니에요 마지막 상황이 진짜 진짜 이제 사이클이 발생하는 그런 상황이라고 볼 수 있는 건데 얘 같은 경우에는 뭐 예를 들면 우리가 0번에서 시작을 했다고 가정해볼게요 그러면 얘를 발견을 했죠 그 다음에 1번이랑 3번을 각각 발견할 것인데 이 정점 같은 경우는 아직 방문하지 않았으니까 둘 다 OK, OK 사인을 내려주면서 이게 결국은 이런 식으로 순방향을 우리가 발견하게 됩니다. 근데 이제 이어서 1번을 우리가 또 DFS를 이어서 재규적으로 실행하다 보면 1번이 0, 2, 3 , 이렇게, 3개의 점에 대해서 다 연결이 되어 있다는 걸 우리가 알 수가 있어요 근데 이 중에서 이미 방문한 순서를 우리가 곰곰이 생각을 해보면 얘는 일단 방문 됐고 그 다음에 우리가 1번을 방문해서 얘까지는 , 이렇게, 끝난 상태인데 지금 1번에서 0번으로 가는 길을 , 이렇게, 찾게 되죠 그러면 이 경우는 일단 당연히 순방향 간선은 아니고 교차 간선이거나 역방향 간선인데 만약에 이 사이클이 이미 만료되어 가지고 끝난 상태에서 얘를 발견했다고 하면 교차 간선이 되는 거지만 지금은 그게 아니죠 지금은 아직까지 탐색을 하고 있는 중입니다 아직 0번에 해당하는 DFS가 완전히 끝나지 않고 그걸 재기적으로 탐색하는 도중에 , 이렇게, 역으로 가는 길을 발견했다고 하면은 이게 역방향 간선을 우리가 발견한 삶이 되는 거예요. 그리고 이 상황이 되었다고 하면은 결국에는 사이클이 발생했다라고 우리가 이제 가정을 할 수가 있게 되는 거죠. 그래서 그래프 사이클 판별 알고리즘에서는 결국 DFS를 빵 돌리면서 이제 두 가지 정보를 추적을 해야 되는데 , 일단은, 이 방문한 순서를 우리가 계속 추적을 해줄 겁니다. 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 이런 식으로 추적을 해줄 것이고 그 다음에 내가 , 이렇게, 방문한 길을 체크를 해보면서 어떤 점이 이미 방문이 되었고 나보다 심지어 먼저 방문이 된 순서가 정점이라고 한다면 일단 조금 이상한 상황이라고 인지를 하고 순방향 간선이 아니라는 걸 깨닫게 되는 거고 그 다음에 마지막으로 체크해야 되는 거는 이 DFS 사이클이 끝나 가지고 이미 더 이상 왈곱왈곱 할 필요 없이 이미 끝난 지점인지 아니면은 지금 계속 서칭을 하는 이 DFS가 돌고 있는 도중에 찾은 것인지를 또 구분을 하다 보면은 최종적으로 이 순방향, 교차, 역방향에 대한 결론은 이제 나오게 된다고 보시면 되겠어요 이게 말로 하니까 살짝 어려울 수 있는데 코드로 보면은 이게 생각보다 그렇게 어렵지 않다는 걸 알 수가 있습니다 그래가지고 이 알고리즘을 이용해가지고 , 이렇게, 사이클이 일어나는 걸 우리가 탐지를 할 것이고 사이클이 일어났다고 하면은 데드락 상황이구나 라고 , 일단은, 우리가 강제로 크래쉬를 내는 코드를 , 일단은, 작업을 해보게 될 거예요 , 이렇게, 해서 그래프 사이클에 대한 간단한 개론을 한번 알아봤고 이제 이어서 코드에서 데드락을 한번 잡아보도록 합시다 , 이렇게, 해가지고 다시 코드로 돌아온 다음에 오늘 간단하게 데드락을 잡는 아이를 만들어 줄 건데 이게 Thread 산하의 클래스 이름은 데드락 프로파일러 라고 딱 봐도 뭔가 탐정 같은 느낌으로 이 클래스를 만들어 준 다음에 얘를 Thread 쪽에다가 , 일단은, 밀어 넣어 주도록 하겠습니다 , 자, 그래서 , 일단은, cpp를 오른쪽에다가 , 이렇게, 이동을 시켜 주도록 할 것이고 어 일단 데드락 프로파일러에서 사용할 전 그런 컨테이너들을 사용 어 스택이랑 , 일단은, 맵 그리고 뭐 벡터 정도로 , 일단은, 이렇게, 크게 추려 보도록 하겠습니다 이걸 뭐 이제 사용할지 안할지는 나중에 결정을 할 것이고 그 다음에 이 프로파일러가 하는 것 자체는 뭔가 그 우리가 락 클래스에서 이 락 클래스에서 실질적으로 라이트 락을 하거나 아니면은 라이트 언락을 하거나 , 이렇게, 뭔가 락을 잡을 때랑 락을 해제해 줄 때 여기다가 낑겨 넣어 가지고 디버그 모드면 이 프로파일러한테 그 정보를 전달해 줘 가지고 얘가 이제 그래프 알고리즘을 그려 준 다음에 사이클이 일어나는지를 체크를 해주게 될 겁니다 그래가지고 , 일단은, 코드 자체는 푸쉬락이 일어날 때 , 이렇게, 얘가 이 푸쉬락이 일어났다는 걸 , 이렇게, 받아줄 것인데 이제 구분은 할 수 있어야 되겠죠? 락이 어떤 락을 사용하고 있는지를 , 일단은, 이렇게, 코론스트 캐릭터 포인터로 잡아 줄 겁니다 이제 나중에 가면은 해당 클래스의 아이디를 우리가 타입 아이디로 받아와 가지고 걔를 요 아이한테 건네 줄 것이기 때문에 일단 , 이렇게, 만들어 줄 것이지만 뭐 요런 문자열이 아니라 하더라도 그냥 우리가 직접적으로 0123 같은 그런 아이디를 뭐 발급해 가지고 사용해도 당연히 무방하죠 이건 뭐 나중에 바꿔도 되지만 , 일단은, 기본적으로 좀 간단한 간단하게 하기 위해서 , 이렇게, 이름을 지어 가지고 그 이름으로 구별을 해주도록 하겠습니다. 그 다음에 checkCycle 이라고 해가지고 진짜 사이클이 일어나는지 아닌지를 판별하는 그런 함수를 만들어 줄 것입니다. , 자, 그리고 이어가지고 dfs 를 시작을 하는 어 함수를 , 이렇게, 하나를 정의를 해 줄 것이고 그 다음에 나머지는 이제 해당 그래프 알고리즘을 구현하기 위해서 그래프를 그려주기 위한 그런 정보들을 하나씩 갖고 있을 거에요 , 자, 일단은, unordered map을 이용해가지고 이 키랑 이 이름이랑 해당 락의 번호를 우리가 , 이렇게, 관리를 해주도록 하겠습니다 name to id 라고 하도록 할게요 그 다음에 역시나 unordered map을 하나를 더 만들어 줄 것인데 이번에는 거꾸로 , 자, 아이디랑 그 이름을 맵핑해주는 이런 Unordered Map을 하나를 만들어주도록 할게요. id to name이라고 일단 이름을 지어주도록 하겠습니다. 즉, 이름을 받아줄 때는 구분하기 쉽게 이름으로 , 이렇게, 관리를 하지만 내부적으로 우리가 연산을 할 때는 정수로 하는 게 빠르니까 , 이렇게, 서로 왔다 갔다 할 수 있게끔 지금 얘를 이제 만들어 준 거고요. 그 다음에 진짜로 이제 락이 실행되는 걸 우리가 스택으로 계속 추적을 해줄 겁니다. 락 스택이라고 이름을 지어주도록 할게요 그래서 락 스택을 만들어 줄 것이고 마지막으로 락 히스토리라고 해가지고 어떤 락이 몇번 몇번째 락을 잡았는지를 히스토리를 만들어 줄 겁니다 그러니까 아까 우리가 ppt에서 살펴본 대로 0번 락이 1번 락을 잡았다 라고 하면은 0번에서 1번으로 가는 간선이 만들어지게 되겠는데 그 간선에 해당하는 정보를 만들기 위해서 얘를 히스토리를 관리한다고 보시면 돼요 0번 락이 만약에 1번 락을 0번을 잡은 상태에서 1번을 잡은 적이 있다고 하면은 여기 맵에서 0번에 해당하는 키에 해당하는 세트에 1이라는 값이 이제 같이 추가가 된다고 보시면 되겠습니다 , 자, 그래가지고 뭐 요렇게 , 일단은, 만들어 줄 것이고 그 다음에 , 일단은, 뮤택스로 잡아가지고 이게 멀티세더 환경에서도 안전하게 동작하게끔 락을 하나를 만들어 주도록 하겠습니다 , 자, 그리고 이제 이어서 이 아랫부분은 뭐냐면은 어 우리가 이제 사이클을 판별하는 알고리즘을 돌리기 위한 그런 임시적인 값들을 여기다가 , 일단은, 만들어 주도록 할게요 얘는 이제 사이클 체크를 할 때마다 매번 초기화 해가지고 다시 체크를 할 겁니다 Discovered Order라고 해가지고 우리가 결국에는 사이클을 판별하기 위해서는 방문 순서를 우리가 추적을 해야되었었죠 그 순서를 얘가 발견된 순서를 추적을 할겁니다 그래서 말그대로 정점이 노드가 발견된 순서를 기록하는 배열이라고 보시면 되겠고 그 다음에 , 자, 디스커버드 카운트라고 해가지고 얘는 노드가 발견된 순서를 우리가 추적하기 위해서 카운팅을 해주는 역할을 맡게 될 겁니다 그 다음에 피니쉬드라고 해가지고 얘는 dfs i번째 i번째가 종료되었는지 여부를 판별할 것이고 마지막으로 패런트라고 해가지고 얘는 vector에 int 32 parent라고 해가지고 내가 발견된 이유, 즉 나의 부모님은 누구인지를 , 이렇게, 추적을 해주도록 하겠습니다 여기까지 , 일단은, 준비물은 , 이렇게, 완료가 되었고요 이건 당연히 코드를 보기 전까진 이해하기 힘들겠지만 코드를 보면서 조금씩 조금씩 조립을 하다보면 그게 엄청나게 어려운 부분은 아닙니다 , 자, 일단은, 제가 늘 하듯 여기다가 뭔가 , 이렇게, 영역 표시를 내 땅 표시를 하도록 할게요 그 다음에 얘는 데드락 프로파일러 라는 이름으로 대충 , 이렇게, 영역을 집어 주도록 하겠습니다 그 다음에 복붙 반대쪽으로 이제 넘어가서 시작을 할 건데 , 자, 일단 뭐 푸쉴락부터 시작을 해보도록 하겠습니다 푸쉴락부터 만들어 줄 것이고 얘를 , 일단은, 정리는 다 , 이렇게, 구현분을 만들어 두도록 할게요 얘도 만들어주고 그 다음에 DFS까지 만들어 주면 , 사실, 모든 기능이 끝날 것이고 , 자, 이제 여기서 시작을 할 건데 푸쉴락 같은 경우에는 먼저 멀티세드 환경에서 돌아가야 되니까 일단 락카드를 , 이렇게, 잡아 줄 겁니다 그 다음에 이제 아이디를 찾거나 발급을 해주기 시작을 할 거예요 아이디를 찾거나 발급한다 락 아이디가 일단 무엇인지를 확인할건데 어 기본적으로 네임2 아이디라는 데에서 우리가 찾고자 하는 이름이 있으면은 이미 이전 단계에서 한번 얘 등록한 적이 있는걸테고 그게 아니라 얘가 없다 없다고 하면은 지금 처음 발견된 그런 정점이 될테니까 아이디를 발급을 해줄거에요 락 아이디는 대략적으로 name to id 에서 사이즈로 추가를 해주도록 합시다. 이 번호에 따라서 0번, 1번, 2번, 3번 식으로 , 이렇게, 락 아이디를 발급을 해주도록 할게요. 그 다음에 발급을 해줬으니까 name to id 에다가 , 이렇게, 락 아이디를 등록을 시켜주고 거꾸로 id to name 에서도 이 아이디를 등록시켜가지고 이 네임을 등록시켜 주도록 할게요 , 자, 그 다음에 만약에 이전에 한번 찾은 적이 있다고 하면은 굳이 새로 발급을 하진 않을 것이고 find iterator의 second을 이용해가지고 해당하는 lock 아이디를 추출을 여기다가 해주도록 하겠습니다 그럼 여기까지 완료가 되었으면 일단 발급된 lock 아이디가 들어가게 되겠죠 0번부터 시작해서 1,2,3,4,5,6,7,8 이런 식으로 발급이 될 겁니다 얘는 이제 순전히 우리가 구분을 하기 위한 용도라고 보시면 되겠어요 , 자, 그 다음에 그 다음에 이제 해야 되는 거는 잡고 있는 락이 있었다면 즉 아직 잡고 있는 락이 없는 상태에서 그 락만 잡는 거라고 하면 솔직히 뭐 딱히 문제될 상황은 아니다 보니까 아무것도 안 해도 되는 거고 락 스택을 체크를 할 것이고 만약에 MT가 false여가지고 이미 무엇인가 잡고 있는 락이 있었다고 하면 여기서 뭔가 처리를 해줄 것이고 그게 아니라고 한다면 , 일단은, 이 스택에 락 스택에다가 얘를 그대로 집어 넣어 주도록 할 거예요 , 자, 그리고 이어가지고 기존에 발견되지 않은 케이스라면 우리가 데드락 여부를 다시 확인을 해야 합니다 사이클이 있는지 판별해야 된다는 거죠 그래가지고 , 일단은, 락 스택 탑을 추출해가지고 기존에 우리가 맨 마지막으로 잡고 있었던 락 번호가 무엇인지를 체크를 한 다음에 만약에 그게 지금 잡으려는 아이디랑 다르다고 하면은 왜냐면 우리가 락을 만들 때 재규적으로 똑같은 락을 여러 번 잡을 수 있게 해놨으니까 그 상황은 솔직히 데드락 상황이 아니니까 통과해 줄 것이고 다른 락을 잡았다고 하면은 이제 사이클을 체크해 줘야 되니까 이런 식으로 히스토리를 참조할 겁니다 ROCK HISTORY를 참고해 가지고 PREVIOUS ID에 해당하는 ROCK HISTORY를 살펴본 다음에 만약에 우리가 새로운 그런 간선을 발견한 경우 즉 우리가 지금 접근하려는 이 ROCK ID가 처음 발견한 거라고 하면 그렇다고 하면 HISTORY에다가 ROCK ID를 추가해 줄 것이고 여기서 CHECK CYCLE를 돌려주게 될 겁니다 지금 코드가 다 이해가 안 가셔더라도 이걸 다 완성한 다음에 보면 조금 쉬울 거예요. 어찌됐건 처음에 발견하는 길이라고 하면 정점들끼리 락을 서로 잡고 잡고 할 텐데 처음 발견한 케이스라고 하면 체크를 한다는 부분이 들어가게 되는 거죠. 그래서 이걸 매번마다 체크를 하는 건 아니고 진짜로 아직까지 방문되지 않은, 발견되지 않은 새로운 길, 새로운 간선이 발견될 때만 얘를 해준다는 게 일단 핵심입니다. 그리고 체크 사이클은 조금 이따가 만들어 보도록 하고 반대로 팝 락은 무엇을 하는 거냐면은 거꾸로 이 락 스택에서 해당 락을 그냥 꺼내주게 됩니다 결국에는 락 스택에서 팝을 해주면 일단 된다는 얘기가 되는 건데 여기서 멀티 세도 환경이다 보니까 락 가드를 , 이렇게, 잡아 줄 것이고요 그 다음에 뭐 혹시 모르니까 여기서도 이런 저런 디버그 체크를 해 보도록 합시다 왠지 락 스택이 엠티어라고 한다면 이건 뭔가 문제가 있는 상황이겠죠 멀티플 언락 크래쉬를 내주도록 하고 어 그 다음에 이 팝 락을 하는 요 아이가 뭔가 이상하게 좀 꼬여가지고 잘못됐다는 것도 체크를 해보도록 할게요 네임2 아이디를 이용해가지고 이 네임을 체크해서 이 아이디를 체크해봤더니만 그게 이 락 스택의 마지막에 있는 탑 값이 아니다고 하면은 우리가 그냥 뭔가 푸쉬 팝 순서를 뭔가 꼬여가지고 그냥 잘못한 상태라고 생각할 수 있으니까 invalid unlock이라고 에러를 크래쉬를 내주도록 할게요 얘는 , 사실, 뭐 굳이 없어도 되는 겁니다 그냥 혹시 모르니까 어... 버그 예방 차원에서 , 일단은, 이렇게, 낑겨넣은거고 나중에 뭐 좀 안정화되면은 얘는 이제 없어져도 되는거에요 , 자, 그럼 이제 체크사이클이 중요한데 여기서 우리가 위에서 사실상 요 부분에서 이 히스토리를 통해가지고 우리가 그래프 구조를 계속 그려주고 있는데 그 상태에서 결국 사이클이 일어났는지 아닌지를 우리가 이 체크사이클을 호출해가지고 판별을 해주게 될겁니다 , 자, 그래서 여기서 코드를 보면은 일단 지금까지 발견된 라카운트가 몇개인지를 알고 싶으면은 name to id에 등록된 애들이 몇개인지를 체크를 해주시면 되겠죠 그 다음에 이어가지고 discovery order 같은 애들을 다 싸그리 초기화를 해줄겁니다 라카운트 개 만큼의 배열 사이즈로 만들어 주고 초기 값은 마이너스 1 로 넣어 주도록 할게요 즉 마이너스 1 이라고 하는 아직 이 정점이 방문 되지 않은 상태라고 볼 수 있는 거고 0 부터 자연수가 들어가게 되면 그 정점이 방문이 되었다, 발견이 되었다고 일단 생각할 수가 있겠습니다. 그 다음에 discovered count, 카운터 역할을 하는 애도 영어로 초기화를 해줄 것이고 그 다음에 finished 배열, finished는 해당 DFS가 완벽하게 끝났느냐를 의미하는 건데 얘는 다 false로 밀어줄 것이고 마지막으로 parent 같은 경우에도 , 자, 얘도 역으로 내가 어떤 경로에 의해 가지고 발견이 됐나를 추적하는 건데 , 일단은, 초기 값으로 마이너스 1을 넣어가지고 한마디로 여기 지금 우리가 정의해 준 값들은 사이클을 체크할 때 필요한 그런 중간 임시 변수라고 보시면 돼요. 근데 걔네들을 다 초기 값으로 밀어주고 있습니다. 초기 값으로 밀어진 다음에 결국에는 락 아이디를 하나씩 하나씩 스케일을 해줄 것이고 락 카운트 개만큼을 아이디 뿔뿔을 해주면서 DFS를 , 이렇게, 빵 돌려주면 된다고 보시면 되겠습니다. 물론 모든 정점들이 다 간선히 연결되어 있어 가지고 DFS 한 번만 호출이 돼도 모든 애들이 간접적으로 다 방문이 된다고 하면은 사실상 한 번만 호출해도 나머지 애들은 다 자연적으로 스킵이 될 겁니다 이제 이게 DFS 특성이고 그 다음에 연산이 끝났으면 이제 정리하는 코드가 여기 이제 들어가면 되겠습니다 뭐 Discovered Order 같은 경우에도 클리어를 해주고 Finish도 필요 없으니까 클리어 해주고 그리고 Parent도 필요 없으니까 클리어 해주고 이런 식으로 초기화, 정리, 체크 , 이렇게, 3단계로 구분을 해주도록 할게요 그러면은 먼저 DFS를 이제 빵! 스캔을 해줄건데 만약에 Discovered Order가 마이너스 1이 아니라고 하면은 이미 방문이 된 그런 점이겠죠? 이거 이름을 DFS Here라고 이름을 좀 바꿔주도록 할게요 현재 지점을 발견을 했다 이미 얘는 방문이 끝난 상태로 가면은 그냥 리턴을 때려주도록 하고 그게 아니라고 하면 이제 방문을 하고 있는건데 , 자, here를 discoveredCount++을 넣어주도록 할게요. 얘가 0부터 시작해가지고 내가 지금 방문하고 있는 정점의 순번을 각각 매겨주는 겁니다. 그 다음에 이어서 모든 인접한 정점을 수뇌를 하기 시작해야 되겠죠 DFS 특성이다 보니까 모든 인접한 정점을 어떻게 아냐면 우리가 Lock History라고 해가지고 해당하는 번호의 정점이 잡은 상태에서 또 타고 타고 가는 그 간선들을 우리가 이 Lock History로 지금 관리를 하고 있으니까 얘를 체크를 해주면 됩니다 Find it를 해가지고 Lock History를 체크를 해주도록 할게요 현재 정점에 해당하는 히스토리를 이제 체크를 해줄 것인데 만약에 히스토리를 판별했던 이만 없었다 라고 하면은 아직까지 해당 정점을 락을 잡은 상태에서 다른 락을 우리가 잡은 적이 없다는 얘기가 되는 거니까 그냥 finished를 true로 끝내주고 그냥 return을 때려주도록 하겠습니다 근데 그게 아니라고 하면은 내가 어떤 락을 잡은 다음에 다른 락을 또 잡은 적이 있다고 하는 거니까 이제 이어서 사이클이 있는지를 판별해 보도록 해야 되겠죠 그래서 이런 식으로 세트를 다시 추출할 건데 여기 세트에서 내가 얘를 잡은 다음에 잡은 목록이 들어가 있을 겁니다 그래서 얘가 이제 상대방이 되는 거죠 데어라고 표시를 할게요 넥스트 세트를 하나씩 순회할 것이고 얘도 이제 DFS를 돌리기 위해서 아직 방문한 적이 없다면 이제 방문을 할 겁니다. 그래서 discover... 아이고, order를 체크를 해가지고 만약에 아직 방문한 적이 없다라고 하면은 그러면은 이 parent를 여기다 기입을 해줘서 너는 나 때문에 방문이 된 거야 라고 , 이렇게, 기입을 해 준 다음에 DFS를 때려가지고 걔를 방문을 하고 넘어가 주도록 하겠습니다. , 자, 이어가지고 이미 방문한 적이 있었다고 하면은 이제 순방향 역방향 인지를 체크를 할 건데 먼저 히어가 데어보다 먼저 발견되었다면 데어라는 애가 히어라는 애의 후손이기 때문에 얘는 순방향 간선인 상황이 되는 겁니다 그래가지고 디스커버트 오더 체크를 해가지고 단순하게 누가 먼저 방문이 되었는지를 체크해가지고 발견이 되었는지를 체크해가지고 , 자, 이런식으로 만약에 히어가 애당초 먼저 왔으면은 문제되는 상황이 아니고 순방향 간선이어서 그냥 쿨하게 넘어갈 수가 있어요 근데 만약에 순방향이 아닌 상태에서 그리고 dfs 데어가 아직 종료하지 않았다면 그러면 대언은 히어의 손조이기 때문에 이 상황은 곧 역방향 간선이 이뤄지는 상황이라고 했었죠. 즉, DFS가 아직 완벽하게 끝나지 않은 상태에서 우리가 역으로 가는 길을 발견한 셈이 되는 겁니다. DFS가 끝나지 않았다는 것은 우리가 Finished라는 이 변수에다가 우리가 기입을 해주고 있으니까 여기서 만약 이 안으로 들어왔다 하면 그냥 무조건 크래쉬가 일어나는 사이클이 일어난 상태라고 볼 수가 있는 거죠 그리고 마지막으로 맨 마지막에다가 , 이렇게, Finished 상태를 바꿔치기를 해주면 되겠어요 그래서 여기 안으로 일단 들어왔으면 무조건 역방향 간선이 있어가지고 사이클이 있는 상황이라고 우리가 볼 수가 있는 겁니다 그래서 뭐 예를 들면 deadlock detected 이라고 , 이렇게, 사유를 주고 크래쉬를 내도록 할게요. detected 근데 뭐 , 이렇게, 크래쉬만 내면은 이게 어떤 경로에 의해 가지고 어떤 애가 사이클이 나는지 좀 알기 힘드니까 여기다가 로그를 찍어 주도록 합시다. 몇번 몇번에서 몇번 몇번에 해당하는 애 때문에 얘가 일어났다라는 걸 , 자, 이렇게, here와 그 다음에 id to name there를 이용해가지고 추출을 해주고 그 다음에 부모를 계속 타고 올라가가지고 , 자, 이렇게, 체크를 해주도록 할게요 얘도 똑같이 요렇게 해주지만 얘는 이제 now를 기준으로 parent now 그리고 얘는 now를 입력을 해준 다음에 분모를 계속 타고 타고 타고 가도록 할 겁니다 parent now 만약에 now가 there까지 왔으면은 브레이크를 하려고 해가지고 이제 내가 결국에는 어떤 사이클이 일어났는지를 여기다가 log로 출력을 해준 다음에 crash를 , 이렇게, 내주도록 할게요 , 자, 이렇게, 해가지고 처음에 볼 때는 좀 어렵지만 이걸 그림을 그려보면서 분석을 하다보면 그렇게 진짜 어마어마하게 어려운 내용은 아니에요 아까 제가 파워포인트에서 설명드린 그 순서도 순서가 지켜지면서 먼저 발견한 점 순서대로 지금 , 이렇게, 접근을 하고 있으면 문제가 없는 건데 아직 DFS가 끝나지 않았음에도 불구하고 역으로 , 이렇게, 타고 가는 순서를 거슬러 올라가는 애를 발견했다고 하면 그게 이제 역방향이 있는 상황 역방향이 있다는 것은 곧 사이클이 있는 상황이라고 볼 수가 있겠습니다 그래서 이 알고리즘을 좀 분석을 해 보시기를 바라고 어찌됐건 요거를 이제 만들어 줬으면 이제 그럼 어떻게 얘를 사용할 것이냐 어.. 우리가 락을 걸어주는 코드를 만들어 놨었죠? 여기 락 양쪽에다가 , 자, 여기다가 , 일단은, 걔를 낑겨 넣어주도록 할거에요 물론 이거를 뭐 나중에 가면은 뭐 디버그 상태에서만 하는게 조금 더 깔끔하긴 한데 , 일단은, 거기까진 신경 안쓰고 여기다가 라이트 락이랑 라이트 언럭을 할 때 각각 이름을 각각 부여해줘가지고 요 부분에다가 이름을 각각 , 이렇게, 사용을 하도록 할겁니다 그래서 여기서도 네임이 들어가고 네임 네임 네임을 다 , 이렇게, 넣어 주도록 하겠습니다 , 자, 그 다음에 이 부분에서 항상 하진 않고 디버그 상태 일때만 얘를 넣도록 할게요 왜냐면은 여기 내부에서 보면은 우리가 결국에는 데드락 프로파일러에서도 락을 잡아 가지고 사용하고 있는데 락을 테스트하기 위해서 락을 잡는 것 자체가 좀 모순적인 상황이다 보니까 얘는 이제 디버그 상황에서만 체크를 하도록 할 겁니다 그래서 여기서 데드락 프로파일러를 이제 실행시켜 가지고 이 락 히스토리를 계속 추적을 하는 그런 방법으로 일단 만들어 볼 것인데 잠시 코어 글로벌에 돌아가가지고 , 자, 이쪽에다가 오늘 추가할 애를 여기에다가 넣어주도록 할게요 deadlockprofiler 그리고 , 이렇게, deadlockprofiler를 이쪽에다가 만들어 준 다음에 그 다음에 CBP에 돌아가가지고 , 자, 이쪽에다가 header-include deadlockprofiler를 추가해준 다음에 여기서 Deadlock Profiler를 gDeadlockProfiler라는 이름으로 , 이렇게, 만들어 주도록 하겠습니다. 그 다음에 Core Global을 만들 때 이 Deadlock Profiler를 같이 만들어 달라고 해 줍시다. 마찬가지로 이쪽에서도 Delete Deadlock Profiler로 날려 주도록 할게요. 그럼 이제 얘를 전역으로 사용할 준비가 되었으니까 다시 Lock으로 돌아와 가지고 이쪽에서 push, lock을 이런식으로 해주도록 할 거에요. 위에서 마찬가지로 include deadlock profiler를 추가해주시면 되겠습니다. 그 다음에 얘를 복붙한 다음에 내려가지고 write unlock을 할 때도 이 코드를 실행할 건데 얘는 이제 lock을 push라는 건 아니고 pop lock을 해주게 되겠죠. , 이렇게, 해주면 되고 그 다음에 리드랑 락도 마찬가지로 어찌됐건 얘는 순서랑 연관이 있는거니까 리드락도 그냥 락을 잡는거랑 마찬가지다 보니까 얘도 , 자, 이렇게, 푸쉬락을 해주도록 할 것이고 그 다음에 리드언락을 할 때도 , 자, 이런식으로 팝 락을 여기다 낑겨 넣도록 할게요 그럼 이제 락을 사용하는 모든 코드에서 우리가 , 이렇게, 프로파일러를 낑겨 넣어 가지고 이거를 추적을 하고 있는 상태가 된 겁니다 , 이렇게, 전역으로 하지 않고 이걸 TLS 영역에다가 해가지고 Thread 단위로 만약에 우리가 만들어주게 되면은 그러면 락카드를 우리가 굳이 걸어주지 않아도 되는 상황이 되겠죠 대신 그럴 때는 Thread A랑 Thread B가 지금 호출하고 있는 순서가 서로 병합이 되진 않으니까 조금 뒤늦게 대드락 상황을 발견할 수 있는 문제도 생기긴 할 겁니다 그래서 그건 이제 어느 정도 융통성 있게 만들어 주시면 되는 거고 여기서 결국에는 Push-Lock을 계속하면서 여기서 Cycle이 있으면 여기서 이 Profiler가 뿅 하고 잡아주게 될 거라는 얘기가 되는 거죠 그 다음에 여기서 끝나는 게 아니라 이걸 바꿔주면 나머지 부분들도 당연히 바꿔줘야 되겠죠 여기 이제 아래 쭉 가다 보면은 이 부분에서도 마찬가지로 이 이름을 들고 있도록 할 건데 여기서 처음에 콘스트 캐릭터 네임을 얘도 받아줄 것이고요. 양옆으로. 그 다음에 네임을 , 이렇게, 저장을 해주도록 할게요. 이쪽에서도. 그리고 이쪽에서 네임을 받아주고 네임을 받아주고 하는 식으로 , 이렇게, 이렇게, 각자 네임을 받아줘가지고 이어서 실행을 시켜주면 되겠습니다. , 자, 그러면 리드락 가드랑 라이트락 가드에다가 , 이렇게, 이름을 지금 우리가 받아줘야 되는데 코어 매크로 쪽에 가면은 우리가 매크로를 , 이렇게, 만들어 놨습니다 , 자, 이렇게, 만들어 놨는데 이제 뒤에다가 이름을 여기다가 기입을 해줘야 되는데 어떤 이름을 사용할 거냐면은 애당초 우리가 이 리드락 라이트락 자체를 어떤 클래스 내부에서 하기 때문에 그 해당 클래스의 이름을 간략하게 우리가 얻어올 수 있는 이 type id라는 걸 이용해 가지고 런타임에 그 해당하는 객체의 이름을 우리가 , 이렇게, 얻어올 겁니다 네 그래서 , 이렇게, 만들어 주게 되면은 우리가 굳이 이름을 일일이 넣어 놓지 않더라도 이제 컴파일러가 열심히 만들어준 코드에 의해서 런타임에서 그 해당 클래스의 이름을 간략하게 추출해주고 그 이름 자체는 동일한 클래스라고 하면 변하지 않을 테니까 우리가 이런 식으로 콘스트 캐릭터 포인터를 이용해서 계속 저장하고 있었던 거예요 만약에 그게 아니라 이 이름 자체가 계속 바뀔 수 있다고 하면 이걸 스트링으로 만들어준다거나 하는 식으로 해야 되겠지만 , 일단은, 이런 식으로 만들어도 충분합니다 그래가지고 , 이렇게, 일단은, 만들어주도록 할게요 , 자, 서브코어를 , 일단은, 다시 빌드해서 에러가 있으면은 나머지 에러를 잡아줄 것이지만 , 일단은, 에러가 딱히 안 나니까 이제 결국에는 얘를 뭐 고지곳대로 테스트를 해볼 수 있는 상황이 된 거죠 , 자, 그래서 데드락 상황을 우리가 인위적으로 하나를 만들어 보도록 할 건데요 , 자, 여기 메인에다가 클래스를 추가할 것인데 AccountManager 라는 클래스를 일단 하나를 추가할 것이고 그 다음에 마찬가지로 PlayerManager 라는 클래스를 또 만들어 보도록 하겠습니다 얘네들은 이제 잠시만 사용하고 실습 끝나면 다시 날려줄 거니까 뭐 이름은 솔직히 상관이 없습니다 그래서 일단 PlayerManager 쪽에 가가지고 얘는 lock을 사용할 것이니까 useLock을 해줄 것이고 그 다음에 대략적으로 playerLock을 먼저 잡은 다음에 그 다음에 accountLock을 잡겠다라는 의미로 playerThenAccount라는 이름으로 , 이렇게, 함수를 하나를 만들어주고 그 다음에 그냥 lock을 잡아주는 함수를 하나를 더 만들어주도록 하겠습니다 그 다음에 이어가지고 extern player-manager 전역으로 이 player-manager 객체를 하나 만들어가지고 서로 크로스로 락을 잡아주게끔 유도를 해줄거에요. 그 다음에 player-manager cpp에서는 account-manager 헤더를 추가한 다음에 이 player-manager 변수를 여기다가 전역으로 만들어 줄 것이고 그 다음에 player-manager에 player 된 account라는 애는 라이트락을 , 이렇게, 잡아줄 것이고 라이트락을 잡은 다음에 G-Account 아직 안만들었지만 G-Account 매니저의 락을 , 이렇게, 잡아주게 될겁니다. 즉 플레이어의 락을 잡아주고 그 다음에 어카운트 락을 이어가지고 잡는 애라고 보시면 되는거고 거꾸로 어카운트 매니저 쪽에서 똑같은 실험을 할 것이기 때문에 얘도 이제 그냥 락만 걸어주는 굉장히 단순한 함수를 , 이렇게, 만들어 주도록 하겠습니다 그럼 이제 똑같은 거를 다시 어카운트 매니저 쪽에 돌아가 가지고 어카운트 매니저 쪽에서도 똑같이 만들어 줄 것인데요 , 일단은, useLock을 넣어주고 그 다음에 얘는 이제 거꾸로 어카운트 락을 먼저 잡고 그 다음에 플레어 락을 잡는 함수를 만들어 줄 것이고 그냥 자기 락을 잡아주는 함수를 만들어 주도록 하겠습니다. account manager type에 전역 변수를 , 이렇게, 선언을 해 줍시다. 그래서 account manager g account manager를 일단 변수를 만들어 주고 그 다음에 위에서 플레어 매니저 헤더를 추가해 준 다음에 이제 얘가 우리가 오늘 테스트 할 거는 거꾸로 된 거죠. account.then.player 여기서 라이트 락을 먼저 잡은 다음에 거꾸로 G 플레어 매니저의 락을 이제 거꾸로 크로스로 호출하는 겁니다 순서가 뒤바뀌었죠 벌써 그러니까 이런 상황에서 , 사실, 데드락이 일어나는 건데 데드락이 제가 늘 말씀을 드리지만 굉장히 짜증나는 게 이게 100% 확률로 일어나는 게 아니어서 개발 단계에서 이제 잘 잡히지 않는 경우가 종종 생기게 되는 거죠 , 이렇게, 해서 지난번에 만든 코드는 , 일단은, 여기서 여기까지 일단 싹을 다 날려주도록 할 거고 그 다음에 오늘 새로 추가할 어 테스트 해볼 어카운트 매니저랑 그 다음에 플레이어 매니저를 각각 추가를 해주시면 되겠습니다 , 자, 그리고 어 요 부분은 , 일단은, 뭐 날려주고요 일단 스레드 두개를 만들어 줄건데 그냥 간략하게 람더로 만들어 봅시다 요렇게 함수를 정의를 할 것인데 얘는 그냥 무한루프를 돌면서 그냥 로그를 하나 찍어봅시다. 플레어댄 어카운트를 실행할 것이다 라고 친절히 로그를 찍어주고 그 다음에 gplayermanager.playerdanaccount를 호출할 거에요. 그 다음에 대충 슬리프호를 통해 가지고 한 100ms 정도를 잠들어 보도록 합시다. , 자, 그 다음에 다른 스레드, 두번째 스레드는 거꾸로 얘를 호출해주는게 아니라 어카운트 된 플레어를 호출해주게 되겠죠? 그니까 여기다가 지 어카운트 매니저의 어카운트 된 플레어를 이제 호출해주는 상황이 될거에요 , 자, 그럼 , 일단은, 우리가 만든 코드가 디버그 상태에서만 잡아주는 거니까 거꾸로 얘를 일부러 릴릿에서 , 일단은, 만들은 다음에 서버 코어를 다시 빌드하고 게임 서버 실행가지고 이게 진짜 데드락이 일어난지를 살펴보도록 합시다 데드락이 잡혔다고 하면은 이 플레이어된 어카운트가 찍히면 안되겠죠? 잠시만 보면은 얘가 지금 점으로 만들어줘야 되는데 요 부분이 잘못됐네요 , 자, 빌드해서 통과 됐구요 , 자, 그러면은 이게 만약에 데드락이 일어나려고 하면은 이 로그가 찍히다가 안 찍혀야 됩니다 어느 순간부터 왜냐면 락을 잡으려고 하는 순간에 계속 무한대기를 타야 되기 때문이죠 근데 얘를 이제 딱 실행해보면 굉장히 묘하게도 그냥 아무런 문제가 없이 그냥 잘 진행이 되고 있어요 이런 상황에서 이제 지나칠 수 있다는 얘기가 되는 거죠 근데 사실상 우리가 실행한 이 호출 흐름 자체가 얘는 플레어 락을 잡고 어카운트 락을 잡고 얘는 어카운트 락을 잡은 다음에 플레어 락을 잡으니까 , 사실, 애당초 데드락 가능성이 있는 코드에요 근데 왜 데드락이 안 잡히냐면은 이건 타이밍 이슈이기 때문에 이 락을 잡고 이 락을 잡는 요 사이가 , 사실, 너무 짧아가지고 거의 동시다발적으로 일어나 보니까 얘가 발생하지 않는 겁니다 근데 이게 라이브에 나가가지고 5천명의 유저들이 동시에 이 짓거리를 하다보면은 이게 확률이 급격히 높아지면서 라이브에서만 일주일에 한번씩 일어나는 그런 버그가 일어날 수 있다는 얘기 되는거죠 이걸 인위적으로 우리가 일어나게 하고 싶다고 하면은 여기서 좀 텀을 둬가지고 대충 여기서도 한 뭐 한 1초 정도를 잠들도록 합시다 그러면 얘의 락을 잡은 다음에 잠들고 다시 이 락을 잡으려고 하는데 반대쪽에서 이미 쥐어컨트 매니저를 락을 잡았다고 하면 결국에는 이제 , 이렇게, 되면 이제 확실하게 데드락 상황이 되는 거죠 그래서 요 상황에 대해서 다시 한번 실행을 해보면 , 자, 이제는 어떤가요? 이게 1초마다 뜨는게 아니라 뭔가 뜨다가 지금 더이상 로그가 안뜬다는걸 볼수가 있는데 이 상황이 결국에는 데드락 상황이 된거죠 그래서 우리가 만든 코드에서는 대충 10초동안 시도를 하다가 랍을 못잡으면 , 이렇게, 크래쉬를 냈으니까 여기서 , 일단은, 크래쉬가 , 이렇게, 난다는걸 볼수가 있어요 그래가지고 결국에는 인위적으로 우리가 , 이렇게, 만들었는데 만약에 우리가 만든 이제 그 프로파일러 데드락 프로파일러를 이용해가지고 이걸 디버그 환경에서 테스트를 하면요 이젠 아까와는 다르게 이게 조건부로 일어나는 거 뭐 그런 걸 상관하지 않고 애당초 그 락 순서를 체크해가지고 그래프 알고리즘으로 체크해가지고 그냥 뭔가 사이클이 일어났다고 하면 바로 판별해중이 될 거니까 얘는 이제 실행을 해보면 그냥 바로 잡아줍니다 실행 땅 바로 우리 프로파일에서 잡아줬었죠 그래가지고 결국에는 사이클이 일어난 그 흐름을 로그로 찍어줬는데 어카운트 매니저를 잡은 다음에 플레어 매니저를 잡았는데 거꾸로 플레어 매니저를 잡고 어카운트 매니저를 잡아가지고 여기서 사이클이 지금 일어났다라고 , 이렇게, 메시지를 찍어주는 겁니다 저는 이제 이런 식으로 디버그 환경에서만 잡을 수 있는 버그를 최대한 잡아주기 위해서 요런 코드를 굉장히 많이 넣는 편이에요 그래가지고 이제 뭐 알고리즘 특히나 이 그래프 알고리즘이 처음이라고 하면 요 코드가 조금 이야기 난해할 수도 있긴 하지만 뭐 제가 파트 3를 만들 시점에서는 그래프를 좀 중요도 있게 많이 다룰 거니까 그때 가서는 이제 아마 이해가 잘 가실 겁니다 그래서 요 코드를 이제 천천히 다시 한번 분석을 해보시면 뭐 생각보다 그렇게 어마어마하게 어렵진 않아요 얘는 이제 결국에는 이 이름을 그냥 편하게 사용하기 위해서 그냥 아이디만 사용해도 , 사실, 이 나머지 코드는 상관없지만 이름이랑 아이디를 맵핑 시켜주기 위해서 이 첫 번째 두 개의 변수가 만들어진 거고 이 락 스택이라고 하는 거는 우리가 실시간으로 락을 해줬다가 언락해주고 락을 해줬고 언락해줬고 이거를 계속 추적을 하기 위해서 이 팝 락 푸쉬랙을 이 스택에다가 계속 넣어 줘 가지고 이 아이디를 추적을 하고 있는 겁니다 그 다음에 락을 잡았을 때 내가 지금까지 보지 못했던 예를 들면 1번 락을 잡은 다음에 4번 락을 잡으려고 하는데 그걸 내가 아직 한 번도 트라이하지 않은 상황이라고 한다면 이제 걔를 넣어준 다음에 사이클이 일어나는지를 , 이렇게, 매번 마다 체크를 하고 있는 거죠 그래서 결국에는 이 체크 사이클은 DFS를 빵 돌릴 건데 DFS를 돌리기 위한 사전 준비를 하고 DFS를 이제 전형적인 DFS 5를 실행해가지고 DFS를 빵 돌리는 상황이 되었고 DFS를 돌림과 동시에 원래는 여기가 이제 아까 PPT로 기준으로는 Discovered 배열인데 Discovered가 아니라 그냥 Visited 배열이었는데 얘를 이제 내가 찾은 순서라고 해가지고 발견 순서를 이제 계속 추적을 할 거에 될 겁니다 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 이런 식으로 얘를 이제 계속 추적을 할 것이고 그 다음에 이제 DFS를 계속 돌리다가 결국에는 순방향 간선이 일어난 상황이라고 한다면 아무 문제가 없지만 역방향 간선이 일어났다고 한다. 즉 순방향이 아닌 뿐만 아니라 교차 간선도 아니다. DFS가 아직 완벽하게 종료가 되지 않았는데 역으로 가는 길을 발견했다고 하면 역방향 간손이 있는 거고 역방향 간손이 있었다고 하면 결국 그래프 알고리즘에서 사이클이 일어난 상태이다라는 얘기가 되는 거니까 여기서 크래쉬를 빵 때린 그런 부분이 들어갔습니다 , 자, 이렇게, 해가지고 굉장히 길었는데 락에 대한 데드락을 잡는 여러가지 방법들을 보여 드리면 좋을 것 같아 가지고 좀 간단하게 , 일단은, 넣어 봤구요 , 이렇게, 해가지고 뭐 오늘 준비한 내용은 , 일단은, 마치도록 하겠습니다 안녕하세요 제가 이제 미래에서 먼 미래에서 돌아왔는데 제가 이제 강의를 찍을 때 살짝 실수한 것이 하나가 있습니다 이 데드락 프로파일러를 원래 제 라이브러리에서 만들 때는 얘를 TLS 전용에다가 사용을 하다가 이걸 강의 코드에서 글로벌로 살짝 바꾸면서 하나를 누락한 것이 있는데 여기 락 스택 같은 경우에는 스레드마다 지금 잡고 있는 락이 각각 다르겠죠? 그렇기 때문에 스레드마다 고요하게 하나씩 갖고 있어야 됩니다 이 부분을 , 일단은, 살짝 제가 누락을 했는데 그래가지고 나중에 나중에 가다 보면은 여기 내부적으로 락 스택을 하나만 관리하는 게 아니라 스레드별로 하나씩 들고 있게끔 , 이렇게, 유도를 해주게 될 거예요 근데 나머지 히스토리와 관련된 부분은 그냥 공용으로 관리해도 되니까 나머지 부분은 바뀌지가 않을 겁니다 그래서 이 부분만 바뀔 것이다 라는 걸 미리 언급을 드릴게요 혹시라도 뭔가 코드를 보다가 조금 의아한 부분이 발견을 했다라는 그런 성견 지명을 가지신 분이 있다면 굉장히 좋은 현상입니다. 네, 그래서 살짝 문제가 있는 게 맞고 이 부분은 나중에 수정될 것이라는 걸 예고를 드리고 넘어가도록 할게요.