자, 이렇게, 해서 길고 길었고 굉장히 어려웠던 그런 lock-free-queue, lock-free-stack에 대한 내용을 일단 어느정도 마무리를 지었구요 어 강의를 다시 제가 찍은 걸 좀 보다 보니까 제가 말실수를 하나 하는게 있는데 요 부분에서 PTR이 널이 아니라 데이터가 널인건데 제가 좀 말실수를 했습니다 뭐 약간 디테일이었고 그건 그렇고 이제 이거를 작성하다 보니까 느낀건데 역시 이해하기가 굉장히 어렵죠. 그래서 웬만해서 저는 이런 락프리 프로그래밍을 제 코드에는 딱히 집어 넣지 않습니다. 이런 락프리 큐, 락프리 스택을. 그런데 물론 굳이 락프리 큐나 스택을 사용하신다고 하면 직접 만들어서 쓰기 보다는 이제 마이크로소프트에서 제공하는 그런 라이브러리들을 이용해 가지고 최대한 사용을 하시기를 추천을 드립니다. , 자, 그건 그렇고 이제 여기 있는 내용을 싸그리 다 삭제를 하고 이제 이어가지고 오늘은 조금 우리 서버 엔진 좀 진도를 한번 나아가려고 합니다 오랫동안 새로운 내용만 공부를 하다보니까 좀 지겹죠 그래서 이제 좀 본격적으로 다음 내용에 대해서 알아볼 건데 , 일단은, 우리가 Thread에 대해서 Thread 표준 라이브러리에 대해서 계속 알아보면서 이제 이걸 사용하는 방법에 대해서 알았는데 물론 이거를 이제 고지곳대로 그냥 Thread를 여기서 , 이렇게, 만들어 가지고 사용을 해도 뭐 안될 건 당연히 없지만 나중에 가면은 TLS에도 굉장히 많은 데이터가 들어가게 될 건데 그걸 이제 좀 묶어서 관리를 하면 굉장히 좋지 않을까라는 생각이 듭니다 그래가지고 이제 서버 코어 쪽에다가 스레드를 관리할 수 있는 스레드 매니저를 만들어 줄 것이고 그리고 겸사겸사 이쪽 코어에서 사용하는 뭐 그런 전역 변수라거나 아니면 TLS 변수라거나 아는 매크로 라거나 하는 등등 온갖 것들을 다 관리하는 부분을 이제 본격적으로 만들어 보겠습니다 , 자, 그래서 우클릭 추가 새 필터를 간 다음에 , 일단은, 뭐 딱히 이름이 생각이 안나가지고 메인이란 이름으로 , 일단은, 이렇게, 만들어 줄 것이고요 그 다음에 여기 사실은 여기 사용하고 있는 P스위치나 타입이나 코 이런 것들이 , 사실, 유티라고 하긴 좀 뭐하고 이게 약간 어... 실행하는 부분이랑 관련이 있는 거니까 이걸 일단 메인에다가 옮기고 유틸은 뭐 xml이라던가 하는 그런 진짜로 유틸성의 파일들을 나중에 이제 여기다가 배치를 해놓겠습니다 뭐 대충 , 이렇게, 바꿔놓도록 하고 , 자, 그 다음에 타입에 가가지고 여기 보면은 지금 우리가 여기서 여기까지 정리를 해놨는데 이제 앞으로 좀 자주 활용할 것 같은 애들을 여기서 , 일단은, 정리를 해놓도록 하겠습니다 , 자, 일단은, 여기다가 mutex를 추가를 해주시고 그 다음에 여기서 이제 자주 활용이 될 애들 중에서 어... 아토믹 타입을 일단 , 이렇게, 추가해 주도록 하겠습니다 어 물론 이 아토믹을 그냥 표준의 아토믹을 SE 아토믹으로 써도 당연히 문제는 없지만 이런 뭐 아토믹, 뮤텍스, 컨디션 베라블 등등을 혹시라도 우리가 직접 만들어서 사용하고 싶을 경우도 생길 수도 있겠죠 네 그러다 보니까 이걸 , 이렇게, 한 번 더 이 type define을 통해 가지고 using으로 이름을 별칭을 붙여 가지고 사용을 하도록 하겠습니다 예를 들면 , 이렇게, 이제 이 대문자 뮤텍스로 우리 코드에서 사용을 하다가 혹시라도 이 mutex가 아닌 다른 버전을 사용하고 싶다고 하면 이 부분만 살짝 바꿔치기 하면 모든 부분에 적용이 되겠죠. 그런 마인드로 일단 , 이렇게, 지금 별칭을 붙여가지고 사용을 하고 있는 거고요. 참고로 여기서 using을 사용하는 경우에 굉장히 좋은 점이 , 이렇게, 템플릿을 대상으로도 작동을 잘합니다. type define이랑은 좀 다르게 이 부분도 이제 기억을 해주시면 좋을 것 같고 그 다음에 condition variable도 condition 그리고 또 뭐가 있을까요 유닉 락 유닉 락 뮤텍스 버전으로 그냥 기본적으로 넣도록 하고 그 다음에 마지막으로 락가드 까지만 넣어주도록 하겠습니다 락가드 어 sd 뮤텍스 유니크 어 이정도면 필요 , 일단은, 뭐 또 필요한게 있으면은 나중에 추가를 하시도록 하고 대충 이쯤에서 만족을 하도록 할게요 일단 당장은 컨디션 베레블 사용하려면은 락가드로는 안되긴 하죠 다른 가드를 이용해야 되니까 이건 나중에 추가를 하도록 하고 그 다음에 메인에다가 클래스를 추가를 해줄 건데 , 일단은, core-global 이라고 해가지고 , 이렇게, 전역으로 사용하는 변수들을 관리할 것이고 그 다음에 또 추가 이어가지고 core-tls 라고 해가지고 말 그대로 쓰레드에서 사용할 tls 들을 관리하는 파일을 하나를 만들어 줄 것이구요 그 다음에 추가 이번에는 새 항목에 가서 헤더만 필요하니까 새 항목으로 헤더만 만들어 줄 건데 core.macro 라고 해가지고 온갖 그런 매크로들을 다 이 파일에다가 넣어 주도록 하겠습니다 그 다음에 이 아이들을 , 일단은, 드래그 드롭으로 넣어 주도록 하고 , 자, 일단 이어서 작업을 해보자면 type.define은 대충 끝났고 그 다음에 core-tls 같은 경우에는 이제 Thread별로 갖고 있는 그 TLS 영역에 해당하는 건데 , 일단은, 오늘 당장 넣어 줄 거는 , 이렇게, l-thread-id 라고 해가지고 Thread-id 를 우리가 직접적으로 만들어서 관리를 하도록 합시다. 그냥 물론 표준에도 ThreadID를 추출하는 그런 기능이 있긴 하지만 그게 1, 2, 3, 4로 쭉 이어지는 게 아니라 주구 난방으로 가다 보니까 그 부분이 좀 마음에 안 들어서 우리가 직접적으로 아이디를 생성 순서대로 관리를 해주도록 할게요. 그래서 , 일단은, 이렇게, LthreadID라는 ThreadLocal 변수 하나만 만들어줄 거지만 여기서 이제 우리 코드가 네트워크나 기타 등등 기능들이 들어감에 따라서 이 내용이 쭉 늘어나게 될 겁니다. 그래서 이 내용이 굉장히 늘어나게 될 것이고 , 자, 그 다음에 잠시 core.psh 돌아가가지고 여기다가 , 일단은, 순서 type.define이 맨 먼저 와야 되고요 그 다음에 순서는 딱히 상관없지만 macro도 넣어주고 그 다음에 tls도 넣어줄 것이고 아이고 대문자를 했네요 그 다음에 global 변수들도 다 , 이렇게, include를 하도록 하겠습니다 , 자, 그래가지고 일단 TLS도 완성이 됐고 뭐 PCH도 대충 넣어준 것 같구요 그 다음에 매크로 같은 경우에는 여기다가 이제 우리가 사용할 그런 뭐 define 같은 걸 다 넣어 줄 건데 예를 들면은 뭐 오늘 그냥 간단하게 몇 개만 넣어 보도록 하겠습니다 크래쉬가 만약에 일어나야 된다 예를 들면 지금 이게 어떤 상황이냐면은 여기서 우리가 어떤 상황에 대해서 크래쉬를 내고 싶다고 가정해 볼게요 어 그러면은 우리가 인위적으로 크래쉬를 내고 싶다고 해가지고 막 엉뚱한 수제를 막 , 이렇게, 하다보면은 이게 크래쉬가 안나고 애당초 컴파일 단계에서 얘를 잡아버리는 문제가 살짝 발생할 수 있습니다 그래가지고 여기 define macro에서는 우리가 인위적으로 크래쉬를 내고 싶은 상황에 대해서 이제 뭔가 작동하게끔 만들어줄건데 예를 들면 , 이렇게, 만들어줄 수가 있어요 , 자, 여기서 어.. 에고 여기다가 define이 여러 줄에 이어서 하기 위해서는 여기다가 backslash를 , 이렇게, 적어주면 됩니다. 줄은 맞춰줄 필요 없지만 조금 이쁘게 하기 위해서 줄도 맞춰주도록 할 거고요. 그 다음에 여기다가 analysis, 이거 assume이라는 거를 이걸 해주면 이게 nullpoint가 아니라고 가정을 하라고 우리가 힌트를 주고 있는 겁니다. , 이렇게, 하면 컴파일러가 우리가 여기다가 crash를 여기다가 입력을 하는 부분에서 얘가 혹시라도 널을 넣었다거나 하는 그런 온갖 상황에 의해 가지고 얘가 알아서 컴파일러가 에러를 잡아주는 게 아니라 얘는 그냥 , 일단은, 널 PTR이 아니라고 가정을 하라고 우리가 지금 요청을 해주고 있는 거예요. 왜냐하면 그게 아니라고 하면은 여기 우리가 널 포인터로 넣어준 다음에 얘를 접근하려고 하면은 컴파일러가 잡아줄 수가 있겠죠 그걸 거꾸로 근데 그게 아니라 이런 식으로 Analysis Assume을 중간에 끼워넣게 되면 여기 위에서 사용한 이 crash라는 포인터 변수가 null이 아니라고 우리가 컴파일러한테 거짓말을 하고 있기 때문에 얘가 아무런 에러 메시지나 경고 없이 통과를 시켜줍니다. 그다 보면 여기다가 우리가 어떤 값을 넣으려고 하면 이 코드가 실행이 됨과 동시에 바로 여기서 뻗게 되겠죠. 그래서 뭐 이런 식으로 일단 사용할 수가 있어요. 일단 사용해보기 위해서 잠시 서버코를 딜드를 해준 다음에 그 다음에 이쪽에 가가지고 예를 들면 크래쉬라고 한 다음에 테스트라고 , 이렇게, 한번 실행을 해보도록 하겠습니다 그 다음에 여기다가 코어 매크로를 , 이렇게, 한번 사용을 해보도록 할게요 그러면 요 부분에서 이제 실행을 해보면은 얘가 실행하다 말고 짜잔 하고 , 이렇게, 여기서 바로 우리가 크래쉬를 낸 거 볼 수 있는데 뭐 , 이렇게, 인위적인 크래쉬를 내고 싶을 때 뭐 사용하는 매크로를 그냥 간단하게 한번 만들어 봤습니다 뭐 이제 이런 온갖 것들이 다 여기다가 이제 추가 된다고 보시면 되겠어요 , 자, 그 다음에 좀 , 이렇게, 이쁘게 나중에 가면 또 여기도 내용이 굉장히 많아질 수 있기 때문에 뭐 , 이렇게, 영역을 좀 집어 가지고 여기다가 크래쉬 관련이라고 , 이렇게, 영역을 한번 찝어 주도록 하겠습니다. 이거는 그냥 별다른 기능은 아니에요. 그냥 이쁘게 하기 위해서에요. 나중에 그러면 크래쉬뿐만 아니라 멀티스레드, 네트워크 등등 온갖 매크로가 추가가 될 예정입니다. 그리고 마찬가지로 이런 걸 몇 개를 더 늘려 줄 수 있겠죠. 예를 들면 Assert Crash라고 해가지고 얘는 어떤 엑스프레션에 대해서 말 그대로 이 값이 true인지 아닌지를 체크해 가지고 조건부로 크래쉬를 내고 싶다 라고 하는 상황이 생길 수 있겠는데 뭐 그런 경우에 사용할 수 있는 매크로도 , 이렇게, 일단은, 추가를 해주도록 하겠습니다 , 자, 이렇게, 백 슬래쉬도 이쁘게 이쁘게 넣어 주도록 하고 크래쉬 Assert Crash가 원인이었다 라고 그냥 힌트를 주고 있는 거고 얘도 Analysis Assume 을 이용해 가지고 괜히 이상한 쓸데없는 경고를 주지 말아달라고 요청을 추가로 해주도록 할게요. , 자, 그 다음에 한 번 더 , 이렇게, 닫아주도록 하겠습니다. 그럼 이제 Asset Crash 같은 것도 우리가 충분히 어떤 조건을 확인하고 싶을 때 예를 들면 A가 3인지 아닌지 체크하고 싶다고 할 때 뭐 이런 식으로 사용할 수 있겠죠 만약에 얘가 너리가 3이 아니라고 하면은 Crash가 나게끔 , 이렇게, 유도를 해줄 수가 있을 겁니다 뭐 , 이렇게, 가지고 , 일단은, 간단하게 이게 지금 뭐하는 파일인지는 이해하시겠죠? 그래서 이런 식으로 매크로를 관련된 부분들을 다 여기다가 넣어줄 것이다 라는 얘기를 하고 있는 거고요 , 자, 그 다음에 오늘의 , 사실, 메인이라고 할 수 있는 코어 글로벌 쪽으로 , 일단은, 넘어갈 것인데 얘 같은 경우에는 이제 뭐 진짜로 말 그대로 전역으로 사용할 그런 매니저류의 클래스들을 다 여기다가 넣어 줘 가지고 사용을 하도록 하겠습니다 그래서 오늘 일단 당장 추가가 될게 Thread 관련된 Thread Manager를 여기다가 일단 추가를 해줄 건데요 , 일단은, 이렇게, 새로운 필터를 만들어 가지고 Thread 관련된 애들, 락이라거나 락 프로파일러, 데드락 체크하는 기능 아니면 뭐 Thread Manager 같은 애들을 이 폴더에다가 다 넣어주도록 하겠습니다 , 자, 그래서 Thread Manager를 추가를 해준 다음에 , 일단은, 여기다가 , 이렇게, 집어넣고 시작을 해주도록 할게요 일단 오늘 만들어줄 쓰레드 매니저는 뭐 딱히 어마어마한 기능을 하는 건 아니고요 그냥 간단하게 우리가 지금까지 배웠던 그 표준 쓰레드들을 관리하고 있는 그런 매니저를 일단 만들어 보도록 하고 나중에 무 추가적인 기능이 필요하면 여기다가 일단 집어 넣도록 하겠습니다 그래서 일단 쓰레드 관련 기능이니까 쓰레드를 추가하고 그 다음에 functional 이라고 해가지고 콜백 함수에서 우리가 사용할 이 함수 SD 펑션을 사용할 수 있게끔 이 라이브러리를 일단 추가를 해줄 것이고요 , 자, 얘가 뭐하는지는 이제 곧 이어서 나올 테니까 , 일단은, 그냥 넘어가시면 되고 , 자, 이렇게, 생성자 소멸자를 만들어 주도록 하겠습니다 그 다음에 , 일단은, 멤버 변수로는 mutex 를 잡기 위한 이 lock을 잡기 위한 하나의 변수와 그 다음에 얘가 들고 있는 thread 목록을 , 이렇게, 벡터로 들고 있도록 할게요 , 이렇게, 만들어 주고 그 다음에 함수는 , 일단은, 런치라고 해가지고 어떤 함수를 , 이렇게, 콜백 함수를 받아 줌과 동시에 이 스레드들을 실행하는 부분을 , 이렇게, 만들어 줄 것이고 그 다음에 조인이라고 해가지고 우리가 sd 스레드에서 조인을 하면은 걔가 끝날 때까지 기다려주는 그 조인을 얘기하고 있는 겁니다 그 다음에 , 사실, 이 매니저를 만들어 준 핵심 이유는 , 이렇게, 쓰레드를 새로 만들어 준과 동시에 우리가 원하는 그런 TLS 영역을 초기화 하는 부분들을 만들어 주고 싶기 때문에 얘를 추가한 것이기 때문에 TLS 을 초기화하고 날리는 부분을 , 이렇게, 만들어 주도록 할게요 , 자, 그럼 이제 반대쪽으로 cpp 로 넘어가 가지고 일단 여기다가 코어 TLS 를 추가를 해 줄 것이고요 그 다음에 나중에 필요하니까 코어 글로벌도 여기서 뭔가 , 이렇게, 사용하도록 넣어 주도록 하겠습니다 그 다음에 , 일단은, Thread Manager 얘 같은 경우에는 뭐 딱히 어마어마한 기능을 하는 건 아니고 일단 메인 Thread도 어찌됐건 TLS 를 사용하긴 할 거니까 메인 Thread 초기화를 여기서 , 일단은, 해 주도록 할 거고 그 다음에 소멸자도 마찬가지로 얘 같은 경우에는 그냥 조인을 해가지고 기다리도록 유도를 해주도록 하겠습니다 나머지는 그냥 자동완성으로 만들어 주도록 할게요 손이 너무 아프네요 오케이 만들어 줬고 그 다음에 어 여기도 이제 뭐 당연히 뭐 필수적인 건 아닌데 나중에 하나의 파일에서 클래스가 여러 개가 있을 수 있기 때문에 뭐 이런 부분들도 저는 개인적으로 좀 , 이렇게, 선을 그어 가지고 , 이렇게, 주석을 어 해주면은 나중에 좀 보기가 편하더라구요 경험상 그래가지고 좀 미관상의 이유로 그냥 얘도 똑같이 , 이렇게, 넣어 주도록 하겠습니다 , 자, 그 다음에 어 여기 런치하는 부분이랑 조인도 아이고 얘네들 안만들어 줬네요 , 자, 런치랑 조인 아이고 컨트롤 점 엔터 조인도 요렇게 만들어 줄 것이고 , 자, 일단은, 런치하는 부분은 우선 락가드를 , 이렇게, 걸어주도록 하겠습니다. 락을 걸어준 상태에서 얘를 동시다발적으로 여러명이 혹시라도 실행할 수 있을테니까 뭐 그런 경우는 많이 없겠지만 혹시 모르니까 , 이렇게, 걸어주고 말 그대로 우리가 배운 스레드 표준 스레드를 그냥 실행을 시킬겁니다. 그 다음에 람다를 적어주고 얘가 하는 부분은 굉장히 단순한데 처음에 스레드가 만들어줬으면 이니TLS를 먼저 호출하고 그 다음에 우리가 콜백으로 넘겨준 그 함수를 실행한 다음에 그 함수가 종료되었으면 디스토리 TLS까지 해가지고 TLS를 정리하는 코드를 일련으로 넣어줄 것이고 사실상 우리가 지금까지 사용할 때는 , 사실, 이 콜백만 사용했던 걸 앞뒤로 TLS를 초기화하고 날려주는 부분을 우리가 , 이렇게, 같이 낑겨 넣어준 겁니다 이제 우리의 그 코어 라이브러리에서는 우리가 사용할 TLS가 초기화 된 상태로 뭔가가 만들어져야 되기 때문에 그 부분이 일단 추가가 되었다고 보시면 되겠어요 나중에 사용하는 걸 보면 이제 간단하고 그 다음에 이 SD Function 이 Function을 라이브로에 추가한 이유가 결국에는 이것 때문이었는데 얘가 이제 뭐 Lambda 뿐만 아니라 함수 포인터도 받을 수 있고 그냥 온갖 함수 형태를 다 받아줄 수 있기 때문에 어지간해서 함수 포인터 같은 걸 사용하지 않고 이 SD Function을 사용하는 게 좋습니다 그래서 얘가 받아주는 거는 input은 void, output은, 반환은 void를 받아주는 그런 일반적인 함수 이런거죠 보이드 보이드 이런 함수를 콜백으로 넣어주면 얘가 이제 알아서 Thread를 만들어주고 그 부분을 실행을 해줄겁니다 네 , 이렇게, 해가지고 , 일단은, 뭐 만들어졌구요 , 자, 그 다음에 조인 같은 경우에는 뭐 얘 같은 경우에는 그냥 이 스레드들을 하나씩 하나씩 순회를 하면서 진행인 삭제를 해주도록 할까요 네 그 다음에 만약에 조인업을 상태라고 하면은 키점 조인을 해주고 그 다음에 최종적으로 Thread를 클리어를 해주도록 할게요. 이거는 우리가 지금까지 계속 알아본 표준 std Thread 라이브러리를 기능들을 다 활용하고 있는 겁니다. 그 다음에 iniTLS 같은 경우에는 지금은 뭐 딱히 많이 필요 없고 Thread 아이디를 뭔가 어떤 값으로 우리가 초기화를 해준 부분이 필요한데 그냥 1부터 시작해가지고 쭉 올라가는 식으로 만들어 주도록 하겠습니다. Atomic 변수로 s-thread id라고 해서 1번부터 시작하는 전역 변수를 만들어 준 다음에 얘가 사실상 이 id 발급기의 역할을 해주게 될 겁니다. 1씩 계속 증가하면서 1,2,3,4,5,6,7,8 이런 식으로 증가하게 될 겁니다. 그 다음에 디스트로이 TLS는 지금은 딱히 필요 없지만 나중에 혹시 여기서 뭔가 동적으로 생성되는 그런 애가 있다고 하면은 여기서 이제 날려주면 되겠습니다. , 자, 이렇게, 해가지고 굉장히 단순하게 매니저를 만들어 봤고요. 그 다음에 이제 이 매니저를 싱글톤으로 만들어서 사용해도 되고 온갖 방법이 당연히 있긴 하겠지만 여기다가 게임 서버 우리가 사용할 컨텐츠 쪽에서 이거를 관리해가지고 만들어주고 뉴 딜리트를 해주고 이런 코드를 넣기가 조금 그렇죠 왠지 엔진 쪽에서 이것도 같이 관리할 수 있게 만들어주면 좋을 것 같으니까 그래가지고 코어 글로벌이라는 파일이 존재하는 겁니다 뭐 예를 들면 , 이렇게, 만들어줄 수 있을 거예요 스레드 매니저를 전방선언을 한과 동시에 , 이렇게, gthreadmanager라고 해가지고 전역변수가 하나가 있다고 지금 , 이렇게, 선언을 해주고 있구요 그 다음에 어.. 꼭 글로벌쪽에 돌아가가지고 threadmanager를 헤더를 추가해준 다음에 , 자, threadmanager가 gthreadmanager가 , 이렇게, 어.. 등장한다고 여기서 이제 구현부를 넣어주면 되겠습니다 그리고 코어 글로벌 같은 경우에는 왜 넣어 주냐면요 이제 나중에 매니저가 여러 개가 등장할 수도 있는데 그 매니저끼리 뭐 순서가 있을 수도 있겠죠? 쓰레드 매니저가 먼저 만들어지고 그 다음에 삭제할 때는 반대로 뭐가 먼저 삭제되고 하는 순서를 우리가 맞춰줘야 되는 경우 생길 수도 있으니까 그거를 이 코어 글로벌 내부에서 해주도록 하겠습니다 생성자에서는 지금은 딱히 매니저가 뭐 하나밖에 없으니까 말 그대로 쓰레드 매니저를 초기화하는 요 부분을 만들어 주는 부분을 여기다가 넣어 줄 것이고 그 다음에 마찬가지로 이런식으로 삭제가 되는 부분은 얘가 , 이렇게, 해주면 되겠죠. delete gthreadmanager를 통해 삭제를 해주도록 하겠습니다. 나중에 매니저가 여러개가 추가되면 이 부분을 순서를 잘 맞춰주면 되겠고 그럼 이제 사용하는 쪽에서는 여러가지 방법이 있겠지만 예를 들면 여기 컨텐츠 단에서 얘를 사용하고 싶으면은 그냥 전역으로 코어 글로발 변수를 뭐 , 이렇게, 하나를 뚝 만들어주게 되면은 생성자가 알아서 호출이 되면서 이 매니저를 추격하고 날리는 부분들이 이제 자동으로 실행이 될겁니다 뭐 , 이렇게, 응용할 수가 있겠죠 그래가지고 어 여기있는 코드가 들어간 이유가 , 사실, 그런 이유였구요 어 , 이렇게, 했으면은 , 자, 이제 진짜진짜 뭐 더 넣을거 없는지 살펴봤는데 뭐 대충 끝난거 같구요 코어 b스위치 끝났고 오케이 오케이 그러면은 , 자, 여기서 이제 결국에는 서버코를 한번 빌드를 한 다음에 매니저쪽에서, 그니까 컨텐츠단에서 간단하게 테스트를 해보기 위해서 뭐 이런식으로 사용할 수 있을겁니다. 예를 들면은 여기다가 ThreadMain함수를 만들어 줄 것이고 그 다음에 뭐 대충 안녕 헬로우 아이엠 스레드 나는 몇번 몇번 스레드다 라는 로그를 찍어 보도록 할게요 이런 느낌으로 그 다음에 너무 많이 찍으면 좀 그러니까 디스 스레드 슬립 포 1 세컨드 1초 동안 잠들고 무한 루프를 실행하도록 하고 뭐 요런 애들을 한 5개만 만들어 보도록 하겠습니다 이제 사용하는 방법은 gthreadmanager의 런치를 통해 가지고 thread main을 , 이렇게, callback 함수로 넣어준 다음에 gthreadmanager에서 조인을 해가지고 얘들이 끝날 때까지 기다리는 식으로 만들어주면 되겠죠 이 부분에서 Include Thread Manager는 똑같이 들어가야 될 겁니다 , 이렇게, 만들어주면 완성입니다 그래가지고 다시 빌드를 해주면 통과가 되었구요 이제는 결국에는 우리 서머코드 내부에서 이런 초기화 코드는 다 알아서 순서적으로 관리를 해줄 것이고 우리는 이렇게만 사용을 하면 된다는 얘기가 되는 거죠 아 참고로 여기 헬로월드는 이제 필요 없으니까 요 부분은 날려주도록 하겠습니다 얘는 이제 필요 없으니까 날려 주도록 할게요 코어 BCH에서 얘를 날려주고 오케이 빌드 , 자, 그러면 이제 이 상태에서 다시 실행을 해보면 , 사실, 별건 안했고 지금까지 뭐 만들었던 기능들을 그냥 이쁘게 랩핑을 해가지고 편하게 매니저에서 관리할 수 있게끔 만들어 준 겁니다 메인 스레드가 1번이고 나머지가 2번부터 6번까지 차지하고 있고 뭐 이런식으로 지금과 마찬가지로 잘 동작한다는 거 , 일단은, 확인을 할 수가 있었어요 , 이렇게, 해서 굉장히 단순하게 Thread Manager를 만들어 봤구요 이제부터 이런식으로 조금씩 조금씩 코드를 쌓아 올리는 식으로 작성을 해보도록 하겠습니다 이제 다음 시간에는 리더라이터락 이라고 해서 우리가 메인으로 사용할 mutex 를 직접 한번 구현을 해보는 시간을 가져보도록 할게요. 이 표준 mutex 를 사용해도 안될 건 없긴 한데 이 mutex 같은 경우에는 완전히 상호 베타적 이어가지고 얘를 이제 중첩해 가지고 사용할 수 없을 뿐더러 완전히 상호 배타적이기 때문에 이 mutex를 걷는 순간 다른 애들은 아예 접근을 못하게 되는 문제가 있어요 그래가지고 이거 말고 리더라이터 버전으로 그리고 중첩해서 사용할 수 있게끔 유도를 해서 우리가 좀 편하게 코드를 관리할 수 있게끔 이제 만들어 보는 시간을 가져보도록 하겠습니다 , 자, 일단은, 이렇게, 해가지고 ThreadManager에 관련된 코드는 , 일단은, 여기까지 , 일단은, 간단하게 마치도록 할게요.