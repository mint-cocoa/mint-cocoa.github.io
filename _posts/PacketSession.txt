자, 이렇게, 해서 우리가 지난 시간까지 샌드 버퍼 풀링에 대한 내용에 대해서 알아봤구요 샌드 버퍼 청크라고 해가지고 굉장히 큰 메모리 덩어리를 한번 할당을 받은 다음에 그거를 열심히 쪼개 가지고 샌드 버퍼로 쓰는 뭐 그런 방법에 대해서 , 일단은, 실습을 해봤습니다 그리고 샌드 버퍼 매니저에서는 이런 식으로 TLS 영역에다가 샌드 버퍼 청크를 물고 있기 때문에 어지간해서는 얘를 교체할 때 빼고는 뭐 딱히 스레드끼리 경합이 일어나지 않는다는 장점도 알아봤습니다 이런 식으로 TLS를 이용하면 굉장히 좋아요 그리고 여기 있는 수치는 나중에 후반부에 가서 좀 크게 크게 설정을 해주면 , 일단은, 더욱더 경합을 줄일 수가 있겠죠 , 자, 이어가지고 오늘 알아볼 내용은 뭐냐면은 이 샌드 버퍼 이쪽 샌드에 대한 내용에 대해서 조금 더 언급을 드릴게 있어 가지고 몇 개를 더 다뤄보고 그 다음에 Packet Session 이라는 아이에 대해서 알아본 다음에 최종적으로 지난번에 했던 작업 중에서 , 사실, 버그가 하나가 있는데 그 부분에 대해서 언급을 하고 수정을 해보도록 할게요 , 일단은, 샌드 쪽에서 제가 간단하게 언급을 드리고 싶었던 게 뭐냐면은 지금 , 이렇게, sand-q라는 거에다가 데이터를 넣고 그 다음에 내가 처음으로 들어와 가지고 샌드 리지스터드가 아직까지는 false인 상태다 아직은 누구도 샌드를 걸어주지 않은 상태라고 하면은 내가 실행하겠다라는 코드를 , 이렇게, 만들어 놨습니다 이것도 당연히 괜찮은 방법이에요 그리고 뭐 경우에 따라서 샌드큐를 락프리로 만든다거나 하는 식으로도 만들어도 되구요. 근데 제가 이제 C샵 서버랑은 조금 흐름이 달라졌는데 이게 처음부터 다르게 만들어 버리니까 사람들이 너무 헷갈려 해가지고 , 일단은, 좀 직관적으로 , 이렇게, 만들어 놨는데 여기서 굳이 조금 마음에 안 드는 부분을 꼽아 보자면 결국은 , 이렇게, 락을 통으로 잡으면서 데이터를 넣고 그 다음에 리지스터까지 호출을 해주고 있으니까 만약에 리지스터 샌드가 뭐 이런 저런 사유로 요 부분이 조금씩 오래 걸린다 특히 핸들 에러까지 호출이 되어 가지고 또 타고 타고 들어가 가지고 뭐 다른 코드를 막 실행하고 있다고 하면 결국엔 돌고 돌아 가지고 그 다음에 샌드를 하던 애들이 좀 불필요하게 오래 기다려야 될 수도 있겠죠 그래서 요런 부분을 조금 더 개선을 해주자면 제가 이전에 C샵 서버에서 만든 코드는 약간 이런 식으로 흐름이 됩니다. , 일단은, 커넥션이 맺어져 있는지 isConnected 체크를 , 일단은, 해서 false면 일단 리턴하는 부분은 안전하게 넣어주도록 하고 그 다음에 stack 메모리에다가 내가 보내야 될지를 여부를 , 이렇게, 들고 있도록 할게요. 그 다음에 락을 전체로 물고 있지 않고 좀 부분적으로만 락을 걸고 있게 유도를 해주도록 하겠습니다 일단 이 코드를 복붙한 다음에 리지스터 샌들을 여기 자체에서 하는게 아니라 얘를 밖으로 , 이렇게, 빼주도록 하겠습니다 이런 느낌으로 그리고 여기서는 리지스터 샌들을 프로로 , 이렇게, 바꿔주면 되겠죠 요 아이는 스택 메모리에 있는 거니까 , 일단은, 얘가 세팅이 되었다고 하면은 내가 , 일단은, 선점을 해서 리지스터를 하겠다라고 일단 선언을 한 셈이고 그 다음에는 락을 풀어준 다음에 느긋하게 리지스터 샌들을 호출해 주게 될 거예요 물론 내부에서 다시 보면은 똑같이 샌드큐에 접근할 때는 잠시 락을 걸어준 상태에서 다시 데이터를 빼오기는 하지만 요 부분까지도 끝났다고 하면은 이제 여기서 스케터 개더를 하기 위해서 WSA 버퍼를 만드는 부분이라거나 하는 요런 나머지 부분들은 이제 락을 걸지 않고 나만 하고 있겠죠 그럼 나머지 애들은 내가 얘를 실행하는 동안에 큐에 접근해가지고 계속 데이터를 밀어 넣는 식으로 조금 같이 작업을 할 수 있게 될 거예요 그래가지고 뭐 요런 식으로 조금 더 개선을 하면은 너무 오래 락을 물고 있는 그런 부분도 약간 해결할 수 있다 좀 더 개선할 수 있다라는 얘기가 되는 거고 이전에 C샵 서버 같은 경우에는 요런 느낌으로 제가 코드를 만들어 놨습니다 근데 이제 그러다 보니까 굉장히 질문이 많이 올라오더라구요 왜 락을 잡지 않고 밖으로 , 이렇게, 빼서 했느냐 이 리지스터 샌들을 안에서 하지 않았느냐 라는 질문이 올라와 가지고 , 이렇게, 투스텝으로 고쳐봤다고 , 일단은, 받아주시면 되겠습니다. , 일단은, 이 코드는 , 이렇게, 냅두도록 할게요. , 자, 그리고 이제 오늘 이어가지고 또 굉장히 중요한 내용인 Packet Session에 대한 내용을 다뤄보도록 할 건데요. 일단 Session을 복사해가지고 여기 주석을 Packet Session이라는 이름으로 만들어 놓도록 할게요 이거는 이제 c-shop 서버에서도 비슷한 아이가 등장을 했었죠 , 자, 얘가 왜 필요한지 , 일단은, 언급을 드리자면 어 이건 이제 받는 쪽이랑 관련이 있습니다 물론 보내는 쪽에서도 신경을 쓰긴 해야 되는데 지금 우리가 onReceive라는 거를 할 때 여기서 최종적으로 onReceive가 끝날 때 이 int32를 어 받아주고 있죠 프로세스 렌스라고 해가지고 이 데이터 중에서 얼마만큼을 처리했느냐를 , 이렇게, 뱉어주고 있습니다 그걸 이용해 가지고 우리가 실질적으로 Receive Buffer를 조절하는 부분을 만들어 놨어요 , 자, 그러면 결국에는 컨텐츠 쪽에서도 이거에 말 맞춰 가지고 이 게임 세션 쪽에서 On Receive를 할 때 내가 지금 어디까지 처리했는지를 똑같이 뱉어줘야 됩니다 근데 지금은 그냥 전체를 처리했다고 가정을 해서 , 이렇게, 만들어주고 있는데 실질적으로 우리가 MMORPG를 나중에 좀 만들게 되고 패킷이 많이 몰리게 되면 TCP 특성상 내가 보낸 모든 패킷이 한 번에 전송된다는 보정이 없다고 했었죠 보내는 쪽에서 100바이트를 보냈지만 그게 이런 저런 이유로 쪽에 가서 20바이트만 전달이 될 수도 있다는 얘기가 되겠습니다 결국에는 어떤 식으로든 모든 데이터가 성공적으로 그러니까 전체 패키지에서 다 전송이 되었는지 여부를 확인할 수 있는 수단이 필요하다는 얘기가 되는 거고 이제 그거를 하기 위해서는 우리만의 프로토콜을 정의를 해줘야 됩니다 그래가지고 뭐 어떤 식으로 이제 데이터가 끝났는지를 판별하느냐가 이제 중요한데 뭐 쉽게 생각하면은 뭐 특수 문자를 줘가지고 그 문자가 나오면은 뭐 패키지 끝났다라고 가정을 하면 되지 않을까라는 생각이 들지만 당연히 그렇게는 만들 수 없습니다 왜냐하면 내가 만약에 뭐 어떤 특정 0002를 이제 끝났다는 표식으로 만약에 사용한다고 하면은 실질적으로 데이터를 보낼 때 운 나쁘게 요 똑같은 데이터가 겹치게 된다면은 오동작하게 될 수 밖에 없으니까 이런 식으로 만들 수가 없어요 그래가지고 결국에는 MMO에서 가장 자주 사용하는 어떻게 보면 정석적인 방법은 뭐냐면은 , 자, 요렇게 , 일단은, packet header라고 해가지고 packet을 보낼 때마다 우리가 header를 만들어가지고 데이터를 추가해서 넣어줄 겁니다 그리고 얘는 대표적으로 uint16size랑 uint16id , 이렇게, 두개의 값을 넣어주는게 정석적인 방법이에요. 2바이트 2바이트 총 4바이트로 넣어줄 것이고 경우에 따라서 4바이트 4바이트 uint32로 하는 경우도 있는데 대부분의 경우에는 그냥 2바이트씩 하는게 충분합니다. 이정도로도 충분하고 요 사이즈는 이제 실질적으로 우리가 보낼 전체 패킷의 사이즈를 먼저 기입을 해줄 거고 요 아이디는 소위 프로토콜 아이디를 의미하는 겁니다 이건 나중에 정해주겠지만 예를 들면 1번은 로그인 요청이고 2번은 이동 요청이고 이런 식으로 우리만의 규약을 정해주게 될 거예요 이 아이디를 보고 이 해당 패킷이 어떤 내용을 포함할지를 예측을 해주게 될 겁니다 그러면 이 아이디만 보고서도 어떤 패킷인지 안다면 굳이 사이즈를 보낼 필요 없지 않느냐라고 생각할 수 있지만 꼭 그렇진 않아요 예를 들면 어떤 특정 패킷에 좀 가변적인 데이터가 들어가 있다거나 예를 들면 이름 같은 거 스트링 같은 정보 같은 경우는 , 사실, 이게 5바이트가 될 수도 있지만 엄청 커가지고 100바이트가 될 수도 있는 거고 게다가 주변에 있는 모든 유저들이 정보를 전달해 준다라고 할 때는 보통 우리가 코드에서는 벡터 같은 동적 배열을 사용했었는데 그런 경우라고 한다면 , 사실, 유저가 주변에 한 명도 있을 수 있지만 50명이 될 수도 있고 100명도 될 수도 있고 그건 알 수가 없는 겁니다. 그렇기 때문에 결국에는 이런 가변적인 데이터 때문에라도 반드시 사이즈를 먼저 기입을 해줘야 된다고 보시면 되겠어요. , 자, 그래서 우리 정책은 요렇게 만들어 줄 건데 사이즈 그 다음에 아이디 여기서 2바이트 2바이트씩을 먼저 기본적으로 , 이렇게, 받아 줄 것이고 그 다음에 이어가지고 요기 나머지 데이터들이 실제 패킷 데이터들이 , 이렇게, 들어가게 될 겁니다 이거를 반복해 가지고 우리가 이런 식으로 만들어 준다는 거죠 그래서 패킷이 완전하게 도착했는지 여부를 판단하려면은 먼저 요 헤더가 헤더를 먼저 파싱 해가지고 그러니까 최소 4바이트는 받은 상태에서 이 헤더를 까본 다음에 이제 이 사이즈를 추출해 가지고 내가 지금까지 받은 데이터가 최소한 이 사이즈보다는 큰지를 확인하면 되겠죠 만약에 우리가 여기까지만 받았다고 하면은 이제 내가 받은 데이터 양이 여기 패킷 헤더에 기입된 사이즈보다 작다는 얘기니까 아직까지는 이 패킷을 완전히 처리할 수 없다는 얘기가 되는 거니까 다음에 들어올 데이터까지 기다려 줘 가지고 걔네들이 이제 합쳐 줘 가지고 충분히 데이터가 들어와야지만 걔를 처리하는 식으로 만들어주면 되겠습니다. 이게 잘 이해가 안 갈 수도 있는데 코드를 만들어 보면 그렇게 어마어마하게 어렵지 않습니다. 그래서 일단 패킷 세션이라는 개념을 , 이렇게, 상속을 받아가지고 만들어줄 거고 얘는 말 그대로 우리가 정해준 패킷 프로토콜을 이용해서 만들어주는 세션이라 이거입니다. , 자, 그래가지고 뭐 간단하게 패킷 세션 생성자랑 그 다음에 버추얼 패킷 세션 소멸자도 만들고 그 다음에 패킷 세션 혹시 모르니까 레퍼런스를 뱉어주는 것도 일단 만들어주도록 할게요 GetPacketSessionRef return staticPtrCast 패킷 세션으로 Shared from this를 , 이렇게, 뱉어주면 되겠죠 이런 느낌으로 , 일단은, 만들어 줄 것이고 그 다음에 패킷 세션 레퍼런스가 아직 딱히 없으니까 이것도 마찬가지로 타입 쪽에 가가지고 추가를 해주도록 할게요 여기다가 패킷을 붙여가지고 얘만 추가를 해주면 되겠죠 얘도 class 패킷 세션 그래서 사실상 컨텐츠에서는 이 Session을 상속받아서 만들지 않고 반드시 Packet Session을 활용하게 될겁니다. , 자, 그럼 다시 돌아와서 일단 이어서 코드를 만들어보자면 이제 요 부분은 만들어놨고 , 자, 이제 다시 , 이렇게, 한 칸을 띄워가지고 그럼 Protected에서 내가 어떤 함수들을 이제 제공해야 되는지를 곰곰히 생각을 해보면 원래는 Session이라는 애가 OnReceive라는 애를 요렇게 지금 호출해주고 있습니다 근데 얘를 우리가 흐름을 가로채도록 할게요 이 OnReceive라는 걸 우리가 가로채가지고 , 일단은, 재정의를 해줄건데 어... 앞으로는 이 OnReceive를 더 이상 사용하지 못하도록 Sealed라는 걸 붙여주도록 할게요 이러면 사실상 컨텐츠단에서 Packet Session을 상속받은 애는 이 onReceive를 더이상 사용할 수는 없고 그 다음 함수인 onReceive Packet이란 애를 반드시 얘를 오버라이드 해가지고 사용을 하게 유도를 해주도록 하겠습니다. 즉, onReceive는 이 Packet Session에서 끊긴다는 얘기가 되는 거죠. 그럼 얘는 반드시 구현하라는 의미로 Abstract로 , 이렇게, 만들어 놓도록 하겠습니다. , 자, 요게 , 일단은, Packet Session에 그 다음에 각각의 구현부를 만들러 넘어가도록 할게요 패키지 세션 영역을 , 이렇게, 집어주고 그 다음에 생성자 만들어주고 소멸차도 만들어주고 그리고 onReceive , 이렇게, 만들어주도록 할게요 onReceive Packet은 abstract니까 딱히 만들어주지 않아도 됩니다 , 이렇게, 해가지고 , 사실, 이 부분만 만들어주면 우리 Packet Session이 끝났는데 , 사실, 생성자랑 소멸자는 브레이크 포인트를 잡을 때만 사용할 것이고 딱히 뭘 넣어줄 필요는 없고요 이제 오늘의 가장 핵심은 onReceive라는 이 함수가 , 사실, 관건입니다 그래서 이 부분을 잠시 복사해 가지고 살펴보면서 작업을 하도록 할게요. , 일단은, onReceive를 하는게 TCP 통신을 통해 가지고 데이터가 넘어왔을 때 이 함수가 호출이 되겠죠. 기존에 있던 Receive 버퍼에 들어가 있는 내용을 기준으로 해당 버퍼 내용이랑 버퍼의 시작 위치랑 Length를 건네주게 될 겁니다. 역시나 TCP 특성상 얘가 어느정도 왔는지 전혀 예측을 할 수 없는 상황이라고 보시면 되는 거죠 이게 완전체가 왔을 수도 있고 중간에 왔을 수도 있고 하나 플러스 일부만 왔을 수도 있고 굉장히 여러가지 상황이 있을 수가 있어요 , 자, 요런 상황을 일단 염두에 두고 작업을 할게요 , 일단은, 무한 루프를 계속 돌건데 먼저 데이터 사이즈를 추출을 해보도록 할 건데 , 일단은, 지금 그냥 하나의 패킷만 존재한다고 가정하고 쉽게 생각을 해보도록 할게요. 그러면은 이 버퍼 시작 위치가 여기고 렌스가 이 데이터의 크기를 얘기하는 거니까 데이터 사이즈는 곧 렌스가 될 것이고 먼저 체크할 거는 최소한 우리가 패킷 헤더는 파싱할 수 있는지를 체크해 보도록 하겠습니다. 헤더가 이 4바이트 초반 시작 위치를 얘기하는 거죠 4바이트도 지금 아직 보내지 않았다고 하면 당연히 우리가 완전체로 패킷을 파싱할 수 없다는 얘기가 되는 거니까 바로 스킵을 해주면 되겠습니다 그러면은 데이터 사이즈가 만약에 사이즈오브 패킷 헤더보다 작다 라고 하면은 그냥 브레이크를 때려주도록 할게요 그리고 지금까지 우리가 얼마만큼을 프로세스 했는지 얼마만큼을 우리가 진행시켰는지를 여기서 따지고 관리를 하고 그 다음에 이 프로세스 렌스를 이런식으로 뱉어 주도록 할겁니다. , 자, 그 다음에 두번째로 만약에 최소한 4바이트는 이미 온 상황이라고 한다면 이제는 이 패킷을 까가지고 살펴보면 되겠죠 사이즈는 얼마인지 , 사실, 아이디는 당장 필요 없고 요게 관건입니다 얘가 보낸 패킷이 몇바이트짜리냐를 체크할 겁니다 지금은 뭐 딱히 우리가 얘를 편하게 파시하는 그런걸 만들어 놓지는 않았기 때문에 , 이렇게, 일단은, 코드를 만들어 보도록 할게요 , 자, 헤더를 만들어 줄건데 이런식으로 패킷 헤더 캐스팅을 해가지고 버퍼에다가 0번 위치를 패킷 헤더 포인터로 캐스팅을 한 다음에 그 아이를 다시 꺼내가지고 해당 내용물을 복사를 해주도록 하겠습니다. 즉, 요 타입의 포인터로 바꿔준 다음에 이 사바이트를 여기 헤더에다가 복사를 한다라는 얘기가 되는 거죠. 뭐 이거를 시스탄이 아니라 조금 더 우아하게 만들자면은 뭐 리인터프렛 캐스트 같은 거로 요렇게 일단 바꿔주면 되겠습니다. , 자, 요렇게 , 일단은, 만들어주도록 할게요. , 자, 그러면은 , 일단은, 여기까지 파싱은 되었으니까 이제 이어가지고 헤더에 기록된 패킷 크기를 반드시 파싱할 수 있어야 합니다. 그래서 이 코드 같은 경우에는 데이터 사이즈가 헤더의 사이즈보다 작은지를 체크해가지고 똑같이 브레이크를 때려주면 되겠죠 참고로 여기에 들어가 있는 사이즈는 이건 여러분들이 어떻게 구현하는지는 여러분들의 자유이긴 한데 정말 이 데이터 사이즈만 넣을 것인지 아니면 이 데이터 사이즈에다가 4바이트를 더한 전체 크기를 넣어줄 것인지는 여러분들이 잘 정해주시면 돼요 그 규약에 맞게 모든 코드를 만들어 주시면 되는데 지금 단계에서는 이 데이터의 크기에다가 헤더까지 포함한 전체의 크기를 여기 사이즈에다가 넣어 주도록 하겠습니다 , 자, 그래서 결국에는 요 데이터 사이즈라는 거 즉 우리가 지금까지 여기 넘겨받은 이 렌스 자체가 데이터의 크기가 전체 패킷을 우리가 파싱할 수 있어야 된다는 거죠 헤더 사이즈에 기입된 크기만큼은 최소한 있어야지만 얘를 완전체로 파싱할 수 있다라는 결론을 얻을 수 있는 거니까 그 상황이 아니라고 한다면 역시나 또 브레이크를 해서 도망가도록 할 것이고 그게 아니라 또 여기까지 들어왔다고 하면은 이제는 최소한 요 사이즈에서 주장하는 크기 이상은 우리가 파싱할 수 있다는 얘기가 되는 거니까 패킷을 조립할 수 있다는 얘기가 되는 거죠 패킷 조립 조립 성공 짜잔 하고 이제 여기서 비로소 onReceive 패킷을 호출을 해주게 될 겁니다 지금은 시작 위치에서 헤더의 사이즈만큼을 너가 써도 되라고 해당 영역을 , 이렇게, 집어가지고 컨텐츠 쪽으로 넘겨주는 거죠. 그럼 걔가 이 패킷 다시 까봐가지고 프로토콜을 참조해가지고 여기는 데이터를 잘 분석해서 실행해주게 될 겁니다. , 자, 여기까지 , 일단은, 실행이 됐으면은 요 첫번째 패킷은 실행이 됐다는 얘기니까 그러면은 프로세스 렌스에다가 우리가 지금까지 성공적으로 조립한 패킷의 크기만큼을 더해줘가지고 이제 다음 패킷으로 요렇게 넘어가면 돼요 이 행동을 이제 계속 반복해서 해주게 될 겁니다. 근데 이제 두번째 패킷부터는 우리가 프로세스 렌스가 이제 0이 아니라 기존에 요만큼을 처리했기 때문에 이제 데이터 사이즈가 살짝 바뀌어야 되겠죠. 그러다보니까 요 렌스를 렌스 마이너스 프로세스 렌스로 바꿔주도록 할 것이고 그 다음에 , 이렇게, 되면은 내가 설령 이만큼 처음에 받았다고 해도 첫 부분을 우리가 성공적으로 파싱해서 이미 넘겨놨으니 처리했다는 얘기가 되는 거니까 이제 이 부분을 찝어주게 되겠죠. 여기부터 여기까지 이런 식으로. 그래서 Length-ProcessLength가 일반적인 상황에서의 데이터 사이즈를 의미하게 될 것이고 마찬가지로 버퍼의 0번 위치가 아니라 우리가 지금까지 얼마만큼의 데이터를 처리했는지를 기준으로 이 기준으로 시작 위치를 정해줘야 되니까 0이 아니라 얘를 process length로 , 이렇게, 바꿔치기를 해주면 되겠습니다. 네 그래서 요 코드가 이제 굉장히 단순한데 , 사실, 전부입니다 그래가지고 무한으로 계속 뺑뺑이를 돌면서 내가 얼마까지를 처리할 수 있을지를 최종적으로 계산을 한 다음에 걔를 리턴을 해주게 되면은 우리가 어디서 어디까지 처리했다는 걸 이제 주장을 해주고 있는 거니까 onReceive 코드를 다시 쭉 위로 올려가지고 살펴보면은 요 프로세스 된 요 크기만큼을 우리가 Receive Buffer On Lead로 넘겨줘서 Lead Cursor를 앞으로 당겨주게 될겁니다. 요런식으로 구현을 해주도록 할게요. 비교적 뭐 그렇게 어려운 내용은 아닙니다. 코드를 놓고 보면은 , 자, 이렇게, 일단은, 만들어놨구요. , 자, 그러면은 서버 코어를 다시 한번 빌드를 해보도록 할게요. 별다른 문제가 없으면 컴파일이 완료가 될 것이고 , 자, 그러면 이제 얘를 , 이렇게, 바꿔놨으면은 상대방 쪽에서 우리가 컨텐츠 단위에서 사용할 때 이 게임 세션이라는 것도 이제는 그냥 세션을 상속 받으면 안 되고 패킷 세션을 상속을 받게 수정을 해줘야 됩니다 얘를 , 이렇게, 바꿔야 된다는 얘기가 되는 거죠 패킷 세션으로 얘를 상속을 받는 순간 일단 onReceive는 바로 에러가 뜨고 있죠 왜냐면 우리가 패킷 세션에서 얘를 sealed라는 거로 봉인을 하겠다는 의도로 , 이렇게, 표현을 해줬기 때문에 이제는 얘를 더 이상 사용할 수 없고 반드시 onReceivePacket 버전으로 얘를 사용을 해줘야 됩니다 그래서 이 코드가 , 이렇게, onReceivePacket으로 바꿔치기가 되어야 된다는 얘기가 되는 거죠 그래서 게임 세션에 온 리시브 패킷을 이제 받아가지고 얘는 결국에는 완전체로 조립된 패킷이 왔다는 걸 얘가 확신을 할 수가 있는 상태일 겁니다. 이 버퍼에 얼마만큼의 크기인지를 받아줘가지고 여기서 이제 뭔가를 실행을 해주면 되겠습니다. , 자, 그리고 오늘은 좀 많은 대상으로 테스트를 해볼 것이기 때문에 이런 자잘한 리시브 뭐 그런 주석은 , 일단은, 다 삭제를 해주도록 하고 이제 위에서 처음에 패킷을 만들어 가지고 보낼 때도 요 부분을 테스트 해볼 건데 , 자, 원래는 우리가 서버에서 클라이언트 쪽에서 먼저 헬로를 보낸 다음에 그거를 다시 서버 쪽에서 받아 가지고 전체로 뿌리는 식으로 작업을 했는데 이제는 좀 간단하게 하기 위해서 그냥 서버 쪽에서 계속 틱을 돌 때마다 어... 패킷을 보내는 식으로 작업을 해보도록 하겠습니다. 근데 그 전에 onReceivePacket에서는 내가 지금까지 받은 패킷 자체가 얼마인지는 우리가 뭐... 로그를 찍어보고 싶죠? 그니까 정확하게는 이 내용물이 어떤 패킷 아이디고 어떤 사이즈인지는 알고 싶으니까 그거를 이제 추출을 해보도록 할게요. , 자, 그래가지고 이 버퍼의 시작 위치에다가 얘를 다시 이런 식으로 패킷 헤더 포인터로 잠시 바꿔준 다음에 그거를 대상으로 다시 데이터를 복사해서 패킷 헤더를 , 이렇게, 꺼내 줬었죠. 우리가 코어코드에서 했던 거랑 마찬가지로 , 이렇게, 일단 해줘도록 할게요. 물론 0번이다 보니까 얘를 그냥 , 이렇게, 바꿔줘도 똑같은 의미입니다. , 이렇게, 해가지고 헤더 값을 먼저 추출한 다음에 지금까지 온 데이터가 패킷 아이디는 얼마 얼마이다. 그리고 패킷의 사이즈는 얼마 얼마이다라고 로그를 , 이렇게, 찍어보도록 하겠습니다. Endline 이래가지고 Receive Packet에서는 그냥 간단하게 지금 무엇무엇이 왔다라는 의미로만 , 이렇게, 바꿔치기를 해주도록 할 것이고 그 다음에 정작 Packet을 보내주는 부분은 요 부분이 아니라 이 코드를 , 일단은, Ctrl X로 복붙해가지고 게임 서버 쪽에서 이 부분에다가 만들어주도록 할게요. 그냥 메인 스레드가 할 거 없으니까 여기다가 계속 루프를 돌면서 전체로 뿌려주도록 하겠습니다. 대부분 나중에 MMO를 만들게 되면 게임 서버에서 자체적으로 처리하는 그런 로직들에 의해 가지고 우리가 브로드 캐스팅을 하는 그런 상황이 빈번하게 생길 거예요. 예를 들면 몬스터가 생성이 되었다라는 걸 우리가 뿌려줘야 된다는 얘기가 되는 거죠. 그렇기 때문에 아까 코드를 다시 복붙해가지고 먼저 샌드 버퍼를 , 이렇게, 꺼내온 다음에 기존에는 우리가 여기서 뭔가 데이터를 바로 밀어넣었다고 하면 이제는 먼저 해야 될 작업이 있죠? 선행작업이 이런 식으로 이 해당 포인터를 꺼내가지고 샌드버퍼의 버퍼 위치를 참조해가지고 여기다가 먼저 우리의 헤더 값을 넣어놔야 됩니다 헤더 값을 먼저 적어준 다음에 그 다음에 비로소 데이터를 적어줄 수가 있었죠? 그러니까 여기서도 마찬가지로 , 이렇게, 일단 만들어 보도록 할게요 Packet Header 타입의 포인터로 얘를 인지하도록 바꿔치기하고 여기서 사이즈를 이제 기입을 해줄 것인데 사이즈는 실질적으로 사이즈 오브 이제 데이터를 보내줄 데이터를 여기다가 옮겨 놓도록 합시다 , 일단은, 헬로월드를 그냥 그대로 이쪽에서 갖고 오도록 할게요 헬로월드를 계속 보내주는 식으로만 작업을 할 거라서 이 샌드 데이터를 갖고 온 다음에 실질적으로 사이즈 오브 샌드 데이터에다가 사이즈 오브 패킷 헤더 둘을 합한 크기만큼을 우리가 패킷 사이즈라고 인지를 하도록 여기다가 기입을 해줄 거예요 , 자, 그 다음에 마찬가지로 Packet ID 같은 경우에는 이거는 나중에 수정할 일이 있겠지만 지금은 그냥 1번이라고 가정합시다 1번이 예를 들면 그냥 Hello Message Packet이라고 가정을 해보도록 할게요 , 이렇게, 해서 가장 먼저 요런식으로 내가 지금 사용할 패킷이 무언 무엇인지 정보를 먼저 기입을 한 다음에 그 다음 순서에다가 우리가 데이터를 넣어주게 되겠죠 데이터 같은 경우에는 지금 유심히 봐야되는게 요 버퍼 기준으로 4번 위치에 접근을 해가지고 4바이트에다가 우리가 적어 놔야 되겠죠? 0바이트부터 지금 3번 인덱스까지는 실질적으로 헤더가 2바이트, 2바이트를 활용하고 있으니까 그 다음 순서로 우리가 데이터를 기입을 해줘야 됩니다. 그래서 이런 식으로 4번 위치에다가 우리가 샌드 데이터의 내용을 넣어달라고 , 이렇게, 일단은, 복사를 해주면 되겠습니다. 그 다음에 다 썼으면 샌드 버퍼 클로즈를 할 때는 역시나 마찬가지로 이 크기만큼을 다시 닫아주면 되겠죠 여기서 딱 보는 바와 같이 사용하기가 굉장히 어렵다는 걸 알 수가 있습니다 그래가지고 다음 시간에는 이걸 개선할 방법에 대해서 알아볼 건데 , 일단은, 그냥 간단하게 하기 위해서 , 이렇게, 수동으로 일일이 한번 다 작업을 해봤어요 패킷을 만들 때는 항상 데이터를 넣어줌과 동시에 해당 사이즈랑 아이디를 기입을 하고 그 다음에 뚜껑을 닫아준다 하고 여기까지 썼다라고 일단 할 수가 있는 거죠 그 다음에 최종적으로 세션 매니저의 브로드 캐스팅을 때려가지고 요런식으로 데이터를 건네주면 된다라고 볼 수가 있겠어요 , 자, 여기서 세션 매니저가 , 일단은, 존재를 모르니까 인클로드 게임 세션 매니저를 추가를 해주도록 하고 이제 , 이렇게, 해가지고 게임 서버 쪽은 어느정도 완료가 되었습니다 , 자, 이렇게, 해서 오케이 통과되었고 그럼 이제 더미 클라이언트에서도 똑같이 테스트를 해주면 똑같은 작업을 해줘야 되는데 , 일단은, Connected to server는 잠시 없애주도록 하고 여기서 send하는 부분도 그냥 없애주도록 할게요 어차피 서버 쪽에서 이거를 계속 빠르게 빠르게 계속 지금 보내주고 있으니까 아 근데 이걸 너무 무한으로 보내는 것도 좀 그러니까 this thread sleephole을 대충 250ms 보내도록 할게요. 0.25초마다 한 번씩 브로드캐스팅을 빵빵빵 때려줘서 헬로월드를 전체로 보내주게 만들어 주도록 하겠습니다. 그럼 얘도 이제 마찬가지로 퍼블릭 세션이 아니라 패킷 세션을 , 이렇게, 상속을 받게 만들어 줘야지만 똑같이 똑같은 방법으로 통신을 할 수가 있겠죠. 그래야지만 여기서 보내준 패킷이 조립이 되어 가지고 넘어오게 될 겁니다. 넘어올 때는 on receive가 아니라 이제 on receive 패킷이라는 함수로 들어오게 될 테니까 얘로 , 일단은, 오버라이드를 해줘야 되는 거고 그 다음에 여기까지 들어왔으면은 이제 어떻게 해볼까요 우리가 여기서 했던 것 마찬가지로 onReceivePacket 정보를 추출을 하기 위해서 얘를 그대로 활용을 해보도록 하겠습니다 이런 느낌으로 이 버퍼에 있던 헤더 값을 꺼내 가지고 그 헤더값의 내용을 그대로 아이디랑 사이즈는 얼마였는지를 복사를 하고 , 자, 그 다음에 만약에 여기서 추가적으로 데이터가 무엇인지 너무 궁금하다고 하면은 요런 식으로 Receive Buffer를 잠시 , 이렇게, 만들어 준 다음에 맴 카피를 해가지고 요 Receive Buffer에다가 해당 내용물을 꺼내서 출력을 해보도록 합시다 버퍼에 4번 위치의 데이터가 들어가있고 그 다음에 여기서 얼마만큼의 데이터를 복사해야 되냐면은 실질적으로 얘가 보내준 패킷 사이즈에다가 사이즈에다가 size of packet header만큼을 뺀 게 실제 데이터의 크기가 될 테니까 그만큼을 receive 버퍼에다가 복붙한 다음에 그 다음에 cout으로 hello world를 보내준 걸 그대로 출력을 해보도록 할게요. 근데 만약에 프로토콜이 1번 프로토콜이 아니라 다른 애라고 했으면 당연히 이런 식으로 hello world가 들어가 있다고 가정을 하면 당연히 안 되겠죠. 근데 지금은 그냥 간단하게 하기 위해서 , 이렇게, 일단은, 만들어 보도록 하겠습니다. , 자, 그리고 얘는 그냥 주석처리 할게요 어차피 뭐 헬로월드가 떴다면 전상적으로 처리가 됐다는 얘기가 되는 거니까 요렇게 , 일단은, 만들어 보도록 하겠습니다 그 다음에 온샌드 온 디스코넥트도 다 막아버리도록 할게요 , 자, 이렇게, 해가지고 , 일단은, 더미 클라이트도 똑같이 빌드를 해가지고 문제가 없는지를 체크하고요 , 자, 지금은 5명을 대상으로 우리가 지금 테스트를 하고 있는데 클라가 5마리가 붙어가지고 서버에 접속을 하면은 서버가 똑같이 헬로월드를 5명을 대상으로 요렇게 열심히 열심히 뿌려주게 될 겁니다 그러면 헬로월드 헬로월드 헬로월드가 정상적으로 잘 뜨고 있다는 걸 볼 수가 있어요 , 이렇게, 해가지고 이게 , 일단은, 우리가 사용할 프로토콜의 기초라고 보시면 되겠습니다 이 부분을 굉장히 유심히 잘 기억을 하셔야 되는데 항상 패킷을 보낼 때는 사이즈, 아이디, 사바이트를 먼저 보낸다가 가장 핵심적인 내용이고 여기서 굉장히 중요하게 아셔야 되는 부분이 하나가 이 부분이 나중에 서버 보안이랑 관련된 내용인데 우리가 서버 쪽에서 지금 유심히 하는 걸 보면은 이런 식으로 사이즈를 넣어주고 있습니다 근데 만약에 이 사이즈를 잘못 기입을 하면 어떤 일이 발생할까가 굉장히 궁금하죠 예를 들면은 클라이언트 쪽에서도 만약에 똑같이 우리한테 데이터를 보낼 때 이런 식으로 사이즈랑 아이디를 기입해가지고 내가 지금 보내는 패킷이 어떤 아이다 라는 거를 기입해서 보내주게 될 텐데 온라인 게임 특성상 항상 해킹에 방비를 해야됩니다. 해커들이 가장 먼저 하는 짓거리가 요 사이즈랑 아이디를 계속 변조를 해보면서 보내보려는 시도를 하게되요. 그러면은 당연한 얘기지만 요 부분에서 만약에 사이즈랑 아이디가 잘못 기입이 되었다고 하면은 엉뚱한 그런 데이터를 파싱을 할 수도 있겠죠 원래는 여기까지인데 뭐 여기까지만 파싱을 한다거나 넘어서 파싱을 한다거나 할 때 그런 부분들을 반드시 우리가 서버 쪽에서 인지를 하고 잘못된 부분이 있다고 하면은 인지를 하고 그 상대방을 그냥 킥하는 부분까지 반드시 나중에 처리를 해줘야 됩니다 근데 그러면 애당초 아니 그러면은 이거 자체가 믿을 수가 없고 신용할 수 없는 부분인데 이걸 왜 굳이 받아주느냐 그냥 부분적으로 신용을 한다고 보시면 돼요 , 일단은, 치팅을 하지 않았다고 가정을 하고 이거를 진행하되 나중에 가서 뭔가 이상한 낌새가 딱 코드에서 잡히면은 그제서야 걔를 해커라고 이심을 하고 킥을 해준다는 얘기가 되는 거죠 애지당초 이 패킷을 결국에는 우리가 조립을 하려면은 이게 얼마만큼의 크기인지는 우리가 미연에 알 수가 없기 때문에 이런식으로 패킷 헤더에다가 정보를 받아가지고 처리하는거는 그냥 필요적인 것입니다. 어쩔 수가 없어요. 다만 이게 이제 조작을 할 수 있다는 것도 따로 염두에 둬야 된다는 얘기가 되는거죠. 그러니까 뭐 어쩔 수 없이 이걸 넣어줬고 그 다음에 얘가 조작 여부도 있다라는 걸 항상 생각을 해야 된다는 얘기가 되는거고 만약에 얘가 뭐 엉뚱한 코드로 사실은 이 데이터가 뭐 4바이트 짜리였는데 그냥 뻥쳐가지고 6만바이트라고 뻥쳤으면은 뭐 , 사실, 6만 바이트가 다 올 때까지 얘가 처리가 되지 않을 거니까 딱히 뭐 문제가 있는 상황은 아닙니다 근데 이제 그 다음에 해당 프로토콜에 의해 가지고 여기 있는 데이터를 파싱해가지고 뭔가 처리가 돼야 되는데 그 부분에서 뭔가 이상하다라는 낌새가 발견이 되면은 진짜 처리를 해줘야 된다는 얘기도 되는 거죠 이 부분을 가장 조심해야 되는 거고 그래서 얘는 부분적으로만 믿는다라는 게 이제 굉장히 중요합니다 서버를 만들 때는 요런 보안 이슈를 굉장히 잘 신경 써야 되는 게 이게 온라인 게임은 결국에는 싱글 게임과는 다르게 모두한테 공평하게 세상이 동작을 해야 되죠 누군가가 치트 프로그램을 이용해 가지고 우리 서버가 막 뚫리고 이상하게 동작을 한다고 하면은 그건 당연히 정상적인 게임이 될 수가 없을 겁니다 네 그래서 요 부분을 , 일단은, 언급을 드린 거구요 그래서 이제 앞으로 요 패킷 세션을 잘 사용하면 된다라는 결론을 얻을 수가 있고 다만 지금 어 요기서 사용하는 것처럼 , 이렇게, 복잡하게 귀찮게 막 사용하는 건 조금 문제가 있으니까 이걸 어떻게 개선해볼지 고민을 해보도록 할 것이고 , 자, 그 다음에 마지막으로 지난번에 사실상 제가 작업한 코드가 요기 세션 매니저에서 요 부분이 , 사실, 문제가 있습니다 근데 문제가 있는지를 어떻게 알 거냐면은 어.. 중간중간에 우리가 이런 식으로 코드를 쌓아 올리다 보면은 뭐 당연한 얘기지만 버그가 아예 없을 수는 없어요 종종 버그가 하나씩 발생하게 될 건데 그 버그를 발견한 다음에 어떻게 그거를 잡아 줄 것인지가 굉장히 중요합니다 지금 문제되는 상황은 뭐냐면은 이제는 이거를 천면으로 굉장히 많게 늘려 보도록 할게요 이런 식으로 500명, 1000명 단위로 늘려가지고 테스트를 하면은 대부분의 경우 진짜 문제가 있으면은 한번씩은 크래시가 터지게 됩니다 그래서 얘를 일단 첫면으로 바꿔본 다음에 실행을 그냥 해보도록 할게요 , 자, 그리고 여기서 , 일단은, 막 헬로홀드가 지금 어마어마하게 많이 뜨고 있구요 요 상황에서 더미 클라이언트를 강제로 한번 꺼보도록 할게요 그러면은 어 뭐지? 우리가 서버가 이런 식으로 브로드 캐스팅을 하다 말고 크래시가 난다는 걸 알 수가 있습니다 여기서 이제 포트폴리오를 만들거나 아직 멀티스레드나 네트워크가 익숙하지 않은 분들은 여기서 일단 멘붕이 오게 돼 있어요 제가 그랬거든요 처음에 포포를 만들 때 이런 크래시가 나면 이게 진짜 힘들었던 게 내가 멀티스레드를 잘 몰라가지고 까먹은 부분이 있는 건지 아니면은 그냥 네트워크 단에서 뭔가 처리가 잘못되었는지 아니면 그냥 C++ 차원에서 뭔가를 잘못했는지가 굉장히 알기 힘든다는 문제가 되는 건데 , 사실, 이런 문제를 해결하면서 굉장히 많은 실력 향상을 얻을 수가 있으니까 너무 겁을 낼 필요는 없겠습니다 , 자, 그럼 이제 이 문제가 왜 발생했는지 일단 이어서 말씀을 드릴 건데 혹시 궁금하시면 그냥 혼자 한번 디버깅도 해보고 하면서 고민을 일단 해보시고 오시면 되겠습니다 , 자, 이제 뭐 고민을 하고 오셨을 수도 있고 뭐 그냥 광의를 보실 수도 있는데 이제 제가 정답부터 일단 알려드리도록 할게요 지금 제가 이거를 뭐 고의적으로 발생시킨 건 아는데 요런 상황이 종종 발생하게 될 거예요 실무에서도 그럼 이제 굉장히 궁금한 게 이런 버그를 어떻게 잡느냐가 굉장히 중요한 거죠 요렇게 뭐 크래시가 난 건 오케이인데 얘가 지금 브로드 캐스팅에서 크래시가 났다는 얘기는 무엇인지가 굉장히 궁금합니다 근데 여러가지 , 일단은, 우리가 가정을 할 수가 있겠죠. 첫번째로는 지금 만들고 있는 이 라이트락이라는 코드 자체에 뭔가 결함이 있어가지고 내가 얘를 접근하는 순간에 리무브를 누군가가 해줘가지고 여기서 못 꼬였다거나 아니면은 뭐 또 뭐가 있을까요 이 세션 레퍼런스 카운팅에 문제가 있어가지고 이미 해제가 되었다 뭐 이런 여러가지 가정을 할 수가 있을 거예요 근데 우리가 수동으로 레퍼런스 카운팅을 관리하고 있는 게 아니기 때문에 레퍼런스 카운트에서 뭔가 꼬일 문제는 , 사실, 거의 없다고 볼 수가 있겠어요 그러면은 이 락의 문젠가라는 것도 합리적인 의심이 되는 건데 그러면은 이걸 어떻게 해결하시냐 뭐 그냥 이걸 라이트 락을 우리가 직접 만든 코드를 사용하는 게 아니라 이전에 있던 뮤텍스로 얘를 다시 바꿔가지고 테스트를 해보면 되겠죠 , 사실, 이 뮤텍스로 바꿔도 문제가 해결이 되지 않는다는 걸 나중에 실습을 하게 되면 알게 되실 거예요 뮤텍스 이 락 문제도 아니고 어 그러면은 애당초 요 셋을 사용을 할 때 이 스마트 포인터를 넘기면 안되는 것이냐라고 의심을 할 수도 있지만 이 문제도 아닙니다. 실질적으로 스마트 포인터를 넘기게 되면은 그 해당 포인터 값 주소를 이용해가지고 그 키 값을 만들어 주기 때문에 얘도 그냥 , 이렇게, 넣어줘도 상관이 없어요. 이거는 뭐 너무 의심스럽다 하면은 구글링을 해보면 스택 오버플러에 그 문제가 아니라는 걸 이제 확인할 수가 있을 겁니다. , 자, 그러면 돌고 돌아가지고 굉장히 이상한데 또 하나 굉장히 재미있는 사실은 우리가 똑같은 테스트를 서버를 꺼가지고 클라이언트에서 테스트하면 클라이언트는 또 안 터진다는 걸 알 수가 있어요 진짜로 이 게임 세션 매니저 여기에서 항상 대부분 터지기 때문에 얘가 뭔가 이상하다는 가정을 할 수가 있는 거죠 , 자, 그래서 너무 뜸을 들이는 것 같아가지고 , 일단은, 그래서 결론부터 말씀을 드리자면 여기 코드가 문제가 있다 그렇다는 것은 이 세션 자체가 우리가 항상 접근하는 동안에 이건 , 사실, 경험의 영역입니다. 제가 C++ 강의에서도 말씀을 드린 것 같은데 여기서 이런 식으로 접근을 하다가 4H나 4문을 돌면서 얘를 접근하는 동안에 만약에 우리가 내부적으로 세션에다가 변화를 준다거나 아니면 여기다가 데이터를 삭제한다고 하는 행동을 하면 애당초 메모리 자체가 오염될 수가 있습니다. 이 구조체 자체를 이런 식으로 4문으로 접근을 할 때는 이 부분을 굉장히 조심해야 돼요. 근데 곰곰이 생각을 해보면 우리가 딱히 그러면 안 된다는 코드를 만들어 놓은 적이 없기 때문에 다시 샌드를 할 때 무슨 일이 일어나는지를 한번 살펴봅시다. 그러면 샌드를 할 때 이런 식으로 리지스터 샌드를 때려주게 될 것이고 이 코드에서 샌드를 하다가 가만히 생각을 해보면 이게 항상 일어나는 게 아니라 항상 우리가 연결을 끊을 때 뭔가가 일어났었죠 연결을 갑자기 끊으면 대부분 보냈던 그런 것들이 WS 샌드를 실행하다가 연결이 끊겼으니까 소켓 에러로 떠서 아마 이 코드로 들어오게 될 거라는 걸 우리가 유추를 할 수가 있을 거예요 실제로 브레이크 포인트를 잡아봐도 여기서 코드가 굉장히 많이 잡힐 겁니다 연결을 빡 끊어주는 순간에 그러면은 그 다음에 펜딩이 아니라 진짜로 연결이 끊긴 상태일 테니까 핸들 에러가 뜰 것이고 아마 여기로 들어와서 디스코넥트로 뜬다는 것까지도 , 일단은, 확인을 할 수가 있을 거예요 근데 굉장히 재밌게도 디스코넥트를 실행하면은 어떤 일이 벌어지냐면은 우리가 내부적으로 온 디스코넥티드라는 걸 호출하고 있습니다 여기까지는 문제가 없는 것 같지만 다시 생각을 해봐서 온 디스코넥티드가 호출이 되면은 , 자, 우리가 뭘 하고 있었나요 온 디스코넥트에서는 다시 세션 매니저의 remove를 지금 호출해주고 있다는 걸 알 수가 있어요 그렇다는 것은 결국에는 broadcast를 함수를 호출할 때 여기서 내부적으로 send를 호출했는데 걔가 내부적으로 타고 타고 가가지고 한바퀴 돌아가지고 다시 이 remove 함수를 호출해줄 수 있다는 얘기가 되는 거죠 그래서 사실상 우리가 요런 코드를 만들 수가 있다는 얘기가 되는 겁니다 접근을 하면서 뺑뺑이를 돈과 동시에 여기서 뭔가를 건드려가지고 사실상 이 루프가 깨져서 지금 사실상 이런 for 이치를 이용해가지고 우리가 돌면 안 되는 얘기가 되는 거죠 근데 물론 이거는 꼭 , 이렇게, 하지 않고 인덱스를 접근해가지고 i는 0번부터 해도 , 사실, 똑같은 문제예요 이런 식으로 중간에 뺑뺑이를 돌면서 얘를 , 이렇게, 삭제를 하는 건 굉장히 위험한 행동입니다 그리고 이거는 이제 이런 자료 구조를 생각해보면 당연한 얘기입니다 , 자, 그래가지고 결국에는 요 문제는 우리가 브로드 캐스팅을 함과 동시에 내부적으로 다시 재규적으로 어떻게 막 되면서 이 세션을 건드렸기 때문에 발생하는 문제라는 걸 알 수가 있는 거고 요런 문제들이 이제 경험이 쌓이다 보면은 조금 더 이제 쉽게 잡을 수가 있게 될 거예요 그래서 뭐 결론적으로 지금 상태에서는 이걸 뭐 어떻게 고치느냐 음... 디스코넥트를 할 때 여기서 당장 온 디스코넥트라는 릴리즈를 하는 게 아니라 등록을 한 다음에 실질적으로 프로세스까지 와가지고 이 부분에서 얘를 등록한 다음에 다음 턴에 프로세스 디스코넥트가 실행이 될 때 다른 스레드가 그걸 실행하게끔 만들어주면 되겠죠 즉 여기 있는 코드를 이제 이동을 시켜 주도록 합시다 프로세스 디스코넥트를 찾아가지고 요 부분에서 릴리스 랩을 한 다음에 얘를 이런 식으로 호출하게끔 하면은 최소한 우리가 아까 만들던 코드에서 요기 샌들을 하는 동안에 얘가 다시 타고 다가가지고 리무브를 하는 그런 코드는 이제 예방을 할 수가 있을 겁니다 네 그래서 예전에 발생했던 실질적인 그런 버그랑 굉장히 비슷한데 제가 이전 프로젝트에서 일했을 때 이런 느낌의 버그로 인해 1바이트 오염이 일어난 적이 있었는데 이게 굉장히 무서운 버그입니다. 그래가지고 항상 , 이렇게, 루프를 돌면서 뭔가 처리를 할 때 여기서 얘를 접근해가지고 삭제하거나 또 다시 추구하는 행동을 진짜 조심해야 된다라는 결론을 얻을 수가 있는 거고 , 이렇게, 수정해가지고 다시 한번 실행을 해보면 1000개를 실행해가지고 헬로월드 테스트를 막 하다가 , 자, 이런식으로 막 테스트를 하다가 더미 클라이언트를 빵 때리면은 정상적으로 모든 애들이 다 끊기면서 , 이렇게, 줄어드는 걸 볼 수가 있습니다. 그래서 , 이렇게, 잘 처리되는 것도 알 수가 있고요 그 다음에 , 이렇게, 코드를 또 만들 때는 우리가 이전 시간에 만들던 샌드 버퍼 쪽에서도 이런 부분도 이제 확인을 하면 굉장히 좋은 게 풀링을 하는 방식이 다 좋은데 한 가지 문제가 있는 게 뭐냐면 만약에 누군가가 얘를 끝까지 물고 있고 해제를 하지 않으면 이 전체 메모리가 해제가 되지 않는다는 문제가 있습니다. 계속 레퍼런스 카운팅이 0으로 줄어들지 않아가지고 얘가 절대로 반환이 되지 않는다는 문제가 있을 수도 있다는 거죠. 그래서 이런 애들도 정상적으로 진짜로 다 지금 반환이 되고 있는지 한번 테스트 해보기 위해서 샌드 버퍼 청크 같은 거를 뭐 , 이렇게, 지금 반환 중이다라고 로그를 찍어본다거나 하는 식으로도 이제 종종 테스트를 해보면 좋을 것 같습니다. 이런 식으로. 팝, 샌드 버퍼 청크가 팝 되었다. 그 다음에 얘는 다시 풀에 반환이 되었다라는 이런 로그들도 종종 찍어보면 도움이 되겠어요. 이것도 한번 테스트를 마지막으로 해보도록 할게요. , 자, 얘를 다시 실행해서 살펴보면은 , 자, 이런식으로 샌드 버퍼 청크 팝까지 장상적으로 떴구요 그 다음에 이제 어느정도 프리프리가 되다가 최종적으로 다 사용을 하게 되면은 이제 얘가 다시 뜨게 될텐데 지금은 요 버퍼 청크가 너무 커서 얘가 잘 발생을 안하는 것 같으니까 뭐 얘를 조금 조절을 해보도록 합시다 샌드 버퍼 청크를 만들어 줄 때 , 자, 여기서 얘가 지금 6000바이트로 되어 있는데 실질적으로 우리가 게임 서버 쪽에서 사용하는 요 데이터가 너무 작아서 그런 것 같으니까 얘를 그냥 1000바이트 짜리로 그냥 통째로 보내주도록 할게요 이거 헬로월드는 둘째치고 나머지 데이터들도 그냥 1000바이트로 보내줘서 다시 한번 실행을 해보면 , 자, 그러면은 이제는 이런 식으로 팝 푸시가 정상적으로 잘 뜬다는 것도 볼 수 있습니다 그러니까 데이터를 보냄과 동시에 중간중간에 이런 식으로 우리가 잘 사용하던 이 버퍼 청크를 다시 반환하고 재사용하고 하는 부분도 정상적으로 실행이 되고 있다는 것도 알 수가 있고요 메모리도 안정적으로 늘어나지 않고 이게 만약에 릭이 일어나는 상황이라고 한다면 메모리가 그냥 조금씩 계속 위로 우상향을 하면서 늘어나게 될 텐데 그런 부분도 , 일단은, 없다는 걸 볼 수가 있어요 근데 물론 여기까지만 테스트하면 알 수가 없고 나중에 가면은 실질적으로 , 이렇게, 한 번만 연결을 하는 게 아니라 이네들을 연결을 했다가 끊고 연결을 했다가 끊고 보내고 온갖 난리를 쳐야지만 우리가 굉장히 안전한 스트레스 테스트를 할 수가 있을 겁니다 이거는 나중에 해보도록 하고 , 일단은, 그래서 오늘 결론이었던 패킷 세션과 관련된 부분이 일단 핵심적인 내용이었고 그리고 겸사겸사 지난번에 만들었던 버그도 같이 고쳐봤습니다 , 이렇게, 해서 패킷 세션과 내용은 굉장히 중요하니까 반드시 숙지를 하고 넘어오셔야 되겠습니다 , 이렇게, 해서 패킷 세션 내용을 마치도록 할게요.