자, 이제 지난 시간에 이어가지고 데이터베이스 연동 작업을 계속 해볼 건데 뭐 일단 요렇게 사용을 해가지고 데이터를 저장하고 사용하는 방식에 대해서 테스트를 해봤는데 지금 사용 방식이 생각보다 조금 복잡하다는 걸 알 수가 있습니다 좀 실수의 여지가 높죠 요렇게 직접적으로 우리가 타입을 지정하는 요 부분들이 , 일단은, 가장 거슬리기 때문에 걔네들부터 일단 수정을 하고 넘어가도록 할게요 , 자, 그래서 , 일단은, 다시 DBConnection 요 클래스를 다시 열어준 다음에 , 자, 오늘 , 일단은, 여기 이전에 사용하던 바인드 파라미터랑 바인드 칼럼 같은 경우에는 이제는 내부적으로만 사용할 거기 때문에 이쪽을 이제 프라이벳 영역으로 잡아주도록 할 것이고 그 다음에 이제 밖에서 사용할 시리즈들을 쫙 만들어주도록 할 겁니다 근데 뭐 우리가 이제 어떤 타입을 사용할지 모르니까 그냥 다 하나씩 준비해주면 되겠죠 그래가지고 첫 번째로 바인드 파라미터를 만들어 줄 것인데 먼저 파람 인덱스를 받아 줄 것이고 그 다음에 분리형 값을 받아주는 경우도 있을 것이고 SQL LENS INDEX , 자, 이거를 몇 개를 더 복사를 해 보도록 할게요 , 이렇게, 컨트롤 D로 그 다음에 이제 두 번째로 float type 에 대해서도 지원을 해 줄 것이고 double type 그 다음에 int8, 그리고 int16, short, 그리고 int32 인트64 여기까지 일단 전해주십시다 참고로 Unsigned는 좀 고민이 되긴 하는데 굳이 지원을 안해주는 이유는 DB 제품군 따라서 예를 들면 SQL 서버 같은 경우에는 애당초 Unsigned라는 개념이 없습니다 그래서 Signed만 지원을 하고 있어요 어 그러면은 내가 만약에 진짜 부호가 없는 그런 Unsigned 데이터를 사용하고 싶으면 어떻게 해야 될까 그냥 더 큰 영역에 사인드 인트를 잡아줘가지고 그냥 활용할 수 밖에 없습니다. 그리고 마이크로소프트 쪽에 이제 왜 Unsigned을 지원 안하냐라고 사람들 질문을 올렸는데 이런 정수 있는 인트와 없는 인트를 섞어가지고 사용할 경우에는 그런 이런저런 캐스팅 문제라거나 등등의 이슈를 인해가지고 지원을 해줄 계획이 없다고 공식적으로 발표를 했기 때문에 그냥 이제 db를 사용할 때는 그냥 int, unsigned를 제외한 그냥 기본 int만 사용한다고 일단 생각하면 되겠습니다. 그리고 참고로 Boolean도 없어요. 근데 Boolean은 이제 그냥 int 8자리로 똑같이 사용해가지고 작은 데이터를 할당해준 다음에 0 혹은 1이라는 값을 이제 사용해주면 됩니다. , 자, 그리고 이어가지고 timestamp struct라고 해가지고 요 아이는 나중에 실습을 해볼 건데 말 그대로 우리가 데이트 타임을 사용할 경우에 그 값을 이제 이 타임 스탬프 스트럭트라는 거로 이제 우리가 갖고 올 것이고 그 다음에 뭐 추가적으로 요런 식으로 , 자, 얘는 좀 예외적으로 스트링을 넣어봅시다 어 요런 느낌으로 이제 어떤 w 캐릭터 문자를 같은 거를 이제 넣어주고 싶다거나 그리고 마지막으로 Byte 배열 이런저런 이유로 Byte 배열을 넣어줄 수도 있겠죠 이미지 파일이라거나 이런 것도 필요할 수 있으니까 얘는 또 사이즈까지 추가적으로 받아주도록 할게요 , 이렇게, 일단은, 시리즈들을 이 정도만 지원을 해주도록 하겠습니다 그래서 앞으로 사용할 때는 이 버전이 아니라 이 윗버전 중에 하나를 골라가지고 사용하게 될 것이고 , 자, 그 다음에 마지막으로 마지막이 아니라 이어가지고 Bind Column 같은 경우에도 여러가지 시리즈를 지원해줄 건데 column index를 지원해줄 것이고 먼저 그 다음에 똑같은 순서대로 value sql-length-pointer index를 , 이렇게, 각각 받아주도록 할거고 얘를 또 여러개를 막 복사해준 다음에 위에서 똑같은 순서대로 얘네들을 이제 하나씩 지원해줄겁니다. double도 지원해주고 int8 int16 int32 그 다음에 int64 그 다음에 timestamp struct 그리고 요런식으로 문자열 스트링에다가 버퍼 사이즈까지 받아올 것이고 그 다음에 마지막으로 데이터를 받아오기 위한 버퍼 주소랑 사이즈까지 , 이렇게, 만들어 주도록 할게요 오늘은 , 일단은, 얘네들을 간단히 채워준 다음에 넘어가도록 할 건데 , 이렇게, 많을 경우에는 하나하나씩 여기서 구현부를 만들기 보다는 , 이렇게, 한 방에 만드는 방법이 있어요 클래스를 클릭해 가지고 여기서 비주얼 스튜디오 기본 단축키가 Alt-Shift-Q 일 겁니다. 그래서 여기서 Alt-Shift-Q를 눌러서 Create Method Implementation을 눌러주면 얘네들을 선택할 수 있는데 좀 기다리다 보면 이런식으로 구현부가 한 번에 만들어져요 이런식으로 여러개를 한 번에 만들어준 다음에 작업을 해보도록 할게요 그 다음에 순서가 살짝 꼬여있네요 전 여기 정의한 순서대로 만드는 걸 좋아해가지고 여기 바인드 파라미터 이 부분만 아래로 좀 옮기도록 할게요 어딨나요? 여기 맨 아래다가 여기 바로 아래다가 옮기고 마찬가지로 바인드 컬럼 같은 경우도 내려서 이쪽에다가 정의를 하고 , 자, 이제 나머지 부분들을 하나씩 채워주면 되겠습니다 먼저 요 부분부터 , 자, 파라미터 인덱스를 받아주는데 걔가 이제 기본적으로 불리언을 뱉어주는 경우라면 무엇을 해야 되느냐 기존에 우리가 공용으로 사용할 요 아이에다가 우리가 직접적으로 인자를 세팅해가지고 그냥 전달해주면 됩니다 파라미터 인덱스랑 sqlc tinyint tinyint 그리고 sql tinyint 이런 식으로 사이즈 32 불리언 사이즈에다가 value index를 , 이렇게, 넣어주면 되겠어요 , 자, 요런 짓거리를 이제 매번마다 하나씩 하나씩 다 해주면 됩니다 이거 하나씩 복붙해가지고 그 다음 같은 경우에는 sql-c-underbar-float가 될 것이고 얘는 sql-underbar-real로 만들어주면 됩니다 , 자, 이거는 이제 나중에 표를 봐가지고 하나씩 확인을 해보시면 돼요 그렇기 때문에 뭐 크게 , 이렇게, 어려운 부분은 없고요 얘는 c-double로 만들어주시면 되고 이어가지고 얘는 SQL W로 , 이렇게, 만들어주고 아 그리고 여기 사이즈 같은 경우에는 일반 정수가 아닐 경우에는 그냥 0으로 밀어줘도 되기 때문에 그냥 0으로 , 이렇게, 세팅을 해주도록 할게요 , 자, 그 다음에 이제 이어서 인트 8 시리즈들이 등장을 하는데 얘 같은 경우에도 , 이렇게, 하나씩 복사를 해준 다음에 얘는 SQL C TinyInt로 똑같이 맞춰주고요 , 사실, 얘랑 똑같습니다 , 이렇게, 그 다음에 크기는 사이즈 32로 인트 8짜리 크기를 여기다가 , 이렇게, 넣어 주도록 하겠습니다. 그 다음에 인트 16 같은 경우에는 sql-c-short로 만들어 주면 되고요. 요 부분은 이어가지고 sql-small-int로 만들어 주면 되겠습니다. 얘는 인트 16이 될 것이고 , 자, 이런 식으로 굉장히 노가다 작업을 하고 있는데 , 사실, 이걸 딱 한 번만 해주면 되는 거기 때문에 조금 지루하더라도 참고 한 번 끝까지 가봅시다. sql-integer 그리고 int32 , 이렇게, 자, 그 다음에 int64 같은 경우에는 sql-csbigint 라는 게 있는데 요 아이로 일단 설정해 주면 되고요. sql-bigint 그리고 size int64로 , 이렇게, 만들어 주도록 하겠습니다. time stamp struct도 마찬가지로 sqlc type time stamp 라는게 있습니다 이건 나중에 이제 데이트 타임을 추출하는 우리가 실습 이어서 해볼 건데 그때 이제 정확히 어떻게 사용하는지는 볼 것이고 time stamp 이걸로 , 일단은, 맞춰주고 , 자, 이렇게, time stamp struct의 사이즈를 넣어 주도록 하겠습니다 이제 거의 끝나가는데 여기부터 어... 이제 조금 달라지는 부분은 뭐냐면 얘는 일단 문자열의 크기를 먼저 우리가 알아와야 됩니다. 얘 같은 경우에는 byte 크기를 받아왔는데 얘는 그냥 기본 함수를 이용해가지고 우리가 크기를 한번 추출해 보도록 합시다. sqlu-length를 뽑아올 것인데 static cast sqlu-length 그 다음에 여기다가 함수를 하나 쓸 건데 wcs-length 여기다가 문자열의 길이를 추출해 가지고 널 포인터, 널 값까지 추가한 1 바이트를 추가해 준 다음에 길이를 1만큼 추가해 준 다음에 W 캐릭터이기 때문에 여기다가 곱하기 2를 해가지고 얘 사이즈를 , 이렇게, 잡아주도록 할게요. 그 다음에 얘는 이제 그냥 일반 정수가 아니니까 여기다가 SQL NTSL을 , 이렇게, 설정을 해줘야 되겠습니다. 네 그래가지고 이어서 사이즈가 만약에 4000보다 크다 이 값은 , 사실, 제가 임의로 정한게 아니라 테스트를 해보면 실제로 이게 그 약간 딱 경계선입니다 이게 4000바이트 이하냐 이상이냐에 따라 가지고 타입이 조금 달라져야 될 수가 있는데 , 자, 이거를 하드코딩 하기도 좀 뭐하니까 여기 위쪽에다가 가가지고 이넘을 정리해 주도록 할게요 W 차 맥스는 4000 그 다음에 바이너리 맥스는 8000으로 크기를 일단 잡아준 다음에 만약에 요 크기가 요 4000을 넘었다고 하면은 그러면은 리턴을 , 자, 일단 여기까지는 복붙한 다음에 바인드 파라미터에서 타입 자체가 sql c w 캐릭터까지는 똑같은데 여기 두번째 타입이 이제 달라집니다 그리고 여기까지는 똑같고 sql w long bar char로 , 이렇게, 설정을 해주도록 할게요 이게 너무 길어질 경우에는 , 이렇게, 만들어줄 겁니다 그리고 크기는 아까 위에서 계산한 사이즈를 넣어줄 것이고 그 다음에 요 스트링 자체는 SQL 포인터로 , 이렇게, 바꿔가지고 넣어주고 그게 아니다 else로 왔다고 하면은 요 버전이 sql-w-var-char로 일단 , 이렇게, 만들어 주도록 하겠습니다 그리고 이제 대망의 이제 마지막인데 요 아이 같은 경우에 그냥 일반적인 그런 이미지 파일 같은 바이너리를 밀어 넣을 때 혹은 그냥 일반적인 클라이어에서 사용하는 데이터를 저장하고 싶을 때 그런 바이너리 파일을 저장하고 싶을 때 사용하는 건데 얘도 마찬가지로 한번 박아주고 만약에 텅텅 비었다 라고 하면은 SQL NULL 데이터로 인덱스를 요렇게 바꿔치기를 해줄 것이고 사이즈는 그냥 1로 밀어줄 것이고 그게 아니라고 한다면은 인덱스에다가 사이즈를 이거 else 사이즈를 요렇게 넣어주도록 할게요 얘도 마찬가지로 binary max보다 얘가 크다고 하면은 , 자, 그러면 일단 여기 있는 내용을 하나를 복사해가지고 똑같이 리턴을 해준 다음에 얘 같은 경우는 sql-c-binary로 만들어주고 두번째 타입이 sql-long-var-binary라는게 있습니다 이걸로 , 일단은, 만들어주시면 되겠어요 , 자, 녹아다가 거의 끝나가는데 얘는 byte로 , 이렇게, 캐스팅을 해서 넘겨주도록 할 것이고 else로 들어왔다고 하면은 아주아주 큰 바이너리는 아닐 때는 그냥 SQL 바이너리 타입으로 기본적으로 그냥 얘로 , 일단은, 넘겨주면 됩니다. 그래서 , 이렇게, 만들어주면 되겠다. 그래서 바인드 파라미터는 다 끝났고 이제 똑같은 노가다 작업을 바인드 콜 대상으로도 칼라온 대상으로도 해줘야 됩니다. , 자, 이걸 한번 만들어주면은 그 다음에 이제 평생 편하게 쓸 수 있기 때문에 이제 그냥 한번, 한번만 참고해주면 되구요 sql-tiny-int size-32-boolean 1byte value-index 까지 , 자, 얘는 이제 그나마 파레미터에 비해서 인자가 많이 줄어들었으니까 조금 더 수월하게 할 수 있을 것 같네요 sql-cfloat size-of-float 그리고 얘는 sqlc double sizeof double 그 다음에 sql.. 얘도 똑같이 ctinyint에 여기 사이즈만 int8 타입으로 치환을 해주면 되겠죠 근데 그냥 1바이트라고 1으로 그냥 넣어도 당연히 상관없습니다 어차피 고칠 것도 아니기 때문에 그 다음에 short type sizeof int16 그리고 sqlc long long 같은 경우에는 그냥 int32를 말하고 있는 거고요. 그 다음에 sqlc sbit int 얘가 이제 int64 짜리를 얘기하고 있는 겁니다. , 자, 그 다음에 이어서 time stamp 같은 경우에는 sqlc time stamp가 있었죠, 아까. 그래서 얘로 , 일단은, 해주면 되겠고요. 사이즈도 , 이렇게, 복붙을 해줄 것이고 , 자, 이제 두 개만 남았는데 얘는 sqlc w 캐릭터로 , 자, , 이렇게, 일단은, 넣어주도록 하겠습니다. 사이즈 나중에 문제가 있으면 그때 어차피 에러가 날 테니까 그때 가서 해결하도록 하고 , 자, 일단은, 빠르게 빠르게 , 이렇게, 처리를 해주도록 하겠습니다 SQL BINARY 그리고 BINARY 여기에는 여기다가 우리가 받아준 사이즈랑 실제 바이너리 요 데이터를 연결해주면 되겠죠 요 버퍼에다가 일단 넣어주게 되겠습니다 , 자, 여기까지 별다른 문제가 없는지 서버 코어를 , 일단은, 빌드를 해보도록 할게요 그래서 서버 코어까지 일단 통과가 된다고 하면은 이제는 그나마 좀 아까보다는 많이 편하게 사용할 수 있게 된 겁니다 그래서 다시 게임 서버 속으로 돌아가가지고 이제 요 부분을 이제 살짝 수정을 해보자면 어... 이 부분 일단 에러가 나긴 날 겁니다. 왜냐하면 기존에 우리가 프라이베트로 바꿔치기 해준 부분에 대해서 빨간줄이 빡 뜨게 될텐데 그 부분을 이제 수정을 해주면 되겠죠. 이 부분을 이제 그러면 어떻게 사용할 것이냐 이제는 db커넥션에다가 바인드 파라미터를 할 때 뭐 나머지 부분은 똑같기는 한데 이 부분에서 이제 3개 인자가 , 이렇게, 없어지게 되는 거죠. , 이렇게, 1번을 대상으로 무언 무엇을 넣어주겠다라는 식으로 사용하면 되니까 많이 편해졌다는 걸 일단 알 수가 있습니다. 그래서 여기도 마찬가지로 여기 3개씩 일단 날아가게 되겠죠 이런 느낌으로 그리고 바인드 컬럼 같은 경우에도 마찬가지로 이런 식으로 2개가 일단 날아갈 테니까 훨씬 더 깔끔하게 일단 사용할 거라는 걸 예측할 수가 있습니다. , 이렇게, 해서 다시 빌드를 해보도록 할게요. 아 그리고 참고로 이왕 새로 하는 거 뭐 우리가 지금 새로 넣어준 타입 대상으로도 잘 되는지 궁금하니까 시간이랑 어떤 이름 자체를 넣어가지고 한번 같이 한번 테스트를 해봅시다 겸사겸사 , 자, 그러기 위해서는 일단 요기 테이블 위에다가 테이블이 있으면 날린 다음에 요기다가 이제 추가적으로 정보를 몇 개를 넣어줄텐데 , 일단은, 골드에다가 쉼표를 하나를 한 다음에 엔터를 해가지고 어, 그 다음에 이름을 넣어줄건데 N바차 길이는 50자리로 , 이렇게, 넣어주도록 할 것이고 그 다음에 마지막으로 만든 날짜라고 해가지고 Create Date라고 해서 데이트 타임 타입을 , 이렇게, 만들어주도록 할게요 , 자, , 이렇게, 일단은, 만들어주고 그럼 이제 타입이 두 개가 늘은 겁니다 그 다음에 실질적으로 여기서 데이터를 만들어줄 때는 데이터를 3개를 지금 만들어주고 있는데 여기다가 이제 추가적으로 이름이랑 , 자, 이름은 그냥 아무거나 , 이렇게, 뭐 100바이트 절을 만들어준 다음에 여러분들이 원하는 그냥 한국어로 테스트 해봅시다 , 이렇게, 이름을 아무거나 넣어주고 근데 지금은 , 일단은, 여기 SQL 랜슨을 같이 넣어주긴 해야 되겠죠 그 다음에 타인 스탬프 스트럭트 ts 라고 합시다 ts. 날짜는 얼마얼마, ts.month는 6월, ts.day는 5일, 6월 5일이라고 가정해봅시다. 뭐 이런 식으로 넘겨주면 된다고 보시면 되겠어요. sql-length, ts-length는 0. 그 다음에 두 개를 복사해가지고 2번, 3번을 각각 넣어줄 것인데 이제 요 이름이 2번이니까 name을 각각 , 이렇게, 넣어주고 name-length를 마지막으로는 ts를 , 이렇게, 넣어주면 되겠죠 얘는 ts-length가 될 겁니다 , 이렇게, 일단은, 바인딩이 되어가지고 들어가게 될 것이고요 아이고 또 name은 얘가 필요 없죠 그 다음에 SQL 실행을 할 때는 insert into 라고 한 다음에 여기서 골드뿐만 아니라 이름이랑 네임이랑 create date 에다가 각각 밸류를 넣어 줄 것이다 라고 해서 물음표가 이제 3개가 되는 거죠 , 이렇게, 해서 정상적으로 실행이 됐으면 이제는 데이터가 뭐 우리가 강제로 넣어준 요런 데이터가 같이 들어가게 될 겁니다 그러면 이제 반대로 리드를 할 때도 이제 이거에 맞춰 가지고 읽어 주면 되겠죠 지금 여기서 지금 사용하고 있는 게 , 자, 골드랑 아이디 , 이렇게, 세가지 골드를 입력을 하고 아웃풋으로는 요렇게 두개를 받아주고 있는데 얘도 마찬가지로 다 긁어오는지 굉장히 궁금하니까 골드랑 네임이랑 크리에이트 데이트까지 다 , 이렇게, 받아오도록 하고 각각 인자를 추가를 해주도록 하겠습니다 아웃 네임 대충 한 100바이트짜리 크기가 100짜리 길이가 100짜리 W 캐릭터 배율을 만들어주고 그 다음에 sql-length로 아웃 네임 렌스라고 합시다 그 다음에 뭐 dbcon-bind-column을 해가지고 3번에다가 아웃 네임에다가 렌스 32 아웃 네임으로 , 이렇게, 길이를 넣어주고 아웃 네임 렌스를 , 이렇게, 넣어주면 되겠죠 그 다음에 얘가 실행이 되는지 궁금하니까 Assert Crash를 또 넣어주도록 하고 그 다음에 Timestamp Struct도 마찬가지로 Outdate라고 , 일단은, 테스트를 해보도록 합시다 SQL Lens는 아웃데이트의 렌즈이다. 그 다음에 어써트 크래쉬를 때려주면서 겸사겸사 DB커넥션에다가 바인드 칼럼을 해가지고 4번에다가 아웃데이트를 넣어줄건데 아웃데이트 렌즈를 같이 요렇게 건네줘가지고 인자들을 다 받아올, 칼럼들을 다 요 인자들한테 받아오겠다라고 하고 , 자, 나머지 부분은 뭐 딱히 고칠 필요 없을 것 같고 실행을 한 다음에 출력을 해보고 있습니다. , 자, 그 다음에 여기다가 이제 한국어 지원을 하기 위해서 , 이렇게, locale을 kor로 일단 살짝 바꿔준 다음에 그 다음에 여기서 기존에는 골드까지만 했는데 추가적으로 이름은 무엇이냐 아웃네임까지 출력을 해주도록 하고 그 다음에 날짜도 데이트는 얼마이다 라는 테스트를 꼼꼼하게 해주도록 할게요 그래서 슬래쉬로 그냥 합시다 빠르게 outdate.month 그 다음에 outdate.day 몇월 며칠이다 라고 해가지고 여기까지 통과되면은 이제는 그래도 아까와는 다르게 타입을 우리가 일일이 지정할 필요 없이 알아서 걔가 인지를 해가지고 알맞은 타입으로 이제 만들어질 거라는 걸 알 수가 있습니다 , 자, 여기까지 , 일단은, 빌드해가지고 정상적으로 실행이 되는지를 한번 테스트를 해보도록 할게요. 네, 그래서 여기 이닛에다가 그냥 전 프레이 폰트를 잡아놨고요. 별다른 문제가 없는지 한번 실행을 해보도록 합시다. , 자, 그래서 실행을 한 다음에 짜잔 하고 정상적으로 , 이렇게, 잡혀와 있는 거는 , 일단은, 잡았는데 아, 그냥 C아웃이 아니라 WC아웃으로 해야 되겠죠? 네, 여기서 얘를 , 이렇게, 고쳐주고 다시 실행을 해보도록 할게요. , 자, UTF-16 와이드 캐릭터이다 보니까 그냥 C하우스로 하면은 얘가 출력이 잘 안 될 수가 있습니다. 그래가지고 다시 바꿔놔가지고 보면은 정상적으로 데이터가 3개가 들어가고 뽑혀오는 것도 알 수가 있습니다. , 자, 여기 심표는 실제로 심표가 있는 게 아니라 그냥 2021로 잘 들어가 있는데 그냥 우리가 W하우스로, C하우스로 출력하다 보니까 얘가 , 이렇게, 출력이 된 거고 날짜랑 이름이랑 뭐 데이터가 정상적으로 다 들어가 있다는 것도 확인을 할 수가 있고 심지어 여기 SQL 개체 탐색키에서 직접 살펴봐도 당연히 데이터들이 잘 들어가 있을 겁니다. 그래도 혹시 모르니까 살펴보도록 합시다. server-db-gold에서 데이터 보기를 가보면 여기 정상적으로 데이터가 들어가 있는 것도 확인할 수가 있어요. 그래서 , 일단은, 1차적으로 , 이렇게, 바인딩을 , 사실, 노가다 작업이긴 했지만 좀 편하게 사용할 수 있는, 추후 편하게 사용할 수 있는 일단 토대를 마련을 했어요. , 자, 그런데 여기까지만 하면은 조금 또 아쉬운 부분이 굉장히 귀찮기도 여기 SQL 랜스를 우리가 직접 만들어 가지고 계속 넣어주는 요 부분이 , 일단은, 하나가 좀 마음에 안 들고요 그 다음에 여기 파라미터랑 컬럼 개수를 우리가 만들어 준 요 쿼리에 맞춰 가지고 똑같이 개수를 맞춰 줘서 실행을 해야 되겠죠 물론 개수가 안 맞는다고 하면은 어차피 크래시가 나기는 날 텐데 이게 나중에 엑세큐터가 실패했다고 해서 여러가지 사유로 인해서 실패할 수가 있습니다. 진짜로 여기 퀄이 자체가 문제가 있어가지고 예를 들면 우리가 인서트를 했는데 같은 프라이머리키로 데이터가 이미 있었다거나 하는 사유로 실패할 수도 있는 거고 그게 아니라 진짜로 , 이렇게, 인자 맵핑을 우리가 안 해가지고 인자를 누락한 게 있어서 실패할 수도 있을 거고 다양한 상황이 있을 텐데 그거를 매번마다 여기 실패한 로그를 보고 수정하는 것도 일이 될 겁니다. 그러니까 진짜로 이 모든 데이터들을 다 정상적으로 순차적으로 순서에 맞게 맵핑을 했는지 굉장히 궁금하다는 얘기가 되는 거죠. 그리고 심지어 여기 순서를 만약에 운 나쁘게 뒤바꿨다고 하면 그 부분도 문제가 될 겁니다. 그래서 이런저런 문제가 있다 보니까 이것도 조금 더 실수의 여지를 줄이기 위해서 , 자, 일단은, 래퍼 클래스를 하나 만들어줄 겁니다 여기다가 추가를 3 클래스를 해준 다음에 dbbind 이제 여기 파라미터들을 바인드 해주는 거를 도와준다 해가지고 dbbind란 이름으로 , 일단은, 클래스를 하나를 만들어 준 다음에 , 자, 여기서 , 일단은, 추가를 작업을 해보도록 할게요 이거는 제가 예전에 일하던 프로젝트에서 비슷한 느낌으로 사용을 했어서 제가 굉장히 좋아하는 방식이라서 이거를 좀 외워서 약간 모작을 해봤습니다 그래서 dbbind를 사용할 것인데 , 일단은, 얘를 어떻게 만들거냐면은 템플릿으로 만들어 줄 것이고 여기서 처음에 parameterCount랑 columnCount를 , 이렇게, 템플릿으로 받아줄 겁니다. 근데 템플릿을 사용한다고 해서 꼭 얘를 타이프네임 모시기로 만들어줘야 되는 건 아니에요. , 이렇게, 정수인 것까지는 우리가 정해줄 수가 있습니다. 근데 이제 , 이렇게, 만들어주면은 여기서 이제 인풋 카운트가 되는 거고 얘가 아웃풋 카운트가 되는 거죠, 사실상. 그래서 , 이렇게, 템플릿으로 만들어주게 되면 여기다가 00을 넣어주는 거랑 12를 넣어주는 거랑 두 경우에 대해서 클래스가 따로따로 만들어지게 될 것이고 서로의 연관성은 없는 완전히 별도의 클래스로 , 일단은, 만들어진다고 생각하시면 되겠습니다 , 자, 그리고 , 일단은, public 나중에 상속을 할 수 있으니까 protected를 일단 만들어줄 것이고 여기서 이제 먼저 db-connection을 , 이렇게, 들고 있을 거예요 얘는 말 그대로 헬퍼니까 얘가 뭔가 실행을 할 때 필요한 모든 애들을 다 받아줄 겁니다 그래서 겸사겸사 db-connection 헤더도 추가를 해줄 것이고 , 자, 그 다음에 여기서 얘가 실행해야 될 Query를 내부적으로 또 , 이렇게, 들고 있을 것이고 그 다음에 우리가 아까 SQL Lens 시리즈를 매버마다 만들어줬는데 그거를 편하게 관리하기 위해서 내부적으로 다 들고 있을 겁니다 근데 얘가 이제 개수가 몇 개인지는 이 파람 카운트에 따라 달려 있을 테니까 요렇게 , 일단은, 만들어주고 싶은데 , 이렇게, 만들어주면 살짝 문제가 되는 게 만약에 인자를 안 받는 경우 0으로 하게 되면은 크기가 0짜리인 배열이 만들어지는데 그거는 문법적으로 맞지 않기 때문에 문제가 일어납니다 그래가지고 이거를 파란 카운트를 체크해서 0보다 크면은 그냥 파란 카운트로 만들어 주고 파란 카운트 그게 아니라고 하면 1로 , 이렇게, 만들어 주도록 할게요 사이즈를 이 문법이 통과되는 이유는 이 파란 카운트라는 것 자체가 컴파일 타임에 결정이 되는 앱이기 때문에 여기 있는 요 구문도 어 컴파일 타임에 결정이 되기 때문에 , 이렇게, 사용할 수 있는 거예요. 그게 아니라 여기 있는 다른 동적으로 런타임에 결정되는 인자들을 이용해 가지고 , 이렇게, 코드를 만들 수는 없습니다. 여기 배열 크기는 무조건 컴파일 타임에 결정이 돼야 되기 때문에 이 문법이 통과되는 거라고 보시면 되겠어요. 마찬가지로 column index도 , 이렇게, 들고 있도록 하겠습니다. column index. 그 다음에 내가 모든 애들을 세팅했는지를 알기 위해서 변수를 또 둘 건데 어... 내가 세팅한 개수만큼을 뭐 추적하는 것도 첫 번째 방법이 되겠죠? 예를 들면 이런 식으로 바인드 파라미터를 할 때마다 카운트를 1 증가시킨다거나 할 수 있겠지만 그렇게 만들면은 조금 찝찝한 게 실수로 같은 넘버로 두 개를 추가할 때가 처리가 안 되겠죠? 그러니까 이왕이면은 그런 부분까지 처리를 하기 위해서 비트 플래그로 관리를 해주도록 하겠습니다. 그래서 파라미터 플래그라고 일단 이름을 지을 것이고 두 번째는 이제 컬럼 플래그라고 해가지고 모든 애들이 다 채워져 있는지를 이제 체크를 해주게 될 겁니다. 64 비트 유인트 64니까 64 비트니까 데이터를 64개까지 사용할 수 있으니까 뭐 충분히 충분할 것 같고 , 자, 그 다음에 여기 이제 이어가지고 먼저 생성자를 만들어 주도록 하겠습니다 생성자에서는 먼저 db 커넥션을 , 이렇게, 받아 줄 것이고 db 커넥션 그 다음에 const wcharacter pointer로 내가 실행할 쿼리를 받은 다음에 각각 들고 있도록 할게요 , 이렇게, 그리고 db connection 그리고 query 오늘 자동완성이 조금 속을 썩이고 있는데 , 자, 요렇게 일단 만들어주고 그 다음에 처음에는 초기화를 할때는 요기 파라미터 인덱스를 그냥 0으로 쫙 밀어주려고 합시다. sizeof 파람인덱스 파람인덱스 그 다음에 복붙해가지고 컬럼인덱스도 0으로 쫙 밀려줄것이고 그 다음에 파람플래그는 0으로 밀어주고 column flag도 0으로 밀어주고 그 다음에 db connection unbind도 호출해가지고 모든 초기화 작업을 마치도록 할게요 이러면 진짜로 완전히 새로운 상태가 된거죠 그래서 이제부터 그럼 무엇을 할 것이냐 나머지 함수들을 만들어 줄 것인데 먼저 , 자, validation 함수를 , 이렇게, 만들어 줄 것이고요 그 다음에 이어가지고 실행하는 함수도 요렇게 만들어 줄 것이고 일단 모양을 만들어 봅시다. 그 다음에 데이터가 여러 개일 경우에 그걸 하나씩 하나씩 긁어오는 fetch 함수도 요렇게 만들어 줄 겁니다. 그리고 여기다가 이제 나머지 bind 함수를 만들어 주게 될 거예요. , 자, 그러면은 우선 쉬운 것부터 해보자면 얘 같은 경우에는 그냥 DB Connection에 Fetch만 호출해가지고 반환을 해주면 되니까 굉장히 간단하고 얘같은 경우에도 Asset Crash를 먼저 해가지고 Validation을 한 다음에 얘를 통과했다 하면은 return dbconnection.execute를 해줘가지고 요 쿼리를 그냥 막바로 실행을 해줄겁니다 그럼 이제 남은 거는 이 Validation 체크를 어떻게 할지 그리고 이제 나머지 부분들을 처리해줄 것인데 지금은 얘를 어떻게 해줄 거냐면은 우리가 파란 카운트랑 컬러 카운트를 대상으로 이제 선정을 해주게 될 겁니다. 예를 들면은 우리가 사용하는 것 중에서 뭐... 요런, 요런 경우 얘 같은 경우는 지금 인풋 파르미터가 3개가 있고 아웃풋은 없으니까 3, 0으로 이제 이 DB Bind를 만들어주게 될 겁니다. 그래가지고 얘네들을 이제 다 Bind, Bind, Bind을 3개를 다 해줬을 경우를 이제 체크를 해준다는 얘기가 되는 거죠. 네 근데 이거는 조금 헷갈리니까 , 일단은, 조금 맨 마지막으로 만들어 보도록 하고 바인딩 하는 부분부터 만들어주도록 합시다 , 자, 얘네들도 이제 하나씩 만들어 줄 건데 Bind Parameter 라고 해가지고 몇 번째 인덱스를 대상으로 Value를 , 이렇게, 받아줄 것이다 라고 한 다음에 DB Connection에 Bind Param으로 호출해줄 것인데 원래 이제 Bind Param이 우리가 여기서 사용하던 게 1번부터 사용을 하고 있는데 저는 개인적으로 1번부터 하면 굉장히 헷갈리는 것 같습니다. 코딩을 할 때 우리가 0번부터 하는 게 익숙하니까 그냥 0번으로 받아주고 거기다 1을 더해서 넘겨주도록 할게요. 그 다음에 Value를 넘겨줄 것이고 파라미터 인덱스를 , 이렇게, 건네주도록 하겠습니다. 즉, 여기서 우리가 , 이렇게, 임시로 할당해가지고 사용하던 부분을 내부적으로 처리를 해준다는 얘기가 되는거죠. 바인드 파라미터를 해주고 그 다음에 이어가지고 파라미터 플래그를 비트 플래그를 이용해가지고 1을 idx만큼 비트쉐프트를 해가지고 옮긴 다음에 오어 연산을 통해가지고 이 비트를 딱 켜주도록 하겠습니다. 그래서 말 그대로 비트 플래그를 관리를 해주는 거죠. 그냥 계산기를 켜가지고 살짝 보여드리자면 만약에 예를 들면 우리가 8개를 사용한다고 과정해볼게요. 지금 데이터를 8개를 입력을 해야 되는데 여기서 인덱스가 두번째 데이터, 두번째 데이터를 만약 설정했다고 하면 걔를 , 이렇게, 뿅! 해서 1로 켜주게 될 겁니다. 그래서 결국에는 우리가 설정한 개수만큼이 모두 다 1로 켜졌으면 걔는 이제 모든 데이터를 채웠다라고 일 때 인지를 할 수가 있겠죠. 그래서 이런 식으로 파라미터 플래그를 지금 관리하고 있는 겁니다. , 자, 그리고 이제 이어가지고 요 방식 말고 나머지들도 하나씩 만들어 주도록 할게요 바인드 파라미터인데 인덱스를 건네주고 w 캐릭터 포인터를 , 자, 이런식으로 문자를 건네준다거나 하는 경우도 있겠죠 바인드 파라미터를 해주고 idx 플러스 1에다가 value 그 다음에 얘도 마찬가지로 파라미터 인덱스 idx번을 , 이렇게, 건네준 다음에 역시나 파람 플래그를 , 자, 이런식으로 다시 똑같이 켜주도록 하겠습니다. 오어 연산을 통해가지고 1만큼을 idx만큼 옮기고 , 자, 이렇게, 한 다음에 얘는 이제 이 템플릿으로 대부분의 경우가 챙겨지는데 좀 예외적인 경우 몇가지만 , 이렇게, 따로 챙겨주고 있는 겁니다. 그래가지고 , 일단은, 또 예외적인 케이스가 뭐가 몇가지가 있는데 이번에는 , 자, 템플릿 타임네임 t 그냥 일반적인 뭐 바이트 배열 같은 느낌으로 뭔가 어떤 배열을 넘겨줄 때 처리를 해주도록 할게요. t 타입을 반환해주고 , 자, 요런 배열이 있다고 했을 때 얘를 이제 어떻게 처리를 해줄 것이냐도 만들어주도록 하겠습니다. 그래서 얘같은 경우는 그냥 const byte 포인터로 뱉어줄 것이고 사이즈 계산은 T 사이즈에다가 n을 곱해 주도록 할게요. 요런식으로 바이트 배열도 받아줄 수가 있을 것이고 , 자, 그 다음에 마지막으로 하나만 더 만들어 볼 건데 이번에는 그냥 포인터에다가 개수까지 지정해가지고 어떤 뭐 이런식으로 배열 형태가 아니라 그냥 데이터를 지정해가지고 몇 개짜리를 우리가 넣어주겠다. 그리고 그 시작 주소는 무엇이다라고 하는 경우도 생길 수 있으니까 그 부분을 요렇게 만들어주도록 하겠습니다. , 자, 얘는 템플릿은 필요 없고 , 이렇게, Value Type을 , 이렇게, 넘겨주면 될 겁니다. 그러면 나머지 부분은 안 건드려도 되고 , 자, 이렇게, 해가지고 대부분의 경우에는 , 사실, 이 윗버전을 사용할 거지만 나머지 문자열이라거나 바이트 배열 등등을 처리하기 위해서 나머지 버전도 , 이렇게, 열어놨어요. 그 다음에 이 똑같은 작업을 이제 BindColumn으로 대상으로 해줄 겁니다. 대부분의 경우에는 이 첫번째 타입으로 들어올 것이고 BindColumn, 그 다음에 Int32, Index1에 대해서 Value를 처리해줄 것인데 DB Connection에 Bind Column을 해줄 것이고 idx++1 Value 그 다음에 Column Index에 idxBurn을 , 이렇게, 해준 다음에 Column Flag를 이번에는 Bit Flag으로 켜줘가지고 1LL idx만큼을 해주도록 할게요. 그 다음에 비슷하게 나머지 좀 예외적인 애들도 굳이 챙겨보자면 아까 위에서 챙겨준 애가 몇가지가 있었죠 여기 만약에 n 타입을 , 이렇게, 받아준다거나 할 때 w 캐릭터 value 그리고 n , 자, 요런 배열 크기의 W 캐릭터 배열 같은 것도 받아줄 수 있을 테니까 뭐 요런 것도 , 일단은, 처리해주면 좋을 것 같습니다. 그래서 앞으로 여러분들이 뭐 사용하는 거에 따라가지고 필요한 거를 이제 하나씩 하나씩 만들어 주시면 됩니다. 필요에 따라가지고 뭐 요런 느낌으로 얘는 넓 바이트까지 일단 포함을 해가지고 생각을 하면은 일단 이를 개수를 빼서 전달해준다거나 하는 식으로 뭐 만들면 되겠죠. 그리고 정말 정말 마지막으로 이 위에서 만들어준 버전이랑 비슷하게 bind column idx번에 대해서 wcharacter value int32 length를 직접 지정해줄 때 포인터랑 개수를 직접 지정할 때 얘는 이제 배열을 지정한 거였고 그게 아니라 뭐 요런 상태도 , 일단은, 뭐 지원해줄 수가 있을 겁니다 그러면은 bind column을 해가지고 idx 플러스 1번 value length-1 column index에 idx번 그 다음에 column flag는 얘는 그냥 복붙을 하도록 할게요 요런 느낌으로 만들어 줄 것이고 그리고 아 하나가 더 남았었네요 , 자, 이런식으로 바인드 컬럼을 똑같이 해줄것인데 이번에는 idx에다가 t 타입으로 value의 n을 뭐 요렇게 좀 받아주는 버전도 만들어 줄 수가 있겠죠. 얘는 이제 그냥 일반적인 그런 바이트 배열을 만들어 줄 겁니다. 뭐 이미지 파일 같은 걸 사용할 때 얘를 들을 수가 있겠죠. bind column index plus 1 value size 32t n 그 다음에 컬럼 인덱스에 idx번 그 다음에 역시나 요 부분은 복붙 하면은 이제 모든 경우에 대해서 이 바인드 파라미터랑 컬럼이 어느정도 만들어져 있으니까 이걸 이용해가지고 이런식으로 비트 플래그를 다 채워줄 것이고 비트 플래그가 최종적으로 채워져 있는지를 이제 테스트해야 됩니다 근데 이게 살짝 여기서 애매한거는 비트 플래그가 모두 다 채워진거를 어떻게 봐야 될까요 이 데이터 크기 따라가지고 달라지기 때문에 뭐 이거를 실시간으로 만들어서 해도 되지만 이거를 조금 재밌게 하는 방법을 보여드리자면 뭐 , 사실, 굳이 , 이렇게, 안해도 됩니다 여기서 그냥 하나씩 하나씩 개선을 해도 돼요 개수만큼을 근데 그게 아니라 템플릿으로 굳이 만들어보자면 저 이 코드를 굉장히 좋아하는데 , 자, 템플릿을 만들어 볼건데 struct를 full bits라는 타입으로 일단 , 이렇게, 하나를 만들어 줄게요 네 그래가지고 얘가 기본적으로 value는 , 자, 1에다가 하나를 뺀 것만큼 비트 쉬프트를 한 다음에 그 다음에 OR 연산을 해줘 가지고 FULL BEATS에다가 C-1 개만큼의 밸류를 추출해줄 겁니다 , 자, 약간 외교 같은데 결국에는 여기가 우리가 예를 들면 FULL BEATS에 3이라고 했으면 얘는 이제 어떻게 되냐면은 뭐 요렇게 되는 거죠 1을 2만큼 옮긴 다음에 FULL BEATS 2를 같이 , 이렇게, OR을 해주겠다 같이 , 이렇게, 해주게 되는데 얘도 결국에는 다시 1에 1로 된 다음에 여기다가 FULL BEATS의 0번 이런 식으로 계속 재규적으로 줄어가면서 얘가 만들어지게 되는 겁니다 이런 코드들이 그러면 모든 우리가 원하는 개수만큼의 모든 비트들이 하나씩 채워진 거를 체크할 수 있다는 얘기가 되는 거죠 그런 느낌이고 근데 그 다음에 이제 예외적인 케이스를 몇 개를 만들어줘야 되는데 이거 특수 상황 FULL BEATS가 1일 1로 딱 끝나게 되면 걔는 더 이상 갈 수는 없으니까 Value가 1일 것이고 그리고 마지막으로 template struct fullBits가 0이다 하면은 그냥 아무것도 없는 값이니까 value는 0으로 만들어주면 되겠습니다. 굉장히 재밌는 코드죠? 저는 이런 코드를 굉장히 좋아합니다. 그래서 요걸 이용해가지고 굳이 만들어보자면 validation 체크를 할 때 파란 플래그를 체크할 것인데 얘가 fullBits에 파란 count의 value랑 똑같고 그리고 columnFlag 같은 경우에는 full bits의 column count의 value랑 똑같은지를 체크해가지고 얘가 만약에 맞다고 하면은 정상적으로 이제 체크가 통과해가지고 넘어갈 수 있게 된다고 보시면 되겠습니다. 뭐 요런 느낌으로 , 일단은, 채워줄 수가 있을 거예요. , 자, 그래서 , 일단은, 서버커를 빌드해가지고 별다른 문제가 없는지를 한번 체크를 해볼건데 어 지금 살짝 문제가 되는 부분이 한가지가 있네요 79번째 줄에서 지금 문제가 일어나고 있는데 w 아 타임네임이 아니라 int32입니다. 네 얘는 크기를 일단 , 이렇게, 만들어준 거니까 이 배열을 받아주기 위해서 우리가 , 이렇게, 만들어준 거니까 int32로 바꿔주면 되고요 오케이 통과가 되었고 , 자, 그 다음에 대부분의 경우에 , 이렇게, 지금 다 처리를 해줬으니까 이제 이어가지고 한번 테스트를 해보도록 하겠습니다 , 자, 그래서 이걸 간단하게 테스트 해보기 위해서 위쪽에다가 , 일단은, include dbbind를 추가해 줄 것이고 아까 우리가 작업한 이 테스트 코드들을 이제 굳이 우리가 새로 만든 dbbind를 이용해 가지고 만들어 보도록 할게요. 여기서 커넥션을 팝한 다음에 여기부터 , 일단은, 주석을 쫙 처리해 주도록 하겠습니다. 여기서 SQL 실행 한 다음에 푸쉬하는 부분은 들어가야 될 테니까 여기서 여기까지 일단 주석 처리를 하고 그 다음에 이걸 이제 다시 한 번 우리만의 방식으로 다시 한 번 만들어 보자면 DB BIND를 해줄 것인데 여기서 , 일단은, 인풋은 3개 아웃풋은 없으니까 연결을 만들어 주면 되고 DB BIND를 만들어준데 DB Connection을 먼저 , 이렇게, 참조를 넘겨주고 그 다음에 여기다가 이제 Query를 우리가 입력을 해주면 되겠죠? Query는 여기 있으니까 긁어오도록 할게요. 여기까지. 그래서 얘를 다시 , 이렇게, 건네주도록 하고 그 다음에 여기서 이제 넣어줘야 되는 값은 기존과 마찬가지로 요 부분 3개는 일단 그대로 갖고 오도록 하겠습니다 이거랑 W 캐릭터 요 부분이랑 그 다음에 Time Stamp Struct 참고로 얘는 이 순서를 보면은 지금 요 순서로 되어 있기 때문에 Year, Month 되어 있기 때문에 그냥 얘를 막바로 , 이렇게, 넣어줘도 됩니다 그래도 잘 인지를 할 거에요. 그래서 , 이렇게, 데이터들을 다 만들어 놓은 다음에 그거를 dbbind를 통해 가지고 bind parameter 0번은 gold dbbind bind param 1번은 name 그 다음에 dbbind, bind parameter 해가지고 2번은 ts 뭐 이런 식으로 편하게 편하게 이제 만들어 주면은 기존처럼 , 이렇게, SQL 랜스를 막 일일이 만들어줄 필요도 없을 것이고 이제는 만약에 우리가 execute를 하는데 execute를 하는데 얘를 만약에 하나도 누락을 해가지고 이 개수만큼을 안 채워줬으면 얘가 먼저 SQL을 실행하기도 전에 잡아주게 되겠죠 뭐 그런 느낌으로 , 일단은, 만들어줄 수가 있을 거예요 그리고 이제 이어서 아랫부분도 바꿔보자면 얘도 마찬가지로 언바인드 하는 부분부터 주석을 처리해가지고 쭉 내려가지고 로그를 찍는 부분 앞에서 , 이렇게, 딱 멈추도록 할게요 여기까지는 일단 똑같이 만들어 줄 것 같으니까 , 자, 그 다음에 여기서 다시 DbBind 래퍼를 만들어 준다면 이번에는 Input은 1개, Output은 4개라는 걸 알고 있죠? 네, 이렇게, DbBind를 만들어줄 것이고 이 객체에다가 마찬가지로 DbConnection이랑 그 다음에 여기다가 이제 Query를 넣어주면 되는데 Query는 역시나 여기 있습니다. 여기부터 끝까지 끝까지 , 이렇게, 긁어가지고 이 부분을 다시 위쪽으로 올려주도록 할게요. , 자, , 이렇게, 한 다음에 필요한 것 골드랑 아웃 아이디 아웃 골드 아웃 네임 그리고 마지막으로 타임 스탬프 , 이렇게, 까지 일단 필요하니까 요 변수들은 이제 사용할 거니까 다시 끄집어 오고 여기서 하나씩 넣어주면 되겠죠 dbbind에 bind parameter 0번은 무엇이다 그리고 여기부터는 dbbind bind column을 해가지고 0번은 out id에 이거를 좀 아래에다가 한번에 관리합시다 4개를 만들어주고 1 2 3 그 다음에 각각 골드 네임, 그 다음에 데이트를 , 이렇게, 만들어주면 되겠죠 물론 지금도 우리가 , 이렇게, 순차적으로 만들어주는 거는 변함이 없기는 하지만 이것도 나중에 따르게 처리하는 방법이 있습니다 이걸 순차적으로 , 이렇게, 우리가 일일이 넣지 않고 하는 방법에 대해서는 나중에 좀 고민을 해보도록 하고 , 일단은, 그래도 기존에 비해서 많이 간단해진 걸 알 수가 있습니다 점점점 발전하고 있는 거죠 이게 좀 더러운 코드들이 없어지고 이제 편하게 테스트를 할 수 있게 일단 되어있다라고 볼 수 있는 거고 여기서 Execute를 빵 때려주면 역시나 실패 여부가 정상적으로 뜨게 될 겁니다. 그래서 이 코드가 정상적으로 잘 동작하는지 기존과 마찬가지로 동작하는지만 테스트 해보고 이 수업을 마치도록 할게요. 아 근데 보다보니까 요 부분 바인드 컬럼을 할 때 화살표를 한 개만 만들어놨네요 비트 쉬프트 하다보니까 두 개를 해줘야 되는데 비교 연산자가 되어서 이 부분을 일단 수정을 하고 다시 테스트를 해보도록 하겠습니다 , 자, 이렇게, 다 모든 부분이 통과가 되면은 여기 이닛에다가 브레이크폰을 잡아가지고 나머지 부분이 빵 실행이 될 테니까 똑같이 한번 실행을 해보도록 할게요 , 자, 그러면 여기 보면은 이제 정상적으로 다 똑같은 부분이 이제 다 실행이 됐고 결국에는 우리가 조금 더 확실하게 이제 잡아줄 수 있는 그런 부분에 대해서 , 일단은, 만들어봤고 이제 앞으로 이런 식으로 만들어주면 된다고 보시면 되겠습니다. 사실은 뭐 그냥 개인 프로젝트라고 하면은 그냥 여기까지만 만들어도 굉장히 충분하긴 한데 이거에 대해서 더 더 더 편하게 만들 부분은 이제 다음 씬에서 조금 고민을 해보도록 하겠습니다. , 이렇게, 해서 간단하게 이번 수업을 마치도록 할게요.