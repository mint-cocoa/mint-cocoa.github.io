자, 이렇게, 해가지고 지난 시간까지 간단하게 이 버퍼 헬퍼 클래스들을 두 개를 만들어가지고 조금 편리하게 데이터를 쓰고 읽는 그런 방법에 대해서 , 일단은, 실습을 해봤습니다 어 , 사실, 버퍼 여기 보다 보니까 버퍼 라이터 쪽에 좀 버그가 한가가지가 있기는 한데 그건 일단 나중에 나올 거니까 뭐 나중에 다루도록 하고 이어가지고 오늘 할 내용을 살짝 언급을 해보자면 , 일단은, 지난번에 만들었던거 기준으로 한번 복귀를 해봅시다 요 방법이 뭐가 좀 찜찜한지 , 일단은, 이런식으로 내가 보낸 순서와 받은 순서를 정확히 일치시켜야 되는거죠 이런식으로 내가 id,hp,attack 순으로 보냈는데 파싱을 할때 거꾸로 하나를 누락하거나 아니면 attack을 먼저 파싱해가지고 순서가 꼬인다거나 하면은 애당초 엉뚱한 값들이 들어가게 될겁니다 그리고 요런 버그들은 굉장히 찾기가 힘들어요 아무런 문제 없이 계속 진행이 되다가 한참 후에 막 터지고 이런 일이 일어날 수 있기 때문이죠 그건 그렇고 또 다른 문제점 중 하나라고 볼 수 있는 거는 이제 우리가 그냥 간단하게 아주 작은 테스트를 하는 게 아니라 진짜로 실제로 이걸 이용해가지고 우리가 진짜 좀 온라인 게임을 만든다고 가정을 하면은 가장 아쉬운 부분은 지금 패킷별로 뭔가 구분이 전혀 안 돼 있다는 거죠 여기서 onReceive 패킷에서 그냥 간단하게 하나 테스트를 해봤지만 나중에 가면 그래도 패킷이 꽤 여러 개가 될 겁니다 이 ID에 따라 가지고 구분을 해줘 가지고 파싱을 해줘야 되는데 일반적으로 그냥 포트폴리오를 만들 때는 한 10개에서 20개 정도면 충분하고요 보통 이제 실제로 라이브로 운영되는 온라인 게임 경우에는 한 100개에서 200개 정도 사이까지 가는 것으로 이제 기억을 합니다. 그러니까 생각보다 뭐 몇천 단위까지는 가지 않아요 생각보다 그렇게까지 많이 필요하지는 않지만 어찌됐건 이 아이디를 구분해줘가지고 무엇을 파싱할지는 알아야 되니까 이제 그거를 한번 나눠줄 필요가 있다는 거죠. 근데 이 Receive Packet 지금 이 Server Session이라는 안에다가 우리가 여기 Receive Packet을 파싱하는 부분까지 넣어놨는데 이 Server Session이라는 애는 나중에 가면은 굉장히 많은 기능들을 얘가 포함을 하게 될 겁니다. 그렇기 때문에 여기 안에서 직접적으로 패킷과 관련한 내용을 섞기 보다는 일단 이거를 하나를 클래스를 별도로 빼준 다음에 별도로 관리를 해주도록 할게요 그래서 새로운 클래스를 만들 건데 뭐 이름하여 클라이언트 쪽에서 패킷을 핸들링 한다 라는 이름으로 클라이언트 패킷 핸들러 라는 이름으로 하나를 클래스를 만들어 주도록 할 것이고 그 다음에 서버 쪽에서도 마찬가지로 서버 쪽의 패킷을 핸들링 하겠다라는 굉장히 엄청난 의미를 담아서 클라이언트 패킷 핸들러 라는 이름으로 클래스를 추가를 해주도록 할게요. 그리고 그 다음에 드래그 , 자, 그래서 , 이렇게, 일단은, 만들어졌구요 어 그럼 가장 먼저 하고 싶은 거는 뭐냐면은 , 자, 우리가 지난번에 여기 onReceivePacket 쪽 부분을 잠시 한번 살펴보도록 합시다. 일단 얘를 오른쪽에 잠시 , 이렇게, 위치시키고 살펴볼게요. 그럼 내가 패킷을 받았을 때 지금 파싱하는 부분이 있는데 요 부분을 , 일단은, 클라이언트 패킷 핸들러 쪽에 처리하도록 넘겨주도록 하겠습니다. 그래서 public static void handlePacket 이라는 함수를 만들어가지고 무조건 패킷 관리는 얘한테 다 떠넘겨 주도록 할게요. 이런 식으로 좀 관리를 구분해서 해야지만 나중에 큰 프로젝트를 관리할 때 굉장히 편하기 때문에 , 이렇게, 만들 것이고 그런데 여기서 에러가 나는 이유는 PCH 설정이 아마 안 돼 있는 것으로 보이네요 속성에 가서 우리가 더미 클라이언트는 아마 안 해줬던 걸로 기억을 하는데 C++에 가서 미리 컴파일된 헤더에서 얘가 설정이 안 돼서 그런 거니까 미리 컴파일된 헤더는 pch.header로 우리가 이름을 짓기로 했고, 그 다음에 사용으로 바꿔준 다음에 확인을 눌러주시면 되겠습니다. 구성은 모든 구성, 모든 플랫폼에다가 적용을 시켜주도록 하고, 그 다음에 pch.cpp를 우클릭해가지고 속성에 간 다음에 얘는 만들기로 가서 OK를 해주시면 , 일단은, 준비가 된 겁니다. 그 PCH는 들어가있고 , 자, 그 다음에 요렇게 하면은 이제 문제가 아마도 없어질 것으로 보이구요 , 자, 그 다음에 요 부분에서는 include PCH를 그냥 우리가 직접 추가를 해주도록 할게요 이게 아까 어 설정이 안되있어가지고 자동으로 추가가 안된 것 같네요 , 자, 그래서 에러가 없어졌고 그 다음에 뭐 핸들패킷 임플레멘테이션을 만들어가지고 요기서 이제 구현부를 만들어 주도록 하겠습니다 그러면 얘를 , 일단은, 더미 클라이언트 쪽에서는 핸들 패킷을 바로 호출한 다음에 얘를 그냥 그대로 토스를 해주도록 합시다 클라이언트 패킷 핸들러의 핸들 패킷이 얘를 처리해줄 것이다 라고 넘겨주고 헤더는 추가를 해줘야 되겠죠 클라이언트 패킷 핸들러 , 자, 그 다음에 여기 지금까지 했던 내용을 싹리 다 복붙 해가지고 핸들 패킷 쪽에다가 , 일단은, 복사를 하고 시작을 해보도록 하겠습니다 그 다음에 더미 클라이언트에서 온 리스 패킷은 , 사실, 더 이상 할 건 없고 참고로 얘 같은 경우에는 여기서 굳이 뭐 인트 31을 뱉어줄 이유도 없죠 왜냐면은 어차피 지금 패킷이 완전체로 왔다는 걸 미리 계산해 가지고 넘겨준 상태이다 보니까 뭐 굳이 여기서 추가적으로 리턴 할 건 없을 것 같고 , 자, 이걸 하는 김에 패킷 세션 쪽으로 돌아가 가지고 요 부분도 같이 수정을 해 보도록 합시다 그건 괜히 해준 것 같네요 , 자, 그래서 패킷 세션에 onReceive 패킷을 보면은 어 얘도 이제 보이드로 만들어 주면은 문제가 해결될 것 같고요 서버코어 빌드를 다시 한번 해 주도록 할게요 , 자, 그래서 아까 하던 얘기로 다시 돌아와 보면은 클라우드 패킷 핸들러에다가 패킷 핸들을 할 수 있게끔 얘를 일단 만들어놨고 버퍼 리더는 다시 추가를 해준 다음에 그 다음에 이제 헤더를 패킷 아 얘도 세션이 지금 추가가 안되가지고 얘를 모르는 것 같은데 세션같은 경우는 뭐 종종 사용할 일이 생길 것 같으니까 코어 P스위치에다가 돌아가가지고 요게다가 , 일단은, 세션은 추가를 해주도록 하겠습니다 세션 세션 헤더까지 추가해서 재빌드를 해서 넘기면은 요 부분도 아마 이제 없어지겠죠 빨간색이 오케이 , 자, 이게 해결이 되었고 그 다음에 요기서 추출해가지고 헤더를 지금 , 이렇게, 살펴본 상태이고요 그 다음에 해야되는거는 이제 이 헤더 값을 참고해가지고 패킷 아이디가 무엇인지에 따라가지고 이제 막 처리를 해주면 될겁니다 근데 뭐 지금은 아직 아이디를 어떻게 관리할지 모르겠으니까 , 이렇게, 이넘으로 , 일단은, 관리를 해주도록 할게요 s-bar-test라는 애 1번부터 시작을 하도록 합시다 요 패킷 자체가 이제 아까 우리가 지금 테스트하고 있는 요 패킷의 번호라고 , 일단은, 가정을 해보도록 할게요 그리고 여기 s-underbar가 붙은 이유는 뭐냐면은 나중에 우리가 클라가 서버한테 보내주는 경우도 있고 서버가 클라한테도 보내주는 경우가 있는데 어지간하면은 요 패킷 이름에다가 컨벤션을 하나 정해가지고 예를 들면은 서버에서 클라로 보내는 거는 s-underbar가 붙고 클라에서 서버로 보내는 거는 c-underbar가 붙는 식으로 작업을 해야 좀 가독성이 높아집니다 그리고 나중에 보안적인 측면에서도 이 S-underbar 테스트 같은 경우에는 무조건 서버에서 클라로만 보내는 것을 확인한다거나 하는 그런 추가적인 작업도 할 수 있기 때문에 이런 식으로 컨베이션을 하나를 만들어 준 겁니다. S-underbar 그래가지고 어찌됐건 여기 클라이언트에서 만약에 스위치 케이스로 봤는데 봤더니만 너가 지금 보낸 패키지 자체가 케이스가 S-Underbar 테스트라고 한다면 그러면 이어서 이 부분을 그대로 처리해주면 되겠죠 여기도 마찬가지지만 나중에 패킷이 몇백개가 된다고 하면 이 스위치 케이스분이 몇백개 단위로 늘어나게 될 겁니다 케이스 뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐뭐� 전역으로 스위치 케이스 없이 얘를 빠르게 찾을 수 있는 그런 수단을 마련한 게 일단 좋긴 하겠어 근데 그건 일단 좀 나중에 챙기기로 하고 , 일단은, 스위치 케이스로 간단하게 만들어 본 다음에 요 부분을 이제 여기서 실행해야 되는데 일단 별도의 함수로 얘도 똑같이 빼줘 가지고 관리를 하도록 할게요 너무 함수가 많아질 수 있으니까 그래가지고 , 일단은, Static Void Handle on the bar s 테스트 패킷을 처리한다라고 해가지고 Handle s 테스트라는 이름으로 만들어 줄 것이고 버퍼랑 렌스는 그냥 그대로 다시 넘겨 받도록 하겠습니다. 그러면 얘는 이제 핸들 S 테스트를 호출해가지고 버퍼랑 렌스를 그대로 다시 전달해준다라고 볼 수가 있는 거죠. 그러면 얘는 이제 구현부를 다시 만들어준 다음에 혹시나 돌고 돌아서 다시 얘를 이쪽에다가 , 이렇게, 밀어 넣어주도록 하겠습니다. 그래서 한바퀴 돌아가지고 요렇게 처리가 된건데 결국에는 receive 패킷이 성공적으로 와가지고 패킷이 조립이 되었으면은 그걸 다시 클라이언트 패킷 핸들러한테 넘긴 다음에 얘가 헤더를 참고해가지고 몇번 아이디인지 참고해서 만약에 요 테스트 패킷이라고 했으면은 핸들 S 테스트로 넘긴다라는 부분까지 실행이 된겁니다 , 자, 요렇게 해서 만약에 왔다고 하면은 이제 그 다음에 코드 자체는 이제 똑같이 만들어주면 되겠죠 여기서 이 부분을 다시 복붙해가지고 갖고 온 다음에 영역을 처음부터 다시 집어 줘가지고 작업을 하면 되는데 근데 여기서 하나 조심할 거는 패킷 헤더도 아직까지 들어가 있으니까 얘도 이제 다시 , 이렇게, 추출을 해주도록 하겠습니다 얘는 뭐 당장 사용하진 않을 거라고 해도 뭐 어쨌든 추출을 해줘야지만 패킷 사이즈가 맞게 되겠죠 그래서 얘를 꺼내 온 다음에 id, hp, attack을 각각 추출하고 그 다음에 출력하는 부분을 , 이렇게, 일단은, 만들어 봤습니다 , 자, 일단은, 이 가변적인 길이는 잠시 없애고 얘는 나중에 따로 다룰 거라서 , 일단은, 여기 없애고 , 이렇게, id, hp, attack만 , 일단은, 있다고 가정을 해 보도록 할게요 , 자, 그래서 이게 , 일단은, 클랫쪽이고 여기까지 완료가 되었으면 클랫 패킷 핸들러 cpp를 다시 왼쪽에다가 , 이렇게, 옮겨 놓고 시작을 하도록 하겠습니다. 그래서 지금까지만 놓고 보면은 우리가 작업하고 있는 이 패킷 설계를 유심히 한번 살펴보도록 하겠습니다. int64, uint32, uint16 , 이렇게, 3개째로 이루어진거죠. 그러니까 만약에 얘가 구조체 형태로 만약에 s-test라는 걸 우리가 표현할 수 있다고 하면은 지금 딱 요런 느낌으로 uint64, uint32, 그 다음에 uint16, attack 여기까지 , 일단은, 들어가 있는 상태라고 볼 수가 있겠어요 패킷, 설계, 임시, 템프 , 자, 그럼 여기까지 만들어놨으면 일단 클래니티는 다시 빌드를 하고 통과가 되는지를 테스트하고 그 다음에 이제 이어서 서버 쪽도 똑같은 작업을 해줄 거예요 그래서 서버 패킷 핸들러를 켠 다음에 여기도 이제 마찬가지로 해주면 되겠죠? 그래서 뭐 아까 마찬가지로 일단 복붙을 하도록 할까요? 여기서 에고 요 부분을 그냥 귀찮으니까 복붙 하도록 하고 핸들 패킷은 일단 똑같이 얘도 들고 있어야 될 겁니다 그래서 cpp에 가가지고 구현부를 얍! 만들어보도록 하고 핸들 패킷에서는 얘도 마찬가지로 버퍼 리더를 참고해가지고 버퍼 렌스만큼을 찝어준 다음에 그 다음에 패킷 헤더를 이제 뭐 추출하면 되겠죠 아까처럼 해도 되고 아니면 그냥 우리가 만든 피크라는 기능을 이용해가지고 살짝 엿보는 것도 가능합니다 요런 식으로 다른 방법으로 좀 만들어 보도록 할게요 그 다음에 여기서 인클루드 버퍼 리더는 추가를 해줘야 되겠죠 그 다음에 스위치를 해가지고 헤더 아이디를 체크해가지고 여기서도 이제 뭔가를 해주면 되는데 어 지금 우리가 패킷 만들어 준 게 딱 한 개밖에 없죠 s-bar 뭐였나요 s-bar 테스트라고 했었나요 네 요 아이밖에 없으니까 지금 , 사실, 서버 쪽에서는 딱히 뭐 핸들링 할 게 딱히 없습니다 클라이언 쪽에서 보내는 패킷을 우리가 설계한 적이 없기 때문이죠 그래서 얘는 그냥 요 상태로 냅두도록 하고 다만 어 요기 이넘에다가 s-bar 테스트는 똑같이 여기서 , 이렇게, 똑같이 복부를 해서 얘도 들고 있도록 하겠습니다. 서버 패킷 핸들러도 , 이렇게, 일단은, 완성이 되겠고요. 그러면 얘는 핸들 패킷을 얘도 똑같이 사용하고 있으니까 결국에는 게임 세션에서도 마찬가지로 onReceive 패킷이 왔을 때 얘도 결국에는 우리가 위에서 했던 거와 마찬가지로 그냥 서버 패킷 핸들러의 핸들 패킷으로 얘를 이제 그냥 그대로 토스를 해주면 된다라고 볼 수 있겠습니다 대칭적으로 만들면 된다는 거죠 그래서 얘도 이런 식으로 서버 패킷 핸들러를 추가하겠습니다 라고 해서 일로 뿅 토스를 해준 다음에 넘겨주면 된다 아 그리고 얘는 우리가 보이드로 바꿔놨으니까 지금 에러가 뜨고 있는거고 보이드 보이드로 바꿔주고 렌스는 일단 없애주면 짜잔 하고 모든게 완성입니다 , 자, 이렇게, 해서 뭐 잔다는게 만들어 봤구요 , 자, 그 다음으로 이제 언급을 하고 싶은건 뭐냐면은 지금 우리가 패킷을 보내는 부분을 살펴봅시다. receive 하는 부분은 이제 무조건 handle s-test라는 요 함수로 들어오게 될 거니까 요 함수를 보면서 여기서 이제 관리를 하겠다라는 걸 알 수 있는데 보내는 부분도 마찬가지로 지금 우리가 이런 식으로 어거지로 패킷을 만들고 있지만 만약에 요 동일한 패킷을 이 코드 저 코드에서 뭐 이리저리 사용한다고 가정해봅시다. 그때마다 요 코드를 Ctrl-C, Ctrl-B로 복붙하는 거는 굉장히 끔찍한 일이 될 거예요 근데 이거에 대해서 한 가지만 더 언급을 드리고 싶은 게 뭐냐면은 진짜 실무에서도 , 이렇게, 작업하는 사람이 가끔 있어요 너무 끔찍한 일인데 최대한 같은 코드가 동작을 하면 그걸 하나의 함수로 묶어야 되는데 만약에 그게 아니라 이리저리 사용한다고 이걸 그냥 그대로 복붙한다고 가정해볼게요 근데 그 다음에 여기 패킷이나 뭔가가 달라져가지고 여기 있는 함수가 박혀가지고 이 부분이 만약에 제거됐다고 가정해봅시다 근데 이 부분만 제거하고 아래 있는 부분은 제거가 안되면 이제 두 기능이 다르게 동작하게 되겠죠 이런 문제 때문에 무조건 동일한 기능을 해야 되는 경우라면은 무조건 함수로 묶어가지고 그 함수에서 건드리는 게 정석적인 방법입니다 요런 식으로 근데 이 부분을 가끔 안 지키는 사람들이 많아가지고 복붙하는 거를 막 너무 난발하다 보면은 이 코드 관리 차원에서 굉장히 끔찍해질 수가 있습니다 뭐 이거는 갑자기 말이 나와가지고 억울한 기억들이 막 새록새록 떠올라가지고 좀 열받았는데 어쨌든 다시 돌고 돌아서 그래서 이 패킷을 만드는 부분도 가급적이면 함수로 관리해가지고 편하게 사용할 수 있게끔 만들어주면 편하지 않을까라는 게 일단 첫 번째 생각이겠죠. 그러다 보면 패킷 핸들러 쪽에서 , 사실, 얘가 패킷 핸들을 하는 부분이긴 한데 여기다가 이 패킷을 만들어주는 부분까지 넣어주면 좋지 않을까라는 생각이 1차적으로 듭니다. 그래가지고 그렇게 한번 작업을 해보도록 할게요. Static Sand Buffer Reference를 뱉어 줄 것이고 Make Underbar S-Test라고 해서 S-Test Packet을 만들어준다라는 의미로 만들어주고 그 다음에 지금 우리 설계상 얘가 받아줘야 되는 인자가 uint64-id, uint32-hp, uint16-attack , 이렇게, 3가지 인자를 받아주게 될 거예요 그러면은 요 내부에서 우리가 , 이렇게, 작업하던 코드에서는 이제 , 이렇게, 바뀌게 되겠죠 Sand Buffer Ref를 똑같이 받아주겠지만 여기서 아래 코드까지는 다 이 함수 안으로 들어갈 것이기 때문에 사실상 서버 패킷 핸들러의 make s-bar 테스트를 호출할 것이고 여기다가 인자로 우리가 아까 넣어준 1110 같은 숫자만 , 이렇게, 넣어주면 되겠습니다 , 자, 그리고 메이크 테스트의 구현부를 만들어 준 다음에 그 다음에 여기서 여기까지 클로저는 오픈하고 클로저는 부분까지 싸그리 잘라 가지고 이거를 메이크 s 테스트 쪽에다가 , 이렇게, 다 옮겨 주도록 하겠습니다 그리고 인클로드 버퍼 라이터까지 추가를 해주면 이제 에러맨은 사라질 것이고요 닫아주고 , 이렇게, 가지고 id,hp,attack을 받아줄 때는 이런식으로 버퍼 매니저에서 뚜껑을 따가지고 버퍼를 할당받은 다음에 그 다음에 뭐 요런 부분들도 얼룩사이즈로 우리가 참 만들어놨었죠 그래서 얘를 참고해가지고 버퍼라이터를 만든 다음에 여기다가 뭐 기존과 마찬가지로 데이터를 열심히 밀어 넣어주면 되겠죠 , 자, 여기가는 우리는 id, hp, attack 3개를 , 이렇게, 밀어 넣어주고 그 다음에 여기 샌드데이터는 없애기로 했으니까 얘는 , 일단은, 잠시 없애주도록 하고 마지막에 사이즈랑 아이디를 채워가지고 클로즈를 한 다음에 요 샌드버퍼를 이제 뱉어주면 되겠습니다 요렇게 서버쪽에서 편하게 패킷을 만드는 함수를 하나를 만들어주면은 이제 앞으로 요 s 테스트를 보내야 될 일이 생기면 한번 만들어준 공용코드를 이용해가지고 얘를 만들어주면 되겠죠 그래서 다시 돌고 돌아가지고 게임 서버쪽에서 이제 이런 식으로 Make S-Test를 사용하면 된다고 볼 수 있는 거고 여기서 지금 Include Server Packet Handler가 빠져가지고 에러가 나고 있으니까 얘를 추가해주도록 할게요 그래서 아까 코드가 이제 , 이렇게, 정리가 되는 겁니다 그래서 실질적으로 사용할 때는 무조건 이 방식으로 Make S-Test를 이용해서 만들어준다라는 부분이 실행이 될 거예요 , 자, 근데 여기서 빌드를 하면은 살짝 에러가 날 겁니다 지금 여기서 에러가 나오고 있는데 이건 제가 지난번에 코드를 만들다가 좀 즉흥적으로 만드는 부분에서 살짝 실수를 한 부분이 있는데 오른값, 왼값 참조라고 했는데 유심히 보면 여기 템플릿이 붙어있는 순간 얘는 왼값, 오른값이 아니라 오른값 참조가 아니라 얘는 이제 보편 참조가 된다고 했었죠 C++ 파트 1 문법 시간에 다뤘는데 저도 살짝 까먹었어요 그러다보니까 지금 요 보편참조가 굉장히 강력한 애라서 모든 애를 다 지금 먹어버리고 있는 상태이고 그 상태에서 우리가 실질적으로 요 메이크 에스테스에서 id, hp, attack을 지금 , 이렇게, 밀어넣고 있는데 얘네들이 사실상 지금 오른값이 아니라 왼값임에도 불구하고 보편참조인 요 아이로 지금 들어오고 있습니다 사실상 얘는 굳이 안 만들어도 상관이 없었겠네요 , 자, 그래서 , 이렇게, 들어오고 있는 상황인데 그 다음에 여기서 이제 문제가 된 건 뭐냐면 얘가 지금 보편참조이다 보니까 보편참조는 왼값이면은 사실상 얘가 이런 식으로 변형이 되는 거고 오른값이면은 그냥 오른값으로 남는 그런 어떻게 보면 이중적으로 동작하는 아이인데 우리는 지금 왼값을 넘겨줬기 때문에 사실상 요 T라는 타입 자체가 요렇게 지금 변론이 된 겁니다 콘스트 인트로 뭐 int64를 넣어놨으면 const uint64가 지금 된 상태죠 그래서 T가 지금 요 타입인데 여기다가 이런 식으로 얘가 치환이 되다보니까 레퍼런스, 참조값의 포인터를 뭔가 추출해두다 보니까 지금 문제가 일어난 겁니다 그래가지고 지금 얘가 뭔가 변환할 수 없는 그런 문제가 일어난 거죠 , 자, 그럼 이런 경우엔 이제 어떻게 해야 되느냐 뭐 간단한데 결국에는 만약에 이런식으로 레퍼런스가 붙었으면 이 레퍼런스를 뗀 나머지 만큼을 우리가 , 이렇게, 바꿔치기를 해주면 되겠죠 그래가지고 이제 요 부분에 대해서 수정을 해보자면 일단 using data type을 추출을 해볼건데 , 자, 이건 템플릿과 관련된 부분이라서 뭐 간략하게만 다루자면 remove reference t라는 기능이 있습니다 이건 타이트 트랙과 관련된 부분이어서 나중에 언젠가 템플릿을 깊이 다룰 때 얘기하겠지만 기본적으로 이 타입에서 레퍼런스를 참조 값을 빼겠다 이겁니다. 즉 아까 예를 들면 const int , 이렇게, 됐을 때 이 부분을 딱 뗀 나머지 부분만 추출하겠다라는 의미가 되는 거고 그렇게 추출했으면 얘를 데이터 타입으로 , 이렇게, 바꿔주면 되겠습니다. 그리고 얘가 보편 참조이다 보니까 move를 하면 안 되고 forward를 , 이렇게, 해주도록 할게요. 데이터 타입 형식으로 forward를 해주세요 라고 , 이렇게, 바꿔치기를 해주면 아까 문제는 해결이 될 거에요 어차피 뭐... 버퍼라이터는 우리가 이 내용을 다룰 때 임시로 사용할 코드라서 뭐 그렇게 엄청 깊이 볼 건 없지만 , 일단은, 문제 해결을 해야 되니까 요렇게 , 일단은, 수정을 해보도록 할게요 , 자, 그럼 이제 문제가 해결이 되었고 결국에는 이제 문제가 아무런 문제가 없다면은 뭐 정상적으로 데이터를 받고 보내는 부분이 실행이 되겠죠 , 자, 지금 클라이언트 패킷 핸들러를 왼쪽에 보고 서버 패킷 핸들러를 오른쪽에 보면서 이제 요 두 부분을 주시를 하면서 작업을 해보도록 할게요 일단 간단하게 되는지만 다시 한번 실행을 해보면은 , 자, 일단은, 실행이 되었고요 그 다음에 클라이언트에서 정상적으로 다 수치가 뜨는 걸 볼 수가 있습니다. 여기까지는 일단 문제가 없고 그리고 지금은 스트레스를 테스트하는 게 아니다 보니까 굳이 더미 클라이언트를 몇백 개씩 띄울 이유는 없다 보니까 더미 클라이언트에 돌아가서 여기 서비스 카운트를 1로 다시 조정을 해줄게요. 그냥 한 개만 띄워서 로그를 정확히 보겠다는 의미고요. , 이렇게, 해서 일단 1차적으로 정리를 해봤습니다. 뭐 아직까지 엄청 새로운 내용은 들어가지 않았지만 이제 코드를 사용할 때 이런 식으로 묶어가지고 패킷을 만들어 준다라는 얘기를 하고 있는 거죠 실질적으로 여러분이 만약에 그냥 라이브 프로젝트에 간다거나 하는 게 아니라 그냥 프로토타입으로 포트폴리오를 만들 생각이라고 하면 진짜 이런 식으로 만들어도 충분해요 이 정도로도 충분하긴 한데 근데 여기서 몇 가지만 더 언급을 해보자면 그냥 일반적인 뭐 인트라거나 플로트라거나 불리언 이런 값들은 그냥 , 이렇게, 그냥 밀어 넣어주는 식으로 만들면 되겠습니다 , 자, 근데 이제 조금씩 내용이 좀 알이 달송해지는 부분은 가변적인 데이터가 들어가는 순간 이제 어떻게 만들어야 될지가 살짝 고민이 되기 합니다 예를 들면은 지금 우리가 어... 간단하게 , 이렇게, 만들고 있는 상황에서 그냥 패킷 핸들러가 이제 가변적인 데이터가 하나가 추가된다고 봅시다 가변 데이터 예를 들면은 뭐 이런식으로 벡터에다가 뭐 버프의 아이디를 만약에 또 추가로 보낸다고 가정해봅시다 그러니까 이게 지금 우리가 딱 하고있는게 너는 너의 ID, 너의 HP, 너의 공격력을 얘기하고 있으니까 추가적으로 내가 들고 있는 지금 나한테 입혀진 모든 디버프나 버프 같은 거를 또 , 이렇게, 보내줄 필요가 생길 수가 있겠죠 온라인 게임에서는 특히 MMO에서는 근데 요 버프와 관련된 정보들은 한 개가 있을 수도 있지만 두 개가 있을 수도 있고 뭐 엄청 여러 개가 있을 수도 있을 겁니다 그러면은 이제 이 부분을 어떻게 처리해야 될지가 굉장히 고민이죠 근데 이것도 잘 응용을 해보면은 가장 정석적인 방법은 역시나 이 가변적인 데이터의 개수를 먼저 보내주고 그 다음에 이어가지고 실제 데이터도 같이 보내주는 방법입니다 이게 좀 얘기가 헷갈리는데 그리고 심지어 이게 지금 int64일 수도 있지만 이거 자체도 그냥 int나 float같은 그냥 일반적인 데이터가 아니라 얘 자체도 또 하나의 struct일 수도 있어요 예를 들면은 지금 버프 데이터라는 struct가 , 이렇게, 있는데 패킷이 , 이렇게, 설계되어 있다고 가정해봅시다 여기서 버프 아이디랑 그리고 remain time 이 버프가 유지되는 남은 시간을 , 이렇게, 두 개의 정보를 같이 보내야 된다고 해봅시다. 그래서 지금 약간 이런 상태라고 가정해볼게요. 그러면 이 상태에서 우리가 이제 s 테스트를 만들어야 되는데 먼저 오른쪽에서 서버 쪽에서 요 데이터를 똑같이 만들어 가지고 딱 요 포맷대로 한번 보내보는 실습을 해보도록 할게요 그럼 이제 요 데이터를 그대로 복붙 해가지고 서버 팩킷 핸들러에 간 다음에 일단 위쪽에다가 얘를 , 일단은, 복붙을 해주고 그 다음에 결국에는 Make S 테스트를 할 때 요 끝에다가 이제는 이런 식으로 버프 데이터를 받아야 된다는 얘기가 되겠죠 그래야지 똑같이 만들어줄 수가 있을 거고 그냥 버프라고 합시다 버프를 받아가지고 얘를 이제 똑같이 보내줘야 된다라는 차이가 생기게 된 겁니다 그럼 얘를 끝에다가 이런 식으로 벡터를 , 이렇게, 일단 만들어주고 그 다음에 이제 이 부분이 굉장히 중요한데 메이크 에스테스를 할 때 기준에는 우리가 그냥 바로 데이터를 밀어 넣었지만 이제는 가벼운 데이터가 들어가게 되었습니다 가변 데이터로 할 때는 먼저 사이즈를 밀어 넣어줄 것이다 버프의 사이즈를 , 일단은, 밀어 넣어주면 되겠죠 다만 이 사이즈가 기본적으로 인트64나 인트32로 하면은 솔직히 불필요하게 너무 많은 용량을 차지하는 것이기 때문에 무조건 가변 데이터의 사이즈를 유인트16으로 보내준다고 가정해봅시다 즉 6만 개 정도가 될 텐데 최대 사이즈가 그 정도로도 어차피 충분하기 때문에 뭐 , 이렇게, 일단은, 보내준다는 얘기가 되는거죠 그래서 먼저 사이즈를 2x2로 보내준 다음에 그 다음에 이어가지고 뭐 하나씩 데이터를 보내주도록 하겠습니다 버프 데이터를 하나씩 순회를 하면서 버프를 순회를 하면서 그 다음에 이런식으로 버프에 버프 아이디랑 버프에 리메인 타임을 각각 밀어 넣어주면 된다라고 볼 수가 있겠습니다. , 이렇게, 해가지고 가변 데이터도 결국에는 그렇게 어렵지 않게 보내줄 수가 있다는 얘기가 되는 거고 , 이렇게, 만약에 보내줬다고 하면은 나머지 부분은 여기 사이즈나 이런 부분은 알아서 처리가 되겠죠. 참고로 1이라는 하드코딩된 값보다는 인원값으로 우리가 만들어준 프로토콜 번호를 , 이렇게, 넣어주도록 하겠습니다. , 자, 그래가지고 서버쪽에서 빌드를 해보면 이제 뭐 아 이거 Make S 테스트를 우리가 아직 고쳐주지 않았으니까 보내주는 쪽에서 , 자, 이 부분을 이제 살짝 수정을 해봐야 되는데 어... 여기서 벡터를 그냥 간단하게 만들어 주도록 할게요 버프 데이터 버프 , 자, 그 다음에 버프 데이터를 뭐 한 3개 정도만 만들어 보도록 하겠습니다 100번은 1.5초 남았고 그 다음에 두번째 버프는 200번인데 2.3초가 남았고 그 다음에 뭐 아무 숫자나 하도록 하겠습니다 300번은 0.7초가 남은 상태이다라고 요렇게 , 일단은, 벡터를 만들어 주도록 하겠습니다 그 다음에 얘를 그냥 그대로 다시 , 이렇게, 넣어 줘 가지고 전달을 해보도록 할게요 그러면 이제 똑같이 이 버프 데이터까지 만들어가지고 make sts가 호출이 되면은 이 가변 데이터가 넣어지는 부분에 의해가지고 사이즈가 먼저 여기서 넣어준 다음에 그 다음에 각기 버프에 대한 정보를 , 이렇게, 넣어주게 될 테니까 그러면은 거꾸로 파싱하는 더미 클라이언트 입장에서도 얘가 아니라 클라이언트 패킷 핸들러 쪽에서도 요 부분을 이제 똑같이 맞춰주면 될 겁니다 얘가 일단 설계 포맷이니까 이거를 보고 맞춰주면 된다고 볼 수가 있는 거고 우리가 약속하기로는 항상 사이즈는 유인트 16으로 만들어 준다고 했었죠 그러다보니까 , 자, 여기다가 , 일단은, 뭐 , 이렇게, 추출할 수가 있을 거예요 버프 데이터를 추출할 것인데 뭐 여기다가 유인트 16으로 버프 카운트를 먼저 추출할 것이다 그래서 버프 카운트를 꺼내준 다음에 여기 버프 사이즈가 들어갔으니까 버프를 리사이즈 해줘 가지고 요 버프 카운트 만큼으로 만들어주고 그 다음에 이런 식으로 하나씩 스네어를 하면서 버프 카운트 갭 만큼을 스네어를 할 것인데 그 다음에 BR에다가 이런 식으로 어... 버프 아이디를 추출하고 그 다음에 이어가지고 버프에 리메인 타임을 추출해주세요 라는 식으로 코드를 만들어주면은 우리가 보내준 데이터를 고대로 다시 얘가 받아줄 수가 있을 겁니다 , 자, 이렇게, 실질적으로 뭐 보낸 데이터가 정상적으로 보내져 있는지를 테스트하기 위해서 여기서 또 로고를 찍어 보도록 합시다 버프 카운트는 몇개 몇개이다 버프 카운트 엔드 라인 그 다음에 루프를 돌면서 , 자, 요 부분을 그대로 복붙한 다음에 여기서 이제 로그를 버프 인포라고 찍어보도록 할게요. 버프 인포는 어떤 어떤 정보를 담고 있다. 뭐 간단하게 버프에 버프 아이디 그리고 한 칸 띄고 버프에 리메인 타임 점 리메인 타임 엔드 라인 , 자, 이렇게, 일단은, 찍어보도록 하겠습니다. 그러면은 정보가 성공적으로 만약에 보내줬다고 가정을 하면은 우리가 보낸 데이터가 그대로 로그에 출력이 되겠죠. 그래서 실질적으로 그런지 한번 테스트를 해보도록 하겠습니다. 실행을 해보면 , 자, 지금 더미 클라이언트에서 받은 정보를 유심히 보면은 정상적으로 데이터를 잘 받고 있는 걸 볼 수 있습니다. 버프는 3개 버프 인포는 100, 200, 300 그리고 몇 초 남았는지 각각 이런 정보들을 정상적으로 잘 받고 있다라는 걸 알 수가 있는 거죠 그래서 가변적인 정보라고 해도 가장 쉽게 생각하면 이런 식으로 먼저 사이즈를 기입을 한 다음에 그 다음에 실제적인 데이터를 밀어 넣으면 된다라는 걸 , 일단은, 알 수가 있는 겁니다 근데 뭐 , 사실, 가변 데이터라는게 꼭 요렇게 간단한 그냥 스트럭트만 있는 경우도 있겠지만 뭐 여러가지 상황이 있겠죠 1번 문자열 예를 들면은 뭐 어떤 유저의 이름이라거나 길드 이름 등등 그런 것도 있을 것이고 그 다음에 그냥 일반적인 바이트 배열도 있을 수가 있어요 예를 들면은 우리가 뭐 길드 이미지, 길드 문양 같은 거를 만약에 커스터마이징 해가지고 올릴 수 있다고 하면은 그 해당하는 길드 문양 이미지를 다시 똑같이 다운로드 받을 수도 있어야 되겠죠? 그런 경우에 ByteBear를 보낼 수도 있을 것이고 아니면은 뭐 이런 식으로 그냥 일반적인 정보 리스트들도 받을 수 있을 것이고 굉장히 다양한 상황에서 이 방법을 이용할 수가 있을 거예요 그래서 , 이렇게, 가변적인 데이터를 보낼 수 있다라는 기초적인 방법에 대해서 알아봤는데 , 자, 근데 여기서 한 가지 조심해야 될 부분을 말씀을 드리자면 이거는 사실상 패킷 설계를 할 때 항상 조심해야 되는 부분이긴 한데 우리가 이제 온라인 게임을 만들 때는 딱 한 가지 법칙을 명심하면 됩니다 그게 뭐냐면은 클란은 절대 신용할 수 없다 이 한 문장을 기억을 하면 돼요 항상 조작의 여지가 있고 해킹의 여지가 있다고 생각을 해야 되기 때문에 우리가 이전에 패킷 사이즈도 그랬지만 패킷 사이즈도 참고는 해가지고 그 보낸 패키지 사이즈만큼이 패키지 사이즈 완성된 패키지라고 가정을 할 거라고는 말했지만 그걸 100% 신용할 수는 없다고 했었죠 그래서 언젠가 만약에 파싱을 하다가 뭔가 말이 안 되는 상황이 있으면 그걸 인지하고 걸러내는 것도 서버의 임무라고 했었습니다 근데 지금도 마찬가지로 이런 가벼운 길이에서 조금 까다로워지는 부분은 버프 카운트 자체, 요 아이도 , 사실, 클라이언트 쪽에서 거짓말을 할 수가 있다는 얘기가 되는 거예요 지금 우리가 실질적으로 데이터는 3개밖에 없는데 만약에 조작을 해줘가지고 데이터가 6만개 있다고 뻥을 치는 상황이었다고 하면은 이 사이즈를 6만개로 한 다음에 6만 번 루프를 돌면서 6만개의 데이터를 꺼내려고 하겠죠? 그러다가 심지어 우리는 요 오퍼레이터에서 범위 체크까지 넣어주지 않았기 때문에 이 부분에서 결국에는 메모리를 초과해가지고 리드한다거나 하는 부분이 일어날 수 있다는 얘기가 되는 겁니다 그래서 나중에 가면 어떤 식으로든 얘를 중간에서 뭔가 이상한 상황이라는 걸 캐치할 수 있는 수단을 , 일단은, 만들어주긴 해야 됩니다 , 일단은, 그건 당장 오늘 다룰 주제는 아니고 오늘은 , 이렇게, 간략하게 이런저런 데이터를 설계하고 보내는 그런 여러 가지 방법에 대해서 , 일단은, 알아봤어요 , 자, 이렇게, 해서 간단한 부분에 대해서 알아봤고 그 다음에 문자열과 관련된 부분 , 사실, 이 두 가지는 이런 식으로 만들면 되겠고 문자열도 비슷하게 만들면 되긴 하겠죠 문자열에 문자 개수를 먼저 입력을 한 다음에 그 다음에 문자를 쭉 받아주면 되는데 근데 이제 문자열 같은 경우에는 이제 인코딩 이슈가 살짝 있습니다 우리가 문자열을 어떤 식으로 받아들일 것인지에 관한 내용을 다뤄야 되는데 이거는 그렇게 복잡한 내용은 아니지만 한 번쯤은 꼭 알고 넘어가야 되는 그런 중요한 내용이기 때문에 이건 다음 시간에 문자열과 관련된 내용을 쭉 모아가지고 한번 다뤄보도록 할게요 , 일단은, 오늘은 여기까지 마치도록 하겠습니다.