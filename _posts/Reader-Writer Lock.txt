이어서 오늘 해볼 거는 리더 라이터 락 이라고 해가지고 우리가 앞으로 서버 컨텐츠 및 서버 엔진 쪽에서 사용할 그 락에 대한 작업을 , 일단은, 해보고자 합니다 근데 지난 시간에 만든 이 매니저 코드 그리고 이 코어 글로벌에 관해서 한 가지만 더 언급을 드리자면 우리가 전역으로 사용할 매니저들을 여기 코어 글로벌에다가 넣어놨고 그 다음에 이걸 생성하고 소멸하는 순서가 나중에 정해져야 될 수도 있기 때문에 그거를 , 이렇게, 일일이 컨텐츠에서 이쪽에서 뉴를 하는 게 아니라 , 이렇게, 엔진 쪽에 CoreGlobal이라는 클래스한테 얘를 이제 위임을 해줬습니다 그 다음에 우리가 이런 식으로 CoreGlobal을 전역으로 만들어 놨었죠 근데 이제 경우에 따라서 , 이렇게, 전역으로 만드는 것조차도 마음에 안 드실 수가 있습니다 왜냐면 이건 어디까지나 엔진 쪽에서 담당해야 되는 부분인데 엔진 쪽에서 해야 될 거를 우리가 , 이렇게, 좀 지저분하게 컨텐츠 쪽에서 얘를 꺼내 쓰는 것 자체가 좀 이상할 수도 있어요 , 자, 그런 분들을 위해서 한 가지만 더 언급을 드려보자면은 애당초 이 코어 글로벌 자체를 , 자, 이렇게, 컨텐츠에서 꺼내 쓰는 게 아니라 그냥 얘를 여기 안에다가 , 일단은, 넣어줘도 , 사실, 상관이 없기는 합니다 , 자, 그래서 이런 방식으로 살짝 수정을 해보자면 대략적으로 이런 느낌으로 일단 바꿔볼 수가 있어요 , 자, 이렇게, 그래가지고 이제 엔진 코드 내부에서 코어 글로벌을 cpp 안에서 정해가지고 뭐 이런식으로 코어 글로벌을 사용할 수 있다는 얘기가 되는 거죠 참고로 이제 이거 인서트 키가 눌렸나 보네요 참고로 말씀드리자면 , 이렇게, 만들어도 되고 아니면 문법 차원에서 여기 이제 클래스를 서넣는과 동시에 여기 붙여가지고 쓰면은 아까처럼 아까와 마찬가지로 그냥 전역 객체를 이제 하나 만들어주는 식으로 동작을 하니까 뭐 , 이렇게, 일단은, 만들어줘도 되겠습니다 그래서 이제 뭐 이런 식으로 빌드를 해가지고 똑같이 실행을 해보면 설령 우리가 컨텐츠 단에서는 얘를 건드려 주지 않았음에도 불구하고 코드가 마찬가지로 정상적으로 잘 동작을 한다는 걸 이제 볼 수가 있을 거예요 뭐 이런 느낌으로 뭐 그건 그렇고 , 자, 그래가지고 이제 뭐 이어가지고 오늘 알아볼 주제는 RwRock, 리더 라이터 락인데 , 일단은, 스레드 쪽에다가 어쨌든 멀티 스레드와 관련된 부분이다 보니까 락 이라는 새로운 클래스를 , 일단은, 파악 주도록 하겠습니다 , 이렇게, 일단은, 넣어 주도록 할 거고요 , 자, 이제 이 리더 라이터 락이 왜 필요한지 , 일단은, 설명을 좀 드려야 될 것 같은데 거꾸로 얘기하면 우리가 지금까지 배운 그 표준 mutex 같은 경우에 어떤 문제가 있는지 말씀을 드리는 게 좀 좋을 것 같습니다 뭐 요 방법이죠 뮤텍스 뭐 , 이렇게, 해가지고 이 뮤텍스를 락하고 언락을 하는 것 자체가 뭐 나쁘다는 건 아닌데 , 일단은, 직접 구현해서 사용할 이유가 몇 가지가 있어요 일단 첫 번째로는 요 표준 뮤텍스 같은 경우에는 재기적으로 락을 잡을 수가 없습니다 그래가지고 이미 락이 잡힌 상태에서 다른 함수를 여기서 뭔가를 호출했는데 그 함수에서도 또 이 락을 잡으려고 하면 문제가 일어날 수 있다는 얘기가 되는 거고 근데 뭐 그건 그렇고 그렇게 뭐 Recursive Lock이라고 해가지고 Recursive Mutex 버전 하나 더 있기 때문에 뭐 그런 걸 딴 걸 사용하면 되는 건데 그거보다 더 심각한 문제는 경우에 따라가지고 정말 아주 가끔 이 상호 배타적인 특성이 필요한 경우가 생깁니다 , 자, 제가 일단 잠시 구글을 켜가지고 어.. 이미지를 하나를 보여드릴건데 예전에 제가 테라라는 프로젝트에서 일할 때 작업한 컨텐츠 중에서 이런 발키온 연합 지령서라는 게 있었어요 이걸 제가 작업을 했었는데 굉장히 단순한 컨텐츠입니다 그냥 일종의 일일퀘 같은 거라고 생각하시면 돼요 그래가지고 이 일일퀘를 완성을 하면 여기다가 보장수령을 받으면 이런 식으로 아이템을 보너스 아이템을 받을 수 있는 그런 컨텐츠였습니다 그리고 여기서 받을 수 있는 아이템 같은 경우에는 시즌마다 어느 정도 기획적으로 정해져가지고 고정된 상태로 데이터 시트에 묶여가지고 들어갔어요 그니까 한마디로 바뀌지 않는다는 얘기가 되는 거죠 그런데 예외적으로 이제 운영툴을 통해 가지고 운영자가 뭐 이벤트를 만약에 하고 싶다 뭐 특정 어.. 예를 들면 이 쿠마스의 놀이터를 차지하라는 이 퀘스트 자체에다가 보너스를 더 밀어넣어주고 싶다고 하면은 운영툴을 통해 가지고 여기다가 데이터를 추가해줘서 보상을 늘려줄 수가 있었습니다 , 자, 요런 상황을 만약에 예로 들 때 만약에 어떤 뭐 함수가 , 이렇게, 있다고 가정해볼게요 여기서 뭐 get reward list라고 해가지고 어떤 퀘스트에 대한 퀘스트 아이디를 주워주면 그 퀘스트 아이디에 해당하는 보너스를 긁어오는 함수가 뭐 , 이렇게, 있다고 가정해봅시다 근데 아까 말씀드린대로 요 리스트 자체는 , 사실, 거의 변하지 않습니다 그렇기 때문에 여기서 뭔가 무엇인가 무엇인가 해가지고 데이터를 추출한 다음에 여기서 , 이렇게, 리스트를 반환하는데 만약에 데이터가 변하지 않는다고 하면 , 사실, 멀티세드 환경이라고 해도 굳이 락을 걸 필요가 없습니다 왜냐면 데이터가 수정이 될 때 문제가 일어나는 것이기 때문에 모든 애들이 다 , 이렇게, 리드만 한 상황이라면 락을 전혀 걸 필요가 없어요 근데 문제는 역시나 아까 그 운영 툴을 통해 가지고 정말 일주일에 한 번씩 이 데이터가 극악의 확률로 변경이 될 수 있다는 얘기가 드는 거죠 그러니까 거의 99.9999%의 확률로 일정한데 정말 극악의 0.00001%의 확률로 뭔가 변경이 있을 수도 있는 상황이 있다는 거죠 그러면은 이 0.00001%의 확률 때문에 여기다가 굳이 락을 걸어가지고 이런식으로 락을 걸어가지고 사용하는 것 자체가 , 사실, 굉장히 좀 아깝게 느껴질 때가 있습니다 만약에 이 get reward list를 이리저리서 많이 호출을 해가지고 get을 하는 부분이 있었다고 하면은 , 이렇게, 매번만한 상호 배타적으로 접근을 막아가지고 한 번에 한 명만 통과시켜 주는 것 자체가 굉장히 아깝게 되겠죠 , 자, 이런 경우에 우리가 사용할 수 있는 게 리더 라이터 락입니다 즉 거의 대부분의 확률에서는 리드만 할 경우가 한다고 하면은 그 애들끼리는 락을 마치 우리가 걸지 않은 것 마냥 서로 공유해 가지고 그냥 사용을 하다가 이 극악의 확률로 만약에 라이트가 들어간다 데이터 수정이 들어간다고 할 때는 규정과 마찬가지로 상호 베타적인 특성을 진이는 그런 락으로 만들어주면 돼요. 라이트를 하게 될 경우에는 역시나 상호 배틀적으로 한 번에 한 명만 통과할 것이고 그게 아니라고 한다면 일반적인 리드끼리는 자기들끼리는 그냥 계속 자유롭게 접근해가지고 데이터를 꺼내 쓸 수 있다는 게 되는 거죠. 이런 특성을 갖고 있는 락을 리더 라이터 락이라고 하는데 이게 이제 뭐 자주 활용은 되지 않는다고 하더라도 이런 걸 만들어 두면 최소한 쓸데없는 경합을 아낄 수 있기 때문에 어느 정도 효율성이 보장이 된다고 보시면 되겠습니다 그래서 이제 이거를 우리가 만들어 볼 거예요 근데 이것도 물론 표준에 리더 라이터 락을 사용하는 몇 가지 클래스들이 있는데 그럼에도 불구하고 우리가 새로 만드는 이유는 여러 가지 이유가 있을 수도 있지만 우리가 원하는 형태로 얘를 최적화할 수도 있을 것이고 정책을 우리가 좀 이리저리 알아서 골라줄 수도 있을 것이고 그 다음에 뿐만 아니라 나중에 가면은 이 락을 우리가 추적을 해가지고 뭔가 데드락 상황이나 이런 것도 미연에 방지할 수 있는 그런 코드를 넣어주면 일단 좋을 것 같다는 생각이 듭니다 그래가지고 이전에 프로젝트 중에서 , 이렇게, 락을 직접 만들어서 사용하는 것도 있었고 아니면 그냥 표준 락을 사용하는 경우도 있었고 이거는 약간 프로젝트에 따라서 갈리긴 하는데 , 일단은, 제가 만들 이 버전에서는 우리가 연습상황에서 직접 락을 만들어 보고 그 버전을 진짜 실질적으로도 사용을 하게 될 겁니다 네 그래가지고 이 락 코드를 일단 이어서 작업을 해 주도록 할게요 , 자, 일단 여기 타입은 , 일단은, 이렇게, 기본적으로 추가를 해 줘 가지고 뮤텍스랑 아토믹은 아토믹은 듣기 필요하니까 얘를 , 일단은, 추가를 해 줄 것이구요 , 자, 그 다음에 여기다가 이어서 만들어 볼 것인데 기존과 마찬가지로 잠시 , 이렇게, 영역을 한번 , 이렇게, 집어 주도록 합시다 얘가 이제 하는 거는 리더 라이터 스피드 락을 우리가 만들어 볼 거예요 이 락 같은 경우에도 고려할 부분이 여러 가지가 있는데 , 일단은, 그냥 상호 베타 정인지 아니면 리드 라이터 락인지 이걸 일단 정해줘야 되고 그 다음에 뭐 역시나 락을 할 때 뭐 스피락 방식으로 만들어 줄지 아니면 뭐 이벤트 방식으로 만들어 줄지 뭐 이런 것도 여러 가지 골라주시는데 기본적으로 우리가 만들 MMO에서는 서로 이제 잠시만 데이터를 참조했다가 놔주는 식으로 동작하는 경우가 굉장히 많기 때문에 일반적으로 , 이렇게, 스피락으로 만들어 주는 게 조금 더 효율적이라고 볼 수 있겠습니다. 그래서 기본적으로 스피락으로 이제 만들어 줄 거예요. , 자, 그 다음에 어 여기서 이제 오늘 만들 락에 대한 코드를 잠시 , 이렇게, 언급을 드리자면 , 일단은, 요런 식으로 어 32 비트를 일단 활용합니다 32 비트 짜리 변수를 사용할 것인데 상위 16 비트 그니까 하나 둘 셋 넷 다섯 여섯 일곱 여덟 , 자, 이걸 1 바이트라고 생각하면은 상위 16 비트와 그 다음에 , 이렇게, 하위 16 비트가 각각 의미가 달라져요. 하나 둘 셋 넷 다섯 여섯 일곱 여덟 , 자, 요렇게 32 비트를 활용할 것인데 하위 16 비트는 얘가 리드 횟수를 의미를 하는 거고 이 W는 라이트 플래그를 의미를 하는 거고 리드는 리드 플래그를 의미를 하는데 결국 얘는 exclusive lock owner의 쓰레드 아이디를 얘기를 하고 있는 겁니다. 즉, 이 락을 현재 획득하고 있는 그 쓰레드 아이디를 여기다가 기입을 할 것이고 리드 플랫 같은 경우에는 공유해 가지고 사용하고 있는 이 리드 카운트를 여기다가 넣어주게 될 겁니다. 그래서 이거를 통으로 , 이렇게, 하나의 인트 32 비트짜리 정수로 , 일단은, 관리를 해주게 될 겁니다. 우리가 락 프리 스택이랑 락 프리 큐에 대해서 다루면서 이런 컴페어 스왑 코드를 굉장히 많이 연습을 했기 때문에 그거에 비하면 생각보다 단순합니다 그래서 엄청 어려운 부분은 없구요 , 일단은, 락 플래그라는 걸 , 이렇게, 만들어주고 그 다음에 라이트 카운트라는 걸 관리를 해주게 될 겁니다 그리고 여기 위에서 우리가 이제 사용할 그런 여러가지 하드코딩된 값들을 정의해줄 것인데 , 일단은, Acquire Timeout Tick 이라고 해가지고 최대로 기다려줄 틱을 , 이렇게, 뭐 일단 1만으로 세팅을 할 거고 맥스 스핀 카운트라고 해가지고 스핀 카운트를 최대 몇 번 돌 것인가를 설정해 줄 것이고 그 다음에 라이트 스레드 마스크라고 해가지고 얘는 , 이렇게, FFFF 0000으로 세팅을 해 줄 거고 이 마스크 자체는 우리가 비트 플래그 방식으로 얘를 이제 사용할 것이기 때문에 정확하게 이 상위 16 비트만을 뽑아오기 위한 그 마스크라고 보시면 되겠습니다. 이제 비트 플래그 코드가 제가 익숙하지 않았으면 이런 코드가 좀 어색할 수 있는데 여기서 FFFF라는 경우에 여기 상위 16 비트가 다 1로 세팅이 된 거를 여기 FFFF라고 하니까 이제 그 부분을 추출하기 위한 일종의 마스크라고 보시면 되겠어요. 그 다음에 마찬가지로 리드 카운트도 추출할 수 있는 마스크는 거꾸로 000FFFF가 , 이렇게, 되겠습니다. 여기 , 이렇게, 짝대기를 해준 거는 엔터킷 바로 옆에 있는 그 키를 해주면 되는데 이건 아무 의미가 없고 코드를 좀 분리해서 보기 위한 좀 보기 편하라고 , 이렇게, 영역을 구분해 준 겁니다 마지막으로 아무것도 없다 초반의 상태는 엠티 플래그 같은 경우에는 0000 0000으로 모든 애들이 다 0인 상태에서 시작을 할 거에요 , 자, 이게 뭐 아직까지는 이게 뭐 하는 짓거리인지 잘 이해가 안 가시겠지만 코드를 작업하다 보면은 좀 이해가 갈 겁니다 그래서 , 일단은, 뭐 , 이렇게, 작업을 해주시면 되구요 처음 시작은 엠티 플래그로 시작을 하게 될 거에요 , 자, 그 다음에 오늘 이제 뭐 어쨌든 건 얘가 락 방식으로 동작을 해야 되니까 write-lock 이라는 기능을 넣어 줄 것이고 write를 unlock 하는 기능을 만들어 줄 것이고 read-lock을 만들어 줄 것이고 read-unlock도 , 이렇게, 정의를 해 줄 겁니다 그래가지고 write를 한 다음에는 그걸 풀어 주기 위해서 write-unlock을 해주면 되고 read를 한 다음에는 read-unlock을 통해 가지고 이제 lock을 풀어 주면 되겠어요 뭐 이런 식으로 , 일단은, 동작을 한다고 보시면 되겠습니다 위에 좀 영역을 , 이렇게, 좀 늘려 줄까요 보기 편하게 그래가지고 이제 이거를 작업을 해볼 건데 일단 위에 돌아가가지고 코어 TLS를 나중에 사용하게 될 거니까 얘는 미리 추가를 해주고 , 자, 이걸 이제 하나씩 하나씩 추가를 해볼 겁니다 라이트 락부터 시작을 해가지고 일단 정의부터 해보도록 할게요 얘를 만들어주고 얘도 만들어주고 얘도 만들어주도록 하겠습니다 , 자, 그래서 이제 이 비트 플래그를 유심히 보면서 이걸 가지고 우리가 장난을 칠 건데 우선 라이트락을 할 때 맨 먼저 생각을 해야 되는 것은 아무도 소유 및 공유하고 있지 않을 때 경합해서 소유권을 얻는 다가 , 일단은, 핵심입니다 첫 번째 핵심이고 여기서 말한 소유 자체는 상호 배타적인 소유권 즉 여기서 누군가가 라이트를 이미 하고 있는 상황을 말하고 있는 거고 공유하고 있다는 얘기는 여기서 누군가가 리드 락을 걸어가지고 이 락을 지금 어찌됐건 리드를 통해서 사용하고 있는 상황이라고 보시면 되겠어요 근데 여기서 거꾸로 아무도 소유하고 있지 않고 아무도 공유하고 있지 않다고 하면 그렇다는 것은 여기 있는 모든 값들이 다 초창기 값인 엠티 플래그 즉 얘가 0이고 얘도 0인 상태를 얘기하는 거겠죠 그래가지고 그 상황에 대해서 이제 우리가 원하는 값을 넣어 줄 건데 만약에 얘가 텅 비었다 라고 하면은 결국에는 우리가 이제 의사 코드로 얘를 만들어 주려면은 결국에는 이 락 플래그 라는 것 자체가 엠티 플래그 인 상황이 있다고 하면은 이제 어 그럼 내가 끼어 들어 가지고 내가 락을 차지할래 라고 하는 건데 내가 락을 차지하고 싶다고 라이트 락을 할 때는 여기 상위 16 여기 비트에다가 내 락 번호를 이제 기입을 해주면 그게 이제 내꺼가 됩니다 그래가지고 여기서 만약에 우리가 코드를 만들어보자면 이런식으로 desired를 만약에 만들어 준다고 하면 내 현재 락 스레드 아이디에서 16비트를 이동시킨 다음에 여기다가 라이트 스레드 마스크를 , 이렇게, 씌워주도록 할게요 이게 내가 원하는 값이죠 즉 나머지 값들은 다 0이고 내 스레드 아이디에 해당하는 요 숫자를 16비트 이동을 시켜가지고 , 이렇게, 이동을 시켜가지고 여기 상위 16비트 하다가 , 이렇게, 적어 놓는 것 자체가 우리가 원하는 최종 값이 되는 겁니다 그래서 만약에 락 플래그가 엠티면은 우리가 원하는 이 디절드가 , 이렇게, 들어가면 , 일단은, 되는 거예요 근데 이게 뭐 멀티스레드 환경이다 보니까 얘를 체크하는 순간에 여기서 누군가가 끼어들어 가지고 얘를 이제 차지할 수 있으니까 당연히 , 이렇게, if-else로는 할 수 없고 이거를 이제 우리가 지금까지 잘 사용하고 있었던 그런 스핀 방식으로 계속 뺑뺑이를 돌면서 컴페어 스왑 방식으로 이제 만들어주면 되겠어요 근데 우리가 원하는 이 desired 상태는 바뀌지 않기 때문에 얘는 , 일단은, 이렇게, 밖에서 만들어줄 것이고 그 다음에 , 자, 이런 식으로 스핀 카운트 번 만큼을 아이고 얘를 이제 i 라고 하지 않고 스핀 카운트로 할게요 몇 번씩 돌아줄 것인지를 요게 정해주게 됩니다 스피인 카운트가 이 맥스 스피인 카운트까지 될 때까지 계속 뺑뺑이를 돌 거예요. 지금 이제 최소 5,000번을 보장을 받은 거죠. 5,000번 내에 어떻게든 락을 획득해봐라 라고 우리가 스피인을 돌 것이고 , 자, 그 다음에 이 상태에서 그러면 expected 우리가 처음에 예상한 값은 empty flag인 경우를 말하고 있는 거죠. 이 empty flag여가지고 지금 락이 텅 비어서 아무도 얘를 write 하고 있지도 않고 read 하고 있지도 않고 그런 상태일 때 우리가 차지하겠다 즉 desired 값을 넣어 주겠다라는 코드로 만들어주면 되는 거고 그러기 때문에 여기다가 lock full에다가 compare exchange strong을 한 다음에 여기다가 expected desired를 순차적으로 , 이렇게, 넣어주면 내가 이제 이 lock을 획득한 애가 된 겁니다 그 다음에 뭐 저 같은 경우는 이 expected라는 것 자체가 여기다 넣어준 다음에 아웃풋 값으로 다시 이 값이 세팅이 되는 경우에는 항상 , 이렇게, 아웃을 붙여주는 습관이 있어요 이게 이제 레퍼런스를 통해서 이 값도 바뀔 수 있다라는 힌트를 주는 거죠 근데 뭐 지금 이 코드가 추가가 안 됐다고 하면은 음 얘를 core macro에다가 가가지고 여기 위쪽에다가 얘만 간단하게 , 이렇게, 추가를 해주도록 할게요 얘를 추가해주고 , 자, 그 다음에 그러고 보니까 코어 피스에 제가 작업하다가 보니까 이 부분을 조금 두 번 들어갔네요 실수가 있었고 여기서 코어 글로벌이 아니라 얘를 매크로로 일단 바꿔줘야 되겠죠 네 오터가 있었습니다 매크로를 사용하도록 , 이렇게, 삼총사를 지금 잘 집어 넣은 상태 이구요 , 자, 그 다음에 다시 돌아와 가지고 결국에는 내가 처음에 예측하던 값 즉 락 플래그가 텅텅 빈 상태라고 하면은 내가 중간에 끼어들어 가지고 내가 원하는 이 엘스레드 아이디 값 즉 내가 요 값을 차지하겠다 라고 우리가 세팅을 해준 거고 여기까지 일단 들어왔으면은 내가 경험에서 이긴 상태가 되는 거니까 내가 이 라이트 락을 획득한 상태가 될 겁니다 그러면은 여기다가 라이트 카운트를 1 증가시킨 다음에 리턴을 때려줄 거예요 , 자, 근데 이 라이트 카운트는 왜 따로 관리를 하고 있는 것이냐 이거는 왜 그러냐면은 우리가 이제 뭐 여러가지 정책 중에서 이 락을 재규적으로 호출하는 걸 허락한다고 했으니까 내가 라이트 락을 통해 가지고 이 락을 잡고 있는 상태에서 또 라이트 락을 호출하게 되면은 크래쉬가 나는 게 아니라 그냥 라이트 카운트를 늘려가지고 얘를 한 번 더 잡게 허락을 해줄 겁니다 그걸 하기 위해서 이 라우트 카운트라는 거를 우리가 추적을 하고 있다고 보시면 되겠어요 , 자, 그리고 그 부분을 이제 위에다가 다시 한번 추가를 해보자면 결국에는 재규적으로 동일한 스레드가 만약에 이 락을 소유하고 있다면 그냥 무조건 성공해야 된다는 법칙으로 우리가 정책으로 만들어준다는 얘기가 되는거고 그렇다는 것은 여기서 락 스레드 아이디 현재 이 락을 잡고 있는 스레드 아이디가 무엇인지를 체크해주면 되겠죠 , 자, 락 플래그에다가 라이트 스레드 마스크를 통해가지고 , 일단은, 비트 에고 비트 플래그를 통해가지고 요기 리드를 싹 날려준 다음에 요기 상위 16비트만 추출하고 거기다가 다시 요렇게 16 비트를 이동시키면 여기 상위 16 비트에 있던 게 이제 딱 내려오면서 우리가 원하는 락스레드 아이디가 추출이 될 겁니다. 그럼 만약에 이게 현재 이 스레드를 호출하고 있는 이 스레드 아이디랑 똑같다고 하면은 그러면 동일한 스레드가 수요하고 있는 상태에서 또 라이트 락을 건게 되니까 여기다가는 라이트 카운트를 1 증가시킨 다음에 바로 리턴을 때려주면 된다는 얘기가 되는거죠 그래서 이 라이트 카운트는 , 이렇게, 관리하고 있는거고 여기서 유지뮤브는 얘는 뭐 이 라이트 카운트 같은 경우에는 이 락을 잡은 애만 독단적으로 사용하는 것이기 때문에 얘는 경합이 붙는 개념이 아니라 나만 사용할 것이기 때문에 , 이렇게, 쿨하게 뿔뿔을 늘려줘도 되고 얘는 굳이 아토믹으로 만들어주지 않아도 됩니다 그리고 이걸 뭐 유인트 16으로 만들어도 되고 32로 만들어도 되고 이거는 그냥 원하시는 거에 따라가지고 대충 숫자를 맞춰주시면 되겠어요 일단 16비트도 충분할 것 같으니까 , 이렇게, 만들어주도록 하고 , 자, 그래가지고 결국에는 내가 중첩해가지고 이 락을 호출할 때도 정상적으로 라이트 라이트를 두 번 연속 호출해도 잡을 수 있다는 얘기가 되는 거고 근데 혹시라도 데드락이 일어났거나 이런저런 상황에 의해가지고 너무 오랫동안 여기서 스피드를 한다고 하면은 우리가 의도적으로 그냥 크래쉬를 낼 겁니다 그래서 여기서 이런 식으로 시간을 체크를 해볼 건데 GettingCount 여러가지 함수 버전 중에서 가장 간단한 GettingCount64를 이용해가지고 시간을 체크를 해 주도록 하겠습니다 어 근데 이게 지금 에러가 나는거는 헤더가 추가가 안된거 같은데 여기 코어 피스에이체에 돌아가가지고 대략적으로 여기 아래다가 , 자, 요렇게 아래다가 윈도우스.h를 추가를 해주도록 할게요 대충 이쯤에다 놓을까요? 아이오스트림 위에다가 그리고 하는 김에 이제 락도 굉장히 자주 사용할 예정이기 때문에 여기다가 락도 같이 , 이렇게, 추가를 해주도록 하겠습니다 겸사겸사 그리고 다시 닫아가지고 보면은 이제 에러가 없어졌구요 , 자, 그래가지고 여기서 , 이렇게, 5,000번을 테스트를 할건데 여기서 이제 5,000번을 테스트를 했으면은 잠시 쉬고 오도록 할게요 디스 스레드 일드를 통해 가지고 소유권을 , 일단은, 내려놓은 다음에 다시 컨택 스위칭이 일어나고 돌아오고 하면서 다시 처음으로 새로운 마음으로 실행할 것인데 중간에 만약에 우리가 예상한 시간보다 너무 오래 걸렸다 10초 이상 걸린다고 하면 이건 문제가 있는 상황이겠죠? 그렇기 때문에 이 시간 자체를 체크해가지고 우리가 Acquire Timeout Tick이라고 정해준 이 Tick보다 더 커지면 의도적으로 크래쉬를 내주도록 할 거예요 사유는 Lock Timeout이라는 사유로 , 이렇게, 그냥 넣어주도록 할게요 이거는 우리가 보기 쉬우라고 넣어주는 거고 딱히 어떤 의미를 지는 건 아닙니다 , 이렇게, 해가지고 라이트락의 코드는 대충 완성이 되었고요 이 흐름을 보면 그렇게 어마어마하게 , 일단은, 어려운 건 없다는 걸 알 수 있는데 여기서 유심히 봐야 될 거는 뭐냐면 이 플래그 자체를 , 이렇게, 컴퓨터 스왑으로 한 번에 딱 지금 작업을 하고 있는 거죠 여기서 내부적으로 내부적으로 우리가 이런 식으로 마스크 스레드를 이용해가지고 마스크를 통해가지고 얘를 밀어주는 순간에 알 수 있는 거는 이 리드 카운트가 만약에 0이 아니라 다른 값이라고 하면은 애당초 우리가 예상한 이 expected 값이 아니기 때문에 얘가 무조건 실패를 하게 되고 다음 틱에 다음 턴에 계속 돌면서 시도를 하게 됩니다 그러니까 누군가가 이 리드 락을 잡고 있는 상태라고 하면은 라이트 락도 획득할 수 없고 계속 경쟁을 통해서 누군가가 얘를 다 놔줘가지고 이 카운트가 0이 돼야지만 내가 잡을 수 있다는 얘기가 되는 거죠 그러니까 결국에는 라이트 락은 내가 처음부터 잡고 있거나 아니면은 진짜로 이 락을 아무도 사용하지 않아서 리드도 없고 라이트 카운트도 없어가지고 진짜 완전히 깨끗한 상태에서만 내가 그 값을 잡을 수 있다라는 게 핵심이 된다고 보시면 되겠어요 , 자, 그 다음에 이제 라이트 언락으로 가가지고 얘 같은 경우에는 뭐 비교적 간단한데 말 그대로 우리가 라이트 카운트라는 걸 관리하고 있으니까 이 라이트 카운트를 그냥 1을 빼주도록 할게요 빼주고 그 값이 결과물을 본 다음에 만약에 락 카운트가 0 이다 즉 더 이상 내가 이 락을 잡고 있지 않다고 하면은 그러면 결국에는 이 락을 내가 더 이상 차지하고 있는게 아니다 보니까 원래 여기서 내가 이 Lock을 잡고 있었다고 하면 여기다가 내 Thread ID가 들어가 있을 텐데 그거를 다시 0으로 밀어주기 위해서 , 이렇게, Empty Flag를 , 이렇게, 호출하고 있습니다 근데 이 Light Unlock을 할 때 조심해야 되는 건 뭐냐면 지금 우리가 만들 코드에서는 순차적으로 이건 좀 지금 말하는 게 맞는 것 같긴 한데 라이트는 연속적으로 , 이렇게, 해도 돼요 그리고 라이트를 잡은 상태에서 리드락도 잡을 수 있기는 한데 거꾸로 리드락을 잡은 상태에서 라이트락은 안 됩니다 이게 이제 우리가 사용할 정책이고 이게 예전 프로젝트에서 제가 사용했던 정책이기도 해요 리드만을 잡았다는 거는 다른 애들도 동시에 리드락을 잡고 있을 수 있다는 얘기가 되는데 그 상황에서 다시 , 이렇게, 라이트락을 잡는다고 자체가 조금 뭔가 이상한 상황이 되는 거죠 그럴 거면 애당초 , 이렇게, 내가 쓸 수 있는 상황이라고 하면 처음부터 라이트락을 잡는 게 맞으니까 리드에서 라이트로 가는 순서는 , 일단은, 인정을 해주지 않을 겁니다. 그래가지고 결국에는 라이트 언락을 할 때 여기서 한 가지만 예외적으로 체크를 해줄 것은 이거는 그냥 버그를 잡기 위한 용도입니다. 꼭 들어가야 되는 건 아니지만 리드 락을 다 풀기 전에는 , 일단은, 라이트 언락은 불가능하다라는 걸 , 일단은, 테스트하기 위해서 이 락 플래그에다가 여기다가 리드 카운트 마스크를 통해 가지고 체크를 해봐서 만약에 이 값 자체가 0이 아니다 라고 하면은 0이 아니다라는 것 자체가 뭔가가 이미 리드 카운트가 0이 아니라는 얘기는 결국 누군가가 쓰고 있다는 얘기가 되는 거죠. 즉 얘가 0이 아니다. , 이렇게, 코드를 작업을 해보도록 하겠습니다. 좀 더 확실히 쓰기 위해서. 그러면 여기다가 우리가 뭔가 문제가 있는 상황이라고 인지하고 invalid unlock order라고 , 이렇게, 에러 메시지를 출력을 해주도록 할게요. 그래서 크래쉬를 내도록 할 겁니다. 그래가지고 혹시라도 내가 리드 락을 동일한 스레드가 잡은 상태에서 락을 안 풀어주고 라이트 언락을 한다거나 하는 순서가 뭔가 꼬인 상황이 있다고 하면 , 이렇게, 잡아주도록 할 거예요 이게 좀 내용이 헷갈릴 수 있는데 이거는 코드를 다 작업한 다음에 큰 그림으로 다시 보면 그렇게 어려운 내용은 아닙니다 그래서 이제 이어서 다시 리드 락도 작업을 할 건데 얘도 마찬가지로 아까 얘기한 대로 라이트 락을 내가 즉 동일한 스레드가 라이트 락을 잡은 상태에서 그 다음에 리드 락을 잡는 거는 우리가 허락을 해 줄 겁니다 그래서 역시나 동일한 스레드가 이 락을 소유하고 있다면 우리가 무조건 성공을 시켜 줄 거예요 이 코드는 조금 있다가 만들어 주도록 하고 그냥 일반적인 상황에서는 아무도 락을 소유하고 있지 않을 때 역시나 경합해서 공유 카운트를 카운트를 올려야 합니다 여기서 공유 카운트라는 리드에 해당하는 이 부분을 얘기하고 있는 거예요. 라이트 같은 경우에는 내가 얘를 잡을 때 내 스레드 아이디를 여기다가 기입을 하는 것이고 그게 아니라 이쪽 하위 16비트 같은 경우에는 나랑 다른 애랑 공유해서 사용하는 거다 보니까 그냥 일종의 카운팅 자체를 여기다가 이 락을 몇 명이서 잡고 있는지를 여기 리드 카운트에다가 기입을 해주게 될 겁니다. 그래서 경합해서 공유 카운트를 올린다는 그 말이고요 여기서 유심유보에는 소유하고 있지 않을 때 소유라는 것은 누군가가 라이트를 잡고 있지 않을 때라는 얘기가 되는 거죠 라이트락을 아직 안 잡은 상태에서 나머지 애들끼리 , 이렇게, 사이좋게 리드를 하는 건 우리가 다 허락을 해준다고 했으니까 이제 그 부분을 , 이렇게, 만들어 주도록 하겠습니다 , 일단은, 와일루프를 돌면서 뺑뺑이를 돌면서 얘도 마찬가지로 스피인 카운트는 뭐 똑같이 0부터 시작을 해가지고 , 자, 이렇게, 맥스 스피인 카운트가 될 때까지 뺑뺑이를 돌아줄 것이구요 뿔뿔을 해줄 것이고 , 자, 그 다음에 이제 그러면 내가 예상하는 값, 이제 expected랑 desired를 골라줘야 되는데 우선 expected 같은 경우에는 , 자, 락 플래그에다가 로드를 해준 다음에 거기다가 , 일단은, 리드 카운트 마스크를 추출을 해줄 겁니다 예를 해줬다는 얘기가 이제 여기서 유심히 봐야 될 부분은 뭐냐면은 의도적으로 우리가 리드 카운트 마스크를 얘랑 , 이렇게, 엔드를 해줬다는 것은 이 위에 있는 라이트 카운트와 라이트 플래그와 관련된 부분을 우리가 의도적으로 0으로 쫙 밀어줄 거예요 그래서 만약에 우리가 예상한 이 엑스펙티드가 맞다고 하면은 이 부분이 위에 있는 상위 16비트가 0이라는 얘기가 되는 거니까 아무도 이 라이트 락을 획득하고 있지 않는 상태가 된다는 얘기가 되는 거죠 즉 리드 횟수만 있기 때문에 여기서 나도 안전하게 리드를 잡을 수 있겠구나라는 상황을 우리가 , 이렇게, expected 가정해 가지고 사용을 하고 있는 겁니다. 그래서 만약에 우리가 예상한 이 상황이 맞다면 아무도 라이트 락을 사용하고 있지 않는 상태가 될 테니까 compile action is strong 을 통해 가지고 expected 에다가 expected을 원을 해가지고 1을 증가시킨 거로 우리가 잡아줄 거예요 즉 요 상황이 맞다고 하면은 그냥 이 리드 카운트를 1 증가시킨 거로 우리가 바꿔치기를 해주겠다라는 얘기가 되는 거죠 만약에 이거를 내가 성공적으로 했다고 하면은 내가 리드 카운트를 올렸으니까 리드 락을 잡은 거니까 이제 빠져나오면 될 것이고 얘가 실패했다고 하면은 뭐 두 가지 원인이 있을 수 있는데 누군가가 라이트 락을 이미 잡고 있었다 나 말고 다른 애가 라이트 락을 잡고 있었다 가 되거나 혹은 그 간발의 차이에 내가 예상한 이 expected 사이에 얘가 누군가가 새치기를 해 줘 가지고 먼저 이 코드를 실행해 가지고 이 expected 값이 바뀌어 가지고 내가 예측한 이 값이 아닐 상황이 있겠습니다. 두 가지 상황 중에 하나가 발생하면 실패할 것이고 아니면 성공할 것이라는 얘기가 되는 거죠. 성공했으면 일단 , 이렇게, 빠져나오면 되겠습니다. 그 다음에 마찬가지로 여기 왔으면 이제 실패한 거니까 5,000번 동안 실패했으면은 이 일들을 해줘서 한번 잠자고 다시 돌아오도록 할 것이고 마찬가지로 얘도 위에서 한 거와 마찬가지로 시간을 똑같이 재줄 것인데 , 자, 여기서 시작할 때 시간을 재주고 그 다음에 , 이렇게, 어 끝날 때 너무 시간이 오래 됐으면은 락타의 마술 요렇게 크래쉬를 내주도록 할게요 요런 경우는 거의 대부분 뭐 데드락 상황이라고나 하는 그런 컨텐츠적인 로직이 꼬여가지고 발생하는 문제니까 그냥 크래쉬를 요게 깔끔하게 내주게 될 겁니다 그냥 크래쉬를 내가지고 버그를 찾는게 훨씬 더 깔끔해요 , 자, 이렇게, 해가지고 리드 락이 그런 의미로 만들어졌고 어찌됐건 동일한 스레드가 이미 라이트 락을 잡고 있다고 하면 얘는 성공으로 인지를 해주게 될 겁니다 그래서 위에서와 마찬가지로 요 부분을 일단 잠시 복붙을 한 다음에 , 이렇게, 긁어와 가지고 이 락을 잡고 있는 스레드가 딱 정확히 나였다 그럼 이미 라이트 락을 잡고 있는 상태에서 그 상태에서 리드 락을 한 번 더 잡으려는 상태이다 보니까 요 경우에는 그냥 락 플래그에다가 그냥 1을 증가시켜 주도록 할게요 어차피 다른 애들은 접근을 못하는 상태라는 걸 우리가 확신할 수 있으니까 그냥 , 이렇게, 싱글 스레드인 것 마냥 우리가 그냥 여기다가 1을 쿨하게 그냥 더해줄 수 있다는 얘기가 되는 겁니다 어차피 다른 애들은 접근을 못하고 있는 상황이기 때문이죠 , 이렇게, 해가지고 리드 락이 어느정도 완료가 되었고 그 다음에 리드 언락 같은 경우는 굉장히 간단한데 그냥 리드 락 카운트를 1 줄여주면 됩니다 그래서 락 플래그에서 Fetch Sub을 통해 가지고 , 이렇게, 1을 줄여 주도록 할게요 근데 혹시 모르니까 여기서도 체크를 해 줘 가지고 여기서 리드카운트 마스크를 체크해가지고 , 이렇게, 씌운 다음에 이 값이 0 이었다고 하면은 뭔가 문제가 있는 상황이 될 겁니다 여기서 , 이렇게, 이렇게, 잡아 줘야겠죠 그러니까 얘가 지금 , 이렇게, 해서 0이 나왔다는 것은 애당초 이 락 플래그가 1을 빼기 전에 값이 0이었다는 얘기가 되는 거죠 Fetch Sub은 얘를 이제 1 뺀 다음에 그 이전 값을 뱉어주기 때문에 그 이전 값이 0이었다고 하면 애당초 뭔가 지금 락을 리드 락을 하기 전에 뭔가 리드 언락을 했다거나 하는 뭔가 묘한 상황이 발생한 거니까 여기다가 바로 크래쉬를 또 내주도록 하겠습니다 이런 크래쉬는 어지간해서 일어나지 않을 거예요 그냥 안전삼아 우리가 버그를 잡기 쉬우라고 , 이렇게, 만들어 준 겁니다 그래가지고 코드가 대략적으로 , 이렇게, 완료가 되었어요 이 코드를 다시 한번 전반적으로 보시면 만약에 락프리 스택이랑 큐에 대한 내용도 같이 공부를 하셨다고 하면 상대적으로 좀 쉽게 느껴질 수가 있을 겁니다 그래가지고 이 부분을 잘 보시기를 바라고요 이 부분이 중요해요 라이트에서 라이트를 또 잡거나 하는 건 아무런 상관이 없고 그 다음에 라이트를 한 다음에 동일스레드가 리드를 하는 것도 이런 부분은 상관없는데 리드를 한 상태에서 동일스레드가 라이트를 하는 것은 막아주겠다는 얘기가 되는 거죠 이 규칙을 이제 기억을 해주시면 되겠습니다 그 다음에 설령 우리가 락을 사용한다고 해도 , 이렇게, 라이트 락, 라이트 언락을 수동으로 하는 것은 너무 무식한 방법이겠죠 얘도 우리만의 그런 락가드를 만들어 가지고 사용할 것이기 때문에 이쪽에다가 , 일단은, 락가드를 정의를 해주도록 하겠습니다 요렇게 한번 또 영역을 집어주고 여기다가 락 가드 영역을 만들어주도록 할게요 뭐 별건 없구요 그냥 리드 락 가드를 만들어줄 것인데 여기다가 나중에 이제 또 버그를 잡는 여러가지 코드를 넣어주겠지만 일단 기본적으로 얘가 하는거는 리드 락 가드가 처음에 만들어질 때 이 락을 , 이렇게, 잡아가지고 여기다가 , 이렇게, 저장해주는 것과 동시에 lock에 read lock을 잡아줄 것이고 말그대로 라이 패턴이죠. r-a-i-i resource acquisition is initialization 이라고 해가지고 그냥 이 객체가 만들어질 때 lock을 잡아줄 것이고 소멸이 될 때 이 lock가 소멸이 될 때는 lock에 read unlock을 해주면 되겠습니다. 굉장히 단순한데 여기다가 조금 우리가 디버그인과 관련한 내용이 나중에 추가가 될 거예요. 그 다음에 마찬가지로 하나를 더 복사해 가지고 이번에는 라이트 버전을 하나를 더 만들어 줄 것인데 라이트 라이트 그 다음에 여기도 리드 락이 아니라 라이트 락을 잡아 줄 것이고 여기서는 라이트 언락을 , 이렇게, 잡아주게 세트를 만들어주면 되겠습니다 그럼 결국에는 우리가 이제 이 락을 사용할 때는 락 가드를 이용해 가지고 이 리드 라이트를 만들어 가지고 자동으로 해제되게끔 유도를 해주면 어지간해서는 락 순서가 꼬여 가지고 발생하는 문제를 , 일단은, 예방할 수 있다는 얘기가 되는 거죠 , 자, 그 다음에 다시 이제 코어 매크로 쪽으로 돌아가 가지고 요 부분을 더 편하게 사용할 수 하기 위한 매크로를 몇 개를 정의해줄 건데요 이 밑부분에다가 이쪽에다가 만들어 보도록 하겠습니다 얘는 이제 락과 관련된 매크로를 일단 정의해줄 것인데 이거는 예전에 제가 작업했던 그 프로젝트에서 사용하던 그런 느낌적인 느낌으로 모방을 한번 해봤습니다 일단 매크로를 몇 개를 만들어 볼 건데 이 매크로의 의미는 작업을 한 다음에 좀 설명을 드리도록 할게요 , 일단은, 이렇게, 처음에 락을 클래스 내부에서 정의를 해주는 매크로를 몇 개를 만들어 줄 겁니다 여러 개를 사용할 것이면 요 버전을 사용할 것이고 일반적으로 락을 하나만 사용할 것이라고 하면은 이 useLock 이라는 거로 매크로를 사용해주면 돼요 그래서 얘를 이제 1번으로 , 이렇게, 세팅을 해줄 것이고 하나만 사용할 것이다 아니면 여러 개 사용할 것이면 윗버전을 사용하면 되고 그 다음에 어... 역시나 여러 개의 락을 사용하는 경우 그 중에서 ReadLockIndex 몇 번째 인덱스의 락을 잡아줄 것이냐라는 걸 할 때 이런 식으로 ReadLockGuard를 만들어 줄 것인데 이름이 좀 달라져야 되겠죠 인덱스에 따라가지고 그래서 ReadLockGuard에다가 샥을 두 개를 , 이렇게, 해주시면 얘가 실질적으로 우리가 만약에 1번을 넣어주면은 이 코드가 , 이렇게, 자동적으로 , 이렇게, 만들어집니다. 그래서 이게 약간 비주얼 컴... 그니까 우리가 이 컴파일을 할 때 이 샵샵이 들어가는 건 아니고 요 부분이 이제 치환이 되어가지고 컴파일러가 처리를 해준다고 보시면 되겠어요. 전처리 단계에서. , 자, 그래가지고 요렇게 코드를 , 일단은, 만들어주도록 할게요. 그래서 말그대로 어떤 클래스에다가 우리가 , 이렇게, 일일이 타이핑하는 거를 최대한 효율적으로 하기 위한 그런 눈물겨운 작업이구요 그 다음에 리드 락을 할 경우에는 리드 락 인덱스 0번을 잡아 줄 것이고 마찬가지로 복붙을 한 다음에 이제 요 부분이 라이트로 바뀌게 됩니다 그래서 라이트 락을 잡을 때도 역시나 , 이렇게, 하고 얘는 이제 라이트 버전으로 , 이렇게, 이름을 맞춰주도록 할게요 아이고 얘가 라이트 락 가드 버전 네 , 이렇게, 만들어지게 되겠습니다 , 자, 이게 아직 와닿지 않으실 텐데 이 코어 매크로를 유심히 보면서 이제 실질적으로 우리가 만든 락을 사용하는 그런 예제를 한번 보여드리도록 하겠습니다 그래서 게임 서버로 돌아가가지고 , 자, 오늘 어떻게 테스트를 해볼 거냐면은 , 일단은, 이 lock 같은 경우에 클래스에 기생을 해서 존재하기 때문에 테스트 클래스를 만들어 볼 것이고 우리가 내부적으로 lock을 사용하겠다 그냥 한 개만 사용하겠다고 해서 useLock이라는 매크로를 클래스 안에다가 , 이렇게, 넣어주도록 하겠습니다. 그 다음에 public 테스트로 읽어보는 함수를 만들어 줄 것이고요 일단 자료구부부터 만들어 보도록 할까요? 여기다가 뭔가 , 이렇게, 멀티스레드 환경에서 공용으로 어떤 큐를 접근해가지고 요 큐를 건드리는 상황이 있다고 가정을 하면은 여기서 뭔가 테스트 푸쉬를 통해가지고 데이터를 수정할 거거나 아니면은 여기서 테스트 팝을 통해가지고 테스트 팝을 통해가지고 여기서도 이제 뭐 데이터를 꺼내 쓰는 그런 작업을 할 겁니다. , 자, 이럴 때 여기서는 데이터를 건드릴 거니까 라이트를 할 것이니까 간단하게 라이트 락을 , 이렇게, 잡아주면 되겠죠. 그래서 , 이렇게, 매크롤을 사용하게 되면은 굳이 복잡한 타이핑을 할 필요 없이 여기서 이 전 영역에 우리가 만든 라이트 락 가드에 의해 가지고 락이 잡히게 될 것이고 여기서 유즈 락을 함과 동시에 사실상 어떤 코드가 들어간 거냐면은 요 코드가 , 이렇게, 들어가게 된 거죠. 여기서 이런 식으로 요 코드가 사실상 간접적으로 들어가게 된 겁니다 이걸 타이핑 하는 것보다 요 버전이 훨씬 더 이해하기가 쉽죠 한 개짜리의 락을 사용하겠다 하나만 사용하겠다는 의미가 되는 거고 , 자, 그 다음에 리드를 할 때는 거꾸로 리드 락을 요렇게 , 일단은, 잡아주면 되겠습니다 , 자, 그 다음에 여기서 뭐 테스트할 때 뭐 팝을 할 때는 예를 들면은 만약에 Q가 MT가 아니다 뭔가 데이터가 있다고 하면은 Q에 팝을 해줄 것이고 그 다음에 뭐 어떤 데이터를 아무 데이터나 밀어 넣어 주려고 할까요? 그냥 랜덤에다가 뭐 , 이렇게, 나누기를 해가지고 나머지를 , 이렇게, 아무거나 갑시나? 라이트를 해주는 그런 코드를 넣어주고 위쪽에서는 만약에 Q에 MT Q가 MT라고 하면은 그냥 마이너스 1을 리턴하고 그게 뭐 아니라고 하면은 return Q.front , 자, 뭐 , 이렇게, 코드를 그냥 아무런 의미 없이 만들어 보도록 할게요 그래서 , 이렇게, 리드 라이트와 관련된 코드가 , 이렇게, 막 지금 들어가고 있는 상황이라고 보시면 되고 그 다음에 이걸 테스트 해보기 위해서 간단하게 전역으로 이 테스트 락 클래스를 만들어 준 다음에 , 자, 이제 어... 스레드들이 어떤 쓰레드에서는 이 값을 쓰고 어떤 쓰레드에서는 쓰레드 값을 읽어보는 그런 행동을 해볼 겁니다 그래가지고 요 부분에서는 테스트 락에서 예를 들면 테스트 푸쉬를 한 다음에 대충 1초 정도 sleep for를 해서 1ms 동안 잠 잔 다음에 다시 테스트 락에 테스트 팝을 막 호출하도록 할게요 그 다음에 어떤 스레드들은 그냥 딱히 뭐 어떤 굉장히 심오한 의미는 없지만 여기다가 테스트 락에 테스트 리드를 호출해 가지고 그 값을 읽어준 다음에 , 이렇게, 콘솔에다가 출력을 하고 그 다음에 디스 스레드에 역시나 Slate4를 통해 1ms를 잠들고 이어서 실행을 해보도록 하겠습니다. 여기서 2개 정도의 Thread는 라이터 Thread가 되어서 데이터를 기입할 것이고 일부 Thread는 예를 들면 5개 정도는 ThreadRead를 호출해서 데이터를 읽는 행동을 한다고 가정을 해볼게요. 그러면 이제 우리가 지금까지 만든 락을 통해 가지고 이제 리드 버전과 라이트 버전이 , 이렇게, 두 개로 나뉘게 될 것이고 , 사실, 대부분의 경우에는 리드만 할 게 없지만 정말 극악의 확률로 , 이렇게, 라이트가 들어간다고 하면 이 경우에 한해서는 역시나 상호 배터적으로 동작을 정상적으로 잘 할 것이고 테스트 리드끼리는 또 자기들끼리 서로 경험 없이 그냥 쿨하게 호출을 해주게 될 겁니다 뭐 이런 느낌으로 이제 만들어지게 될 거예요 , 자, 이렇게, 해가지고 우리가 사용한 라클래스가 완성이 되었는데요 어 근데 지금 실행해보면 크래시가 날 건데 이게 왜 크래시가 날지 저도 약간 오래 찾았는데 여기 유심히 보면은 마스크를 작업할 때 F를 하나를 더 썼네요 네 이게 정확하게 , 이렇게, 떨어져야 됩니다 F가 4개 그래가지고 요 부분이 잘못되어 가지고 발생한 문제였고 그래서 요렇게 다시 정상적으로 오타를 지운 다음에 이제 다시 한번 실행을 해보시면 이 상태에서 정상적으로 크래시가 나지 않고 자기들끼리 잘 경합을 해서 , 이렇게, 사용하는 걸 볼 수가 있습니다 물론 지금 이것만 보면은 밉텍스에 비해서 얘가 어떤 장점이 있는지 잘 알지 않을 수도 있지만 결국에는 , 이렇게, 리드락 자체가 거의 정말 99% 확률로 굉장히 심하게 서로 리드만 사용할 경우에는 사실상 요 부분은 서로 경합하지 않고 리드 카운트만 올려가지고 막 서로 통과시켜 주기 때문에 훨씬 더 효율적으로 동작하는 거고 정말 그 가격 확률로 라이트 락을 할 경우에만 얘가 이제 나머지 애들을 호출을 막아버리고 자기가 독점적으로 사용하는 그런 코드가 되겠습니다 , 자, 그리고 요 상태에서 이제 뭐 여러가지 실험을 해보시면 되는데 일반적으로는 그냥 , 이렇게, 라이트 락하고 끝나겠지만 여기서도 뭐 경우에 따라 가지고 다른 함수를 막 호출해 줄 수가 있겠죠 뭐 예를 들면은 왠지 모르겠지만 요기 내부에서 , 이렇게, 테스트 리드를 호출한다거나 하는 경우가 나중에 컨텐츠 코드를 작업하면 함수가 한두 개가 아니니까 이런 일이 발생하게 될 겁니다 근데 우리가 얘기한 정책에서는 동일한 스레드에서 라이트 락을 획득한 상태에서 다시 리드 락을 잡는 건 아무런 문제가 되지 않는다고 했기 때문에 요 코드는 이제 문제가 없게 되지만 반대로 , 이렇게, 리드를 한 상태에서 괜히 라이트락을 잡기 위해서 뭔가 이런 코드가 막 실행이 된다고 하면은 여기서는 이제 크래시가 나게 될 겁니다. 크래시가 나는 상황이 이제 왜 일어나게 되냐면은 이 코드를 유심히 보면은 누군가 이 코드가 실행이 되려면은 결국에는 리드 카운트가 0이 되어야만 내가 락을 잡을 수 있는데 여기서 사실은 내가 몰래 리드 카운트를 잡고 있었기 때문에 절대로 내가 성공적으로 얘를 , 이렇게, 안에 들어올 수가 없게 됩니다 그렇기 때문에 결국에는 , 이렇게, 락 타임아웃이 나가지고 결국 크래시가 나는 식으로 동작을 하게 될 겁니다 그래서 데드락 뿐만 아니라 , 이렇게, 리드를 한 다음에 라이트를 하는 경우에도 거의 100% 확률로 그냥 크래시가 난다고 보시면 되겠어요 뭐 이런 것도 테스트 해보시면 되겠죠 예를 들면은 여기다가 라이트를 잡은 상태에서 내가 무한 루프를 돌려가지고 이 라이트를 절대 안 놔준다고 하면은 나머지 애들이 여기서 라이트랑 리드를 하려고 막 대기를 하다가 스피드를 계속 열심히 돌다가 시간 경과로 인해가지고 요 부분에서 이제 크래시가 일어나게 될 겁니다 뭐 이런 것도 테스트를 한번 해보시면 되겠어요. 그래가지고 한쪽에서 너무 락을 오래 잡고 있다거나 하는 그런 뭔가 이상한 상황이 발생한다고 하면 최종적으로 코드가 실행이 되지 않고 크래시가 나는 상황이 발생하게 된다고 보시면 되겠습니다. 그래서 아까 우리가 초비엔 10초로 세팅을 해놨으니까 이게 밀리세컨드 단위여서 10초거든요. 10초 정도 딱 지나면 이런 식으로 정상적으로 크래시가 나는 것도 볼 수가 있죠. 실질적으로 서버가 크래시나는 이유 중에서 널 포인터와 마찬가지로 이것도 굉장히 상위권에 속해 있었어요 근데 , 이렇게, 진짜 문제가 있는 경우에는 역시나 진짜로 어 그게 크래쉬를 낸 다음에 원인을 찾는게 훨씬 낫지 뭔가 운빨의 코드를 잘 돌아가게 의도하는 것은 좋은 방법이 아니기 때문에 , 이렇게, 그냥 크래쉬를 내서 사용을 하곤 했었습니다 , 자, 이렇게, 해가지고 이번 시간에 했던 코드는 그래도 상대적으로 컴퓨어 스왑을 이용하긴 하지만 우리가 워낙 어려운 락 프리 스택 락 프리 큐를 먼저 알아보고 얘기를 했기 때문에 그래도 상대적으로 적응하기 쉬웠을 거라고 일단 저는 예상을 합니다 개인적으로 근데 여기서 굉장히 배울 점이 많죠 이런 식으로 결국에는 두 가지의 독립된 정보 , 사실, 라이트라는 거랑 리드 카운트랑은 엄밀히 말해서 딱히 상관이 없어 보이는 이 두 정보를 하나의 uint32 안에다가 비트플래그로 낑겨 넣어 가지고 얘네들이 한 번에 우리가 , 이렇게, 교체를 하는 작업으로 체크를 하고 있기 때문에 얘가 멀티셋 환경에서도 안전하게 동작을 하는 거죠. 그래가지고 한쪽을 우리가 예상한 값, 예를 들면 리드를 해야 되는 경우라면 라이트가 있으면 안되니까 이 값을 0으로 밀어놓는 그런 상태로 우리가 예측을 해가지고 그 예측한 상황을 이용해 가지고 우리가 , 이렇게, 컴퓨터 수업을 돌리는 요런 부분들을 주의깊게 보셔야 됩니다 처음으로 참고로 말씀드리면 저는 처음에 프로젝트에 가 가지고 요런 코드를 봤을 때 이런 컴퓨터 수업이라는 개념도 없어 가지고 이게 도대체 뭔 외계어인가 싶었어요 근데 이제 제가 어느 정도 이거를 좀 오래 다뤘기 때문에 이제 이런 코드를 보셔도 크게 당황하지 않고 분석을 하실 수 있을 거라고 생각이 됩니다 , 자, 이렇게, 해 가지고 우리가 앞으로 사용할 리더라이트 락을 완료를 하고 마치도록 하겠습니다.