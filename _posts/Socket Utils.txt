자, 이제 네트워크 소켓 프로그래밍에 대한 내용을 쭉 어느 정도 다뤄봤고요. 이번 시간부터 본격적으로 우리의 네트워크 라이브러리를 이제 쌓아 올리는 시간을 가져보도록 할 건데요. 일단 기존에 했던 내용은 서버 쪽은 , 일단은, 삭제를 해주도록 할게요. 클란은 일단 냅둬가지고 우리가 서버 쪽만 , 일단은, 이쪽만 고쳐가지고 접속 테스트를 해볼 것이기 때문에 일단 클란은 남겨뒀도록 하겠습니다. , 자, 그리고 이제 네트워크 라이브러리 같은 경우에는 지금까지 우리가 배웠던 그 IOCP 모델을 좀 편하게 쓸 수 있도록 기능을 이리저리 분리를 할 것이기 때문에 처음에 볼 때는 , 사실, 조금 헷갈릴 수가 있어요 왜냐면 이제 모든 클래스들이 다 만들어진 다음에 걔네들이 조립이 되어 가지고 뭉쳐져야지만 기능이 동작하는 형태이기 때문에 처음에 할 때는 굉장히 헷갈릴 수가 있습니다 그건 , 일단은, 감안을 하시고 그래서 처음에 뭐 조금 이해가 안 가는 부분이 있다고 하더라도 일단 넘어간 다음에 최종적인 조립된 코드를 보고 다시 분석을 하시는 게 좋을 수 있어요. 첫 시간에는 너무 복잡한 걸 하진 않을 거고 일단 간단하게 소켓 라이브러리를 초기화하는 이런 스타트업 그리고 정리하는 부분 등등 소켓과 관련된 라이브러리를 일단 정리를 해보도록 하겠습니다. 우리가 지금 클라랑 서버에서는 다 이 헤더를 추구해주고 있는데 여기 있는 내용들을 메모리 헤더까지 긁어 가지고 , 일단은, 코어 피스위치에다가도 옮겨 놓도록 하겠습니다 위치는 대략적으로 표준이 지금 이쪽에서 윈도우즈랑 아이오 스트림이니까 여기 이어서 윈속과 관련된 내용을 아래에다가 추가를 하고 메모리 헤더는 맨 아래에다가 , 이렇게, 추가를 해주도록 할게요 뭐 딱히 이유는 없지만 , 이렇게, 좀 정리를 해봤습니다 그 다음에 오늘 추가할 애들은 네트워크 쪽에 가서 가장 기본적인 클래스 몇 개를 추가해 볼 건데 , 일단은, SocketUtil이라는 클래스를 SocketUtilsS 까지 붙여도록 할게요 SocketUtil과 관련된 라이브러리를 하나 만들어 줄 것이고 그 다음에 이어서 추가 클래스를 한 다음에 네트워크 어드레스라는 클래스를 하나를 만들어보고 얘네들을 네트워크 쪽에 옮긴 다음에 이쪽에다가 작업을 시작을 해보도록 하겠습니다 소켓 유틸이랑 네트워크 어드레스 헤더를 왼쪽에 , 이렇게, 저장을 해주고 소켓 유틸이 해주는 역할은 이제 그냥 소켓 프로그래밍을 우리가 처음에 할 때 윈도우즈 속 윈속 초기와 같은 부분도 있을 것이고 그 다음에 뭐 지난번에는 우리가 실습을 하진 않았지만 비동기의 Connect, Disconnect, Accept 같은 함수들은 그냥 사용할 수는 없고 우리가 처음에 프로그램이 실행이 될 때 런타임에 주소를 얻어야 된다는 제가 언급을 했었는데 그 부분을 처리하게 될 겁니다 , 자, 그래가지고 여기서 만들어줄거고 , 일단은, 얘는 net address header를 포함을 한 다음에 제가 늘 하는 이 부두술과 같은 쓸모없는 짓거리지만 저는 항상 하는 영역을 일단 집어가지고 socket-utility라고 그냥 요렇게 주석을 남겨주도록 하겠습니다. 그래서 public public private는 딱히 안 쓸 것이고 public에서 , 일단은, static lpfn connect x 라고 해가지고 이제 얘가 connect x 라는 extended라는 그 함수의 포인터가 될 거예요 그래서 얘를 이제 connect x 라고 이름을 지어 줄 것이고 두개를 더 복사한 다음에 얘는 Disconnect 함수를 우리가 똑같이 불러올 것이고 마지막으로는 Accept Extended , 자, 요 아이도 우리가 긁어올 겁니다 정렬을 해주고 이름도 당연히 바꿔줘야 되겠죠 얘는 Disconnect 그리고 얘는 Accept 그래서 얘네들이 함수의 포인터 같은 역할을 해주게 될 것이고 처음에는 얘네들이 그냥 널값인데 이걸 나중에 우리가 실질적으로 런타임에 긁어와야 됩니다 그래서 , 일단은, 오른쪽에다가 얘를 만들어주면서 진행을 해보도록 하겠습니다 이 부분을 , 일단은, 그냥 복붙한 다음에 스태틱은 없애주도록 할 것이고 소켓 유틸의 무엇무엇 디스코넥트의 아 소켓 유틸의 디스코넥트 커넥트 디스코넥트 억셉트를 다 , 이렇게, 만들어주도록 할게요 기본적으로 얘네들이 사실상 함수 포인터인데 다 널 포인터로 일단 있을 것이고 이걸 우리가 실시간으로 이 해당 함수들의 주소를 로드해가지고 여기다가 이제 저장을 해줘야 됩니다 그게 이제 우리의 목적이고 , 자, 그리고 좀 오늘 이제 등장할 함수가 꽤 많은데 한번 하나씩 작업을 해보도록 할게요 처음에 초교하는 부분이랑 클리어하는 부분이 있을 것이고 얘네들부터 이제 만들어 볼까요 여기서 이제 하나씩 만들어 보자면 소켓 유틸에 이닛하는 함수를 , 이렇게, 만들어 주도록 하겠습니다 그 다음에 이어가지고 소켓 유틸의 클리어 함수도 만들어줄 것인데 우선은 우리가 늘상 하던거 있죠? 그 WSA 데이터를 받아가지고 WSA 데이터 그 다음에 WSA 데이터 스타트업 아이고 wsa-startup을 해가지고 항상 winsock을 초기화하고 시작을 했었죠 , 자, 이거는 맨 처음에마다 등장을 했었으니까 얘는 다시 , 이렇게, 맞춰주도록 하구요 wsa-data를 , 이렇게, 초기화해주고 , 자, 그 다음에 혹시 모르니까 어서트 크래쉬로 혹시라도 뭔가 잘못되면 그냥 크래쉬를 바로 내도록 할게요 스타트업이 정상적으로 호출이 되면 얘가 그냥 0을 뱉어주기 때문에 0인지를 이제 어서트를 해주면 되겠죠 , 자, 이렇게, 일단은, 만들어 보도록 하겠습니다 , 자, 그건 그렇고 그래서 여기서 이 각각 함수들의 주소를 어떻게 얻어와야 되느냐 뭐 그건 당연한 얘기지만 msdn의 뭐 acceptext 같은 문서를 찾아보면은 어떤 식으로 하라 뭐라고 다 , 이렇게, 나와 있기는 합니다 그리고 아래에 내려보면 예제코드도 당연히 있을 거예요 그래서 이런 걸 기억이 안 날 때는 한 번씩 읽어 보면 되고요 어차피 지금 여기서 할 거니까 굳이 오늘은 문서를 읽으실 필요는 없지만 항상 문서 읽는 습관은 드리는 게 좋다라고 한 번 더 언급을 드리고 있는 거고 런타임의 주소 얻어오는 API를 여기서 호출해줘야 됩니다 근데 여기서 그 샘플을 보면 , 일단은, 잠시 더미로 소켓을 하나를 만들어 준 다음에 그 소켓을 대상으로 우리가 몇몇 함수들을 호출을 해줘야 됩니다 , 자, 그래가지고 그 부분을 일단 처리하기 위해서 여기 이어가지고 Static Socket Create Socket 이라고 해가지고 그냥 이미의 그런 TCP 소켓을 만드는 그런 함수를 만들어 줄 것이고요 어차피 소켓을 만들 일이 종종 생길 테니까 이걸 , 이렇게, 그냥 간단하게 하나 만들어 보고 그 다음에 이어가지고 Static Boolean Bind Windows Function 이라고 해가지고 소켓이랑 gid 그리고 lp void fn , 이렇게, 해가지고 어떤 보이드형 포인터 즉 포인터죠 지금은 어떤 함수 주소를 이제 받아주고 있습니다 네 , 이렇게, 해가지고 얘네 둘을 , 일단은, 만들어 보도록 할게요 , 자, 바인드 펑션도 만들어 줄 것이고 크레이트 소켓도 겸사겸사 같이 , 이렇게, 만들어 주도록 하겠습니다 Create Socket 같은 경우에는 뭐 , 사실, 여러가지 방법이 있겠지만 우리가 기존에 사용하던 Socket 만든 함수는 이 버전이었죠 Socket 뭐 이걸로도 만들어 줘도 되는데 , 사실, 윈도우즈 윈소그에서는 WS의 Socket이라는 함수가 있는데 Socket 얘를 이용하면은 조금 더 우리가 세분화 해가지고 옵션을 설정할 수가 있습니다 그래서 그냥 이걸로 만들어 주도록 할게요 af-inet sock-stream ip-proto-tcp 그 다음에 null 0 wsa-flag-overlapped , 자, 문서를 찾아보면 당연히 얘가 뭘 하는지는 나오는데 , 사실, 우리가 지난번에 사용했던 소켓이랑 별반 차이가 없습니다. 지금 단계로는 이 flag-overlapped를 켜주면은 우리가 사용했던 그 overlapped 계열의 비동기 함수들을 사용할 수 있게 되는데 , 사실, 우리가 지난번에 이걸로 안 만들었음에도 불구하고 뭐 똑같이 비동기 입출력 함수들을 사용했었죠 그건 왜 그러냐면은 기본적으로 윈속에서는 우리가 요 작은 소켓을 이용해가지고 소켓을 만들어도 사실상 얘가 기본적으로 설정이 되어있기 때문에 그렇게 동작을 하는 겁니다 뭐 그래가지고 얘를 그냥 , 이렇게, 리턴을 해줘가지고 어.. 이제 두번 다시 얘를 반복해서 만들지 않고 그냥 이 createSocket이라는 함수를 뿅 호출을 해줘가지고 이제 소켓을 만들어 주도록 하겠습니다 , 자, 그 다음에 여기 위에서 bind windows function 이라고 해가지고 , 일단은, byte 이런거 한 다음에 , 자, 이제 이 확장 포인터, 런타임에 이 아이들의 주소를 얻어오는 그런 함수입니다 그래가지고 얘가 하는거는 wsaioctl 이라는 요 함수를 이용해가지고 소켓을 넣어준 다음에 얘는 그냥 더미 소켓을 넣어주면 됩니다 그 다음에 sio.getExtensionFunctionPointer라는 굉장히 묘한 이런 옵션을 넣어주게 되구요. 그 다음에 여기다가는 GUID를 넘겨주면 되고 이어서 sizeof GUID를 넣어주고 그 다음에 이 해당 함수 function을 넣어주고 sizeof fn , 이렇게, 찍어주고 그 다음에 out bytes 에다가 마지막 인자는 널널로 넣어주면 됩니다 널널 , 자, 이게 좀 긴데 , 이렇게, 살펴보시면 되고요 이게 너무 길다 싶으면 두 줄로 나눠줘도 상관없습니다 저는 이왕이면 그냥 한 줄로 하는 걸 어디간에선 좋아하기 때문에 , 이렇게, 만들어 줄 것이고 이게 무엇을 하는지는 굳이 이해할 필요 없어요. 그냥 이 connect, disconnect, accept를 런타임에 불러오기 위한 그런 함수다라고 , 일단은, 이해해주시면 되고, 정 궁금하시면 문서를 찾아보시면 됩니다. 그 다음에 return을 할 때 socket error가 났는지만 , 이렇게, 체크를 해주도록 할게요. 너무 얘가 기니까 이 소켓 에러를 그냥 앞쪽에다가 놨습니다. 비교문을. , 이렇게, 해가지고 , 일단은, 요 함수를 사용해서 Bind Windows Function을 해가지고 요 아이들의 주소를 알아오게 되는데 그냥 사용하는 거는 요렇게 만들면 됩니다. , 일단은, 더미 소켓을 하나를 만들어 줄 거예요. 우리가 만들어준 Create Socket을 이용해가지고 그냥 빠르게 만들어 줄 것이고 그 다음에 Bind Window Function 이라는 걸 , 이렇게, 호출해 줄 건데 거미 소켓을 , 이렇게, 넣어주고 그 다음에 여기다가 GUID 위치에다가 우리가 찾아오고 싶은 그 함수를 이제 넣어주게 될 겁니다 WSAID Connect Extended 요 함수의 GUID가 이걸로 이제 우리가 접근을 할 수가 있어요 그 다음에 이어가지고 요 포인터를 이제 이쪽에다가 전달을 해줘야 됩니다 이 함수 포인터를 그래서 이걸 reinterpret 캐스트를 한 다음에 lpvoid 포인터로 바꿔주고 , 자, 요렇게 , 일단은, 이 위치에다가 어... 그 포인터가 함수의 주소를 여기다가 넣어달라고 요렇게 , 일단은, 만들어 주시면 되겠습니다 , 자, 이게 조금 헷갈리죠 요렇게 만들어 주고 그 다음에 얘가 실패했는지를 알기 위해서 assert crash를 한번 때려주도록 할게요 얘가 반드시 true여야 한다. 만약에 실패했으면은 뭐 이상한 상황일 거니까. 그 다음에 컨트롤 뒤로 두 번을 복사한 다음에 , 자, Connect, 그 다음에 Disconnect, 그 다음에 Accept , 이렇게, 세 개를 다 불러올 겁니다. 얘 같은 경우에는 뭐 ID가 Disconnect Extended라는 게 있고요. 얘 같은 경우에는 Accept Extended라는 게 있는데 , 이렇게, 세 번 각각 호출해 줘 가지고 각각의 주소를 여기다가 이제 불러오게 될 겁니다 그냥 , 이렇게, 사용하면 돼요 문자도 다 똑같이 이 wsa-ioctl 이라는 함수에다가 요 extension function pointer를 불러오겠다라는 옵션을 넣어 줘 가지고 되어 있습니다 뭐 그래서 , 이렇게, 만들어주면 되고 , 자, 그 다음에 여기서는 클리어 할 때는 그냥 wsa-cleanup 함수를 호출해 줘 가지고 원칙상 이 스타트업이랑 클린업의 개수가 맞아떨어져야 된다고 했었죠 이닛을 3번 하면 얘도 3번 해주고 근데 이거는 뭐 원칙상 그렇다는 거고 안한다고 뭐 큰 문제가 일어난 걸 본 적은 없습니다 네 그 다음에 이제 이어가지고 소켓을 만들어 줬는데 여기다 이제 소켓을 닫아 주긴 해야 되겠죠 , 자, 이것도 그냥 여러 가지를 이제 우리가 또 추가적으로 만들어 줄 건데 소켓을 닫아주는 함수 이런걸 , 이렇게, 오버 어... 한번 랩핑 해가지고 다 사용을 해주도록 할게요 , 자, 클로즈 그 다음에 이어가지고 스태틱 불리언 바인드나 리슨같은 함수도 그냥 우리가 랩핑한 요 함수를 이용해가지고 하도록 유도를 해줍시다 소켓에다가 나중에 만들어줄 요 어드레스를 맵핑을 해줄 것이고 , 자, 이 net address는 아직 설명을 안 드렸는데 이어서 만들 거니까 뭐 잠시 넘어가시면 되고 bind any address 소켓에다가 이미의 IP 주소를 그냥 바인딩 하겠다. 대신 포트는 설정하긴 해야되겠죠? , 자, 요 포트는 요렇게 지정을 해줄 것이고 그 다음에 이어가지고 Listen 암수도 , 이렇게, 랩핑을 해주도록 하겠습니다. Socket 그리고 Back Log도 설정할 수 있는데 기본값은 So Max Con으로 그냥 , 이렇게, 알아서 설정을 하게끔 유도를 해주도록 할게요. , 자, 그래가지고 얘네를 하나씩 만들어주도록 할건데 얘도 만들어주고 Bind Any Address도 만들어주고 Listen도 만들어줄 것이고 Close도 만들어줄 것이고 그래서 최종적으로 여기서 Create Socket을 한 다음에 클로즈를 해주도록 하겠습니다 이런식으로 그럼 이제 실질적으로 각각 함수들이 무엇을 해야되느냐 클로즈 소켓 같은 경우에는 뭐 굉장히 단순하죠 얘같은 경우에는 그냥 클로즈 소켓을 요렇게 때려주면 되겠습니다 그리고 이제 두번 닿지 않게 하기 위해서 소켓이 인벨리 소켓이 아닌지를 체크를 해서 클로즈 소켓을 한 다음에 그 다음에 원래 있던 클로즈 소켓에다가는 얘를 그냥 인벨리 소켓으로 , 이렇게, 넣어 줍시다 이거를 참조를 받아 줘 가지고 그냥 클로즈를 한 다음에 인벨리 소켓 상태로 바꿔 주도록 할게요 마치 우리가 포인터를 딜리트 한 다음에 널 포인터를 넣는 느낌으로 그냥 , 이렇게, 한번 만들어 봤습니다 , 자, 그 다음에 위에서 리슨 같은 경우에는 얘는 그냥 이런식으로 listen함수만 그대로 , 이렇게, 호출을 해주도록 할 것이고 그 다음에 이어가지고 bind any address 같은 경우에는 어떤 주소인건 상관없이 아무거나 bind를 해달라 라는 의미였으니까 속 address in을 , 일단은, 만들어 줄 것인데 , 자, 이거 우리가 많이 해본적이 있죠 address in family 같은 경우에는 먼저 AF-INET으로 해줄 것이고 그 다음에 SYN-ADDR-SADDR 같은 경우에는 아무거나 상관없다 host-to-network-long in-address-any 라는 거로 아무거나 연결을 해줘라고 우리가 바인드를 할 때 사용한 적이 있었죠 그거를 그대로 사용을 , 이렇게, 해줄 것이고 마지막으로 포트 같은 경우에는 host2-network-short-port를 , 이렇게, 만들어 준 다음에 즉, 이 sock-address-in을 만들어 준 다음에 bind를 때려가지고 이 socket을 대상으로 이제 이 my-address를 바인딩을 시켜주면 되겠죠. re-interpret-cast const sock-address의 포인터 형태로 얘를 , 이렇게,... 이거... my-address의 주소를 , 이렇게, 넘겨줄 것이고 그 다음에 두번째로는 size of my address를 , 이렇게, 넣어주시면 되겠습니다. bind 같은 경우에 실패하면 소켓 에러가 뜨기 때문에 얘도 마찬가지로 소켓 에러가 아닌지를 판별해가지고 성공 여부를 반환해 주도록 하겠습니다. 여기서 불리언으로 계속 뱉어주는 이유는 성공 여부를 계속 뱉어주기 위해서입니다. 그런데 매번마다 정확히 어떤 상황이 성공인지 모르니까 그냥 , 이렇게, 계속 랩핑을 해서 사용을 하고 있는 거예요. 참고로 클러스 같은 경우에는 얘는 없어도 되겠네요. 어차피 닫는 거니까. , 이렇게, 일단은, 만들어주도록 하겠습니다. , 자, 그리고 bind 위에 bind 같은 경우에는 net address를 먼저 만들어주고 돌아와야 되니까 잠시 스킵을 하도록 하고 일단 net address로 잠시 돌아가 보도록 할게요 얘가 하는 거는 뭐냐면은 , 사실, 뭐 굉장히 단순하고 굳이 사용해야 되는 건 없는데 이거입니다. 우리가 SockAddressIn 이라는 걸 이용해가지고 나중에 주소를 받아주겠죠. 그런데 나중에 이제 뭐 클라이언트들이 접속해가지고 우리가 나중에 서버를 운영하다 보면은 그 해당 클라이언트의 뭐 IP 주소라거나 이런 거를 우리가 추출을 해주고 싶을 경우가 있습니다. 그때 뭐 함수를 매번마다 부르기 보다는 모든 주소를 우리가 요 클래스로 관리해가지고 랩핑을 해서 사용한 다음에 편하게 설정을 하고 그리고 우리가 원하는 정보를 추출할 수 있게끔 유도를 해주도록 할게요. 그래서 얘도 뭐 간단하게 net address 라는 요런 클래스로 이제 만들어 줄 것이고 , 일단은, 기본 생성자 같은 경우에는 뭐 그냥 냅두도록 할 것이고 여기다가 여러가지 버전으로 얘를 만들 수 있게 유도를 해두도록 하겠습니다 요런 버전도 생성자를 만들어주고 IP랑 포트도 , 이렇게, 입력을 받아가지고 만드는 버전도 만들어 줄 것이고 다양하게 지원을 해주도록 할게요 그리고 이제 뭐 스트링을 사용할 것인지 더블 스트링을 사용할 것인지는 하나를 정해가지고 어지간해서는 통일하는게 훨씬 더 낫습니다. 너무 헷갈리기 때문이죠. 더블 스트링이랑 스트링 왔다갔다 하기보다는 이제는 무조건 W 캐릭터 형태로 우리가 서버에 있는 문자를 관리를 하도록 할 것이고 그 다음에 이어가지고 속 address in을 get 해줄 경우가 생길 수도 있으니까 get 속 address를 , 이렇게, 만들어 주도록 하겠습니다. return 속 address , 자, 그 다음에 get ip address 말 그대로 ip 주소를 반환하는 함수도 , 이렇게, 만들어 줄 것이고 그 다음에 포트 같은 경우에도 필요할 수 있겠죠 , 자, 포트든 이거는 바로 할 수 있는데 network-to-host-short를 한 다음에 속-address에 있는 이제 scene-port를 여기다가 , 이렇게, 넣어 줘 가지고 꺼내 주면 됐습니다 이거는 좀 비교적 간단하니까 그만 바로 해 주도록 하고 그 다음에 여기다가 뭐 기타 등등 필요한 그런 나머지 뭐 함수들을 여기다가 이제 넣어 주면 되겠죠 in-address 예를 들면은 ip 주소를 이용해 가지고 어 인어드레스로 반환하고 싶다 라거나 뭐 굉장히 다양한 그런 헬퍼 기능들을 여기다가 일단 넣어 주도록 할게요 나중에 가면 뭐 dns 서버를 운영한다고 하면은 뭐 어떤 호스트 주소 예를 들면 www.naver.com 을 이제 ip 주소로 환산한다거나 하는 그런 기능들도 여기다가 이제 뭐 넣어 주면 되겠죠 이제 필요에 따라 가지고 이걸 확장해서 사용을 할 예정입니다 , 이렇게, 해서 NetAddress 클래스를 이어가지고 간단하게 채워보자면 , 일단은, 이 생성자부터 하나씩 만들어주면 되겠죠 그 다음에 두번째 생성자도 만들어줄 것이고 GetIPAddress도 만들어줄 것이고 얘도 , 일단은, 이렇게, 만들어주고 사실은 뭐 대단한 기능은 하는 건 아니고 우리가 편하게 사용하기 위해서 Network 주소라는 클래스를 , 이렇게, 만들어줘서 사용하고 있다고 보시면 되겠습니다 처음에 그냥 속어드레스인을 막바로 우리가 넣어준 경우에는 그냥 얘를 그대로 사용할 것이니까 뭐 딱히 많이 해줄 건 없고 , 이렇게, 그냥 받아주고 끝내면 될 것이고 그 다음에 ip랑 포트를 받아왔으면 , 자, 이제는 어떻게 할 거냐면 일단 맵셋을 해가지고 속어드레스를 , 일단은, 한번 밀어 주도록 할게요 sizeof 속어드레스 그 다음에 속어드레스의 s in family 같은 경우에는 af-inet으로 만들어주고 그 다음에 address 같은 경우에는 ip to address 함수를 호출해가지고 , 이렇게, 호출을 해주도록 하겠습니다. 이 함수는 우리가 여기서 아래서 만들어주는 그 함수를 얘기하고 있는 겁니다. 그 다음에 마지막으로 port 같은 경우에는 host2.network.short 한 다음에 포트를 , 이렇게, 넣어주는 건 많이 해봤죠? 그래서 , 이렇게, 그냥 설정을 해서 알아서 들어가게 만들어주면 되고요. , 자, 그 다음에 이 ip를 받아서 in address를 만들어주는 함수도 여기서 정의를 해주도록 합시다. 얘네 이제 종종 필요하게 될 수도 있으니까 , 이렇게, 별도의 함수로 빼서 만들어줬고요. inet p2nw라는 걸 이용해가지고 만들면 되고요. 이게 w 캐릭터이기 때문에 w가 붙는 거고. 뭐 이런 건 당연한 얘기지만 외울 필요는 없고 인터넷에 찾아보면 다 나오는 얘기입니다. 어쩌다가 한 번 만들게 되는 거니까 당연히 외울 필요 없어요. 그래서 , 이렇게, 해가지고 추출을 한 다음에 이 어드렛을 복사해가지고 그냥 밖으로 리턴을 해주도록 할게요. 그럼 이런 식으로 우리가 w스팅으로 넣어준 거를 이 in address 형태로 추출해가지고 다시 이제 반환을 해주게 될 겁니다 마지막으로 get ip address 같은 경우에는 inet n2pw라는 요 함수를 이제 이용을 해줄 것인데 ef inet이랑 그 다음에 속 address의 sin address를 넣어주면 되구요 그 다음에 여기다가 이제 잠시 버퍼를 넣어 줘 가지고 한 100바이트 충분하게 버퍼를 만들어 준 다음에 , 자, 여기다가 이제 버프 사이즈를 넣어 줘야 됩니다 뭐 이런 식으로 그 다음에 return w-sting으로 바꿔 가지고 이제 이 버퍼에 있는 내용을 w-sting으로 넣어 주면 되는데 , 이렇게, 100바이트인데 100을 똑같이 넣어 줘도 되지만 이걸 뭐 예를 들면 sizeof 같은 거로 이런 식으로 우리가 종종 만들어 준 적이 있습니다 근데 여기서 하나 조심해야 될 거는 이제 앞으로도 종종 이런 상태가 등장하겠지만 얘가 지금 살짝 문제가 있어요 sizeof은 말 그대로 이 버퍼 배열의 크기를 나타내고 있는데 w 캐릭터가 2바이트다 보니까 얘가 지금 100 곱하기 2 즉 200으로 뜨게 될 겁니다 정확하게 우리가 원하는 100이란 숫자가 아니죠 그래서 보통 이런 경우에 sizeof 버퍼에다가 sizeof w 캐릭터로 나눠준다거나 하는 식으로 우리가 이 개수를 추출하게 되는데 이제 이거를 뭐 종종 사용할 일이 생기기 때문에 요렇게 매번 마다 위험하게 코드를 작성하기보다는 이거를 그냥 매크로를 하나 만들어 주도록 할게요 그래서 타입 쪽에 돌아가 가지고 이전에 들어간 다음에 어 이제 앞으로 종종 사용하게 될 그럼 몇 가지를 만들어 볼 건데 , 일단은, 사이즈 16 얘는 뭐 굉장히 단순하게 int16으로 sizeof를 한 다음에 그냥 캐스팅을 해주는 역할을 해주게 될 것이고 size32는 똑같은데 얘를 size32로 캐스팅해주는 것이고 그 다음에 length라는 거를 이제 두 개를 만들어 줄 건데 여기다가 어떤 배열을 우리가 받아줄 것이고 static cast int16 그 다음에 sizeof array에다가 sizeof array의 0번 정보를 우리가 사이즈 오브 해 줘 가지고 뱉어 주겠다라고 하면 사실상 우리가 지금 여기서 만들어 준 게 매크로로 , 이렇게, 만들어지게 됩니다 그래서 Length 32는 똑같은데 Int 32로 뱉어주는 경우를 , 이렇게, 각각 만들어주도록 할게요. 그럼 이제 앞으로 우리가 뭐 요런 기능이 필요하다 싶으면은 , 이렇게, 길게 만들기보다 Length 32를 해가지고 버퍼를 그대로 , 이렇게, 넣어주면 되겠습니다. 이런 형태로 , 일단은, 간단하게 코드를 만들어 봤고요. , 자, 그 다음에 여기서 지금 에러가 뜨는... 아, 이거 땡땡이는 없애줘야 되고요. 얘가 항상 마지막에 등장한다는 보정은 없으니까 , 자, 그 다음에 이제 이어가지고 대충 보면은 이제 net address가 어떤 역할을 하시는지 알겠죠 그냥 이거를 편하게 사용하기 위해서 얘를 이제 만들어 준 것이고 그렇게 어마어마한 기능은 하는 건 아니니까 다시 이제 이어가지고 소켓 유틸 쪽으로 돌아가 보도록 할게요 그럼 소켓 유틸에서 우리가 하던 걸 계속 하자면 어디까지 했었죠? 여기 바인드를 하는데 net address를 건네줘가지고 우리가 지정한 이 클래스를 지금 넘겨줘가지고 여기서 이제 바인딩을 호출하고 있는데 얘는 이제 무엇을 해야 되냐면 소켓 에러랑 다른지를 체크한 다음에 바인드를 똑같이 해줄 것인데 여기다가 reinterpret cast를 해줘서 속 address 포인터를 똑같이 꺼내줄 것인데 net address에서 이제 여기서 주소를 꺼내와야 되죠 cat socket 속 address를 , 이렇게, 꺼내오도록 하겠습니다 여기다가 포인터로 , 이렇게, 비트어주면 될 것이고 sizeof 속 address in으로 , 이렇게, 일단은, 코드를 만들어 줄게요 그래서 우리가 넘겨준 네트워크 어드레스랑 바인딩을 할 때도 이런 식으로 만들어 주면 되겠습니다 그래서 일단 , 이렇게, 라이브러리가 계속 조금씩 조금씩 쌓여 나가고 있고요 그 다음에 Bind Window Function Create Socket , 자, 그 다음에 이제 할 거는 뭐냐면은 우리가 중간에 알아본 것 중에서 Set Socket 옵션을 이용해가지고 막 이런저런 정보들을 막 세팅을 해줬었죠 소켓에 대한 정보를 근데 그런 것도 매번마다 함수를 외워서 하기보다는 여기서 랩핑을 해가지고 여기 있는 소켓 유틸이 있는 함수를 사용할 수 있게끔 유도를 해주도록 할게요 근데 Set Socket 옵션을 이제 굉장히 반복해서 사용할 것인데 걔가 사용하는 방법이 굉장히 비슷했기 때문에 , 일단은, 여기다가 템플릿을 하나 만들어줄 것인데 static inline bool setSocketOption도 랩핑을 해주도록 하겠습니다 어떤 대상 소켓을 받아주고 레벨을 받아준 다음에 그 다음에 여기서 int32로 옵션 이름을 받아줄 것이고 마지막에 옵션 밸류를 각각 받아주도록 하겠습니다 얘가 하는 거는 굉장히 단순한데 setSocketOption 함수를 호출해 주면서 소켓과 레벨과 옵션 네임을 받아 줄 것이고 그 다음에 reinterpretCast 캐릭터 포인터로 바꿔 주면서 옵션 밸류에 주소값을 , 이렇게, 넣어 줄 것이고 마지막으로 Size of T로 , 이렇게, 해주면 되겠습니다 Set Socket Option 오랜만에 등장해서 까먹으셨을 수 있는데 항상 이런 식으로 우리가 사용을 했었습니다 여기다가 레벨이랑 옵션 네임을 정해주고 이제 이 마지막에 넣는 값이 불리언이 될 수도 있고 뭐 인트가 될 수도 있고 다른 구조체가 될 수도 있었죠 그거를 좀 이제 광범위하게 사용하기 위해서 , 이렇게, 템플릿으로 , 일단은, 만들어 준 겁니다 그래서 이제 나머지 함수들은 이 Set Socket Option 이라는 걸 잘 호출하면 될 것이고 오늘 우리가 뭐 만들거는 지난번에 알아봤던 그 주요 기능들을 다 만들어주도록 할게요 setRinger uint62 on off를 받아주고 linger 값도 , 이렇게, 받아주는 , 자, 요런 함수를 만들어 줄 것이고 그 다음에 링거 말고 또 뭐 있었냐면은 자주 사용하는 거 setReuseAddress 똑같은 그 주소랑 포트를 재사용할 수 있겠다 재사용하겠다 라는게 있었죠 얘도 , 이렇게, 만들어 줄 것이고 그 다음에 setReceiveBufferSize 이건 뭐 설명할 필요 없죠 너무 중요한 거였고 어떤 사이즈로 만들어주는 거 그리고 이어서 샌드 버퍼 사이즈 소켓 인트 사이즈 그 다음에 또 중요한거 네이글 알고리즘 기억하시는지 모르겠는데 set tcp no delay 얘도 이제 꼭 설정해야 되는 애니까 똑같이 요렇게 라이브러리에 넣어주도록 할게요 그리고 이제 앞으로 뭐 새로 사용하고 싶은게 있으면 여기다가 계속 넣어주면 되겠죠 지난번에 알아보지 않았지만 오늘 하나만 더 추가할 것은 update accept socket 이라는 요런 함수를 만들어 줄게요 이제 이 내용은 조금 있다가 등장할 것이고 listen socket , 자, 요렇게 , 일단은, 주로 사용할 만한 것을 각각 만들어주도록 할게요. 그리고 구현부를 각각 추가를 해줄 것이고, 얘도 추가를 해주고, 추가, 추가. 네, 각각 추가를 , 이렇게, 해줬습니다. 그럼 이제 돌아가가지고 이제 이쪽에다가 만들어 줄 것인데 우선 링거 같은 경우부터 시작을 하면은 여기다가 우리가 링거 옵션을 넣어 줬었죠 이 링거라는 걸 만들어 줘 가지고 L on off 를 그대로 세팅을 해주고 그 다음에 linger 값도 세팅을 해 줘 가지고 , 이렇게, 넘겨 준 다음에 실제고 리턴하는 값은 setSocketOption을 그대로 다시 불러 가지고 socketSOlinger 그 다음에 옵션을 , 이렇게, 넣어 주면 되겠습니다. 요런 식으로 , 일단은, 이 setSocketOption을 활용을 하는 거예요. 그래서 reuse address 같은 경우에는 이제 요 부분이 SO reuse reuse address 이 아이로 바꿔주면 되고 여기다가 flag 를 , 이렇게, 넣어주면 되겠고 그 다음에 receive buffer 사이즈를 수정하고 싶다라고 하면은 so receive buffer 라는게 있었죠 요 버전이었는데 이거 RCV 버프 여기다가 사이즈를 넣어주면 될 것이고 샌드버퍼 사이즈를 만약에 고치고 싶다 라고 하면은 여기다가 SND 버프로 바꿔치기 해주면 되고 NO DELAY 네이글 알고리즘 설정하는 거는 TCP NO DELAY 라는 게 있었죠 그래서 FLAG 를 넣어 줄 것이고 마지막으로 ACCEPT SOCKET 이라는 것도 비슷하게 , 이렇게, 넣어 주는데 얘 같은 경우는 SO SO Update Accept Socket 이라는게 있습니다. 여기다가 Listen Socket을 , 이렇게, 넣어주면 되고 얘는 참고로 뭘 하는 거냐면은 Listen Socket의 특성을 우리가 처음 인재로 넣어준 사실상 클라이언트 소켓에 그대로 적용한다는 옵션입니다. 이것도 궁금하시면 한번 찾아보면 도움이 되요. 그래가지고 이제 자주 사용할 애들을 , 이렇게, 일단은, 쭉 만들어 봤습니다. 또 더이상 고칠 거 없나 살짝 살펴봤는데 없을 것 같구요. 그래가지고 이제 앞으로 만약에 우리가 이제 이 라이브러리를 이용해가지고 소켓을 만든다라고 하면은 대충 이런 식으로 만들 수가 있겠죠? 여기다가 소켓 유틸을 추가한 다음에 뭐 예를 들면 소켓을 만들 때 소켓 유틸즈에서 크레이트 소켓을 빵 때려주고 그 다음에 소켓 유틸즈의 바인드 애니 어드레스를 호출해가지고 소켓에다가 7777로 연결해달라고 한 다음에 그 다음에 리슨을 빵 때려주고 그 다음에 이어서 Accept는 아직 딱히 안만들었는데 얘같은 경우에는 왜 Wrapping을 하지 않았느냐 얘는 어차피 우리가 새로 여기서 받아준 Accept Extended를 이용해가지고 우리가 Accept를 해줄겁니다 근데 얘같은 경우에는 바로 사용하는게 아니라 이제 우리가 그 IoCP를 만들어가지고 걔랑 연동시켜서 사용할 것이기 때문에 얘는 바로 사용을 우리가 안 할 거에요 지금은 근데 단지 초기화가 될 때 이 주소들이 정상적으로 들어가는지만 오늘은 테스트를 할 겁니다 그래가지고 여기다가 뭐 그냥 간단하게 클라이언트 커넥티드 로그가 잘 뜨는지만 살펴보도록 하고 얘는 받아주도록 할게요 클라이언트 소켓 , 자, 그 다음에 이어가지고 이 이니시랑 클리어가 어디선가는 호출이 돼야 되겠죠 얘가 소켓 초기화하고 런타임에 우리가 사용할 요 삼총사들을 얻어오는 그런 하임스였고 클리어는 말 그대로 그냥 날리는 작업이었는데 얘를 이제 어디서 할까가 좀 고민이긴 한데 굳이 우리가 게임 서버 쪽에서 하기보다는 우리가 전역으로 사용하는 코어 글로벌 쪽에다가 여기다가 낑겨 넣어 주도록 할게요 그래가지고 이제 위에다가 Include Socket Utils를 추가해준 다음에 대충 한 이쯤에다가 Socket Utils를 초기화하는 부분을 호출해줘가지고 사실상 윈속을 초기화를 여기서 해준 다음에 날릴 때는 Socket Utils의 Clear를 여기서 호출해주도록 할게요 그래서 이제 짝을 맞춰가지고 한 번씩 호출을 해주도록 하겠습니다 , 자, 서버콜을 빌드해줘가지고 뭐 딱히 오타를 냈는지 아니면 문제가 있는지를 확인해보고 , 일단은, 없으니까 실행을 해가지고 서버도 빌드를 한 다음에 클라이언트 커넥티드가 정상적으로 뜨는지를 보고 마치도록 하겠습니다. 그래서 , 일단은, 이렇게, 실행을 해보면 커넥티드2 서버가 정상적으로 뜨고 여기서 지금 얘가 바로 끝나가지고 그런 거니까 무한 루프를 돌아주도록 할게요. 그래서 , 이렇게, 해가지고 , 일단은, 다시 한번 호출을 해주면 게임 서버에서 클라이언트 커넥티드가 뜨고 , 이렇게, 멈춰있는 걸 볼 수가 있습니다. 그래서 우리가 만든 그런 유티를 이용해가지고 지금 , 이렇게, 작업을 하고 있는 거고 저는 유니티도 마찬가지지만 서버 측도 어지간해서는 이런식으로 함수들을 랩핑해서 사용하는걸 선호합니다 어차피 얘네들을 엄청 자주 사용할건 아니지만 인자들을 일일이 외워서 하는것보다 정말 꼭 우리가 설정해야하는 인자들만 밖으로 빼놓고 나머지들은 , 이렇게, 한번씩 문서를 보면서 만들어주면 나중에 사용하기가 굉장히 편하기 때문이죠 , 이렇게, 해서 간단하게 사용할 소켓 유틸부터 만들어 봤구요 이걸 먼저 만든 이유는 뭐냐면 다음 시간에는 굉장히 또 클래스가 많이 등장하게 될 겁니다 이제 IoCP 핵심이 되는 클래스를 만든 다음에 그 다음에 걔를 등록하기 위해서 일단 리스너를 만들어 줄 것이고 등등 여러 가지 클래스들이 동시다발적으로 등장하는데 동시다발적으로 등장하는 와중에 이런 자잘한 부분까지 같이 다루면 너무 머리가 아프니까 , 일단은, 가장 독립적이고 간단한 애부터 , 일단은, 이렇게, 두 개를 만들어 봤어요 별다른 내용은 아니었습니다 , 자, 이어서 다음 시간 부터 이제 진짜로 넘어가도록 할 테니까 심호흡을 하시고 넘어오시면 되겠습니다 아 그리고 한가지만 더 덧붙이자면 지금 보면은 우리가 여기 소켓 유틸 이니트 하는 부분에서 얘가 이제 실행이 되어 가지고 얘가 초교화가 되고 있는지가 굉장히 궁금한데 지금 요렇게만 만들어 주게 되면은 어 그 초교하는 부분이 호출이 안되더라구요 이게 이제 컴파일러 버전에 따라 가지고 조금 다르긴 한데 코어 글로벌에서 얘를 만들어주는 것 자체를 만약에 우리가 여기 있는 코드들을 아예 사용을 안 할 거면 컴퓨터가 굉장히 똑똑하게 얘네들을 아예 호출도 안 합니다. 얘를 만들어주지도 않더라구요. 그러다 보니까 여기서 그냥 간단하게 G-thread 매니저 조인만 그냥 , 이렇게, 강제로 호출을 해주도록 할게요. 그 다음에 다시 빌드를 해주고 이제 어 소켓 유틸 쪽에 돌아가 가지고 여기 처음에 초기화 되는 부분에서 여기다가 브레이크 폰들을 잡아가지고 한번 실행을 해보도록 하겠습니다. 그러면은 딱 여기서 breakpoint가 잡히는 걸 볼 수가 있구요. 그 다음에 connect랑 disconnect, accept extended가 정상적으로 다 주소를 찾아가지고 얘가 , 이렇게, 연동이 되어 있다는 걸 볼 수가 있습니다. 그럼 앞으로 우리는 이제 이 함수를 호출하고 싶으면은 그냥 말 그대로 connect-ex 라는 거에다가 이런 식으로 호출을 하는 식으로 , 이렇게, 그냥 호출해주면 돼요. 그러니까 사실상 함수 주소를 여기다가 , 이렇게, 연결을 시켜준 것이기 때문에 얘를 그냥 그대로 , 이렇게, Connect Extended를 호출을 해주는 식으로 이제 동작을 시킬 수가 있습니다. 그래가지고 이 부분을 잠시 빼먹은 것 같아가지고 추가 언급을 드리고 이제 앞으로 얘네 삼총사도 사용할 준비가 되었다라는 걸 일단 알 수가 있는 겁니다. , 자, 이렇게, 해가지고 진짜 진짜 다음 순간부터 중요한 내용으로 이제 넘어가도록 할게요.