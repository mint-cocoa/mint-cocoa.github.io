우리가 지난 시간까지 열심히 작업을 해가지고 그나마 데이터베이스 연동을 좀 편리하게 하기 위한 일단 준비작업을 다 끝내놨습니다 만약에 개인 프로젝트를 만든다고 하면 그냥 이 정도로도 충분하고 넘친다고 , 일단은, 볼 수가 있겠어요 그런데 더 한 발짝 더 나아가 가지고 만약에 진지하게 여러분들이 큰 프로젝트에서 작업을 한다거나 아니면 이제 게임이 출시된 다음에 라이브까지 병행한다고 생각을 하면 여기에다가 추가적으로 생각할 게 조금 더 많아집니다 특히나 이제 버전 관리를 어떻게 할 것인가가 굉장히 큰 문제가 돼요 버전 관리. 제가 버전 관리 시스템에 대해서는 딱히 설명을 드린 적이 없는데 이거는 워낙 자료도 많고 구글에 찾아보면 나오는 내용이 굉장히 많기 때문에 이 부분은 딱히 언급을 한 적이 없기는 하지만 관리 시스템이란 것 자체가 이런 걸 말하는 겁니다. 예를 들면 저는 지금 Git을 사용하고 있는데 이런 식으로 코드를 작업할 때마다 그거를 이제 코드를 , 이렇게, 올려가지고 일종의 세이프 포인트를 만든다고 생각하시면 돼요 이거 처음 보시면은 뭐 Git 사용법 이런거 검색해보시면 많이 나옵니다 그래가지고 이제 이런식으로 작업을 하면은 굉장히 큰 장점이 생기는게 만약에 내가 뭐 작업을 하다가 과거로 돌아가고 싶다 요 버전으로 돌아가고 싶다고 하면은 그냥 모든 버전 관리 툴에서 그냥 이 버전으로 돌아갈 수 있게끔 작업을 할 수가 있습니다 그니까 말 그대로 진짜 게임에서 세이프 포인트라고 생각하시면 돼요 그냥 요게 이 시점으로 정확하게 돌아가겠다 그럼 내가 지금 이 시점에서 무엇이 바뀌었는지도 , 이렇게, 체크를 할 수 있고 이 버전에서 이어서 작업을 하면 된다는건데 이게 이제 왜 라이브에서는 중요하냐면은 라이브로 나가게 되면은 항상 최신 버전을 우리가 배포하는게 아닙니다 한번 이제 안정화되어가지고 버그가 어느정도 수정이 되면은 그거를 이제 라이브로 우리가 내보낸 다음에 그 다음에 다음 컨텐츠를 우리가 이어서 작업을 하게 될겁니다 예를 들면 지금 여기 잡큐 1번까지가 뭐 어떤 라이브 버전 1.01이라고 했으면은 만약에 이제 1.01 버전에서 뭔가 버그가 났다고 하면은 여기서 고치면 되는게 아니라 요 버전으로 돌아가가지고 어 이걸 스트림을 따로 딴다고 하는데 어찌되건 요 버전에 해당하는 그 코드에서 이제 걔를 고쳐준 다음에 다시 뭐 배포를 해야 되겠습니다 뭐 그런식으로 버전 관리가 필요하다. 특히나 많은 사람들이 작업하는 프로젝트에서는 여러분들이 혼자 작업하는 거에서는 다른 사람이 안 건드리는 보정이 있으니까 편하게 할 수 있겠지만 만약에 프로그래머가 10명, 20명에서 동시에 다발적으로 같은 소스를 건드린다고 하면 남이 건드린 것 때문에 내 소스가 깨진다거나 하는 일이 비일비재하게 발생할 수밖에 없습니다. 그래가지고 그런 버전 관리 툴을 이용해가지고 선빵으로, 선빵 필승이라고 하는데 그 버전관리 툴에 먼저 커밋하는 사람이 , 일단은, 승리자입니다. 나머지 사람들은 그거에 맞게 코드를 고쳐야 되고요. 근데 어찌 됐건 이런 소스코드 같은 경우에는 뭐 그런 툴이 굉장히 많이 존재하기 때문에 뭐 그렇게 크게 어려운 부분이 없어요. 그냥 잘 관리를 해주면 되고 만약에 과거로 돌아가야 된다고 하면 그냥 그 버전에 맞는 쪽으로 돌아가서 그 코드에 대해서 버그를 수정하면 된다는 얘기가 되는 거죠 그런데 데이터베이스가 들어가기 시작하면 이 부분이 굉장히 애매해집니다 왜냐하면 사실은 우리가 지금 여기 DBA에서 어떤 정보가 , 이렇게, 들어가 있기는 하지만 이거 자체를 우리가 지금 버전 관리로 넣어주지는 않았기 때문이죠 근데 매번마다 이런식으로 서버를 띄울때마다 기존에 있던 정보를 드랍한 다음에 다시 테이블을 만드는거는 이건 그냥 간단하게 테스트하니까 가능한거지 이건 말도 안되는 소리입니다 왜냐면은 나중에 라이브로 또 게임이 나가게 되면은 이미 이 테이블에 굉장히 중요한 정보가 많이 들어있을수가 있겠죠 유저들에 대한 정보도 있을거고 유저가 지금껏 모아놓은 골드라거나 아니면 뭐 엄청 비싼 아이템도 다 포함이 되어있을텐데 매 버전마다 그거를 쿨하게 날리고 다시 디비를 테이블에 생성하는건 당연히 말도 안됩니다. 그러면은 결국에는 어떤식으로든 결국 이제 어떤 식으로건 내가 지금 작업하고 있는 소스 코드랑 DB 버전을 맞춰줄 필요가 있다는 얘기가 되는 건데 이걸 만약에 그냥 ORM 기술을 사용한다고 하면 이런 부분을 다 알아서 처리해줍니다. 예를 들면 우리가 C샵, 예전에 C샵 시리즈에서는 Entity Framework Core라는 ORM을 이용했었고 거기서 이제 DB 관리도 어느 정도 같이 해주기 때문에 , 자, 요런식으로 지금 마이그레이션 파일이 만들어졌어요. up, down 요 버전으로 만약에 넘어간다 적용을 시켜준다고 하면은 이런 account라는 테이블을 만들어줘야 되고 그 다음에 account 테이블을 만들어줄 때는 index를 어떻게 걸어줘야 된다라고 친절하게 지금 설명이 나와있고 이제 이 코드에 의해 가지고 db가 알아서 만들어주게 될 겁니다. 거꾸로 만약에 버전을 내린다고 가정을 하면은 이제 여기서 만들어 줬던 테이블은 필요가 없으니까 Drop Table Account, Account 테이블을 날려줘라 라고 , 이렇게, 들어가 있는 걸 볼 수 있습니다. 이걸 이제 Migration이라고 하는 거죠. 그래가지고 버전을 왔다 갔다 할 수 있게끔 뭔가 이미 다 준비가 되어 있고 우린 이제 이 소스 코드 상에서 이게 지금 관리가 되어있기 때문에 이것도 이제 같이 우리 버전 컨트롤 툴을 이용해가지고 관리를 해주게 되면은 알아서 소스코드랑 DB 버전도 쉽게 맞춰줄 수 있다라는 결론을 내릴 수가 있는 건데 지금 이런 식으로 ODBS를 이용해가지고 직접적으로 우리가 쿼리를 날리는 경우라고 한다면 이제 이런 부분을 어떻게 처리해줄까가 굉장히 골치 아픈 일이 된다는 거죠 만약에 DB 버전이랑 소스코드 버전이랑 안 맞다고 하면은 예를 들면 여기 테이블에서는 아이디랑 골드만 들어가 있을 텐데 예를 들면 우리가 처음에는 네임 크레이트 데이트를 안 넣고 아이디랑 골드만으로 테스트를 했었죠 그런데 막상 여기 내보내는 쿼리에서는 이미 이 테이블이 네임이랑 데이트까지 있을 거로 만약에 예상을 해가지고 커리를 날린다고 하면 당연히 문제가 일어날 수 밖에 없습니다 이런 부분들이 굉장히 골치 아프다는 거죠 그래서 결과적으로 뭐 이런 부분들에 대해서 고민이 필요한데 뭐 , 일단은, 제가 여러모로 알아본 바에 의하면 일단 두 가지 스타일이 있어요 첫번째는 뭐냐면은 , 자, 예를 들면은 여기다가 메인에다가 db라는 폴더를 만들어 준 다음에 여기다가 진짜 우리가 아까 본 그 업과 다운 같은 느낌을 느낌의 파일을 진짜 손수 관리를 하는 겁니다 그래서 이제 이건 보통 이제 dba라는 직군분이 담당해서 해주시게 될텐데 뭐 예를 들면은 그냥 아무거나 한번 만들어 볼게요 db01.sql 이라고 해가지고 이게 첫번째 버전의 db 파일이다라고 , 일단은, 가정을 하면은 첫번째 버전에서 , 일단은, 해야되는 행동들을 다 넣어주게 되는 겁니다 예를 들면은 우리가 지금 여기 오른쪽에서 만들어준 요 아이라고 만약에 가정하면은 , 자, 골드라는 테이블을 요렇게 만들어줘야 된다라는 걸 넣어주면 되겠죠 요런 느낌으로 그리고 , 이렇게, 밀어주고 , 자, 이렇게, 골드라는 테이블을 넣어주면 되겠다 그리고 이제 필연적으로 이런식으로 dbo. 버전 관리하는 테이블도 하나를 뚫어줘가지고 db에다가 현재 db 버전이 몇 번인지도 , 이렇게, 따로 기록을 해줄 겁니다 뭐 이런 느낌으로 그래서 이제 이런 식으로 계속 늘리게 되는 거죠 그래서 만약에 다음 버전이 또 필요하다 DB에 뭔가 바뀜이 있었다라고 하면은 DBA가 또 이런 저런 쿼리들을 쿼리들이나 아니면 테이블 같은 걸 추가하는 걸 만들어 준 다음에 그걸 또 별도의 파일로 또 이런 식으로 DB 버전 0, 2 이런 느낌으로 계속 숫자를 늘려가면서 관리를 해주는 겁니다 그러면 우리가 소스 코드에서 이제 서버를 띄울 때 서버도 일종의 컨피그 파일을 항상 들고 있습니다 뭐 이런 db 커넥션 스트링 뿐만 아니라 서버 포트 뭐 ip 등등 온갖 정보들을 다 이제 보통 컨피그 파일로 따로 빼 가지고 관리를 하는데 거기에다가 현재 서버가 연동해야 되는 DB 버전도 같이 기입을 하는 거죠 현재 버전 DB 버전은 2번이다 그래서 현재 요구하는 DB 버전이 2번인데 지금 막상 DB를 접근해서 이 버전을 체크해보니까 1번때라고 하면은 뭔가 아드리가 안맞네 버전이 안맞네 라고 해가지고 그냥 띄우지도 않고 바로 크래쉬를 내버린다는 거죠 요런 식으로 , 일단은, 버전을 맞춰주는 방법이 한가지가 있어요 그래서 뭐 지금 간단하게 있으니까 테이블만 만들어 놨지만 나중에 가면 요런 퀄이들 같은 것도 다 여기 내부에다가 다 , 이렇게, 만들어 줘야 됩니다 뭐 그건 그렇고 , 이렇게, 뭐 버전 관리를 손수 하는 게 이제 뭐 나쁘다는 건 아닌데 일단 굉장히 귀찮습니다 어 아까 업다운만 봐도 1번에서 2번으로 넘어갈 때랑 2번에서 1번으로 다운그리드 할 때랑 등등에 대한 처리를 다 , 일단은, 만들어 줘야 되겠죠 만약에 거꾸로 1번을 날린다고 하면 크레이트 테이블이 아니라 드랍 테이블로 뭔가를 만들어줘야 될 테고 이런 식으로 스크립트를 만들어줄 게 굉장히 많이 필요하다 보니까 뭐 전문적인 DBA가 있고 DBA가 그걸 담당해서 다 해주는 프로젝트라고 하면 상관 없겠지만 어떤 프로젝트는 그냥 서버 직군 프로그래머가 DB까지 일단 같이 설계하고 관리하는 곳도 덜어 있습니다 그게 컨텐츠 개발이 좀 더 빠르기 때문이죠. 그런 경우라고 한다면 , 사실, 이런 식으로 버전 관리를 하는 거는 굉장히 귀찮은 일이 될 겁니다. 서론이 길었는데 오늘부터 알아볼 것은 뭐냐면 제가 이전에 있던 프로젝트에서 굉장히 감명 깊게 봤던 방식이 하나가 있는데 이 일종의 아주 간단한 ORM을 직접 만드는 겁니다. 그래가지고 db 원본 설계는 xml 파일로 관리를 한 다음에 그걸 자동화 툴을 빵 때려가지고 이용해서 만들어주면은 뭐 요런 바인드 같은 계열의 클래스들도 자동 생성이 될 뿐만 아니라 이제 db 버전 관리도 쉽게 업데이트나 뭐 그런 업데이트 해줄 수 있는 그런 스크립트까지 갖춰서 자동으로 딱 생성이 되는 뭐 그런 부분을 일단 만들어놨어요 그래서 그런 부분에 대해서 간단하게 일단 실습을 해볼 건데 좀 갈 길이 멀긴 합니다. 이것저것 만들어줘야 될 게 많아요. 그래가지고 , 일단은, 새 항목에 가가지고 웹 쪽에 XML 하나를 만들어 줄 건데 게임 DB라고 , 일단은, 만들어 주도록 할게요. 그리고 여기 SQL 파일은 필요 없으니까 , 일단은, 삭제를 해 주도록 하겠습니다. 얘는 그냥 테스트 삼아서 보여드린 거고 여기서 이제 우리의 데이터베이스를 일단 설계를 시작을 해 볼 거예요. 근데 지금 뭘 만들어 볼까 하다가 그냥 이전에 만들었던 이 골드 테이블을 그냥 그대로 옮겨 가지고 한번 만들어 보도록 합시다 , 일단은, 이런 식으로 루트 루트를 만들어 주고요 루트 노드가 게임 디비가 될 것이고 그 다음에 내부적으로 이제 데이터베이스를 설계하는 겁니다 지금 이런 테이블 하나가 있죠 테이블이 들어가 있는데 테이블이 , 이렇게, 있고 그 다음에 이 테이블은 이름은 테이블 이름은 골드라는 이름으로 우리가 지어놨고요 그 다음에 여기 테이블 내부에서는 뭐가 있나요? 여기 컬럼이 , 일단은, 4개가 들어가 있다는 걸 볼 수가 있습니다. 그래서 컬럼을 , 이렇게, 하나씩 하나씩 만들어 줄 거예요. 컬럼 , 자, 이렇게, 한 줄 자리로 만들어주고 4개를 만들어 준 다음에 이 컬럼의 첫번째는 이름이 id고 type은 int not null은 true 뭐 이런식으로 , 일단은, 묘사를 해줄수가 있겠죠 두번째는 name은 gold 그 다음에 type은 type은 int 그리고 not null은 false 이런식으로 만들어주면 되겠고 세번째는 이름은 name이 name이네요 이름은 그냥 이름이고 type은 n bar 차 50 그리고 not null은 false 뭐 요렇게 일단 되겠습니다 마지막으로 name은 create date type은 date time 그 다음에 not null은 false 이런 식으로 지금 묘사를 해주고 있어요 그 다음에 여기서 이제 인덱스가 지금 프라이머리키 인덱스가 하나가 걸려있죠 그러니까 인덱스도 여기다가 , 이렇게, 설계를 해주도록 하겠습니다 인덱스가 있는데 인덱스 타입은 클러스터드다 프라이머리키니까 일단 클러스터드로 인정을 해줄거고 그 다음에 얘는 프라이머리키이다 그리고 어떤 아이를 대상으로 지금 인덱스가 걸려있냐 id라는 컬럼을 대상으로 얘가 인덱스가 걸려있다 라고 해서 , 이렇게, 일단 만들어주면은 말 그대로 이제 이 테이블 자체를 우리가 xml로 묘사를 한 상황이 되는 겁니다 그래서 실질적으로 이 xml 자체를 나중에 버전 관리 툴에 커밋을 해가지고 이거를 이제 인정을 하는 거죠 , 이렇게, 만들어져야 된다 테이블이 그래서 이걸 토대로 나중에 요 dbbind 같은 요런 아이들도 자동으로 생성해 주게 될 겁니다 굉장히 놀랍죠 , 자, 그리고 하던 걸 계속 하자면 어 여기 지금 테이블을 만들어 준 다음에 여기다가 우리가 무엇을 해달라 insert into 뭐시기뭐시기라고 , 이렇게, 장황하게 만들어 놨는데 이거를 나중에 가면은 매버마다 , 이렇게, query 자체를 날리는 게 아니라 이걸 procedure로 만들어 주게 될 거예요 store procedure라고 해가지고 일종의 데이터베이스에서도 함수를 만들어 가지고 그 함수를 호출하는 형태로 만들 수가 있습니다 그래서 이런 것도 이제 우리가 store procedure로 다 만들어 줄 것이기 때문에 나머지 이제 실질적인 기능들도 다 , 이렇게, 정의를 해주도록 합시다 , 자, 프로세저를 만들어 줄 건데 어 그런데 이름하여 뭐라고 할까요? 이 아이의 이름은 sp-insert-gold 라고 할게요 스토어 프로세저인데 골드를 추가하는 함수다 라고 간단하게 이름을 지어주고 그 다음에 여기서 이 아이가 , 일단은, 인서트 인투가 인자를 3개를 받는 걸 볼 수 있습니다 그래서 인자를 우리가 파라미터의 약자인 파람이라고 , 일단은, 지어주도록 할게요 네임은 무엇이냐? , 일단은, 골뱅이를 붙여가지고 , 이렇게, 표시를 해볼 것이고 타입은 int 얘는 이제 나중에 여기 물음표 안에 있는 query에다가 들어갈 것이기 때문에 일단 골뱅이를 , 이렇게, 붙여준 겁니다. , 자, 그 다음에 여기서 name이라는 애랑 그 다음에 create date , 이렇게, 세 개를 받아주고 있죠. name 같은 경우에는 n bar 차 50을 받아줄 것이고 그 다음에 type은 date time을 받아줄 겁니다. , 자, 그 다음에 body 내용은 무엇이냐 이 내용물을 만들어 줄 것인데 여기다가 그냥 고지곳대로 요 코드를 그냥 복붙을 하기보다는 이제 , 자, 여기다가 이 cdata 라는걸 이용해 줄 거에요 이게 이제 xml 에서 정식으로 이제 인정하는 문법인데 이걸 만약에 그냥 여기다가 문제를 막 입력하다 보면은 혹시라도 뭐 , 이렇게, 비슷한 , 자, 그런 부분이 만약에 , 이렇게, 등장한다고 하면은 얘를 이 자체를 또 인식을 할 수가 있겠죠 근데 그게 아니라 여기 C 데이터에 묶어 있는 내용은 건드리지 않고 얘는 따로 파싱하지 않고 그냥 하나의 통의 데이터로 인정을 해달라라고 부탁을 하는 겁니다 그래서 항상 , 이렇게, C 데이터를 만들어 가지고 여기다가 이제 우리가 만들어 주고 싶은 query를 , 이렇게, 넣어주도록 할게요. 이런 느낌으로 insert into dbo-gold, gold-name, createDate, values 다음에 여기다가 물음표 대신 이런 애들로 바꿔치기를 해주도록 하겠습니다. create date , 자, 그래가지고 여기서 이제 , 이렇게, 함수가 하나가 완료가 되는 거예요 프로세저가 그래서 이제 나중에 가면은 어 이런식으로 쿼리를 직접적으로 , 이렇게, 날리는게 아니라 진짜로 요 stop 프로세저라는걸 이제 호출하게 유도를 해줄겁니다 그래서 여기서 call sp-insert-gold 뭐 이런 식으로 이제 호출을 해주게 된다는 얘기가 되는 거죠 그건 일단 언젠가 나중에 다음 시간에 아마 실습을 해보게 될 것이고 뭐 그래서 이런 식으로 우리가 설계를 해줄 수 있다라고 보시면 되겠습니다 그리고 뭐 하나만 더 해보자면은 여기서 데이터를 꺼내 오는 것도 있었죠 , 자, 일단은, 얘를 통으로 복붙한 다음에 하나만 더 만들어 보도록 합시다 sp-get-gold 골드를 주세요 우리가 뭐 항상 골드만 , 이렇게, 넣어주고 그 다음에 이 뒷부분에서는 셀렉트 문으로 교체를 해주면 되겠죠 셀렉트 이 부분을 일단 긁어가지고 , 이렇게, 일단은, 넣어주도록 할게요 셀렉트 보시기 웨어 골드가 골드인 애들을 보여달라 뭐 , 사실, 조금 이상하긴 하죠 이걸 왜 굳이 봐야 되나 싶긴 하지만 어쨌든 우리가 테스트할 때 , 이렇게, 만들어놨으니까 이걸 그대로 한번 다시 모의사화를 해봐서 이걸 다시 한번 생성을 해보도록 하겠습니다 , 자, 이렇게, 해가지고 , 일단은, 설계는 완료가 되었구요 이제부터 그래서 약간 우리만의 ORM 시스템을 만들어야 되는데 근데 아직 좀 갈 길이 멀어요 , 자, 그래가지고 일단 기존에 했던 요런 내용들은 뭐 , 일단은, 다 날려 주도록 할 것이고 다 날려 주도록 할게요 , 자, 여기까지 일단 다 날려줄 것이고 이제 그러면 무엇이 필요하냐 순차적으로 생각을 해봅시다 먼저 가장 1단계는 무엇이냐면은 이 xml 파일을 긁어가지고 어찌됐건 여기 있는 내용을 다 파싱할 수 있어야 되겠죠 그래서 긁어가지고 이런 정보들을 추출할 수 있어야 되는데 xml 같은 경우에는 뭐 씹샵에서는 내부에서 다 , 이렇게, XML이나 JSON을 파싱하는 그런 기능들이 다 지원을 하지만 C++에서는 표준에서 이런 걸 지원하지 않기 때문에 굉장히 슬프게도 이거를 밖에서 찾아와야 됩니다 외부 라이브러리를 , 일단은, 갖고 오는 게 좋고 이걸 굳이 XML 파설을 다시 만드는 건 미친 짓입니다 너무 방대해요 그래가지고 , 일단은, 엔진 서버 코에다가 추가 3필터 xml 이라는 필터를 만들어주고 얘를 유틸에 넣어줘도 되고 밖에다 빼주셔도 되고 그건 뭐 본인의 자유입니다 어디에다가 , 이렇게, 넣어주시면 되요 일단 유틸쪽에다가 , 이렇게, 넣어 보도록 할게요 아니면은 밖에다 넣을 거라고 하면은 여기 맥 올려가지고 서머코에다가 , 이렇게, 넣어주면은 , 이렇게, 맨 아래 들어가니까 뭐 , 이렇게, 해도 되겠네요 , 자, 이렇게, 한 다음에 , 일단은, 오늘 사용할 라이브러리를 , 일단은, 갖고 와야 되는데 구글에 가가지고 Rapid XML을 일단 쳐보시면 되기는 합니다 근데 굳이 그거를 뭐 구글에 가서 다운받기보단 어차피 제가 소스 코드를 올려 드릴 거니까 그냥 거기서 그냥 복붙을 하시는 게 조금 더 편할 것 같아요 그래가지고 여기 폴더 가가지고 지금 제 코드는 지금 여기서 지금 다 작업을 하고 있습니다 여기다가 , 자, 이게 제가 올려드린 파일이라고 하면은 여기에 지금 , 이렇게, 4개가 있을 거에요. RapidXML 시리즈가 HPP 붙은 게 4개가 있을 텐데 걔를 복 붓 해가지고 일단 오른쪽으로 복사를 해주시길 바라겠습니다. 잘못된 것 같으니까 다시 한번 해볼게요. Ctrl-C, Ctrl-V, OK. 그래서 들어갔으면 얘네들을 끌어가지고 여기다가 , 일단은, 이렇게, 추가를 해주시면 되겠습니다. 얘는 그래도 굉장히 좋은 게 뭐냐면은 따로 라이브러리 파일이 필요한 게 아니라 소스 코드 자체만 갖다 복붙을 해주면 일단 사용할 준비가 끝난다고 보시면 되겠어요. 굉장히 편리하죠. 그래서 요 아이들을 이용해 가지고 이제 우리가 XML 파싱을 해볼 거고 , 자, 그 다음에 먼저 여기 유틸에다가 클래스를 하나 추가해 가지고 FileUtils라는 클래스를 하나 만들어 줄 건데 말 그대로 이제 파일을 읽고 뭐 하는 작업들을 다 여기 안에서 기능들을 넣어 줘 가지고 일단 관리를 해 줄 것이고 그 다음에 오늘 추가적으로 XML 파싱을 도와줄 헬퍼 클래스를 만들어 줄 건데 그걸 이제 XML 파서 라고 만들어 줄 것이고 얘는 여기 XML 안에다가 , 이렇게, 넣어 주도록 할게요 , 자, 그래가지고 이제 이걸 작업을 해볼 건데 근데 뭐 솔직히 이런 파일 입출력 부분이나 아니면은 뭐 xml 파싱하는 부분은 뭐 그렇게 대단한 부분이 아니기 때문에 일단 복붙을 해가지고 전 진행을 하도록 하겠습니다 이걸 제가 굳이 일일이 타이핑 하는 거는 너무 시간 낭비인 것 같아 가지고 그냥 간략하게 복붙을 해서 보여드리도록 할게요 그래서 분석만 일단 해드리도록 하겠습니다 파일 유틸 같은 경우에는 굉장히 많은 기능은 없고요 , 일단은, 그냥 두 개만 넣어놨어요 read file 이라고 해가지고 어떠한 경로를 일단 받아준 다음에 그거를 그냥 표준 입실력 함수를 등등을 이용해가지고 파일을 , 일단은, 그냥 긁어왔습니다 참고로 이 파일 시스템이라는게 C++17에서 추가가 된 아이예요 그래서 이제부터는 어지간하면 이 파일 시스템을 이용하는게 좋습니다 예전에는 표준에 놀랍게도 입출력 함수가 없었기 때문에 그냥 윈도우즈였으면 , 이렇게, 파일 포인터 만들고 이런식으로 윈도우에만 의존적인 함수를 이용하거나 리눅스에만 의존적인 함수를 이용하거나 하는 식으로 했었는데 이제는 어느정도 표준에 들어갔기 때문에 어지간하면 이런걸 이용하시길 추천드립니다. 그래서 서버코어 다시 속성에 가가지고 여기서 버전을 어.. 언어였나요? 네 언어에서 여기서 C++17까지 지원하도록 요 버전으로 , 일단은, 바꿔주도록 하겠습니다 적용 이거 , 사실, 모든 플랫폼 대상으로 해도 되긴 하니까 , 자, 다시 , 이렇게, 해서 세븐틴까지 , 일단은, 지원하도록 해서 다시 오면은 이제 아까 빨간줄이 없어지겠죠 그래서 이 파일 시스템이 놀랍게도 C++17에서야 추가가 되었고요 이 fspath 이 네임스페이스를 하나 정리해가지고 이제 패스를 이용하게 되면 여기다가 이제 뭐 디렉토리 긁어오고 하는 그런 굉장히 편리한 기능들이 많이 들어가 있습니다 이건 언젠가 나중에 사용해보면 되고 지금 여기서 하고 있는 거는 그냥 경로를 받아가지고 그 다음에 그 경로를 basic ifstream 인풋 파일 스트림을 이용해서 그냥 쫙 긁어와서 그걸 여기다가 저장을 해준 다음에 뱉어주고 있어요 굉장히 단순합니다 그리고 우리가 참고로 지금 파일 같은 경우에는 이 아이를 보면 UTF-8로 일단 만들어져 있어요 만약에 얘를 UTF-8 인코딩이 아니라 다른 애로 하고 싶다고 하면 어떻게 하면 되냐면 파일에서 다른 이름으로 저장을 가보시면 여기다가 저장이 뜨긴 하는데 여기다가 인코딩하여 저장이라는 게 있습니다 그래서 여기서 우리가 다른 애로 바꿔줄 수가 있기는 해요 근데 뭐 파일 같은 경우는 , 사실, utf-8을 사용하는 경우가 더 많습니다. 웹에서 통신할 때도 utf-8을 많이 사용하기 때문에 이 부분은 일단 건드리지 않도록 할게요. 일단 영문이 많기 때문에 확실히 utf-8로 인코딩하는 게 더 이점이 있기 때문에 , 이렇게, 일단 가만히 두겠습니다. 그래서 여기 read 파일은 , 일단은, utf-8를 이용해 가지고 다 이제 만들어지게 될 거예요. 그거를 이제 utf-16으로 파일을 다 긁은 다음에 그 내용물을 다시 UTF-16으로 바꾸기 위해서 요런 기능을 만들어놨습니다. 아, 지금 참고로 스트링이 예전에는 우리가 , 이렇게, 만들어놨는데 이제 그냥 하나로 통일해서 가기로 했으니까 그냥 얘를 , 이렇게, 스트링으로 인정하고 그냥 위에 건을 지워주도록 할게요. 이제는 무조건 요 와이드 캐릭터를 우리가 스트링이라고 합시다. 약간 C-Sharp 느낌으로 네, 이렇게, 해가지고 대문자 스트링을 사용하면은 그게 이제 어... W 캐릭터 형이다 라는 걸 일단 인지를 해주면 될 것이고 그래서 멀티바이트 투 와이드 캐릭터 이거는 그냥 윈도우즈 함수인데 이걸 이용해가지고 , 이렇게, 바꿔봤어요 , 사실, 이런 부분은 중요한게 아닙니다 그래서 제가 굳이 타이핑하지 않는 이유도 그렇게 중요한 부분은 아니니까 넘어가는거고 그 다음에 이어가지고 xml 파스터라는 애로 넘어오게 될겁니다 물론 우리가 방금 받은 사총소를 이용해서 그냥 바로 작업을 해도 되지만 이거를 조금 더 편하게 관리하기 위해서 , 일단은, 랩핑을 한다고 보시면 되겠어요. 그래서 얘도 마찬가지로 복붙을 해서 빠르게 보여드리도록 할게요. 그게 중요한 내용은 아닙니다. , 이렇게, 일단은, 만들어봤어요. , 이렇게, 만들어봤고 먼저 이제 분석을 해보자면 , 자, 좀 내용이 복잡해 보일 수 있는데 의외로 보면은 그렇게 복잡한 부분은 없습니다 , 일단은, 타입 정의를 , 이렇게, 했고 w 캐릭터를 사용할 거다 라고 일단 , 이렇게, 지정을 해줬어요 타입 정의를 해줬고 그 다음 실질적으로 사용할 때는 굉장히 단순한데 xml 파서를 만들어 준 다음에 path from file 이라는 걸 빵 호출해 주면은 어 얘가 이 패스를 이용해서 파일을 읽어주고 있죠? 읽어준 다음에 Convert를 해가지고 얘를 이제 와이드 캐릭터로 지금 변환해주고 있습니다 그게 여기까지 와이드 캐릭터로 변환한 다음에 Document라는 애를 만들어주고 있고요 XML Document Type 아까 위에서 정의해준 이 타입이죠? 얘네들은 이제 아까 우리가 다운받은 RapidXml 에서 지원을 해주는 아이들입니다. 그래서 걔를 이용해서 document, 문서를 만들어 준 다음에 path라는 함수를 호출해주면 되는데 이것도 역시나 우리가 만들어 준 게 아니라 방금 받은 라이브러리에서 지원을 해주고 있는 거예요. 그럼 끝입니다. , 이렇게, 해주면 문제가 없으면 잘 파싱이 되었으면 문제가 있으면 크래시가 날 것이고 문제가 없으면 잘 파싱이 될 것이고 거기서 document에서 first node를 딱 꺼내주면 첫번째 node라는 것 자체가 root node입니다. 요 아이가 되는 거죠 그래서 요 아이를 이제 뱉어주게 되고 끝나게 됩니다 그래서 이 xml node root라는 게 지금 사실상 이 첫 번째 node를 가리키고 있다고 보시면 되는 거고 이게 xml이다 보니까 그냥 트리 구조라고 생각하시면 됩니다 그래서 root node를 기준으로 우리가 이제 하나씩 하나씩 파싱을 하면 된다는 얘기가 되는 거죠 근데 그럼 나머지 윗부분은 무엇이냐 이거를 좀 편리하게 사용하기 위해서 , 이렇게, 함수를 다 하나씩 하나씩 정리해준 겁니다 뭐 어려운 내용은 전혀 없어요 예를 들면 Get Boolean Attribute 라고 딱 요렇게 입력을 해줬으면은 이 노드에서 First Attribute 첫번째 Attribute 찾아볼 건데 이 키값에 해당하는 Attribute 가 있는지를 체크해 가지고 만약에 있다고 하면은 그거를 이런 식으로 문자열을 비교를 통해 가지고 지금 비교를 해주고 있다라고 보시면 되는 거죠 그래서 만약에 성공적으로 지금 얘가 이 애트리뷰트가 true 라고 했다면 이제 return true를 해줄 것이고 아니면 false를 해줄 겁니다 , 자, 불리언은 조금 더 보기 어려우니까 나머지들을 보도록 할게요 제일 많이 쓰는 거 int 32 attribute 이 node 에다가 역시나 이 키값에 해당하는 attribute 가 있는지를 체크해 가지고 있다고 하면은 걔가 일단 string 형태를 딜 테니까 이런식으로 변환 함수를 이용해 가지고 string 을 정수로 반환을 해준다라는 부분을 , 일단은, 실행하고 있는 거죠. 그런 식으로 하나씩 하나씩 다 , 일단은, 작업을 해준 겁니다. 이걸 만약에 , 이렇게, 랩핑하는 클래스를 만들어주지 않으면 이런 부분들을 직접 해야 되는 거죠. 어차피 얘가 뱉어주는 거는 일단 스팅이다 보니까 우리가 원하는 건 스팅이 아니라 이 해당 값을 추출하고 싶은 거니까 , 이렇게, 해주고 있다고 보시면 되겠어요. 얘네들을 이런 숫자들 하나하나씩 숫자들이 무엇인지를 알고 싶다라고 하는 거죠 , 자, 뭐 이런 자세한 내용들은 뭐 크게 중요하지는 않지만 그래도 한번 , 이렇게, 뭐 구경을 해보시면 되겠고요 뭐 이런 식으로 사용을 하는구나 라고 볼 수가 있는 거고 참고로 여기 있는 내용들이 애트리뷰트고 여기 사이에 들어가 있는 부분들이 밸류입니다 이거 xml에서 이런 걸 이제 애트리뷰트 들어가는 거고 그 다음에 사이사이에 들어가는 거 예를 들면 만약에 column 이라고 했는데 여기다가 , 이렇게, 값을 넣어서 얘가 이제 밸류가 될 거예요 , 자, 그 다음에 이어서 무엇을 해볼 거냐 그럼 이제 최종적으로 , 이렇게, 만들어 준 기능들을 이용해 가지고 다시 게임 서버 쪽으로 돌아가 가지고 간단하게 파싱을 하는 실습을 해볼 겁니다 , 자, 근데 이것도 뭐 굳이 타이핑 할 필요는 없을 것 같아 가지고 그냥 간단 간단하게 보여드리자면 먼저 include xml 파스터를 추가해 줍니다 얘가 이제 xml 파싱을 도와주는 그런 기능을 하는 애였고 그 다음에 메인 함수에다가 어 여기에 assert crash 바로 위에다가 여기까지 긁어가지고 요 부분을 일단 통으로 복사해 줄 거에요 좀 내용이 많아 보이는데 뭐 , 일단은, 이런 식으로 하나씩 하나씩 분석을 해 보도록 하겠습니다 , 자, 해가지고 어... 먼저 얘가 뭘 하고 있냐면은 pass from file 을 호출해가지고 game.db.xml 아까 방금 우리가 만들어준 요아이를 , 일단은, 파싱을 해주게 될 겁니다 그래서 얘가 성공적으로 만약에 파싱이 되었다고 하면은 무엇이 되느냐면은 요아이가 루트가 , 일단은, 여기 추가가 되겠죠 루트를 추출해 오게 될 겁니다 루트 노드를 이용해가지고 즉 이 테이블을 이용해가지고 나머지들도 이제 하나씩 하나씩 파싱을 해주고 있습니다 아 근데 지금 에러가 나는 거는 서버 코어를 빌드를 한번 해줘야 돼서 그럴 것 같네요. 아까 스트링을 바꿔줬는데 그거 빌드를 안 해가지고 지금 인지를 못하는 것 같으니까 , 자, 이렇게, 일단은, 빌드를 해보도록 하겠습니다. , 자, 그러면은 이 부분 게임 서버에 이제 빌드를 하면은 별다른 문제가 없다고 하면은 통과가 될 것으로 일단 예상이 되고요 네 그 다음에 오케이 이 빨간 줄은 그냥 지금 잘못 뜨고 있는 겁니다 , 자, 이렇게, 해가지고 계속 이야기를 해보자면 일단 루트 노드가 이 게임 디비라는 노드가 되는 거고 거기서 find children 이용해가지고 테이블을 다 싸그리 찾아 줄 겁니다 지금은 뭐 테이블이 하나밖에 없으니까 하나만 들어가게 되겠죠 그래서 이 노드를 , 일단은, 다 찾아주게 될 거예요 이 노드를 벡터에다가 넣어주고 있고 모든 테이블 노드가 들어가게 됩니다 그럼 이제 그 테이블 대상으로 하나씩 하나씩 순위를 할 건데 먼저 String Attribute 를 찾아주고 있습니다 이 Name 이란 애가 있는지 Name은 우리가 , 이렇게, 넣어주고 있죠 그래서 그 Name을 , 이렇게, 추출할 수 있다 라고 볼 수 있는 거죠 뭐 이 DSC는 만약에 여기서 옵션으로 우리가 약간 주석같은 얘가 뭘 하는 앤지 그냥 뭐 골드 테이블입니다 이런 식으로 추가적인 정보를 기입할 때 그냥 사용하는 애고요 네임이랑 디스크립션을 , 이렇게, 추출해주면 될 것이고 그 다음에 이 내부적으로 칼럼들이 여러개 들어가 있으니까 역시나 테이블에서 find children을 이용해가지고 칼럼을 또 수뇌를 빵 해주고 있습니다 그래서 컬럼들을 하나씩 하나씩 순환을 해가지고 거기 있는 정보들도 , 이렇게, 하나씩 하나씩 추출할 수 있는 거죠. 그래서 이걸 나중에 뭐 그냥 , 이렇게, 추출하는 게 끝이 아니라 이걸 메모리에다가 들고 있어가지고 이 해당 테이블의 구조를 정확하게 파악할 수 있게끔 만들어주게 될 겁니다. 뭐 이런 식으로. Name, Type, NotNull, Identity, Default 등등의 값을 추출한다고 보시면 되겠어요 그 다음에 역시나 똑같은 이유로 인덱스도 , 이렇게, 찾아주고 있는데 지금은 클러스터 인덱스 하나만 넣어주고 있지만 경우에 따라서 논 클러스터 인덱스도 여러 개도 걸어줄 수 있으니까 역시나 File Children으로 하나씩 하나씩 딱 스캔을 해주고 그 다음에 하나씩 돌면서 이런저런 정보들을 찾아주고 있습니다. 얘가 프라이머리 키가 맞는지 아니면 그 유니크 컨스트레이트가 붙어 있는지 등등을 체크하고 있을 것이고 그 다음에 어떤 컬럼을 대상으로 이 인덱스가 걸려 있는지도 지금 찾아주고 있습니다. 지금은 아이디를 대상으로만 , 이렇게, 걸려주고 있는 거죠. 그 다음에 프로세저도 마찬가지로 이런 식으로 하나씩 하나씩 순위를 하면서 여기 해당하는 내용들을 지금 긁어주는 부분이 , 이렇게, 나와가 있습니다. 그래서 이런식으로 파싱을 해주면 된다라고 결론을 내릴 수가 있는거고 이걸 잠시 실행은 해볼건데 게임 서버를 실행을 해보긴 해볼건데 정상적으로 파싱이 되는지 궁금하니까 브레이크 포인트를 잡아가지고 보도록 할게요 사이즈가 1개짜리로 , 이렇게, 딱 됐고 네임이랑 데스크립션 잘 뜨고 있고 그 다음에 컬럼도 하나씩 하나씩 , 이렇게, 순회를 하는데 여기다가 정보가 정상적으로 들어가는 것도 일단 확인할 수가 있어요 그래서 , 일단은, ORM을 만드는 첫번째 단계는 이런식으로 XML을 파싱을 해가지고 일단 XML 먼저 만들어준 다음에 , 이렇게, XML 파스를 하는 느낌으로 하나씩 데이터를 추출한다라는 걸 , 일단은, 실습을 해봤습니다. 이어서 다음 시간에는 이런 정보를 그냥 추출하고 끝내는 게 아니라 이제 이걸 이어 해가지고 실질적으로 우리가 데이터베이스를 다시 복원시키는 작업 그러니까 이 테이블이랑 프로세저 등등을 이제 만들어주는 작업을 일단 이어서 해보도록 할게요.