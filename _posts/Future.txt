우리가 지난 시간에 조건변수 컨디션 Variable에 대해서 알아보면서 굉장히 유용하게 활용할 여지가 많다는 것을 일단 알 수가 있었습니다. 특히나 여러 Thread에서 통신을 할 때 어떤 공용으로 사용하는 큐를 두고 한쪽에서는 데이터를 밀어 넣고 한쪽에서는 데이터를 꺼내 쓰는 그런 전형적인 프로듀서 컨슈머 상황에서 특히나 유용하다는 걸 알 수가 있었는데요. 하지만 경우에 따라 가지고 그렇게 복잡한 상황이 아니라 조금 더 가벼운 상황에서 우리가 또 순서를 보장해 가지고 다른 애한테 뭔가 , 이렇게, 이벤트를 알려주는 그런 상황이 또 생길 수도 있습니다 단발성 이벤트 같은 경우에는 굳이 조건변수까지 가지 않고 더 가벼운 방법이 존재하는데 이제 오늘 주제는 SD Future 미래 객체에 대해서 , 일단은, 알아보도록 할 거예요 근데 뭐 솔직히 말씀드리면 기존에 우리가 배웠던 Mutex나 조건변수 등등의 내용에 비하면은 , 사실, 조금 제 개인적인 느낌으로 활용도가 조금 떨어지는 것 같긴 한데 그럼에도 불구하고 얘가 이제 뭐 C++11에 공식적으로 추가된 그런 내용이다 보니까 내용은 그래도 간략하게 언급을 드리고 넘어가는 게 나을 것 같아 가지고 , 일단은, 가볍게 이번 강의를 준비했습니다 , 자, 오늘 이제 주인공을 사용하기 위해서는 , 일단은, 헤더를 include future라는 이 헤더를 , 일단은, 추가를 해줘야 되구요 이름이 굉장히 재밌죠 미래 future라는 애를 일단 사용해 볼 겁니다 , 자, 근데 이게 이제 어떤 식으로 사용을 하는지 유용한지 한번 살펴볼 건데 , 일단은, 어 , 일단은, Calculate라는 좀 복잡한 느낌의 함수가 있다고 가정해볼게요 뭔가 복잡한 계산을 할 것이고 여기서 뭔가 sum을 계산을 해줄 것인데 , 이렇게, i는 0번부터 100만개의 데이터를 , 이렇게, 뺑뺑이를 돌면서 , 일단은, 왠지는 모르겠지만 여기다가 sum에다가 다 더해주는 그런 간단한 기능이 있다고 가정해봅시다 그러면 우리가 사실은 만약에 얘를 동기화 된 상태에서 얘를 막바로 , 이렇게, 만약에 호출한다고 하면은 이거를 지금까지는 뭐 딱히 언급을 안 드렸지만 동기 방식의 호출, 싱크로너스 방식의 실행이라고 합니다 그래가지고 이 Synchronous 라는게 이제 어떤 의미냐 예를 들면은 얘를 지금 우리가 , 이렇게, 최종적으로 return 여기서 return sum을 , 이렇게, 뱉어준다고 하고 여기서 그거를 호출하기 위해서 호출해가지고 결과를 받아가지고 뭐 , 이렇게, 출력을 할 수가 있었겠죠 그러면 지금 요 함수의 지금 실행 순서를 보면은 메인이 실행이 되면서 메인스레드가 호출이 되면서 이 캘큘레이트란걸 우리가 동기방식으로 실행했기 때문에 이 캘큘레이트 안으로 들어가가지고 얘를 이제 다 실행한 다음에 얘가 반환이 되면 다시 빠져나와가지고 얘로 이제 이어서 실행하게 될 겁니다. 그니까 실행 순서가 정말로 요렇게 이어져가지고 계속 연속해서 호출이 된다는 얘기가 되는 거죠. 하지만 만약에 얘가 진짜 어마어마하게 오래 걸리는 함수였다고 하면 얘가 100초씩 걸리는 함수였다고 하면 , 이렇게, 동기방식으로 실행하는 순간 이 메인 함수도 결국에는 100초 동안 얘를 완료할 때까지 여기서 멈춘 상태에서 더 이상 진행을 못하게 되겠죠 그래가지고 경우에 따라가지고 얘가 만약에 좀 중요도는 떨어지지만 좀 오래 걸리는 함수라고 한다면 얘를 비동기 방식으로 다른 애한테 떠넘기는 혹은 나중에 실행하는 방식으로 호출하는 게 유용해질 때가 있습니다 그래가지고 지금까지 우리가 배운 내용으로 만약에 얘를 만든다고 하면은 뭐 , 일단은, Thread를 하나를 만들어가지고 Calculate라는 거를 요렇게 떠넘긴 다음에 얘가 다른 일을 하다가 이제 최종적으로 결과가 필요할 때 이 Thread가 완료가 되기를 기다려가지고 뭔가를 하는 요런 방법이 일단 존재하겠죠 요렇게 , 일단은, 만들어 줄 수가 있겠습니다 그러면은 요 방식에서는 , 일단은, Calculate라는 걸 다른 Thread한테 시켰으니까 지금 요 캘큘레이트가 완료가 될때쯤 일단 데이터를 다시 받아와야 되는데 공용으로 사용하는 데이터를 예를들면 리설트라고 해가지고 여기다가 어떤 공용 데이터를 받아줘가지고 여기다가 모섬을 저장하거나 하는 식으로 , 일단은, 데이터를 받아올 수 있기는 하겠죠 하지만 요 방법에서 살짝 아쉬운 점이 여러가지 있는데 , 일단은, 아까 방금 지금 우리가 살펴본 , 이렇게, 데이터를 넘겨받기 위해서 뭔가 공용 데이터를 사용해야 된다라는 것 자체가 조금 귀찮구요 만약에 함수가 한두개가 아니라 진짜 , 이렇게, 일감을 여러개를 떠넘겨야 되는 상황이 있다고 하면 이 변수를 여러 번 늘리는 것도 좀 애매하게 되겠죠 다중 스레드 상태에서 만약에 얘를 참조하는 애가 여러 개가 있다고 하면 역시나 락을 걸거나 하는 복잡한 그런 동기방식 동기화가 데이터에 대한 보호가 이뤄져야지만 이게 정상적으로 동작하는 등의 귀찮은 작업이 될 겁니다 뿐만 아니라 , 사실, 이렇게, 단순한 일감 딱 한 개만 시킬 건데 그걸 위해 가지고 , 이렇게, 스레드를 만들고 스레드를 조인해 가지고 기다려서 소멸시키고 하는 요런 부분들이 의외로 좀 깔끔하지 않은 느낌이 들 수도 있어요 정말로 그냥 캘큘레이트 하나만 다른 애한테 외주를 줘가지고 다시 받아오면 되는 상황인데도 불구하고 , 이렇게, 쓰레드를 만드는 게 과연 맞을까 싶기는 하죠 만약에 우리가 식당을 운영한다 과정했을 때 정말로 장기간 동안 꼭 필요한 사람이 포지션이 있다고 해가지고 직원을 공해가지고 장기적으로 같이 일한다고 하면 말이 되지만 1-2시간 살짝 일손이 부족한 그런 느낌이 든다고 하면 1-2시간 사용하기 위해서 직원을 한 명 더 고용하는 건 조금 아깝긴 하겠죠 그냥 뭔가 단계 알바를 구하는 게 훨씬 나을 텐데 약간 그런 느낌이라고 볼 수가 있겠어요 그래가지고 항상 , 이렇게, 무겁게 스레드를 만들고 하기보다는 이거를 조금 더 가볍게 체리할 수 있는 방법이 있는데 그게 이제 오늘 알아볼 다른 SD Future와 같은 방식으로 약간 단계 알바를 시키는 느낌이라고 볼 수가 있겠습니다 , 자, 그래가지고 이거는 뭐 설명을 드리기보다는 그냥 진짜 사용 예제를 보는 게 조금 더 이해하기 쉬울 것 같아가지고 일단 바로 사용 예제부터 살펴보도록 할게요 , 일단은, 이 Future라는 객체를 만들어 줄 것인데 얘를 만드는 방법이 이제 여러가지 있는데 가장 단순한 방법 중에 하나는 이 SDAsync란 걸 이용해가지고 함수를 호출해 주는 겁니다 그리고 여기서 옵션을 두 가지 중 하나를 넣어 줄 수가 있는데요 , 일단은, Async, Launch Async라는 정책으로 Calculator를 호출해주세요 라고 요청을 해보도록 하겠습니다 여기 Launch Policy라는 것 자체가 들어가보면은 Async라는 거랑 Depod라는 방식 두 가지 방식 중에 하나를 골라주게 될 건데요 그 차이에 대해서는 지금 이어서 설명을 드릴 거고 어찌됐건 , 이렇게, Calculator라는 거를 Async 방식으로 호출해주세요 라는 걸 요청을 하게 되면은 얘가 , 이렇게, 동기방식으로 실행되는 거랑 느낌이 완전히 달라집니다 얘는 정말로 메인 앱수가 실행이 되면서 캘큘레이트를 호출하고 얘가 끝내야지만 다음 단계로 넘어와서 빠져나와서 호출하는데 얘는 그게 아니라 이 시점을 비동기 방식으로 호출하게 되기 때문에 작동 방식이 달라진다고 볼 수 있는 거죠 여기서 , 일단은, Future라는 걸 , 이렇게, 만들어 준 다음에 일단 이 Future 당장 우리가 결과물을 당장 받을 필요가 없다고 가정을 하면은 여기서 그냥 딴짓을 하게 됩니다 우선 이 Async를 호출하면은 얘가 이 캘큘레이트가 호출이 완료될때까지 대기를 타는게 아니라 일단 무조건 빠져나와서 이어서 계속 호출을 해주게 됩니다 그럼 당연히 얘기지만 그러면 요 결과물 자체가 완료되었나요 완료되지 않았나요는 , 사실, 케바케로 다르게 되겠죠 완료될수도 있고 안될수도 있고 그건 모르겠고 , 일단은, 얘를 그냥 뭔가 , 이렇게, 객체를 만들어주고 이어서 계속 실행을 하게 됩니다 그래서 만약에 당장 결과물이 필요 없다고 하면 여기서 뭐 딴짓거리를 막 실컷 하다가 한참 후에 그러고 보니까 내가 어... 아까 부탁한 일이 있는데 그 일은 끝났을까라고 궁금해 줘가지고 그 일을 진짜로 사용할 때가 되면은 비로소 future.get을 이용해가지고 그 결과물을 , 이렇게, 뽑아올 수가 있어요 그래서 뭐 예를 들면은 아까 요청한 그 데이터는 얼마이냐라고 이제 진짜로 최종적으로 결과물이 이제서야 필요하다라는 상황이 됐을 때 얘를 이제 꺼내서 쓰는 거죠 , 자, 그러면 요런 느낌으로 , 일단은, 호출이 되는 건데 여기서 그럼 궁금한게 아니 캘큘레이트를 지금 여기서 애당초 여기서 이제 만약에 실행이 된다고 하면 그냥 지금 실행하지 않고 캘큘레이트를 여기 하는거랑 뭐 별로 다를 바가 없지 않느냐라고 생각할 수도 있는데 , 자, 이게 옵션에 따라가지고 이게 완전히 달라집니다 , 일단은, 첫번째 옵션 이 퓨처 그니까 이 에이싱크란걸 만들어줄 때 우리가 세가지 옵션을 넣어줄 수가 있는데 첫번째는 디퍼드를 넣어줄 수가 있구요 아까 두번째로 에이싱크라는 걸 넣어줄 수 있고 세번째로는 1 플러스 1으로 둘 다 합쳐줄 수가 있습니다 디퍼드 혹은 에이싱크 , 자, 요렇게 만들어줄 수가 있는데 요 방식은 첫번째 방식은 지연된 상태 레이지 에발루이션이라고 우리가 표현을 하는데 그냥 지연해서 실행하세요 라는 의미가 되는 거고 두번째 방식은 이 에이싱크를 만들어 주게 이 옵션을 넣어주게 되면은 별도의 스레드를 를 만들어서 실행하세요 라는 의미가 되는 겁니다 마지막으로 얘를 이제 티퍼드랑 에이스잉크를 같이 , 이렇게, 넣어주게 되면은 둘 중 알아서 원하는 대로 알아서 골라주세요 라고 요청을 하게 되는 거에요 그래서 딥허드를 만약에 , 이렇게, 넣어주게 되면 얘는 멀티스레드 환경은 아니고 그냥 말 그대로 캘큘레이트란 하는 거를 잠시 미뤄가지고 나중에 실행한다는 얘기가 되는 겁니다 진짜로 캘큘레이트를 나중에 호출한다는 거랑 별반 다를 바가 없다는 얘기가 되는 거죠 그러면은 지금 호출하는 게 아니라 얘는 잠시 호출하겠다는 그런 객체를 만들어주고 이걸 나중에 실행하는 게 어떤 의미가 있느냐 싶겠지만 이게 경우에 따라서 유용한 경우가 종종 생겨요 이게 , 일단은, 커매드 패턴의 전형적인 패턴이라고 볼 수가 있는 건데 예를 들면은 어.. 클라이언트 쪽에서 서버한테 뭐 어떤 유저가 어떤 좌표로 이동하겠다는 요청을 보내왔다고 가정을 해봅시다 근데 서버가 다른 일감, 예를 들면 뭐 몬스터 AI라거나 다른 일감을 처리하느라고 너무 바빠가지고 당장 처리할 여력이 없다고 가정을 할 때 그럴 때 그 요청사항을 잠시 이런 식으로 뭐 퓨쳐라거나 하는 객체로 일단 만들어가지고 나중에 기가 여력이 될 때 이런 식으로 여유가 될 때 걔를 호출하는 식으로 말 그대로 실행하는 시점을 지연을 해가지고 실행을 하는 게 유용해질 때가 있어요 이런 방식도 결국에는 우리가 비동기 방식이라고 할 수 있기는 한 거죠 왜냐면 동기방식은 애정초 예를 호출하는 순간 실행해야 된다는 걸 동기방식으로 하는 거고 비동기는 그게 아니라 실행시점이 뒤로 밀린다라는 차이가 있게 되는 거니까 이것도 어떻게 보면 비동기 방식이라고 , 일단은, 할 수가 있기는 합니다 근데 물론 이거 자체는 뭐 그렇게 100% 확률로 좀 깔끔하고 유용한 것 같지는 않죠 두 번째 방식 이게 사실은 우리가 좀 더 관심을 가지는 그런 상황인데 얘를 이제 Async로 넣어주게 되면 얘는 이제 사실상 멀티스레드 환경이 되는 거예요 그래가지고 얘를 Async Calculate를 하는 순간 별도의 스레드가 자동으로 만들어져 가지고 이 Calculate를 같이 병률로 실행을 해주게 됩니다 그러면은 우리가 여기서 메인스레드에서 다른 일을 신나게 처리하더라도 그 와중에 캘큘레이터는 계속 연선이 되고 있을 거니까 최종적으로 우리가 필요한 시점에서 이 결과물을 딱 받아주려고 할 때 얘가 이제 연선이 끝났다고 하면은 걔를 받아줄 것이고 아니라고 하면은 나머지 연선을 끝내고 이제 결과물을 받아오는 그런 상황이 된다고 보시면 되겠어요 , 자, 이게 굉장히 중요하니까 잠시 그림판을 켜가지고 다시 한번 이 실행시점을 간략하게 한번 짚어드리자면 만약에 우리가 동기방식으로 실행했다 일단 메인 암수로 요렇게 들어온 상태에서 만약에 동기방식으로 Calculate를 실행했으면 말그대로 Calculate가 끝난 다음에 빠져나와 가지고 이제 이어서 실행이 되는 요런 굉장히 1차원적인 형태로 호출이 될 것이고 그게 아니라 우리가 Depod를 넣어 준 옵션으로 이 Lazy Evaluation 방식을 사용하게 되면은 , 일단은, 이 Calculate라는 요청 자체는 여기서 들어왔지만 얘를 당장 호출하지는 않을 것이고 한참 후에 진짜로 우리가 이 결과물이 필요한 시점에서 여기서 Calculate를 호출해주겠다는 실제로 요청하는 시점과 호출하는 시점이 , 이렇게, 나눠지게 된다는 차이가 생기는 거죠 그냥 그런 차이가 있는 거고 마지막으로 가장 관심있는 Async 버전을 이용해가지고 Async를 만약에 이 두 번째 옵션으로 넣어주게 되면 메인 스레드에서 요청하는 이 Future 객체를 만들어주는 순간 얘가 , 이렇게, 아예 별도의 Thread로 얘가 이제 이어서 일감이 떠넘겨지게 되는 겁니다 얘가 이제 Calculator가 이쪽에서 실행이 될 것이고 그 다음에 우리가 Future 갯을 통해가지고 결과물을 받아주고 싶은 시점이 생기게 되면은 예를 들면 여기서 우리가 갯을 딱 때렸으면은 우리가 던져준 얘 결과물이 완료되어가지고 돌아올 때까지 기다렸다가 이어서 다시 합쳐져서 실행이 되는 그런 느낌이라고 볼 수 있는 거죠 사실상 다른 스레드를 만들어서 이 일감을 처리한 것이지만 우리가 명시적으로 귀찮게 스레드를 새로 생성하고 관리할 필요 없이 알아서 자동적으로 얘가 이루어졌다고 보시면 되겠습니다 그래서 사실상 멀티스레드 환경을 간접적으로 체험해서 만들어준 이런 상황이라고 볼 수 있는 거죠 그래서 예전에 제가 일하던 프로젝트 중에서 이 기능을 사용한 적이 있었는데요. 이게 어떤 상황에서 사용을 했냐면 데이터시트 로딩을 개선할 때 사용을 한 적이 있습니다. 그래가지고 서버를 만약에 우리가 띄웠는데 서버를 띄울 때 이제 처음에 서버같은 MMO 서버 같은 경우에는 데이터시트를 다 로딩을 하기 시작합니다. 데이터시트가 그 당시에는 XML로 만들어져 있었는데 뭐 이건 나중에 정확한 내용을 살펴볼 것이고 어쨌든 이 데이터 파일이 굉장히 많아요 얘가 어떤 데이터 파일이냐면은 뭐 몬스터 AI라거나 플레이어 스탯이라거나 아니면 어떤 던전에서 보스몬스터가 어떤 패턴을 해야 된다거나 하는 그런 굉장히 많은 기획적인 요소들을 우리가 다 파일로 빼줘 가지고 관리를 하게 되고 서버가 딱 뜨는 시점에서 이 모든 데이터 파일을 다 로드해서 시작을 해야 되는데 당연한 얘기지만 나중에 게임이 10년 되다 보니까 엄청나게 데이터가 많았었죠 그래서 이 데이터를 다 로드하는데 거의 뭐 50초씩 걸린 겁니다 예를 들면 뭐 맵에 정보 로드하고 몬스터 AI 정보 로드하고 플레이어 뭐 정보 로드하고 이런걸 순차적으로 다 처리하다 보니까 얘가 너무너무 오래 걸리게 된 거예요 그래서 이거를 어떤 용자가 어떻게 개선을 했냐면은 요런 기능들을 이제 잘 이용해가지고 어 , 이렇게, 비동기 방식으로 새로 떠넘기게 된 거죠 한쪽은 너는 AI를 로드해 너는 뭐 딴 건 로드해 너는 무엇을 로드해라고 , 이렇게, 다 떠넘겨준 다음에 실제로 여기서 만남의 장소로 딱 고정을 시켜가지고 얘네들이 다 , 이렇게, 호출이 완료되면은 이쪽에서 모이게끔 , 이렇게, 유도를 해준 겁니다. 물론 이걸 이제 쓰레드를 새로 만들어 가지고 관리해서 만들어도 되긴 하지만 잠시만 , 이렇게, 로드를 하는 요 기능만 잠시 사용할 것인데 굳이 그거를 쓰레드로 새로 만들고 쓰레드를 생성하고 소멸하고 하는 걸 관리하는 것도 이제 일이 되는 거죠 그러다 보니까 그냥 단순하게 하나의 함수만 잠시 비동기로 실행하고 싶다 이런 식으로 호출하고 싶은 경우가 생길 때는 우리가 지금 얘기하고 있는 요런 Future를 이용하는 방법이 굉장히 유용하다는 걸 이제 알 수가 있는 겁니다 그래서 딥퍼드나 에이싱크 이런 둘 중 하나의 옵션에 따라가지고 딥퍼드를 넣어주게 되면 멀티스레드 환경은 아니고 그냥 이어가지고 얘를 이제 호출하고 있는 스레드에서 나중에 얘를 지원해서 실행한다 에이싱크를 넣어주면 진짜로 별도의 스레드가 만들어져서 실행한다는 차이가 있지만 어찌됐건 이 실행시점이 계속 밀리게 되어가지고 결과물을 얻어온다라는 건 공통적인 사항이에요 , 이렇게, 해가지고 일단 퓨처에 대해서 간단히 알아봤고요 , 자, 그런데 이제 경우에 따라 가지고 여기서 Get을 하는 순간에 결과물이 이제서야 정말 필요할 때 우리가 Get을 하는 거지만 뭐 경우에 따라 가지고 진짜 꼭 필요하진 않지만 이 일감 자체가 끝났는지 안 끝났는지 잠시 살짝 엿보고 싶은 경우가 생길 수도 있겠죠 그럴 때는 future.을 찍어 보면은 여기서 wait 계열의 함수들이 있습니다 , 일단은, wait for 얘가 이제 대표적이에요 몇 초 동안 그러니까 얼떤 기간 동안 기다려주세요 예를 들면 1ms만 한번 기다려 보겠다라고 , 이렇게, 호출이 되면은 wait for를 호출하는 순간에 만약에 이 캘큘레이터가 완료가 될 수도 있고 아니면 안 될 수도 있겠죠 그러면 이 결과물 자체가 유심히 보면은 future status라는 걸 뱉어주고 있는 걸 볼 수가 있죠 future status 이 상태를 이용해가지고 실제로 일감이 끝났는지 안 끝났는지를 우리가 판별을 해줄 수가 있어요 예를 들면은 레디 상태라고 하면은 이제 일감이 완료가 되었으니까 여기서 만약에 처리하고 싶은 게 있으면 여기서 , 이렇게, 처리를 해주면 되겠어 뭐 이런 식으로 , 일단은, 잠시 살펴보는 기능도 있습니다 참고로 future wait라는 걸 이용하면 아까 wait4를 무한정 기다리는 거랑 마찬가지예요. 얘도 사실상 진짜로 결과물이 이 세상에 필요한 거랑 마찬가지죠. 그렇기 때문에 , 이렇게, wait를 호출한 다음에 get을 호출하나 얘를 생략하고 get을 호출하나 그냥 결과물은 똑같습니다. 그래가지고 사실상 wait_for랑 get , 이렇게, 두 개만 , 일단은, 당장 기억을 해주시면 된다고 보시면 되겠어요. 그래서 이 future라는 것 자체가 결국에는 요약을 해보면 언젠가 언젠가 미래에 결과물을 우리가 뱉어줄 거야 라는 어떻게 보면 약속을 받고 있는 겁니다 얘가 당장은 결과물이 없을 수도 있긴 하지만 언젠가 미래에 그게 뭐 별도의 스레드에서 하건 아니면 지혜원에서 실행을 하건 이 갯을 하는 순간에는 우리가 결과물을 얻어올 수 있다라는 어떻게 보면 일종의 약속을 한 셈이 되는 거죠 네 , 이렇게, 해가지고 뭐 feature에 대해서 알아봤구요 , 자, 그 다음에 음 이건 약간 디테일이긴 한데 경우에 따라 가지고 요렇게 그냥 전역으로 된 그런 전역함수나 스태틱함수 같은 거 사용하는 게 아니라 어떤 멤버에 기생하는 함수 멤버함수를 호출할 수 싶은 경우도 있겠죠 예를 들면은 뭐 , 이렇게, 클래스 나이트라는 클래스가 , 일단은, 있다고 가정을 하고 얘가 뭐 예를 들면은 getHP라는 함수가 내부적으로 뭐 요렇게 있다고 가정해 볼게요 그러면은 만약에 요거를 , 이렇게, 똑같이 getHP를 호출하고 싶어가지고 얘를 그냥 고지곳대로 요렇게 넣으면은 , 일단은, 통과가 되지 않는다는 걸 볼 수가 있습니다 문법에 맞지 않기 때문이죠 요 HP함수는 그냥 독립적으로 존재하는 게 아니라 이 나이트에 속해있는 그런 HP라는 멤버 함수이기 때문에 얘는 문법이 살짝 달라져요 그래가지고 얘는 이제 어떻게 적어주면 되냐면은 night.getHP를 우리가 호출해줄 것이다 라고 요렇게 만들어주시면 되고 그 다음에 어떤 객체에 의존적으로 얘가 호출이 되는 것이기 때문에 그 객체가 반드시 , 이렇게, 만들어져서 포함이 되어야 됩니다 그래서 뭐 예를 들면 요렇게 만약에 호출하게 되면은 사실상 얘가 night.getHP를 요렇게 호출하는 셈이 되는 거죠 이런 느낌으로 얘가 이제 반드시 이런 전역함수나 스태틱함수뿐만 아니라 이런 멤버함수도 똑같이 호출할 수 있다는 걸 그냥 잠시 언급을 드리는 겁니다 크게 중요한 내용은 아니고요 혹시라도 얘가 뭐 이런 객체 대상으로 사용할 수 없다고 오해하실까봐 이건 잠시 언급을 드린 거고 그 다음에 이제 알아볼 거는 이 Future라는 것 자체가 SD Async를 이용하는 방법뿐만 아니라 , 사실, 다양한 방법으로 얘를 만들 수가 있어요 Future 자체는 언젠가 우리가 미래의 결과물을 뱉어줄 거야라는 의미를 갖고 있는 거지만 그게 반드시 , 이렇게, 어떤 함수를 이용해 가지고 함수의 결과물을 뱉어준다는 의미만 포함하고 있는 건 아니죠 예를 들면은 우리가 여기서 뭐 예를 들면은 아까 처음에 했던 것처럼 , 이렇게, 공용으로 사용하는 변수를 만들어 준 다음에 그 변수를 통해 가지고 받아주는 그 상황 자체를 만약에 다시 한번 만들어주고 재현하고 싶다고 가정하면은 이 Future라는 객체가 그 다른 Thread가 결과물을 뱉어 줄 거야라는 걸 우리가 Future로 받아주고 있었는데 그걸 다른 스냅에서 데이터를 밀어넣는 작업만 추가해주고 싶다고 가정해볼게요 말을 사용하니까 좀 어려운데 일단 실습 한번 해보도록 하겠습니다 말로 표현하니까 너무 어렵네요 , 자, 일단 Promise라는 두 번째 타입에 대해서 일단 알아볼 건데 이제 Future 객체를 만들어주는 두 번째 방법이라고 보시면 되겠어요 , 일단은, 이 미래 Future 객체, Future 객체를 만들어주기 위해서 Promise라는 걸 일단 먼저 만들어주게 됩니다 얘가 이제 여기서 하는 거랑 마찬가지로 이 Future가 뱉어줄 그 타입을 여기서 , 일단은, 만들어주면 되겠어요? 예를 들면 String을 얘가 만약에 반한다고 화정을 해봅시다 그러면 이 Promise 객체를 통해 가지고 우리가 Future를 , 일단은, 추출해줄 수가 있어요 이런 식으로 Promise에 Get Future 그럼 이게 약간 무전기처럼 얘랑 얘랑 어떻게 보면 1대1로 지금 연동이 된 상태입니다. 그래서 다른 스레드에서 여기 프러미스에다가 set 함수를 통해가지고 데이터를 세팅을 해주게 되면은 그거를 우리가 future.get을 이용해가지고 그 데이터를 받아올 수가 있게 돼요. 네 그래가지고 이거를 뭐 잠시 한번 뭐 실습을 해보자면 예를 들면은 , 자, 위에서 프러미스 워커라는 함수를 만들어주고 여기다가 std promise를 , 이렇게, 받아주도록 할게요 어... 일단 오른값으로 , 이렇게, 만들어주도록 하겠습니다 오른값으로 만들어준 다음에 setValue 함수를 통해가지고 여기다가 뭐 어떤 메시지를 , 이렇게, 전달해준다고 가정해볼게요 secretMessage라고 setValue를 해봅시다 그럼 얘가 지금 하고 있는거는 뭐냐면은 이제 여기서 결국에는 미래에... 미안 미래가 결국에는 우리가 사용하고 있는 future가 미래죠 미래의 결과물을 반환해줄 거라 약속을 해줘라고 지금 부탁을 하고 있는 겁니다 STD 프러미스는 어떻게 보면 일종의 약속이라고 볼 수가 있겠어요 뭐 약간 계약서 같은 느낌이죠 그래가지고 이 프러미스는 다른 슬레드한테 넘겨줄 것이고 이 Future는 우리가 갖고 있을 겁니다 마치 계약서를 두 장을 만들어가지고 한쪽은 다른 사람한테 넘겨주고 한쪽은 내가 갖고 있는 그런 느낌이죠 그래가지고 만약에 이 상태에서 새로운 슬레드를 우리가 만들어준다고 가정을 하고 새로운 스레드를 만들어 준 다음에 여기서 이 프러미스를 반쪽짜리를 딴 애한테 , 이렇게, 무브를 시켜서 얘한테 소유권을 넘겨 주도록 할게요 그러면 이 Future는 메인 스레드가 갖고 있는 것이고 이 Promise는 여기 만들어 준 두번째 워커 스레드가 이 두번째 스레드가 갖고 있을 겁니다 그래서 이 상태에서 이 두번째 스레드가 여기서 Promise Set Value를 통해 가지고 데이터를 빵 입력을 하게 되면은 그거를 우리가 인지해가지고 Future Get을 통해 가지고 받아올 수가 있게 된다고 보시면 되겠어요 요렇게 네 그래서 뭐 요런 느낌으로 cout 메시지를 출력을 하게 되면은 그 다음에 얘를 땅 컨트롤 F5 실행을 해보면 , 자, 이런 식으로 Secret Message가 잘 출력이 되는 걸 볼 수가 있습니다 결국에는 여러 스레드끼리 뭔가 통신을 하고 결과물을 받아주고 해야 될 때 , 이렇게, 지저분하게 전역변수를 이용하기보다는 이런식으로 promise future 짝을 맞춰가지고 이 promise 에다가 데이터를 넣어주고 그걸 우리가 future 객체를 통해 가지고 받아주는 형태로 일단 동작을 하게 만들어줄 수 있다는 얘기가 되는 거죠 여기서 이제 브레이크 포인트를 잡아가지고 다시 한번 살펴보면은 여기까지는 프로미스랑 퓨처가 둘 다 펜딩 상태입니다 근데 여기서 Move를 해가지고 소유권 자체를 다른 스레드한테 넘겨줬기 때문에 이제 이 프로미스는 Empty 상태이고 이제 이 메인 스레드에서는 얘를 더 이상 건드리면 안 되는 상태가 됐고요 그 다음에 퓨처 갯을 빵 때리는 순간에 데이터가 메시지에 , 이렇게, 넣어지게 되면서 퓨처도 이제 Empty가 되는 걸 볼 수 있습니다 진짜로 , 이렇게, 한번 데이터를 추출하는 순간 퓨쳐도 더 이상 유효하지 않기 때문에 혹시라도 실수해가지고 퓨쳐캣을 여러번 호출하면 문제가 일어난다는 얘기가 되는 거죠 그래서 퓨쳐캣은 딱 한번만 호출해야 된다는 것도 일단 겸사겸사 알 수 있었습니다 , 이렇게, 해서 Future를 만드는 두 번째 방법에 대해서도 알아봤는데 약간 느낌이 다르죠? 첫 번째 방법은 Calculate라는 비동기 방식으로 실행할 함수를 , 이렇게, 간단하게 만들어주고 그 다음에 그 결과물을 우리가 Future 객체에서 Get을 통해서 추출할 수 있는 거였고 두번째 방법에서는 이 Promise라는 어떻게 보면 Future를 세팅할 수 있는 그런 창구를 우리가 만들어 준 다음에 그 창구 자체를 다른 쓰레기한테 소유권을 넘겨줘 가지고 걔가 Promise에 세팅을 해주면 그걸 우리가 Future 객체로 받아오는 이런 상황이라고 볼 수 있겠습니다 마지막으로 또 하나가 더 있는데요 Packaged Task라고 이름조차 복잡한 애가 하나가 더 있습니다 얘도 이제 뭐 비슷한 느낌인데 , 일단은, 사용 예제를 한번 보도록 할게요. Packaged Tasks. 얘도 마찬가지로 타입을 정해주게 되는데 얘는 , 일단은, 어떤 함수의 시그니처랑 맞춰줘야 됩니다. 예를 들면 우리가 여기는 Calculate라는 것을 다른 Thread에 넘겨준다고 과정을 하면 실행해달라고 의뢰를 한다고 가정하면 캘큘레이트라는 함수가 인풋으로는 보이드를 받아오고 아웃풋으로는 인트64를 받아오고 있으니까 얘를 아웃풋은 인트64 인풋 타입은 보이드 요렇게 , 일단은, 세팅을 해주면 되겠어요 함수 타입이랑 맞춰줘야 된다는 얘기가 되는 거죠 그래서 이 캘큘레이트를 시킬 것이다 라고 요렇게 만들어 줄 것이고 그 다음에 여기서도 마찬가지로 , 자, 요렇게 태스크에다가 getfuture 함수를 이용해 가지고 여기다가 future를 추출해 줄 수가 있어요 , 사실, promise future의 관계랑 여기 package task랑 future의 관계랑 거의 비슷합니다 다만 여기서 promise에서는 그냥 이 타입에 맞는 데이터를 넣어 주세요가 되는 거고 얘는 task는 이 calculate라는 거를 딴 쪽 쓰레기에서 호출해 주세요 라는 요청을 우리가 일감이라는 단위로 만들어 준 셈이 되는 겁니다 그런 차이만 있고 그 다음에 여기서 실습을 해보기 위해서 Thread를 만들어줄건데 어.. 이번에는 , 자, 여기서 PromiseWorker가 아니라 TaskWorker라고 , 이렇게, 만들어줄 것이고 PackagedTask를 인자로 , 이렇게, 전달해줄게요 근데 얘도 마찬가지로 소유권을 아예 넘겨줄 것이기 때문에 rvalue 오른값으로 만들어주고 얘가 하는거는 요기에 얘가 받은 요 TaskType을 테스크를 받아가지고 걔를 이제 호출해주게 될 거예요 사실상 어떤 함수를 우리가 어떤 패키지 테스크라는 더 상위 개념으로 묶어가지고 , 이렇게, 전달해준 것이고 얘도 그냥 일반 함수를 호출한 것과 마찬가지로 그냥 , 이렇게, 똑같이 호출할 수 있는 상황이라고 볼 수가 있는 거죠 , 자, 그러면 얘가 이제 함수가 호출한 결과물 자체가 인투 육사를 반환할 것인데 여기서 리턴 값을 받아가지고 뭔가를 하는 개념이 아니라 이 결과물 자체가 , 사실, 이 Future를 통해서 받아올 수 있게 됩니다 이게 하나가 좀 다른 점이죠. 그래서 일반 함수는 원래 캘큘레이터를 호출한 다음에 그 결과물을 이런 식으로 받아주는 게 일반적이었지만 우리가 사용하는 패키지 태스크에서는 결과물 자체가 여기 있는 Future 객체를 통해서 우리가 걔를 받아올 수가 있다는 차이가 살짝 생기게 돼요. 뭐 그 차이 뿐이죠. 만약에 Thread를 새로 만들어준다고 가정할 때 TaskWorker라는 함수를 처음에 엔트리 포인트로 받아줄 것이고 그 다음에 여기다가 Task를 , 이렇게, 전달을 해주면은 실질적으로 이 Thread가 새로 만들어주고 호출을 할 때 이 태스크를 호출해 줄 것이고 그 결과물 자체가 future 갯체에 갯체를 통해 가지고 우리가 추출해 줄 수 있게 됩니다 그래서 만약에 결과가 완료가 된다고 하면은 future 갯을 통해 가지고 똑같이 요렇게 얻어올 수가 있다는 얘기가 되는 거죠 근데 뭐 , 사실, 이거 봐도 이게 다시 사용하는 얘가 굉장히 명확하게 뭐 깔끔하진 않죠 뭔가 Arithmetic하게 사용 방법은 알겠지만 어떤 상황에서 뭘 사용해야 되고 이런 게 살짝 헷갈리긴 하는데 뭐 그건 당연한 겁니다 그래서 이런 식으로 데이터를 받아올 수 있다는 것도 , 일단은, 알 수가 있었고요 결국에는 요약을 잠시 해보자면은 우리가 오늘 알아보는 내용이 뭘 하는 거냐면은 Mutex나 조건변수, Condition Variable까지 가지 않고 뭔가 단순한 애들을 처리할 수 있는 그런 방법에 대해서 알아보고 있는 겁니다 특히나 얘네들이 어쩔 때 유용하냐고 하면은 일회성으로 한 번만 딱 일어나는 그런 이벤트에 대해서 굉장히 유용하다고 볼 수 있는 거죠 우리가 이전 시간에 알아본 Q에다가 계속 데이터를 밀어넣고 추출하는 것은 무한 루프를 돌면서 계속 일감이 진행되는 거였지만 그게 아니라 한 번만 호출해줘서 그 결과만 한 번만 받아와야 되는 상황으로 한다면 굳이 컨디션 웨어블까지 가지 않고 이런 식으로 Future 객체를 통해 가지고 받아오는 게 굉장히 유용하다는 걸 알 수가 있습니다 물론 이제 그 Future 객체를 어떻게 만들어주는지는 상황에 따라 가지고 달라지게 되는 거죠 어떤 함수를 그냥 비동기로 뿅 실행을 시켜 줄 것이냐 아니면은 그 결과물 자체를 그냥 프로미스에다가 받아 줄 것이냐 등등의 차이라고 , 일단은, 볼 수 있겠습니다. 패키지 테스크는 사실상 프로미스랑 굉장히 비슷하긴 하죠. 1번 여기서 그럼 에이싱크로 캘큘리트를 딱 넘겨주는 것이랑 3번째 패키지 테스크랑 어떤 차이가 있는지 이것도 헷갈리게 쓰고 있는데 얘를 유심히 보면은 이 방식은 사실은 스레드를 하나를 만들어 가지고 캘큘리트를 우리가 시킨 셈이 되는 겁니다. 그러니까 이 캘큘레이터라는 일감 하나를 처리하기 위한 전용 스레드를 만들어 가지고 우리가 딱 떠넘긴 상태라고 한다면 얘 같은 경우에는 , 사실, 꼭 , 이렇게, 한 번만 하는 게 아니라 이 스레드를 만든 다음에 실질적으로 우리가 이 태스크를 여러 개를 만들어주고 계속 건네줄 수도 있겠죠 물론 지금 방식에서는 우리가 태스크 워커라는 간단하게 여기서 요 함수 내부에다가 인자로 하나만 받고 있지만 그게 아니라 이거를 뭐 다른 방식으로 여러 개의 태스크를 만들어 가지고 쭉 전달하는 방식으로도 똑같이 응용해서 만들어 줄 수가 있을 겁니다 약간 미묘한 차이가 있는 거죠 얘는 일단 이미 존재하는 스레드를 대상으로 이런식으로 일감이라는 개념을 만들어 가지고 떠넘겨 준 다음에 그에 대한 결과물을 Future로 받아주는 그런 방식이라고 볼 수 있는 거고 반면 첫번째 방법 Async로 만들어 준 방법은 그 자체로 하나의 간접적인 Thread를 만들어 가지고 결과를 받아주는 그런 미묘한 차이가 있습니다 뭐 그건 그렇고 어찌됐건 요렇게 세가지 방법 중에서 , 일단은, 하나를 사용할 수 있다는 걸 , 일단은, 간략하게 알 수 있었습니다 그래서 특히나 한번 단발성으로 한번 발생하는 이벤트에 유용하다라는 걸 일단 알 수가 있었던 거죠 삼국지에서 그 명언 있죠 닭 잡는데 소 잡는 칼을 쓸 필요 없다 이게 뭐 그 화홍이라는 장수가 동탁한테 했던 뭐 그런 걸로 기억을 하는데 그러니까 결국에는 너무 여러가지 방법이 있는데 굳이 , 이렇게, 최종적으로 좀 복잡한 방법을 사용하기 전에 간단하게 어 뭔가 한 번만 일어나는 그런 동기화를 해야 되는 상황이 있다고 하면은 요런 방식의 Future와 객체를 이용해가지고 하는 방식도 굉장히 유용하다라는 걸 일단 알 수가 있는 겁니다 그래서 결국에는 첫번째 async를 이용해가지고 만드는 미래 객체 future는 원하는 함수 하나를 비동기적으로 실행한다라는 개념이 되는거고 두번째인 promise같은 경우에는 약간 약속을 한다 계약서를 받는 느낌이라고 했었죠 결과물을 우리가 promise를 통해서 future로 받아주는 요런 느낌이라고 볼 수 있었고 마지막으로 packaged task는 어떻게 보면은 promise는 promise인데 어떤 함수를 우리가 뭐 건네주는 그런 느낌이라고 볼 수 있겠습니다. 그래서 원하는 함수의 실행 결과를 뭔가 패키지 데스크를 통해서 다시 퓨처로 받아주는 이런 상황이라고 볼 수 있겠어요. 그래서 뭐 결국에는 , 사실, 프로미스랑 패키지 테스크는 뭐 아까도 말씀드렸지만 , 사실, 이거를 실전에서 제가 사용하는 걸 본 적은 없어요 이게 뭐 그렇게 자주 사용해야 될 일은 없지만 이 에이싱 같은 경우는 뭐 종종 사용할 일이 생길 수도 있겠죠 그냥 단순하게 우리가 굳이 이미 있는 스레드한테 얘를 만들어주는 게 아니라 그냥 관리하기 싫지만 그냥 약간 단계 알바 식으로 잠시만 다른 스레드 누군가가 얘를 실행해가지고 결과물을 합치고 싶은 경우가 생긴다고 했을 때 이 Future 객체를 이용하는 게 은근히 유용하다는 걸 알 수가 있었습니다 , 자, 이렇게, 해가지고 , 사실, 중요도는 조금 떨어지지만 그럼에도 불구하고 경우에 따라서 유용하게 사용할 수 있는 그런 Future라는 기능에 대해서 , 일단은, 알아봤고요 이름 그대로 언젠가 미래의 결과물을 뱉어줄 것이다 라는 그런 기능을 하고 있었던 걸 알 수 있었습니다 그리고 혹시나 이것도 약간 걱정이 돼서 다시 한번 말씀을 드리지만 여기서 얘기하고 있는 비동기라는 것 자체가 멀티스레드랑은 동일한 개념이 아닙니다 비동기는 비동기로 호출이 된다고 하면 경우에 따라서 멀티스레드로 호출이 될 수도 있겠지만 만약에 우리가 얘를 디퍼드로 놨으면 디퍼드로 놔두고 가면 그냥 신행 시점이 뒤로 밀렸다는 얘기가 되는 거지 멀티스레드라는 의미는 아니라고 했었죠 그러니까 비동기랑 멀티스레드도 어느 정도 개념을 잘 구분해서 이해를 해주시고 정리를 잘 해주시면 되겠습니다 , 자, 이렇게, 해가지고 조금 헷갈리는 내용이었지만 그래도 간단하게 필처에 대해서 알아보고 , 일단은, 마치도록 할게요.