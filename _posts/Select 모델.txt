자, 이어서 오늘은 여러가지 소켓 입출형 모델 중에 가장 기초가 되는 셀렉트 모델에 대해서 알아보도록 할 건데요 일단 지난 시간까지 얘기했던 블록킹과 논블록킹에 대한 내용은 어느정도 숙지가 되셨기를 바라고요 결국에는 논블록킹이란 자체가 필요하긴 한데 무조건 논블록킹으로 소켓을 바꾼다고 해서 만병통치약처럼 모든 문제가 해결이 되지 않는다는 것도 실습을 해봤습니다 결국에는 준비가 되지 않았는데 괜히 함수를 호출하고 그리고 바로 리턴시켰더니만 그게 오히려 더 역효과를 보고 쓸데없이 , 이렇게, 무한 루프를 돌게끔 그리고 CPU를 낭비하게끔 했다라는 게 지난번의 결론이었죠 그러면 결국에는 논블록킹 소켓을 사용을 하되 준비되었을 때를 우리가 미리 파악할 수 있도록 하면 어떨까라는 생각이 드는데 그게 이제 , 일단은, 오늘 알아볼 셀렉트 모델의 컨셉이라고 보시면 되겠습니다 , 자, 일단은, 지난번까지 만들었던 부분 중에서 여기부터 우리가 진행을 해보도록 할게요 여기서 여기까지 삭제를 하고 어차피 소켓을 , 이렇게, Ioctl 소켓을 호출을 해가지고 논블록킹으로 만들고 바인드 리슨까지 하는건 어차피 똑같으니까 여기부터 이제 진행을 해보도록 하겠습니다 그래서 굉장히 다양한 그런 입출력 모델이 있는데 가장 기초가 되는 셀렉트 모델에 대해서 알아볼 거고 얘가 셀렉트 모델이라고 불리는 이유는 그냥 셀렉트 함수가 핵심이 되는 그런 모델이기 때문입니다 그리고 나중에 가면은 결국엔 우리가 게임서버를 만들때 통상적으로 이제 IOCP로 만들게 될거에요. 그러면은 바로 쓸데없는 시간 낭비하지 않고 그냥 IOCP만 공부하면 안될까라는 생각이 들긴 하지만 서버 입장에서는 그게 맞을 수도 있기는 해요 근데 이런 나머지 방법들도 알아야 되는 게 교양 차원에서 알아야 되는 것도 있지만 어차피 나중에 클라도 네트워크 연동을 해가지고 서버한테 붙어야 되겠죠 그런데 클라이언트는 솔직히 자기 자신만 처리해 가지고 서버랑 1대1 통신만 하면 되는 거지 그렇게 몇천 명의 동제벌 처리할 필요가 없다 보니까 굳이 그렇게 IOCP 라거나 굉장히 고급 기법까지 갈 필요가 없어요 뭐 그냥 파리 한 마리 잡는데 바주카 포를 날릴 필요는 없겠죠 그러다 보니까 클라에서는 아직도 뭐 셀렉트 모델 이라거나 다양한 그런 방식을 이용해 가지고 간단하게 비동기로 붙을 수 있는 어 그런 방법을 이용하게 되는데 그런 차원에서라도 이제 오늘 그리고 나중에 계속 배울 다양한 이런 입출력 모델들이 굉장히 유용해진다 라고 보시면 되겠습니다 , 자, 그리고 셀렉트 모델은 참고로 얘는 윈도우즈에도 존재하고 리눅스에도 똑같이 존재합니다 함수가 조금 뭐 다르긴 한데 거의 한번 하나를 공부하면은 나머지에도 금방 적응할 정도로 별 차이가 없다고 일단 보시면 되겠어요 , 자, 그래서 셀렉트 모델을 간단하게 실습해보자면 , 일단은, 얘는 컨셉은 소켓 함수 후출이 성공할 시점을 일단 미리 알 수 있다라는게 핵심입니다 소켓함수 호출이 성공한다는 의미가 무엇이냐 , 사실, 우리가 지금까지 문제 상황이 됐던 것 자체가 수신 버퍼에 데이터가 없는데 괜히 우리가 모르고 그냥 리드를 때린다거나 리드 한다거나 아니면은 거꾸로 송신 버퍼가 꽉 찼는데 혹은 상대방의 수신 버퍼가 차가지고 우리가 송신 버퍼를 비울 수가 없는데 괜히 라이트를 한다거나 하는 상황에서 이게 블록킹 계열의 그런 소켓이었으면 여기서 대기를 타게 될 것이고 아니면은 논블록킹이라고 하더라도 통과는 되지만 여기서 (WSA)EWOULDBLOCK이라고 그냥 또 대기를 타는 그런 상황이 발생했었습니다 , 자, 그러면은 거꾸로 말을 하면 우리가 이제 오늘 사용할 셀렉트 모델에서는 꼭 셀렉트 모델이라고 해가지고 논블록킹에서만 사용할 수 있는 건 아닙니다 그냥 이 방식은 기본적으로 성공할 실점을 미리 엿본다는 게 핵심이지 이게 블록킹이고 논블록킹은 딱히 상관이 없어요 양쪽에다가 응용할 수 있습니다 만약에 우리가 블록킹 소켓의 대상으로 이 셀렉트 모델을 적용하면은 조건이 만족되지 않아서 블록킹 되는 상황을 우리가 예방할 수 있을 것이고요 거꾸로 만약에 논 블록킹 소켓이었다고 하면은 조건이 만족되지 않아서 불필요하게 반복 체크하는 상황을 일단 예방할 수 있다는 장점이 생깁니다 즉 얘는 어떤 함수를 호출하기 이전에 샌드나 리시브를 하기 이전에 진짜로 그 샌드랑 리시브를 할 수 있는지 여부를 먼저 체크한다는 게 일단 핵심이에요 , 자, 그 다음에 이거를 이제 사용하는 방법은 비교적 간단한데 , 일단은, 소켓 세트라는 걸 이제 만들어 주게 될 겁니다 세트 뭐 세트 이라고 하는게 나을 것 같네요 , 자, 읽기 쓰기 그리고 예외 , 이렇게, 관찰 대상을 등록을 합니다 세트라고 해가지고 그냥 묶음이라고 보시면 돼요 약간 배열같이 그냥 여기다가 소켓을 막 넣어 줄 거고 여기도 넣어 줄 거죠 여기도 넣어 줄 건데 물론 세 개를 동시에 다 사용해야 되는 건 아니고 우리가 어떤 소켓을 대상으로 그런 일기와 관련된 성공 시점을 체크하고 싶다 관찰하고 싶다 라거나 아니면 쓰기와 관련된 부분을 관찰하고 싶다 하는 여부에 따라 가지고 둘 중 하나에 넣어주거나 아니면 양쪽에다가 넣어주거나 하는 식으로 내가 원하는 관찰을 해주면 됩니다 , 자, 근데 솔직히 이거 말하면 좀 까다롭긴 한데 나중에 이제 예를 보면 좀 그렇게 어려운 부분 아닙니다 읽기 쓰기는 알겠는데 그러면 이 예외는 무엇을 의미하는 것이냐 , 사실, 뭐 우리는 거의 쓸 일이 없을 거예요 이게 뭐 out of band라는 건데 우리가 샌드를 원래 할 때 마지막 인자를 뭐 딱히 설정해준 적이 없는데 경우에 따라서 이거를 , 이렇게, msg 언더바 oob로 설정할 수가 있어요 특별한 데이터가 됩니다 그러면은 받는 쪽에서도 받는 쪽에서도 똑같이 리시브를 할 때 oob 세팅을 해야 이 해당 데이터를 받을 수가 있습니다 그래서 이거는 약간 긴급 상황을 알리는 좀 특이한 상황을 알리는 그런 용도로 사용하는데 뭐 솔직히 우리는 딱히 사용할 일 없을 테니까 얘는 그냥 없다고 무시를 하셔도 됩니다 그래가지고 일단 읽기랑 쓰기 이 두 가지 정보를 채워 줘 가지고 관찰 대상을 등록한다고 , 일단은, 보시면 되겠어요 그래서 여기서 이 소켓셋을 만들어 가지고 읽기 쓰기 중 하나를 뭔가 열심히 등록을 한 다음에 그 다음에 셀렉트 함수를 빵 때리게 됩니다 여기서 이 리드 세트랑 라이트 세트랑 그리고 이 익셉션 세트 여기서 이 삼총사를 , 사실, 여기서 인재로 받고 있는데 꼭 세 개를 다 넣어줄 필요는 없고요 우리가 만약에 리드랑 라이트만 사용할 것이면 나머지는 널 포인터로 그냥 밀어주면 됩니다 그래서 이제 셀렉트를 딱 시작을 하면은 얘가 이제 실질적으로 관찰을 시작합니다 관찰을 시작을 해가지고 이제 우리가 여기다가 관찰 대상으로 등록한 애들 중에서 최소 하나라도 준비가 되면 그제서야 얘가 리턴을 합니다 즉 적어도 하나의 소켓이 준비되면 리턴한다 그리고 재밌는 게 나고자는 알아서 제거됩니다 이게 무슨 말이냐면 예를 들면 우리가 소켓이 1 2 3 이라는 소켓을 대상으로 리드를 하고 싶은데 그냥 쌩으로 리드를 때리면 , 사실, 리드할 수 있는 상황이 아니다 수신버퍼에 데이터가 없어서 이런식으로 블록킹이건 논블록킹이건 굉장히 안좋은 상황이 발생할 수 있죠 그러니까 이 1,2,3에 대한 소켓을 다 여기 소켓 셋에다가 등록을 한 다음에 체크를 하고 싶은 겁니다 지금 읽을 수 있는 상황인지 즉 결국에는 수신버퍼에 데이터가 있는지를 체크한다는 얘기가 되는 거죠 그래가지고 이 상태에서 셀렉트를 빵 때려주면은 이제 얘네들을 관찰하기 시작을 하다가 이 중에서 딱 하나라도 정말로 준비된 상태가 된다면 예를 들면 2번이 2번 소켓에 뭔가 데이터가 와가지고 수신 버퍼가 찼다고 가정을 하면은 이제 바로 셀렉트가 반환을 해주면서 이 중에서 준비된 애들의 개수를 반환해주게 될 겁니다 예를 들면 2번만 준비됐으면은 1을 리턴해주게 되겠죠 그리고 또 재미있는 것은 나고자는 알아서 여기서 제거가 됩니다. 삭제가 , 이렇게, 될 거에요. 우리가 매번 마다 얘를 채워 준 다음에 셀렉트를 때리는 식으로 반복을 해줘야 됩니다. 결국에는 , 이렇게, 해서 최종적으로 남은 애는 읽을 수 있는 상태가 된 거니까 여기 있는 소켓이 누가 누가 있는지를 체크해 가지고 그 아이 대상으로 우리가 리드를 빵 때려주면은 이미 걔가 리드할 수 있는 상황이라는 걸 우리가 체크한 다음에 실질적으로 작업을 진행하기 때문에 그렇게 불필요하게 대기를 한다거나 아니면은 불필요하게 반복 체크하면서 이 우드 블럭이 뜨는 그런 상황을 예방할 수 있게 됩니다 남은 소켓 체크해서 진행 약간 이런 순서로 되어 있어요 이게 말로 하면 좀 어려운데 예제 코드를 보면 굉장히 단순합니다 , 자, 그리고 여기 있는 소켓 셋을 다룰 때는 일단 만들 때는 대략적으로 이런 느낌으로 만들어요 fd set 이라는 걸 만들어 줘야 됩니다 예를 들면 우리가 리드셋을 만들어 줄 거면 리드셋 아니면 라이트셋 이라는 이름으로 지어주면 편리하겠죠 그 다음에 여기다가 설정을 해줄 때 그냥 우리가 멋대로 비트 플래그 같은 거를 우리가 직접 조립해 가지고 만들고 하면 너무 어려우니까 준비된 애들이 다 있습니다. FD0라는 애를 이용해 가지고 , 이렇게, 하면 4가지를 외우면 됩니다. FD0 를 이용해 가지고 , 일단은, 비우는 작업을 할 수가 있구요 사용 예제가 요렇게 되는 거죠 그 다음에 FD Set 을 하면은 소켓 모시기 모시기를 넣는다라는 작업을 할 수 있습니다 예를 들면은 , 자, 얘를 이름을 지금 S 라고 할게요 Set 라고 할게요 Set 그러면 FD Underbar Set 을 한 다음에 우리가 넣어줄 소켓을 요렇게 넣어주고 뒷 인자로 Set 를 요렇게 넣어주게 되면은 지금 관찰 대상에 우리가 추가하는 소켓이 들어가게 됩니다 그리고 거꾸로 클리어를 해가지고 소켓 S를 제거할 수도 있어요 얘는 역시나 FD 언더바, C 클리어, S 세트 이런 식으로 사용할 거고요 마지막으로 최종적으로 남은 소켓들 중에 몇 번째 소켓이 있느냐 여부를 확인하고 싶을 때 fd under bar is set 라는 걸 이제 활용하게 됩니다 소켓 s 가 s 세트에 들어 있으면 0이 아닌 값을 리턴한다 라고 일단 보면 되겠어요 없으면 0을 리턴하겠죠 그래서 일단 순서는 , 이렇게, 1 2 3 4로 되고 요런 함수들을 이용해 가지고 작업을 한다 라고 , 일단은, 결론을 내릴 수가 있구요 이제 이거를 이어가지고 간단하게 한번 사용을 해 보도록 하겠습니다 , 자, 오늘 사용할 셀렉트 모델은 게임 서버 쪽에만 적용을 시켜 주도록 할게요 뭐 어차피 클라랑 서버랑 대칭적이다 보니까 얘는 그냥 안 건드리고 서버 쪽에다가만 , 일단은, 넣어 보도록 하겠습니다 , 자, 그리고 잠시 위에 가 가지고 구조체 하나를 만들어 주도록 할 건데 Session 이란 이름으로 구조체를 하나 만들어 주고 여기다가 어떤 소켓에 대한 정보를 받아 줄 거고 Receive Buffer를 만들어 주도록 할 거고 하는 김에 버퍼 사이즈를 대충 한 100... 1000 바이트라고 할까요? 그냥 1000 바이트로 설정을 해주도록 할게요. 요렇게 초기화도 해주고 그 다음에 Receive Byte도 적용을 할 것이고 Send Byte도 , 이렇게, 추적을 하도록 할게요. Invalid Socket으로 초기화를 하고 , 자, 이게 나중에 클라가 서버에 접속을 하게 되면은 어, 그걸 이제 Session이라는 그런 구조체를 이용해가지고 우리가 정보를 관리하게 될 겁니다. 그래가지고 이 세션이 말 그대로 동접수만큼 세션이 생기게 되겠죠 5000명이 접속하면 세션도 5000개가 생겨가지고 각각의 그 클라이언트에 대해서 쇼켓과 자기 자신의 리시브 버퍼 등등이 , 이렇게, 들어가게 될 겁니다 그래서 요런 상태로 우리가 한번 만들어 보도록 하겠습니다 물론 지금 어차피 1대1 통신이다 보니까 뭐 이렇게까지 해야 될 필요가 있나 싶지만 데이터가 많다고 가정을 하고 코드를 만들어야지 이 셀렉트 모델이 조금 더 보기 쉬워 가지고 그렇게 한번 만들어 보도록 할게요 그 다음에 여기다가 , 일단은, 이 세션을 관리하는 벡터를 하나를 간단하게 만들어 보도록 할게요 그 다음에 뭐 나중에 가면 이거를 뭐 리셀프 해가지고 충분한 크기로 , 일단은, 이렇게, 잡아주는 게 좋겠죠 불필요한 복사를 막기 위해서 , 자, 그 다음에 여기서 보면은 먼저 우리가 추적하고 싶은 관찰 대상이 읽기랑 쓰기 , 이렇게, 두 가지가 있을 겁니다 그러니까 , 일단은, 그 셋을 만들어 주도록 할게요 리드 그 다음에 라이트라고 요렇게 일단 두 개를 만들어 주도록 하겠습니다 그 다음에 무한 루프를 돌 것인데 계속 뱅뱅이를 돌 것인데 먼저 해야 되는 거는 소켓 셋 초기화 작업을 해야 됩니다 이거를 매 루프마다 초기화를 해줘야 돼요 그래가지고 아까 초기화를 할 때는 FD0라는 걸 이용해서 한다고 했었죠 리드셋도 초기화하고 그 다음에 라이트셋도 , 이렇게, 초기화를 해주도록 하겠습니다 그 다음에 맨 처음에 우리가 해야 되는 것은 Listen Socket을 등록을 해주도록 할게요. FD 언더바 Set 그 다음에 Listen Socket을 등록하고 싶다. Listen에서 이제 그러면 리드에다가 등록을 해야 되냐 라이트에다가 등록을 해야 되냐는 조금 헷갈리는데 Listen이 이제 얘가 듣고 있는 거죠. 억셉을 할 대상이 있는지를 얘가 지금 기다리고 있는 건데 그럴 때는 이걸 리드에다가 넣어 줘야 됩니다 그래가지고 얘는 조금 헷갈릴 수 있지만 , 일단은, 리드에다가 넣어 줘야 된다 리드 쪽 셋에다가 얘를 집어 넣어서 등록을 해 주도록 하고 그 다음에 이어서 나머지 소켓들도 다 하나씩 등록을 해 주도록 하겠습니다 세션에 지금 등록되어 있는 나머지 소켓 등록을 하고 있어요 근데 여기서 등록을 뭐 얘가 이제 리드를 할 차리냐 라이트를 할 차리냐에 따라 가지고 둘 중 하나에다가 등록을 해줄 건데 , 일단은, 이 Receive Byte랑 Send Byte라는 거를 비교해 가지고 Receive Byte가 더 작거나 같으면은 얘를 리드 쪽에다가 등록을 해주도록 할게요 read 그리고 else라고 하면은 얘를 write 쪽에다가 등록을 해주도록 하겠습니다. 이거는 왜 , 이렇게, 하냐면은 우리가 지금 하고 있는게 약간 에코 서버 같은 느낌이죠? 얘가 이쪽에서 클라에서 데이터를 보낸 다음에 보낸 데이터를 다시 쏴주는 작업을 하게 될 겁니다. 그러니까 먼저 데이터를 받았는지를 체크해야 되는데 데이터를 받았으면 우리가 얼마 데이터를 받았다는 걸 receive byte를 설정을 해주게 될 거예요. 그러면 그 바이트만큼을 얘가 데이터를 보내기를 대기를 해가지고 다 보낸 다음에 그 다음 데이터를 받는 식으로 이제 이어서 작업을 할 것이기 때문에 이 두가지 변수를 이용해가지고 얘가 지금 읽어야 되는 상태인지 아니면은 라이트를 해야 되는 상태인지를 판별을 해주게 될 겁니다. 그리고 이건 지금 당장 이해가 안가도 나머지 코드를 보면은 이제 이해가 가실 거예요. , 자, 그 다음에 여기서 이제 모든 소켓들이 다 등록이 되었죠 매번 마다 제로로 밀어준 다음에 여기다가 이런 식으로 read, write에 대해서 우리가 , 이렇게, 등록을 해놨으니까 그 다음에는 무엇을 한다? 셀렉트를 빵 때리라고 했었죠 셀렉트를 때리는데 우선은 첫 번째 인자는 그냥 0으로 넣어 주시면 되고요 얘는 이제 리눅스 쪽이랑 인자를 맞추기 위해서 들어간 거고 사실상 윈도우에서는 사용하지 않는다고 보시면 되고 그 다음에 fdset, read, write, accept 세 가지를 넣어 줄 수 있는데 우리는 지금 두 개만 사용하고 있으니까 read 라이트 그 다음에 널피티알 또 널피티알 , 이렇게, 넣어주도록 할게요 여기서 마지막 인자 같은 경우에는 타임밸류라고 해가지고 옵션으로 넣어줄 수 있는데 마지막 타임아웃 인자 설정 가능 얘가 하는 역할은 대기시간을 우리가 설정할 수 있어요 그러니까 셀렉트를 만약에 , 이렇게, 마지막 인자를 안 넣어주게 되면은 얘가 하나라도 준비된 애가 있을 때까지 무한 대기를 하게 될 것이고 그게 아니라고 하면은 우리가 타임아웃을 , 이렇게, 적용을 시켜 줄 수가 있습니다 타임 벨류 여기서 뭐 점을 찍어 보면은 tv 언더바 세크랑 tv on the bar, usec , 이렇게, 두 개를 설정할 수가 있는데요 각각 초랑 마이크로 세컨드 단위로 두 개를 , 이렇게, 입력할 수 있습니다 몇 초, 몇 마이크로 세컨드 얼마만큼을 기다릴 것인가를 세팅해가지고 요 아이를 여기다가 이제 넣어주면은 셀렉트가 무한 대기를 하지 않고 우리가 기다리는 시간을 설정할 수가 있습니다 근데 지금은 , 일단은, 그냥 무한 대기를 하도록 할게요 뭐 딱히 상관없으니까 그 다음에 얘가 그러면 이제 뭐 하나라도 준비가 된 애가 있으면은 리턴을 해주게 되면서 이 리턴 밸류를 체크해가지고 보면 되는데 혹시라도 얘가 뭐 마이너스 3이다라고 하면 좀 이상한 상황이니까 브레이크를 하고 어 그 다음에 이제 이어가지고 이 숫자가 뭐 당연히 0보다 큰 수조이긴 하겠지만 그렇다고 해가지고 어떤 애가 준비되었는지는 또 알지 못합니다 그거는 바로 알 수는 없고 여기 Ease Set라는 걸 이용해 가지고 다시 한번 어떤 소켓이 이 Set에 들어가 있는지를 체크를 해야 됩니다 이 셀렉트를 할 때 굉장히 중요한 것은 여기서 빠져나온 다음에 적합하지 않은 낙오자들을 다 알아서 그냥 제거를 해버린다고 했었죠 그러니까 실질적으로 얘가 호출이 된 다음에 여기 리드랑 라이트에 남은 애들은 아직까지 삭제되지 않았다는 얘기는 결국 준비가 되었다라는 애들이라고 볼 수가 있겠어요 그래가지고 이제 그 준비된 A인지를 체크를 하면 된다는 얘기가 되는 거죠 먼저 우리가 리스너 소켓을 체크를 할 건데 리스너 같은 경우는 이제 리셋 소켓이어가지고 억셉트를 할 준비가 되었는지를 체크하는 애라고 보시면 되겠습니다 그래가지고 fd-reset listen-socket이 read 쪽에다가 있느냐를 우리가 체크를 해볼 것이고 만약에 reset이 true다 listen-socket이 아직까지 read라는 이 fd-set에 들어가 있다라고 하면 얘가 준비된 상태이니까 즉 accept를 할 준비가 됐다라는 의미가 되는 거니까 누군가가 클라가 커넥트 요청을 했다라는 상황이 되는 거죠 그러면 여기다가 속 어드레스 인을 이용해 가지고 우리가 늘 하던 대로 클라이언트를 이제 받아 주도록 할게요 사이즈 오브 클라이언트 어드레스 그 다음에 소켓 클라이언트 소켓을 받아 줄 건데 억셉트를 호출해 가지고 리슨 소켓을 넣어주고 그리고 리슨 소켓 그 다음에 속 어드레스 포인터로 클라이언트 어드레스랑 어드레스 렌스를 , 이렇게, 각각 넣어주면 됐었죠 그럼 원래 같은 경우라면은 이제 이 클라이언트 소켓이 만약에 우리가 그냥 생으로 요런 식으로 셀렉트 모델을 사용하는 게 아니었으면 얘가 진짜로 성공적으로 받았는지 안 받았는지 막 그거를 또 체크해야 됐었죠 이런 에러 같은 건데 지금은 그런 게 아니라 이 셋이 설정되어 있다는 건 무조건 얘가 성공한다는 걸 우리가 지금 가정할 수가 있을 겁니다. 근데 뭐 혹시 모르니까, 인베리 소켓이 아닐 때만 진행을 해보도록 할게요. 클라이언트, 커넥티드. 드디어 누군가가 들어왔다 라고 신나게 로그를 , 이렇게, 찍어보고 그 다음에 얘가 들어왔으니까 이제 이 소켓을 세션에다가 등록을 해주도록 할 겁니다. 푸쉬백 해가지고 세션을 만들어가지고 첫 번째 클라이언스 소켓을 , 이렇게, 전달해서 넣어 주도록 할게요 우리 세션을 , 이렇게, 4개를 만들어 놨으니까 나머지는 다 초기 값으로 하고 여기다가 소켓을 전달해 줘 가지고 이 세션이라는 걸 만들어 준다고 보시면 되겠습니다 그래서 처음에 리스너 소켓부터 먼저 체크를 했고요 근데 그 다음 턴부터는 이 세션에 들어가 있는 애가 같이 여기 소켓 등록에 들어가게 될 테니까 이 리슨 소켓 뿐만 아니라 새로 추가된 요런 애들도 같이 지금 이 리드셋에 들어가 있을 겁니다 그러니까 나머지 소켓을 대상으로도 체크를 할 건데 나머지 소켓은 사실상 우리가 리드나 라이트를 해주게 될 거죠 그래서 여기서 이제 하나씩 체크를 해볼 건데 이거 session 하나씩 하나씩 돌도록 할게요 sessions 에다가 하나씩 돌면서 session 마다 체크를 할 건데 만약에 fd is set 소켓이 리드할 준비가 되었느냐를 체크해 가지고 만약에 true 라고 하면은 리드를 바로 , 이렇게, 때려주면 되겠죠 그러면 소켓 리시브 버퍼에다가 우리가 데이터를 넣어놨을 테니까 여기다가 리시브를 해줘라 우리가 준비한 버퍼에다가 버프 사이즈 만큼을 최대 긁을 수 있다고 해가지고 , 이렇게, 리시브를 해주게 되면은 얘가 실질적으로 받은 데이터 크기만큼을 리시브 렌스로 받아주게 될 겁니다 그러면은 이거를 리시브 렌스가 만약에 0보다 작다라고 하면은 뭔가 문제가 있는 상황이겠죠 연결이 끊긴 상황일 테니까 여기서는 나중에 2도 Sessions에서 얘를 제거해주면 될 겁니다 근데 지금은 해주지 않을게요 우리가 그냥 , 이렇게, Form을 해가지고 루프를 돌고 있다 보니까 여기서는 제거하지 않겠지만 나중에 가면은 여기서 더 이상 연결이 끊긴 애는 추적할 필요가 없으니까 이 Session 벡터에서 날려주면 되겠습니다 그 다음에 여기까지 왔으면 이 Receive Byte를 여기다가 , 이렇게, 저장을 해주도록 할게요. 이만큼을 받았다라고 기억을 해주는 거죠. 그러면 그 다음 턴에서는 얘가 이제 보낼 데이터가 있다는 얘기가 되는 거니까 이제 이 라이트 쪽으로 얘가 세팅이 되어 가지고 라이트를 시도하게 될 겁니다. 그래서 이어가지고 이제는 아이고 여기가 아니라 이쪽 안에서 얘는 원래 리드를 하려던 애들을 다 체크를 하는 거고 이쪽은 리드 체크 그 다음에 이어가지고 라이트 체크도 해야 되겠죠 이제 내가 데이터를 이전 턴에 받아가지고 다음 루프에서 내가 데이터를 보내라고 하면은 거꾸로 fd is set 이라고 한 다음에 소켓이 라이트 쪽에 들어가 있을 겁니다 그래서 라이트셋을 체크를 해본 다음에 만약에 얘가 True라고 하면은 내가 데이터를 쓸 준비가 되었다는 얘기가 되는 거죠. 그러니까 우리의 송신 커널 버퍼가 어느 정도 비어 있어가지고 거기다가 데이터를 복사할 준비가 되어 있다라고 볼 수가 있는 겁니다. 그러면 사실상 요 안으로 들어오면은 만약에 우리가 블록킹 소켓을 이용하고 있었으면은 , 일단은, 샌드를 호출해야 되겠죠. 샌드를 호출할 건데 여기다가 이 소켓을 대상으로 , 자, 이제 데이터는 어디에 있느냐면은 Receive Buffer의 Send Bytes만큼을 접근을 할 것이고요 Receive Bytes 마이너스 Send Bytes 그리고 0을 , 이렇게, 해주도록 할게요 , 자, 이건 왜 그런지 이어서 설명이 나올 건데 우리가 지난번에는 제가 이걸 굳이 언급을 안 했지만 이 Send를 호출할 때 얘가 뱉어주는 리턴 값이 사실상은 Send를 한 크기를 지금 얘가 뱉어줍니다 근데 이게 블록킹 모드였으면 , 사실, 그냥 기본적으로 모든 데이터를 다 보냅니다. 근데 논블록킹 만약에 소켓이라고 하면은 일부만 보낼 수가 있어요. 상대방 수신 버퍼 상황에 따라서 우리가 설령 100바이트를 보낸다고 요청을 했다 하더라도 상대방이 10바이트밖에 못 받는 상태라고 하면 이게 경우에 따라서 10바이트로 반환이 될 수도 있다는 얘기가 되는 거죠 그러니까 공식 문서에는 그렇게 되어 있어요 근데 실질적으로 이걸 테스트해 보면 그런 상황은 거의 일어나지 않습니다 대부분의 커널 쪽 구현을 할 때 이걸 한 방에 보내게끔 하기 때문에 이런 일은 거의 발생하지 않기는 한데 그럼에도 불구하고 조금 더 FM대로 만들면 요 인트 샌드에서 리턴하는 요 숫자가 더 작을 수도 있다는 걸 알아야 됩니다 여기 보면은 바이트 샌트 내가 보낸 바이트를 반환하는데 내가 처음에 요청한 것보다 작을 수 있다라고 나와 있기는 하죠 그래서 그 부분을 일단 챙겨주기 위해서 얘를 받아주는 것이고요 그 다음에 만약에 샌드랜스가 소켓 에러 마이너스 1이다라고 하면은 뭔가 문제있는 상황이니까 얘도 마찬가지로 세션을 제거하고 이제 뭔가 다른 처리를 해주면 되겠죠 그게 아니라고 하면은 일단 성공적으로 데이터의 일부는 보냈다는 얘기가 되는 거니까 샌드랜스 만큼을 더해 줄 것이고 만약에 Receive Byte랑 Send Byte가 동일해졌다고 하면은 모든 데이터를 다 보냈다는 얘기가 되는 거니까 다시 Receive Byte랑 Send Byte를 0으로 밀어 주도록 할게요 그럼 이제 다음 턴에서는 다시 Receive를 할 상태가 된다는 말이 되는 거죠 그래서 아까 뭐 굳이 얘를 , 이렇게, 설정한 이유는 뭐냐면 내가 10 바이트를 받았다고 해도 이전 턴에 5 바이트만을 받았을 수도 있기 때문에 그거를 추적하기 위해서 나머지 데이터를 보내도록 조작을 해준 겁니다 만약에 내가 이런 식으로 10 바이트를 받아가지고 10 바이트를 보내야 된다는 상황이 있었는데 뭐 어쩌다 보니까 첫 턴에 5바이트밖에 안 보냈다 라고 하면은 이제 데이터를 여기서 이어가지고 나머지 5바이트를 보내야 되겠죠 그래서 그런 부분을 처리하기 위해서 그냥 간단하게 요렇게 만들어 봤어요 근데 뭐 사실상 꼭 , 이렇게, 안 하더라도 별 차이가 느껴지진 않을 겁니다 뭐냐면 얘가 거의 보낸 크기에 따라서 일치하게 일단 나오긴 할 거예요 , 자, 그리고 뭐 요렇게 , 일단은, 코드가 완료가 됐는데 이제 여기서 중요한 건 , 사실, 뭐 이런 자잘한 부분이 중요한 게 아니라 얘를 어떻게 사용하는지를 이제 유심히 봐야 됩니다 내가 관찰하고 싶은 리드 라이트 셋을 각당 , 이렇게, 만들어 준 다음에 처음에 초기화를 하고 매번 마다 이거를 루프를 돌면서 매번 마다 초기화를 하고 등록을 하는 거 반복한다는 거 알 수 있습니다 아니 왜 굳이 이미 등록을 해놨는데 이걸 귀찮게 다시 밀고 다시 등록하냐 그건 왜 그러냐면은 아까 다시 한번 말씀을 드리지만 셀렉트를 호출한 다음에 셀렉트가 호출이 완료되어 가지고 반환이 될 때 나고자는 알아서 제거가 된다고 했습니다 그러니까 우리가 넣어준 리드 라이트가 그대로 항상 유지가 되는 게 아니라 셀렉트가 호출된 다음에 살펴보면은 여기 있는 데이터가 일부가 막 날아갈 수가 있다는 얘기가 되는 거죠 진짜로 생존한 애들 진짜로 우리가 원하는 관찰이 이루어진 애들만 여기서 승자로 남게 되기 때문에 이거를 , 이렇게, 매번 마다 루프를 돌면서 계속 세팅을 하고 있다는 걸 볼 수가 있어요 조금 기어보 코드가 , 이렇게, 깔끔해 보이진 않죠 , 이렇게, 매번 마다 반복된 작업으로 등록을 해야 되니까 그리고 이 코드도 유심히 보셔야 됩니다. 내가 둘 중 하나만 지금 , 이렇게, 리드 혹은 라이트로 등록을 해주고 있는데 이건 어디까지나 우리가 에코서버를 만드니까 , 이렇게, 한건데 경우에 따라가지고 리드랑 라이트도 둘 다 필요하다고 하면 동시에 얘를 등록하면 안된다는 규칙은 없어요 당연히. 이제 이건 어떻게든 응용을 하시면 되겠습니다. , 자, 그리고 뭐 나머지 부분은 딱히 어려운 부분이 없을 것 같구요 이제 이거를 빌드 해가지고 한번 뭐 실행을 해보도록 할게요 왼쪽은 , 일단은, 안 바꿔놨습니다 이건 기존 이즈앤어시그릴 만든거 그냥 그대로 재사용을 하고 있구요 그러면 , 일단은, 서버쪽을 살펴보면은 클라이언트 커넥티드가 떴고 그 다음에 지금 백바이트가 주고받고 주고받고를 지금 성공적으로 한다는 걸 알 수가 있습니다 , 자, 이렇게, 해가지고 뭐 조금 다른 방식으로 만들어 봤는데 이게 뭐 지금은 어차피 데이터가 많이 없으니까 티가 안 나지만 그럼 이게 어떠한 장점이 있는지를 곰곰이 생각을 해보면 우리가 Q를 사용할 때 이런 Q를 사용할 때 큐에 데이터가 있는지 없는지 이걸 모르니까 막상 팝을 미리 하는게 아니라 얘가 mt 인지 아닌지를 먼저 체크해 가지고 mt가 아니면 팝을 하게끔 우리가 이제 항상 구현을 하죠 그런 것과 유사하게 무작정 우리가 여기서 accept나 receive 그리고 send를 막 호출하는게 아니라 진짜로 걔가 이 함수가 호출이 될 준비가 되어 있는지를 먼저 체크를 한 다음에 그 다음에 이제 우리가 비로소 안전하게 리시브랑 샌드를 한다는 차이가 생겼다고 볼 수 있겠습니다 그리고 이 셀렉트 모델 자체는 딱히 뭐 블록킹이건 논블록킹은 양쪽에 다 사용할 수 있다고 했었죠 네 그거는 알아주시면 될 것 같고 그래서 , 이렇게, 사용하는 게 셀렉트 모델인다 라는 걸 이제 기억을 해주시면 되겠습니다 그러면은 뭐 장점이라고 한다면 그래도 뭐 비교적 간단하게 구현이 가능하다 그리고 뭐 낭비하는 부분이 없어진다 라는 정도가 있고 단점이 없는 건 아니에요 얘의 가장 큰 단점은 뭐냐면 , 사실, 어 , 이렇게, 매번 반복해 가지고 등록하는 것도 좀 문제긴 하지만 , 사실, 얘가 한계가 있어요 그래가지고 FD 세트 사이즈라는 걸 살펴보면은 얘가 실질적으로 이 FD 세트라는 게 한 번에 세팅을 해줄 수 있는 최대 크기라고 보시면 되겠습니다 근데 이게 생각보다 작다는 걸 볼 수가 있어요 64죠 64개 밖에 지금 얘가 등록을 못한다는 얘기가 되는 거니까 아니 그러면은 이 모델을 이용하면은 동접을 64명 밖에 못 받는 건가요? 라는 생각이 들 수 있지만 그 얘기는 아닙니다 단일 세트 대상으로 우리가 64개를 등록할 수 있다는 얘기인데 만약에 우리가 640명을 등록해야 된다고 하면은 이 세트를 10개를 만들어 가지고 이 코드를 10번 반복해야 된다는 얘기가 되는 거죠 네 그렇기 때문에 진짜로 좀 귀찮게 되어 있기는 한데 이게 어쩔 수가 없습니다 여기 안에 구조를 보면은 얘가 애덩초 카운트를 추적을 하고 있고 그 다음에 소켓 자체를 요렇게 배열로 관리하고 있는데 이 배열 자체가 최대 크기가 64로 일단 잡혀 있기 때문에 뭐 이거는 울며 겨자 먹기로 그냥 감안을 하고 더 많은 숫자가 필요하다고 하면은 이제 얘네들을 여러 개를 사용해서 루프를 돌면서 이제 작업을 해야 됩니다 , 이렇게, 해서 셀렉트 모델에 대해서 간단히 알아봤고요 이 코드가 잘 이해가 가실지 모르겠는데 천천히 살펴보면 크게 어마어마하게 어려운 내용은 없으니까 한번 복습을 해보시기를 바라겠습니다 , 이렇게, 해서 가장 간단한 입출력 모델 중 하나인 셀렉트 모델에 대해서 간략하게 살펴봤습니다.