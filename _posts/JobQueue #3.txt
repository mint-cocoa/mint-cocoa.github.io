자, 이렇게, 해가지고 지난 시간까지 굉장히 외계어 같은 문법을 이용해 가지고 , 이렇게, 잡을 템플릿을 이용해 가지고 좀 편하게 사용할 수 있는 그런 방법에 대해서 알아봤고요 뭐 최종적으로 우리가 이 방식을 채택하지는 않을 것이지만 그럼에도 불구하고 이런 코드를 한두 번씩 보다 보면은 C++에 대한 이해도가 굉장히 높아지는 것 같습니다 저 개인적으로는 그랬어요 , 자, 그런데 오늘 이제 최종적으로 사용할 버전은 요 버전은 , 일단은, 아니기는 해요 그래서 불행하게도 요 코드는 다 날릴 거고 오늘 이제 최종적으로 작업할 코드는 두고두고 사용할 거니까 서버 코어에다가 , 일단은, 작업을 해주도록 할게요 잡 이라는 폴더를 만들어준 다음에 요기 안에다가 클래스를 만들어가지고 잡이라는 클래스를 만들어주고 그리고 겸사겸사 잡큐도 같이 내부에 만들어주도록 할게요 잡큐 , 자, 요렇게 , 일단은, 두개를 추가했구요 그래서 여기다가 , 일단은, 놓고 시작을 하도록 합시다 , 자, 우리가 위에서 밑단에서 사용하던 것 중에서 여기 잡큐는 그대로 사용할 것이기 때문에 여기서 끝까지는 , 일단은, 복붙을 해가지고 엔진 쪽에다가 , 일단은, 옮겨 놓도록 하겠습니다 잡이 아니라 잡큐 쪽이죠 , 이렇게, 헤더는 왼쪽에 놓는게 좋으니까 왼쪽에다가 놓고 , 자, 이렇게, 만들어주고 usingJobRef는 , 일단은, 잠시 긁어가지고 타입에다가 여기다가 , 일단은, 옮겨놓도록 할게요 나머지 애들이랑 같이 , 이렇게, 낑겨놓도록 합시다 정리를 한번 하고 그 다음에 iJob이 아니라 오늘 사용할 그냥 Job 클래스 자체를 , 이렇게, JobRef라고 하도록 하겠습니다 , 자, 그래서 JobQueue는 그냥 , 이렇게, 완성이 된 거고요 그 다음에 이제 잡 같은 경우에 어떻게 만들 것이냐를 고민을 해볼건데 일단 위에서 사용하던 이 버전들은 더이상 사용 안할 것이기 때문에 일단 윗단에서 사용하던 게임 컨텐츠 쪽에 잡은 그냥 다 날려보도록 하겠습니다 , 자, 그리고 이제 여기서 작업을 해볼건데 근데 위에서 몇가지 테스트를 하긴 해야되니까 일단 빌드를 해가지고 에러가 나는 곳은 일단 잠시 주석처리를 하고 넘어가도록 할게요 그래서 밑단도 빌드 해가지고 아마 룸쪽이랑 뭐 몇몇 군데에서 에러가 나겠죠 , 자, 여기서 에러를 기다려가지고 음 잡큐는 일단 잠시 주석처리를 하도록 하고 그 다음에 다른 부분도 문제가 되는 부분이 있으면 다 주석처리를 하도록 할게요. 어, 아마도 게임 서버 쪽에서도 이런저런 테스트를 하고 있었으니까 , 자, 여기서 여기까지 , 일단은, 다 날려주도록 하고 네, 그 다음에 다시 한번 빌드를 해보도록 하겠습니다. 그리고 조금 기다리다 보면은 이제 마지막으로 패킷 핸들러 쪽에서 사용하던 부분들에서 에러가 나겠죠? , 자, 플러시 잡도 여기서도 얘도 잠시 주석처리를 하도록 할게요. 그리고 다시 빌드 , 이렇게, 해서 계속 군성 있게. 그리고 푸쉬 찹도 마찬가지로 얘도 더 이상 사용 안 할 건데 얘는 , 일단은, 그냥 다 날리도록 하겠습니다. 다 날리도록 할 것이고 그다음에 마지막으로 클라이패킨 핸들러 쪽에서도 여기 관련된 부분들이 있을 테니까 얘도 , 이렇게, 직접 주석 처리를 하고 넘어가도록 하겠습니다. 좀 이리저리 작업을 하던 게 많아가지고 생각보다 오래 걸렸는데 , 자, 이렇게, 깔끔하게 처리를 하고 이제 내용을 진행해 보도록 할게요 , 자, 그래서 이제 오늘 최종적으로 그러면 이제 잡을 어떤 방식으로 사용을 할 것이냐 사실은 우리가 C++11으로 넘어오면서 굉장히 강력한 무기를 우리 손에 얻었는데 일반적으로 사람들이 그거에 대해서 깊게 생각을 안 하는 경우가 많아요 그게 뭐냐면은 바로 람다식입니다 그리고 Functional이라는 거랑 조합을 하는 거죠 , 자, 여기서 Include Functional Header를 추가하면은 요런 식으로 std Function이라는 걸 사용할 수 있는데 요 아이가 사실은 온갖 함수들을 다 받아줄 수 있는 온갖 콜라보를 다 받아줄 수 있는 형태입니다 그래서 만약에 void void를 요렇게 하면은 return은 void를 하고 인자는 아무것도 안 받는 타입의 모든 형식을 받아줄 수 있어요 참고로 여기 안에 있는 애들은 생략을 해도 되고 이거를 뭐 funk 라고 이름을 지어 볼게요 그럼 여기다가 우리가 어떤 식기랑 어떤 그런 콜라보 타입도 다 넣을 수 있다고 했으니까 예를 들면은 이거를 람다로 만들어 보도록 할게요 , 이렇게, 람다로 만들어 본 다음에 여기 람다 내부에서 우리가 원하는 그런 행동을 여기서 일단 만들어주면 된다는 얘기가 되는거죠. 예를 들면 우리가 지금 뭐 전역으로 사용하고 있었던 groom. 뭐 엔터라고 해볼까요? 엔터에다가 뭐 어떤 플레이어를 만약에 전달해줘야 된다라고 하면은 그냥 , 이렇게, 만들 수가 있다는 얘기가 되는거죠. , 자, 플레이어 래퍼를 한번 간단하게 가상으로 make shared를 여기 위에서 만들어 보도록 할게요. make shared player 타입을 만들어 준 다음에 이런 식으로 , 이렇게, 넣어줄 수 있다는 얘기가 되는 겁니다. 그러면 한참 후에 뭔가 이런저런 일을 하다가 func를 호출하게 되면은 뒤늦게 우리가 여기 안에다가 넣어준 내용이 실행이 된다는 거죠 굉장히 놀랍기도 그렇다는 것은 지금까지 우리가 뭐 허수구를 한 것이냐 왜 이런 기능이 있는데 왜 굳이 다른 내용을 공부했냐 싶기는 한데 그럼에도 불구하고 우리가 이전에 그 func에 대한 내용을 깊게 다룬 이유는 func를 깊게 이해하면은 , 사실, 이 lambda에 대한 곧잘이 많이 늘어나게 됩니다 , 자, lambda라는 것 자체를 처음에 배울 때는 그냥 익명 함수라고 배우는 경우가 굉장히 많아요 그래가지고 그냥 , 이렇게, 우리가 직접적으로 예를 들면 뭐 hello world라는 함수를 만들고 여기다가 뭐 hello world를 치고 요렇게 함수를 만들어 가지고 처음에는 만드는 걸 정석적으로 우리가 배우긴 했을 텐데 , 자, 이런 식으로 hello world를 매버마다 만들지 않고 그냥 요 부분만 , 이렇게, 덩그러니 lambda 안에 넣어 가지고 함수를 만들 수가 있다 라는 부분으로 처음에는 공부를 하게 됩니다 근데 그거와 더불어서 람다 캡쳐라는 기능도 있죠 이 기능 근데 그 캡쳐라는 것 자체가 사실은 우리가 이전에 만들었던 펑터랑 굉장히 느낌이 비슷해요 사실은 여기 인자에 우리가 넣어주는 그런 부분들을 생각을 해보면 , 자, 원래 일반적인 함수 포인터 같은 경우에는 인자를 , 예를 들어, 인트A랑 인트B를 얘가 인자로 받는다고 가정을 하면은 우리가 함수를 호출할 때 헬로월드를 호출할 때 1과 2를 요렇게 넣을 수는 있지만 우리가 얘를 함수 포인터로만 저장하고 있으면은 1이랑 2라는 값을 따로 저장할 공간이 없었기 때문에 그래서 우리가 함수자 펑터를 만들 때 이거를 튜플에다가 요 1이랑 2라는 값을 저장하고 호출할 때는 그걸 복원시키는 작업을 해봤습니다 근데 굉장히 놀랍게도 람다에서는 그냥 아무런 위화금 없이 진짜 이런 코드가 정상적으로 실행이 된다는 게 놀라워요 그래서 지금 이 코드가 정상적으로 빌드가 되는지 한번 테스트를 해봐서 게임 서버에다가 빌드를 하고 실행을 하면은 진짜로 뭐 아무런 문제 없이 실행이 됩니다 그래가지고 요 코드가 나중에 우리가 필요해질 때 이 펑크를 실행하면은 아이고 이거는 좀 다른 문제인데 어 플레어를 몰라서 그런 거 같네요 , 자, 여기서 플레어를 추가를 해주도록 할게요 그 다음에 다시 한번 빌드 그래서 하던 얘기를 계속하면 이런 1과 2 같은 숫자가 결국에는 여기 익명 함수 내에 우리가 같이 전달을 해가지고 저장하는 거랑 마찬가지로 실행이 다 된다는 얘기가 되는 거죠 그래서 지난 시간에 우리가 그 어려운 문법을 이용해 가지고 했던 흑마법들을 이 lambda식에서 사실상 지원을 하고 있다는 거라는 걸 볼 수 있는 거고 그래서 이런 것들을 , 사실, 우리가 프로그래밍 언어에서 보통 클로저라고 하는데 이런 코드를 만들게 되면 컴파일러가 내부적으로 어떤 클래스를 , 이렇게, 만들어주게 됩니다 그래서 실질적으로 우리가 1과 2로 넣어준 그런 데이터들도 우리가 지난번에 알아본 바와 마찬가지로 진짜로 어딘가에다가 , 이렇게, 들고 있는 형태로 만들어진다는 얘기가 되는 거죠 굉장히 놀랍게도 그래서 이 방식이 진짜 좋다 결국에는 잡이라는 것 자체도 그렇게 힘들게 막 만들 필요 없이 그냥 SD function이라는 것 자체 요 아이 자체를 그냥 우리가 잡으로 인정해 버리면 나머지 문제들은 다 해결이 된다고 , 일단은, 볼 수가 있는 거예요 , 자, 그런데 여기서 람다가 장점만 있는 것은 또 아닙니다 이게 약간 C++이랑 람다식이 어떻게 보면 약간 궁합이 안 맞는 부분이 종종 있기에 해요 그래서 지금 여기서 우리가 복사해 가지고 안에다가 , 이렇게, 밀어 넣을 때 이걸 기본적으로 캡처 모드로 우리가 지정을 해야 됩니다 , 이렇게, 아무것도 지정을 안 하면 에러가 나는데 만약에 , 이렇게, equal을 하면은 모든 것을 다 복사해가지고 넣어주겠다라는 의미가 되는 거고 그게 아니라 , 이렇게, 참조값을 넣어주면은 모든 것을 참조값으로 다 전달을 해주겠다라는 의미가 되는 겁니다 그러니까 아까 다시 한번 복원을 해가지고 이런 이미의 클래스가 만들어진다고 가정을 했을 때 여기서 내부적으로 찰칵 사진을 찍어가지고 이제 여기 있는 player라는 애를 진짜로 복사해가지고 전달을 할 것이냐 아니면은 , 이렇게, 참조값으로 들고 있을 거냐를 우리가 하나의 문법으로 선택을 해줄 수가 있다는 얘기가 되는 거죠. 굉장히 놀랍게도. 그리고 , 이렇게, 전체 모드를 모든 애들을 대상으로 다 하는 게 아니라 하나하나씩 지정할 수도 있습니다 그냥 이름을 , 이렇게, 하면은 얘는 우리가 플레이어를 복사해 가지고 전달할 것이다고 그게 아니라 여기다가 , 이렇게, 주소 표시를 하면은 얘를 역시나 레퍼런스로 참조 값으로 얘를 넘기겠다 즉 이 의미가 되는 겁니다 이제 두 가지 모드가 있어요 , 자, 그런데 이게 도대체 그러면 C++에서 발생하는 문제랑 그러니까 C++에서의 문법이랑 이 lambda가 왜 안 어울리냐는 얘기를 하냐면은 이거를 그냥 만들자마자 바로 호출하면 그냥 아무런 문제가 없습니다 그런데 우리가 지금 job을 사용하는 방식을 생각을 해보면 이 job이라는 걸 만들었다가 jobQueue에다가 집어넣고 그거를 한참 후에 누군가가 꺼내가지고 실행을 할 예정이에요 그렇다는 것은 애당초 우리가 여기서 캡쳐해가지고 넣어준 모든 값들이 반드시 유지가 되어야지만 그 함수들을 실행할 수 있다는 얘기가 되는 겁니다 그러니까 예를 들면 우리가 지금 여기다가 캡쳐를 살짝 해가지고 요 플레이어에 지금 레퍼런스로 만약 , 이렇게, 넘겼다고 가정을 해볼게요 그러면 사실상 클래스가 지금 요런 형태로 만들어진 겁니다 레퍼런스 즉 셰어드 포인터를 참조값으로 들고 있다는 얘기는 레퍼런스 카운트가 1 증가하지 않는다는 얘기이기 때문에 실질적으로 우리가 , 이렇게, 만약에 사용하게 되면 누군가가 , 사실, 누군가라기보다는 얘가 레퍼런스 카운트가 0이 되어서 만약에 삭제된 다음에 그 다음에 우리가 만들어준 이 잡이 실행이 되면 애당초 얘는 더 이상 유효하지 않은 주소이기 때문에 이 코드가 애당초 와장창 깨질 수가 있다는 얘기가 되는 거죠 그래서 반드시 , 이렇게, 캡쳐를 할 경우에 그리고 어떤 객체를 넣어줄 경우에는 그 객체의 생명 주기가 최소한 이 잡이 유지가 될 때까지는 꼭 살아있어야 되는 보장을 해줘야 돼요 이 얘기는 결국에는 우리가 네트워크 코드를 만들 때 세션 쪽에서 샌드나 리시브 같은 걸 걸어줬을 때 반드시 그 세션이 정상적으로 살아 있어야지만 우리가 걸어준 이벤트가 말이 됐던 것과 마찬가지로 람다에서 넣어준 이런 모든 객체들도 다 유지가 되어야지만 , 사실, 말이 된다는 얘기가 되는 거죠 이런 부분이 솔직히 좀 까다롭습니다 그래서 아무렇지 않게 그냥 이런 식으로 코드를 3조 값으로 넣어주면은 이런 코드가 사실상 엄청 큰 문제가 되는 코드다 라는 걸 알 수가 있는 겁니다 마찬가지로 지룸이라는 것도 마찬가지에요 여기서 넣어주는 모든 개체들이 정상적으로 다 유지가 된다는 보장이 없기 때문에 문제가 되는 겁니다 반면 , 이렇게, 1, 2 같은 그냥 뭐 상수 같은 경우는 아무런 문제가 없어요 , 자, 그리고 람다를 사용할 때 또 추가적으로 이 레퍼런스 카운트와 관련된 문제 생명과 관련된 문제 말고 또 몇가지 주의사항이 있는데 예를 들면은 , 자, 우리가 뭐 여기 내부에서 , 자, 일단은, Knight라는 클래스를 한번 만들어 볼게요 테스트는 너무 성의가 없으니까 Knight라는 클래스를 만들어 본 다음에 여기다가 뭐 예를 들면 테스트라는 함수가 있는데 여기 내부에서 우리가 또 이런저런 이유로 잡을 여기 내부에서 만들어 가지고 전달한다고 합시다 , 자, 그런데 어 여기에 이 Knight라는 애가 들고 있는 정보 중에서 뭐 예를 들면은 HP가 있다고 가정해 볼게요 HP가 100인 값이 있고 그 다음에 어떤 heal me라는 함수가 있는데 여기다가 어떤 값을 넣어주면은 hp에다가 value를 더해주고 그 다음에 뭔가 힐 미 로그를 찍어 주도록 할게요 이런 상태에서 우리가 나이트 객체가 실행되는 도중에 이런저런 이유로 여기서 실시간으로 만약에 잡을 만들어준다고 가정을 하고 , 이렇게, 잡 테스트를 해보도록 할게요 그래서 여기 이제 똑같이 람달을 이용해 가지고 만들고 있습니다 람달을 이용해 가지고 , 이렇게, 만들고 있는데 여기서 우리가 힐미를 예약을 하고 싶어요 그래가지고 이런 식으로 만들었다고 가정을 해봅시다 그러면은 뭐 여기까지만 놓고 보면은 애당초 이 HP라는 값은 뭐 포인터 값이 아니고 그냥 뭐 정수이다 보니까 이런 부분에서 아무런 문제가 없다고 지나칠 수가 있습니다 그리고 이 잡을 이제 외부에서 뭔가 뭐 리턴을 해준다거나 아니면은 어떤 외부에 있는 큐에다가 얘를 전달해준거나 하는 식으로 코드를 구현할 수 있겠죠 근데 사실은 여기에 굉장히 치명적인 버그가 벌써 들어가 있습니다 이건 제가 파트 1에서도 살짝 언급을 드린 적이 있는데 애당초 요렇게 캡쳐를 할 때 그냥 모든 애들을 대상으로 다 복사를 하겠다라고 지정하는 건 굉장히 위험한 방법입니다 그래서 실질적으로 지금 요 코드 같은 경우에는 애당초 우리가 복사하는게 이 HB를 복사해가지고 건네주는게 아니에요. 사실상 요런 코드가 지금 생략이 되어있기 때문에 여기서는 우리가 디스라는 포인터 자체를 캡쳐해가지고 넘겨주고 있었던 겁니다. 즉 자기의 주소를 복사해 줘 가지고 , 이렇게, 들고 있는 셈이 되는 거죠 근데 애당초 이 주소값 자체는 자기 자신의 주소는 이 나이트라는 애가 객체가 유효해야지만 얘도 유효한 건데 만약에 이런저런 이유로 나이트가 소멸이 되었다고 하면은 애당초 자기 자신의 주소라는 게 아무짝에 쓸모없어지고 애당초 오염된 포인터, 댕글댕글한 포인터를 지금 가리키고 있는 상태이기 때문에 이 코드 자체가 문제가 될 수 있다는 거죠 엉뚱한 메모리를 지금 참조하고 있는 겁니다 그래서 이런 부분에 대해서도 굉장히 많은 신경을 써야 돼요. 그래서 어지간해서는 람다를 쓸 때는 , 이렇게, 그냥 모든 애들 대상으로 복사를 한다거나 하면 안 되고 그냥 진짜 필요한 애들을 하나하나씩 우리가 적어 가지고 이런 습관을 드리는 게 좋아요. 디스 포인트를 내가 복사하겠다 라고 명시적으로 지정을 하는 거죠. 그러면 최소한 내가 디스포인터를 복사한다는 걸 코드상에서 볼 수 있으니까 훨씬 더 위화감이 들고 버그를 찾을 확률이 높아질 겁니다 물론 그렇다고 해서 문제가 해결되는 건 아니죠 우리가 만약에 나이트를 심지어 쉐어드 포인터로 만약에 활용하고 있었다고 가정을 하면 쉐어드 포인터랑 디스포인터는 섞어서 쓰면 안 된다고 제가 말씀을 드렸죠 이건 레퍼런스 카운트에 아무런 도움을 주지 않기 때문에 완전히 잘못된 코드라고 , 일단은, 볼 수가 있는 거예요 그래서 뭐 이런 걸 만약에 그러면 어떻게 뭐 우회해야 되느냐 예를 들면 우리가 Shared Pointer를 사용하기로 했으면 얘를 Enable Shared From This를 해가지고 요렇게 만들어 준 다음에 요 부분을 This Pointer를 이용해가지고 만드는 게 아니라 , 이렇게, Shared From This를 일단 호출해가지고 그 데이터를 우리가 셀프라는 이름으로 , 이렇게, 복사를 해준 다음에 여기 내부에서는 이런 식으로 , 일단은, 사용할 수가 있을 거예요. , 이렇게, 바꿔주면 아까와는 다르게 이 잡이 유지가 되는 동안에는 이 Knight라는 객체도 같이 우리가 스마트 포인트를 1 증가시켜가지고 레퍼런스 카운트 1 증가시키고 유지시켜주기 때문에 얘도 같이 살아있다는 걸 , 일단은, 보장을 받을 수가 있을 거예요 그래서 이런 디테일한 부분 , 일단은, 잘 신경 써야 된다 그렇지 않으면 좀 큰 문제가 일어날 수 있다고 볼 수가 있는 겁니다 , 자, 그리고 마지막으로 한 가지만 더 언급을 드리자면 제가 이제 뭐 이런 Shared Pointer랑 그리고 람다에 대한 조합에 대해서 이것저것 리서치를 하면서 자료를 찾아 보다가 예전에 어떤 글을 봤는데 이게 C++에서 람다에서 셰어드 포인터를 섞었으면 메모리 리익이 일어나기 때문에 절대로 사용하면 안 된다라는 글을 본 적이 있어요 그리고 굉장히 많이 인터넷 상에서 떠돌고 있는데 그게 사실은 좀 잘못된 정보입니다 , 자, 일단은, 제가 한번 원문을 보여드릴 건데 뭐 이런 블로그가 굉장히 많더라구요 남다랑 셰어드 포인터를 쓰면은 메모리를 이기 일하니까 쓰면 안 된다 , 자, 그래가지고 이 사람이 주장하는 코드를 살짝 살펴보면은 어 어떤 클래스를 만들었는데 거기다가 , 자, 딱 우리가 하려는 거죠 콜백이라는 걸 만들어 가지고 , 이렇게, 들고 있습니다 그 다음에 람다 값을 이용해 가지고 자기 자신의 셰어드 포인터를 건네 줘 가지고 그걸 캡쳐해가지고 지금 콜백이라는 애한테 뭔가 얘로 이제 들고 있는 거예요 여기다가 전달해 줘 가지고 여기다가 들고 있는 거죠 그랬더니만 메모리 릭이 일어나고 요 스마트 포인터가 절대로 레퍼런스 카운트가 용이 되지 않기 때문에 문제가 일어난다 고로 씹뿔뿔해서 람다랑 쉐어드 포인터는 같이 활용하면 안 된다라고 주장을 하고 있는데 저건 완전히 틀린 얘기입니다 그냥 애당초 본인이 잘못 코드를 짠 거예요 방금 본 코드에서 문제가 뭐냐면은 약간 이런 느낌이죠 나이트라는 객체 안에서 자기 자신의 셰어드 포인터를 사실상 , 이렇게, 들고 있는 거랑 똑같은 얘기입니다 근데 , 이렇게, 만약에 자기 자신에 대한 스마트 포인터를 들고 있는 거는 사실은 얼미일 보면은 람다랑은 아무런 문제 없고 그냥 이 설계 자체가 잘못됐고 얘가 이제 사이클이 생겼기 때문에 레퍼런스 카운트가 해제가 안 되어 가지고 절대로 메모리가 이제 정리가 되지 않는 거지 람다랑은 아무런 문제가 없는 겁니다 그래서 실질적으로 람다랑 셰어드 포인터를 섞어 쓴다고 해도 딱히 문제가 될 건 아무것도 없어요. 다만 이런 식으로 레퍼런스 카운트를 1 증가시키지 않고 그냥 참조 값으로 셰어드 포인터의 참조 값만 넘겨 가지고 활용한다고 하는 식으로 잘못 사용할 경우가 문제가 된다고 보시면 되겠습니다. 그 부분을 주의하시면 되겠어요. 그래서 앞으로 이런 식으로 진짜 람다를 이용해 가지고 코드를 넘기는 것도 당연히 괜찮은 방법입니다. 그래서 예를 들면 우리 룸에서도 똑같이 이걸 활용을 해보는데 지금은 뭐 이전에 간단하게 테스트를 하기 위해서 룸을 , 이렇게, 전역 객치로 만들어 놨는데 , 일단은, 얘를 셰어드 포인트로 살짝 바꿔치기 한 다음에 실습을 한번 해보도록 할게요 그래가지고 룸을 , 일단은, shared 포인트로 바꿔놓도록 하고요 그 다음에 여기서 잠시 make shared를 해가지고 룸을 , 이렇게, shared 포인트로 들고 있겠습니다 그 다음에 얘도 마찬가지로 public enable share from this를 켜줘가지고 이제 스마트 포인트로 활용할 준비를 끝냈고요 그렇다고 하면은 이제 우리가 활용을 할 때 G룸에다가 이런 식으로 엔터를 잡을 만들어 줄 때 이런 식으로 남달리 이용해 가지고 만들어 줄 수가 있다는 얘기가 되는 거죠 여기도 마찬가지로 지룸을 막바로 , 이렇게, 집어 넣기 보다는 어지간해서는 이제 이게 전역 객체가 아니라 그냥 스마트 포인터라고 하면은 뭐 이런 식으로 해당 룸을 복사해 가지고 레퍼런스 카운트를 유지시킨 다음에 사용하는 식으로 이제 만들어 주면 되겠습니다 뭐 이런 느낌으로 만들어 주면 되겠죠 , 자, 그건 그렇고 이제 그럼에도 불구하고 이런 스마트 포인터와 관련된 그런 실수를 하지 않는다는 보장이 없지 않느냐 약간 위험하지 않느냐라고 하실 수도 있으니까 그럴 경우에는 얘를 이제 살짝 랩핑 해가지고 직접 관리를 하면 됩니다 그래서 오늘 뭐 살짝 만들어 볼 건 뭐냐면 일단 잡이라는 걸 이어서 만들어 볼 건데 기본적으로는 람다랑 std-function 조합으로 만들어 볼 거지만 여기다가 추가적으로 몇몇 안전 장치를 더 추가를 해 줄 거예요 , 자, 그래서 , 일단은, 코드를 한번 간단하게 만들어 보자면 일단 job이라는 걸 , 이렇게, 만들어 줄 건데 먼저 callback 타입은 std function에 보이드를 그냥 , 이렇게, 만들어줄 겁니다 어떤 함수인데 보이드를 뱉어주고 인자는 아무것도 안 받는 함수다 이거죠 어차피 이 람다 타입이 딱히 인자를 뭔가 받아주는 건 아니고 여기 내부적으로 캡쳐를 하는 거기 때문에 이 람다 자체만 놓고 보면은 이 보이드 보이드에 들어갑니다 그렇기 때문에 , 이렇게, 일단은, 만들어주고 있고요 , 자, 그 다음에 이어가지고 여기다가 public private로 만들어주고 내부적으로 여기 우리가 콜백으로 쳐야 될 함수를 , 이렇게, 들고 있도록 할게요 그 다음에 우리가 뭐 execute라고 해가지고 실행을 한다고 했을 때는 이제 이 콜백을 그냥 뿅 실행해주면 되겠습니다. , 자, 그 다음에 잡을 만들어주는데 만약에 막바로 콜백 타입을 그냥 요렇게 지정을 해줬다라고 하면은 그냥 sdmove를 이용해가지고 콜백을 바로 요게다가 저장을 해주도록 하겠습니다. 에고 모터가 났는데 닫아주고 닫아주고 요렇게 , 일단은, 만들어주도록 할 거예요. 그게 이게 사실은 뭐 굉장히 단순한 거죠 그래서 잡이라는 거로 일단 랩핑을 해가지고 얘를 사용하겠다 라는 그런 컨셉입니다 그런데 만약에 만약에 셰어드 포인터를 관리를 하는 게 너무 귀찮다 라고 하면은 뭐 여러가지 버전을 더 만들어 주면 됩니다 예를 들면은 이번에는 만들어 볼 거는 뭐냐면은 어떤 객체가 있는데 , 자, 타임네임, 리턴 타입이랑 타임네임, 점점점 아귀먼트를 받아주고 이 잡같은 경우에는 자기 자신의 share the point를 먼저 건네준 다음에 그 다음에 함수는 대부분의 경우에는 우리가 이제 멤버 함수로 사용할 것이기 때문에 이 버전을 이제 특별히 챙겨주는 겁니다 아귀먼트, 점점점 그리고 마지막은 아귀먼트 , 자, 이렇게, 보편참조로 만들어가지고 , 이렇게, 건네주도록 할게요 그러면 콜백은 이제부터 캡쳐를 해줄건데 이제 여기서 우리가 첫번째 인자를 뭐... 셰어드 포인터로 받아줄것이냐 아니면 위크 포인터로 받아줄것이냐 어떻게 잡을 관리할지는 이제 우리의 선택이 되는건데 일단 기본적으로 셰어드 포인터 버전으로 만들어주자면 자기 자신을 이제 복사를 해가지고 셰어드 포인터 카운트를 증가하고 그 다음에 요 멤버 펑크랑 아귀먼트들을 사용할 것이니까 얘네들을 요렇게 캡쳐해가지고 owner. .get을 해가지고 포인터를 꺼내온 다음에 거기다가 이 멤버 함수를 호출하고 인자들은 아귀먼트를 그대로 건네주면 되겠습니다 요런 느낌으로 소문자 , 자, 이렇게, 해가지고 만들어주면은 이제 이거를 어떻게 활용할 수 있냐면은 잡을 만들 때 owner랑 그리고 멤버 함수랑 나머지 인자들을 넘겨주게 되면은 얘가 알아서 스마트 포인터를 증가해준다거나 하는 식으로 동작을 하게 유도를 해줄 수가 있겠죠 뭐 이런 느낌으로 만들어 보면 되겠습니다 , 자, 근데 이게 뭐 잘 와닿지 않을 수도 있으니까 이건 좀 사용 예제를 한번 보도록 할게요 , 일단은, 잡은 대충 , 이렇게, 만들어 줄 것이고 잡큐 같은 경우에는 잡을 , 이렇게, 넣어주는 식으로 만들어져 있으니까 이제는 마지막으로 이걸 좀 편하게 사용할 수 있도록 잡 시리얼라이서라는 걸 만들어 주도록 하겠습니다 잡 시리얼라이서 이거는 왜 있는 거냐면 우리가 룸에서 푸쉬랑 팝을 각각 지정을 해가지고 사용을 하고 있습니다 이 부분 플러쉬랑 푸쉬 모시기라고 해가지고 만들고 있었는데 그거를 매번마다 일일이 다 만들기는 귀찮으니까 이제 잡큐를 사용하는 애들은 잡 시리얼라이저라는 클래스를 상속을 받게끔 만들어 줄 거예요 그래가지고 좀 공용으로 활용할 수 있는 코드를 만들어 가지고 얘를 잡큐를 , 일단은, 이렇게, 헤더를 인클루드하고 뭐 이건 좀 쓸모없지만 제가 늘상 하는 일이라서 주석을 한번 달아보도록 할게요 잡 시리얼라이서라는 걸 만들어 줄 것인데 요 아이는 이제 무엇을 하는 것이냐 , 자, 내부적으로 protected랑 , 이렇게, private가 있는데 잡큐를 내부적으로 들고 있을 거에요 그리고 얘가 public enable share from this를 상속을 받아가지고 잡 시리얼라이저라는 거를 , 이렇게, 위크 포인터를 들고 있을 것이고 자기 자신의 스마트 포인터를 꺼낼 수 있게 되었고 그 다음에 푸쉬 잡을 해준다고 하면은 여기다가 두가지 버전을 열어줄건데 콜백 타입이 타입이 콜백 타입을 바로 지정해주는 경우 얘는 이제 막바로 꽂아주는거죠 콜백 타입을 어... 이게 지정이 안되어있는지 보면은 , 자, 이 버전인데 어... 여기 아 잡 큐에 잡이 없어서 그런거 같군요 아 여기다가 잡도 같이 , 이렇게, 넣어주도록 합시다 인클로드 잡까지 추가해주면 되겠죠? 그리고 잡큐에서도 내부적으로 여기서 팝만 하니까 여기서 딱히 실행은 안하니까 없어도 됐던 것 같고 , 이렇게, 해가지고 푸쉬 잡을 만약에 필요한다 해준다고 해야 된다고 하면은 이제 얘를 잡을 여기서 만들어 주도록 할게요 잡을 만들어 줄 건데 뭐 object 풀해서 잡을 꺼내 가지고 make shared를 한 다음에 여기서 std move를 해가지고 콜백을 그대로 전달해준 다음에 이거를 잡큐에다가 push를 해가지고 사용을 하겠다라는 거고 그 다음에 또 하나 버전을 더 만들어 가지고 이번에는 아까 우리가 방금 만들어준 두 번째 버전 즉 템플릿 타임네임 t, 타임네임 return, 타임네임 argument를 , 이렇게, 받아가지고 요 함수 경우에는 , 자, 이렇게, 멤버 함수를 받아가지고 memfunc를 받았는데 멤버 함수는 요런 느낌으로 return을 뱉어주고 argument를 받아주는 타입이다 라고 , 이렇게, 지정을 해줬고 그 다음에 인자들을 , 이렇게, 받아줄 겁니다 그러면은 이 경우에는 예를 들면은 만약에 우리가 스마트 포인터를 적용시키겠다라고 정책을 정했다고 하면은 뭐 요런 식으로 만들어줄 수가 있겠죠 static pointer cast t 얘를 shared from this를 추출해가지고 스마트 포인터를 추출한 다음에 make shared를 할 때는 이런 식으로 owner에다가 내 함수랑 그 다음에 나머지 인자들은 그냥 forward를 해주면 되겠죠 forward argument를 해 줘 가지고 , 자, 요런 느낌으로 점점점을 해주면 되겠습니다 그래서 그러면은 푸쉬잡 푸쉬잡을 , 이렇게, 뭐 어떤 형식으로든 우리가 만들어 줄 수 있는 거고 그냥 일반적으로 람다 식으로 만들 때는 요 버전을 활용하고 그게 아니라 그냥 함수를 지정하고 인자들을 따로 지정하는 그니까 이전 방식으로 만들어 줄 거면 그냥 요 버전을 일단 활용하면 되겠습니다 그리고 마지막으로 virtual void flushJob 앱스트랙트로 만들어가지고 이 잡 시리얼라이저를 상속받는 애는 반드시 요 함수를 구현하게끔 유도를 해주도록 합시다 , 일단은, 뭐 , 이렇게, 간단하게 만들어 봤어요 , 자, 그러면은 이 잡 Q 같은 경우에는 뭐 은근히 자주 쓰일 것 같으니까 얘를 코어 PCH에다가 추가를 해주도록 할게요 그 다음에 서버 코어는 끝난 것 같으니까 한번 빌드를 해 보도록 합시다 문제가 없는지 그래서 정상적으로 만약에 통과가 되었다고 하면은 이제 룸에 가 가지고 룸을 살짝 바꿔 줄 건데 기존의 코드가 똑같이 동작하게끔 유도를 해 주도록 하겠습니다 먼저 여기다가 잡 시리얼라이서를 상속을 받게끔 , 이렇게, 만들어줄거에요 그래서 이제는 잡을 추가하는게 아니라 잡 시리얼라이서를 , 이렇게, 헤더를 추가를 할것이고 그러면은 이제 여기서 잡큐는 굳이 추가를 안해도 자동으로 얘를 상속받음으로 인해가지고 자동으로 얘가 들고있게 될겁니다 그럼 이제 이 FlushJob 이라는 요 함수를 오버라이드를 해주면 되겠죠 요런식으로 , 자, 그리고 어 이거 여기다 닫아야죠 네 그 다음에 FlushJob에 가가지고 이제 요 부분만 정상적으로 다시 복구를 시켜주면 되는데 이 부분을 다시 복구시켜줄 것인데 지금 내부적으로 우리가 잡큐라는 이름으로 바꿔놨으니까 , 이렇게, 해주면 되겠네요. 잡큐를 꺼내서 엑세이큐트를 하겠다. 물론 이 부분도 이제 어떻게 할지는 다음 시간에 또 이어서 논해 볼 건데 , 일단은, 그냥 간단하게 , 이렇게, 일단은, 살짝 수정을 해보도록 할게요. , 자, 그러면은 이제 나머지 코드 그러니까 요 부분은 , 일단은, 테스트하는 거였으니 삭제를 하고 이제 나머지 코드도 다시 한번 복원을 시켜보자면 , 일단은, 플러시 잡든 요렇게 얘가 지금 스마트 포인트로 바꿔놨으니까 요렇게 만들어주면 되겠고 클라이언트 패킷 핸들러에서 어.. 우리가 잠시 주석처리했던 부분들을 찾아가지고 다시 복원을 시켜줄 건데 , 자, 요 부분 같은 경우에는 예를 들면은 기존과 마찬가지로 , 이렇게, 당겨가지고 만들어줄 수가 있겠죠 사실은 대부분의 경우에는 같은 클래스의 멤버 함수를 호출하는 경우 거의 대부분일겁니다 그래가지고 뭐 예를 들면은 요런식으로 일감을 넣어줄 수가 있을거에요 그리고 마찬가지로 요 부분도 이제 브로드 캐스팅이 필요하다고 하면은 이런식으로 당겨가지고 어... 아이고 , 이렇게, 내가 이 gRoom이라는 클래스라고 한다고 하면은 PushJob을 해줄건데 거기다가 이 broadcast라는 멤버 함수 주소랑 샌드버퍼를 인자로 넣어줄 것이다 라고 , 이렇게, 호출해주면 되겠죠 그러면 이제 이 두 번째 버전이 호출이 될 겁니다 그래서 직접 람다로 만들 경우에 이런 레퍼런스 카운팅을 우리가 신경쓰는 게 너무 귀찮다고 하면은 진짜로 이런 식으로 내부적으로 챙겨주게끔 유도를 해줄 수도 있다라고 볼 수가 있는 겁니다 , 이렇게, 해서 잠시 한번 빌드를 하고 실행을 해보도록 할게요 그래서 이제 굉장히 단순하게 수정을 해봤는데 어.. 나이트 클래스 제정이.. 어 위에 나이트가 하나 더 있었네요 놀랍게도 네 그래서 요 부분은 날리고 테스트는 필요 없고 헬레월드 필요 없고 , 자, 필요 없는 건 다 날리도록 할게요 나이트도 이제 더 이상 필요 없을 것 같고 우리가 지난번에 테스트했던 걸 그대로 복원시키기 위해서 다시 한번 , 이렇게, 빌드를 해보도록 할게요 , 자, 이렇게, 조금 기다려 보면은 요 부분에서 일감을 밀어 넣었으니까 이제 정상적으로 꺼내 쓰는 부분이 여기서 실행이 될 것이고 그렇다고 하면은 이제 다시 클라랑 서브랑 같이 켜야 되니까 잠시 솔루션에 가가지고 속성에 가서 얘를 두 개를 다 켜주고 그 다음에 이제 빌드를 해보면 뭐 로그가 쫙 출력이 되는 부분까지 , 일단은, 다시 확인을 할 수가 있을 겁니다 네 그렇게 해가지고 뭐 굉장히 내용이 길었는데 사실은 뭐 이렇게까지 해야 될 필요가 있었나 싶긴 하죠 결국에는 뭐 딱히 어마어마한 그런 행동을 한 건 아니었고 그냥 기본적으로 람다를 캡쳐 해가지고 그걸 SD 펑션에다가 넣었다가 , 일단은, 뭐 작은 결론이 되겠는데 그럼에도 불구하고 뭐 이런저런 방법들에 대해서 알아보면서 굉장히 많은 도움이 되셨기를 바라겠습니다 , 자, 그리고 이게 아직 끝은 아니에요 지금 이제 그 다음에 생각해야 되는 문제는 뭐냐면은 뭐 어찌됐건 수정과 방법을 가리지 않고 , 이렇게, 잡이라는 걸로 묶어 가지고 인자들이랑 같이 낑겨 넣어서 그거를 지금 , 이렇게, 잘 들고 있는 것까지는 이제 통과를 했는데 지금 그 다음으로 이제 좀 고민해야 되는 부분은 푸시팝을 할 때 이걸 어떻게 할 것이냐에 관한 문제입니다 그러니까 지금은 일감을 넣어주는 애 따로 그리고 플러쉬를 해주는 애가 따로 있습니다 플러쉬 하는 애가 지금 예를 들면은 게임 서버에서 , 이렇게, 돌면서 지금 플러쉬를 하고 있는데 , 자, 지금은 우리가 간단하게 테스트를 하기 위해서 룸을 하나만 만들어 가지고 이거를 메인 어 스레드에서 그냥 계속 뺑뺑이로 돌면서 체크를 하고 있어요 근데 나중에 가면 룸이 어마어마하게 많아질 수 있을 뿐더러 에덩초 정착에 따라 가지고 , 이렇게, 잡큐 같은 거를 룸 단위로 배치하는 게 아니라 객체마다 배치하는 경우도 있습니다. 특히나 그걸 시뮬리스 MMORPG를 만들 때는 그렇게 하는 경우가 굉장히 많아요. 즉, 이런 나이트라거나 아니면 몬스터라거나 아니면 미사일이라거나 그냥 살아서 움직이는 모든 객체들한테 다 잡큐를 넣어주는 경우가 굉장히 많은데 그렇게 될 경우에는 이제 이거를 뺑뺑이를 돌면서 플러쉬를 하는 것 자체가 굉장히 애매해집니다. 왜냐하면 , 이렇게, 하면 지금은 딱 봐도 우리가 메인 스레드에서 이거를 다 처리하고 있는데 나중에 가서 이제 굉장히 객체가 많아지면은 스레드끼리 각각 분배해가지고 일을 처리하는 것 자체가 굉장히 애매해지기 때문이죠 이게 좀 잘 와닿지 않을 수도 있어요 이거는 , 사실, 컨텐츠를 좀 만들어봐야 좀 감이 잘 오실 거고 만약 C샷 강의를 들어가지고 이 잡 시리얼라이서가 어떻게 동작하는지를 컨텐츠를 만들어보면서 실습을 했다면 좀 이해가 가시겠지만 지금은 뭐 딱히 와닿지 않을 수도 있긴 한데 어찌됐건 요 관련된 내용을 , 일단은, 다음 시간에 이어서 일단 알아보도록 하겠습니다 그래서 일감을 어떻게 실행을 해야지만 좀 편하게 관리할 수 있을까에 대해서 , 일단은, 이어서 알아보도록 보도록 할게요.