자, 이렇게, 해가지고 UDP에 대한 내용도 이제 알아봤구요. 이번 시간에는 어떻게 보면은 좀 가벼운 내용이긴 한데 소켓 옵션을 설정하는 그런 방법에 대해서 알아보도록 하겠습니다. , 자, 일단은, 뭐 UDP는 더이상 사용을 안 할 거라서 탁재를 해줄 거구요. , 자, 일단은, 뭐 여기까지 일단 쭉 날리고 오늘 좀 따로 내용을 할 거니까 정리를 좀 하도록 하겠습니다. 나중에 가서 이 코드는 다시 복원을 하도록 하고 , 일단은, 이렇게, 소켓을 우리가 만든 다음에 소켓을 만드는 순간 사실상 커널단에서 샌드버퍼랑 리시버퍼 등등이 만들어진다고 했었습니다 그리고 제가 말씀을 얼핏 드리긴 했지만 원하면은 그 커널 버퍼 샌드버퍼랑 리시버퍼 성수심 버퍼의 크기를 우리가 변경할 수 있다고 했습니다 그리고 그것뿐만 아니라 , 사실, 굉장히 다양한 옵션을 우리가 커스터마이징 해가지고 , 사실, 설정을 할 수가 있는데 오늘은 이제 그것에 대해서 알아보도록 할게요. 근데 , 사실, 내용은 굉장히 간단합니다. 여기 보면은 setSocketOption 이라는 이런 함수가 있어요. , 자, 그리고 마찬가지로 getSocketOption 이라는 이런 함수가 있습니다. 이거 두 개를 이용해 가지고 소켓 옵션을 설정하고 그 다음에 소켓 옵션을 가져오고 하는 그런 작업을 할 수가 있는데 여기서 묘하게도 일단 소켓을 받아준 다음에 레벨, 옵션 이름, 옵션 밸류, 옵션 렌스 뭐 , 이렇게, 굉장히 다양한 인자들을 받아주는 걸 볼 수가 있습니다. 얘는 조금 헷갈릴 수 있으니까 잠시 MSDN을 살펴보고 오면은 여기는 소켓 그냥 우리가 설정할 소켓을 넣어준다는 걸 볼 수가 있고요 이건 딱히 어렵지 않고 그 다음에 레벨이라는 걸 넣어주고 있습니다 여기서 레벨이라 하면 옵션을 우리가 넣어줄 건데 그 옵션을 해석하고 처리할 주체를 우리가 넣어주는 겁니다 만약에 소켓이 처리하는 거다 라고 하면은 이 SOL 소켓이라는 걸 넣어줄 것이고 뭐 그게 아니라 뭐 다른 옵션 IP가 해야 되는 거다 아니면 뭐 DCP 프로토클이 처리해야 되는 거다에 따라 가지고 요 레벨이라는 게 바뀌게 됩니다 그래가지고 결국에는 옵션을 해석하고 처리할 주체는 누구냐가 레벨이라고 볼 수 있는 거고 그냥 소켓 단계에서 소켓 코드가 하는 애면은 기본적으로 요거를 제일 많이 사용할 것이고 그게 아니라 뭐 예를 들면 IP BEFORE 단계에서 뭔가를 하는 거다라고 하면은 IP PROTO underbar IP라는 걸 입력을 하면 되고요 tcp 프로토콜 단계에서 뭔가 처리하는 것이 다 라고 하면은 ip prot on the bar tcp 뭐 이런 식으로 우리가 레벨을 설정해 줄 겁니다 레벨을 설정해 준다고 끝나는 게 아니라 레벨을 설정해 준 다음에 그 해당 레벨의 어떤 옵션 인지를 우리가 또 선택을 해줘야 돼요 이게 몇 층 몇 호 약간 이런 느낌인 거죠 이걸 끄면 안되고 그래서 이제 이어가지고 살펴보면은 여기 이제 자주 사용하는 그런 몇가지 밸류들이 대표적으로 , 이렇게, 지금 나와 있습니다. 소울소켓으로 할 때 , 자, 요렇게 옵션들이 있는데 이런 모든 옵션들을 다 알 필요는 없지만 그 중에서 좀 자주 사용하는 거 그리고 좀 공부할 만한 한 거 몇 가지만 집어 드리도록 할게요 대표적으로 여기 Keep Alive랑 Linger, Receive Buffer, Reuse Address랑 Sand Buffer 뭐 대충 이 정도만 알면은 , 일단은, 큰 무리가 없다고 , 일단은, 볼 수가 있겠어요 그래서 이런 거에 대해서 간단하게 실습을 해 보도록 합시다 , 일단은, 맨 먼저 알아볼 것은 요 아이예요 s-underbar, Keep Alive라는 요 아이인데 얘는 한마디로 주기적으로 연결 상태를 확인을 할지 여부를 우리가 설정할 수 있습니다. 그리고 연결 상태라 하면 역시나 뭐 TCP에서만 동작을 하는 거죠. UDP는 뭔가 연결이 되어 있는 개념이 아니라 그냥 에라이 모르겠다 하고 보내는 개념이었기 때문에 얘는 이제 TCP only라고 생각하시면 되겠습니다. 근데 이 옵션이 이제 왜 필요하냐면은 상대방이 소리소문 없이 연결을 끊는 그런 경우가 있을 수 있기 때문이죠. 제가 써보고 상대방이 클라이어서 우리가 통신을 하다가 상대방이 어느 순간 조용해졌어요 근데 그게 진짜로 할 말이 없어서 조용한건지 아니면 연결이 끊어져서 조용한건지 뭐 알 수가 없겠죠 그러다보니까 주기적으로 뭔가 TCP 프로토콜 단계에서 연결 상태를 확인하는 그런 패킷을 계속 보내다가 그걸로 인해가지고 끊어진 연결을 우리가 감지하고 싶다 라고 할 때 요런 옵션을 선택할 수가 있습니다 그래서 이제 이걸 사용하는 방법에 대해서 이제 알아보면은 우선은 여기다가 이런 식으로 서버 소켓을 넣어주고 그 다음에 소켓 단계에서 설정하는 거니까 , 이렇게, 넣어주고 옵션은 keep alive였고 그 다음에 여기다가 이제 보면은 콘스트 캐릭터 포인터랑 옵션의 크기를 받아주는 걸 볼 수 있습니다. 이 세트콘 옵션은 굉장히 다양한 애들을 여기 인자로 받아줄 것이기 때문에 이 크기가 몇 사이즈인지 아직 몰라요. 그래가지고 아까 우리가 문서를 살짝 살펴봤을 때 여기서 각 옵션마다 어떤 타입을 받아주는지를 알 수 있는데 일단 불리언이라고 하죠. 얘는 이제 불리언으로 설정해주면 됩니다. 예를 들면 뭐 이런 식으로 불리언을 만들어준 다음에 넣어줄 때는 얘를 포인터로 , 이렇게, 캐스팅해서 넣어줘야 됩니다. enable, size of enable. 이런 느낌으로 일단 세팅을 해주면 돼요. 나머지 애들도 걔가 인트를 받아줄 수도 있고 아니면 다른 옵션을 받아줄 수도 있겠지만 그걸 맞게끔 그냥 적당하게 이제 옵션을 건네주면 이제 설정이 됐다고 보시면 되겠습니다. 네 그래서 뭐 대표적으로 keep alive 뭐 이런게 있구요 그 다음으로 알아볼거는 so on the bar linger linger라는게 이제 지연하다라는 뜻이 있습니다 그래서 무엇을 지연하는 것이냐 어 이건 뭐냐면은 우리가 연결을 막 하다가 더 이상 이제 연결을 끊고 싶다 나는 더 이상 할 말이 없다라고 하면은 Close Socket 이라는 함수를 이용해 가지고 소켓을 빵 닫아 버릴 수가 있어요 , 사실, 여기서도 똑같이 해놨죠 이게 소켓 리소스 반환이라고 했는데 사실은 얘가 소켓 리소스 반환한 것 뿐만 아니라 굉장히 다양한 작업을 해주고 있는데 클로즈소켓을 하는 순간에 엄밀히 말하면 상대방은 더 이상 우리한테 연락을 할 수가 없어요 왜냐면 애당초 이제 우리가 버퍼에 쌓여가지고 커널 버퍼에 이제 송소심 버퍼에 쌓인 거를 이제 보내고 받고 했었는데 소켓을 닫아주겠다는 건 더 이상 우리가 할 말이 없다는 거니까 이제 모든 연결이 빵 끊기게 되는 거죠 근데 여기서 문제는 그럼 만약에 바로 이전에 우리가 어 이런 식으로 샌드를 했다가 바로 이어가지고 클로즈소켓을 때렸다고 하면은 , 사실, 샌드가 호출이 됨으로써 우리가 뭔가 예약이 된 그런 패킷이 분명히 커널 버퍼에 들어가 있을 겁니다 이제 이게 전송 중일 텐데 그거를 그럼 어떻게 처리할 것이냐 찌꺼기들을 다 보낸 다음에 연결을 끊을 것인지 아니면은 그냥 뭐 쿨하게 끊을 것인지 등등을 설정을 해줘야 되겠죠 그래가지고 결국에는 요 링건 같은 경우에는 송신 버퍼에 있는 데이터를 보낼 것인가 아니면 그냥 날릴 것인가 등과 관련된 부분이라고 일단 볼 수가 있겠어요. 얘 같은 경우는 , 일단은, 인자를 이 LINGER라는 구조체를 받아주고 있는데 LINGER라는 애를 또 , 이렇게, 타고 들어가서 살펴보면은 SHORT, U-SHORT를 두 개를 받아주고 있습니다. ON-OFF, TRIGGER , 이렇게, 두 가지 옵션을 받아주고 있어요. 그래서 on off 같은 경우에는 0이면은 , 일단은, 클로우소켓이 바로 리턴하고 아니면 즉 1로 설정하면은 링거 초 만큼 대기를 하게 됩니다. 즉 디폴트는 0인데 우리가 이제 링거를 켜도겠다 즉 우리가 어느정도 시간을 기다리겠다라고 하면은 얘를 이제 1로 켜주면 된다는 얘기가 되는거죠 그래가지고 얘로 이제 이런식으로 링거.onoff를 1로 , 이렇게, 켜주고 그 다음에 링거. 여기다가 몇초동안 대기할것인지를 초단위로 , 이렇게, 입력을 해줄수가 있어요. 그래서 링거는 대기시간이라고 생각하시면 되겠습니다. 어... 결국에는 우리가 보낼 뭔가 샌들을 하자마자 클로즈소켓을 하게 될 경우에 바로 소켓을 닫는 게 아니라 어느 정도 텀을 둬 가지고 충분히 나머지 정보들이 다 보내지기를 기다렸다가 소켓을 닫아 주겠다라는 그래서 뭔가 , 이렇게, 지연하다라는 의미가 , 이렇게, 들어가게 되었다고 볼 수 있는 거죠 그래서 링거를 만약에 설정하고 싶다라고 하면 요것도 마찬가지로 Set Socket 옵션을 한 다음에 여기다가 S on the bar 링거를 입력을 하고 그 다음에 여기 링거로 되어있는 요 아이들을 요렇게 요렇게 넣어주시면 되겠습니다. 참고로 이제 링거에 대한 내용이 나왔으니까 한 가지만 더 말씀을 드리자면 , 사실, 이렇게, 그냥 소켓을 닫아버리는 건 조금 매너가 없는 짓입니다. 애당초 , 이렇게, 서로 통신을 하고 있는 거는 우리가 무전기로 서로 통신하고 있을 때 할 말이 없으면 보통 말이 끝났다는 걸 상대방이 알리기 위해서 뭐 누구누구다 대답하라 오버라고 오버라는 단어를 꼭 붙여가지고 우리가 할 말이 다 끝났다는 걸 상대방한테 또 알리죠 항상 근데 그런 거 없이 그냥 내 할 말이 끝났다고 딱 끊어버리면은 사실상 상대방은 어 내가 진짜 뭐 할 말이 없어서 끊은 건지 어떤 상황인지 알 수가 없겠죠 게다가 심지어 상대방은 더 할 말이 있었을 수도 있는데 우리가 그렇게 매너 없이 끊는 거는 솔직히 조금 좋은 방법이 아니에요 그래서 이거를 좀 우아하게 처리하기 위해서 이걸 소위 Head Close라고 하는데 Shut Down이라는 함수가 하나가 더 있습니다 그래서 여기 서버 소켓에다가 어떤 식으로 내가 셧다운을 할지 여기서 이제 선택을 해주게 되는데 샌드를 하면은 샌드만 막는다 샌드 버퍼 쪽에서 이제 우리가 데이터를 보내는 걸 막는 거고 리시브를 입력을 하면은 리시브를 막는다 아니면 혹은 SD 보스를 하면은 그냥 둘 다 막는다 막는다가 되겠습니다 이걸 이용해 가지고 나는 진짜 할 말 다 끝났어 라고 하면은 엄밀히 말하면은 셧다운을 해가지고 나는 더 이상 너한테 보낼 것이 없다라고 , 이렇게, 세팅을 해주면 이 소켓 같은 경우에 이제 더 이상 샌드는 안 되지만 상대방 쪽에서 할 말이 있을 수 있으니까 리시브는 계속 받을 수가 있는 상태가 됩니다 즉 반만 닫히는 그런 상황으로 만들 수가 있다는 거죠 그래서 뭐 정석적인 방법은 클로즈 소켓으로 그냥 매너 없이 그냥 빵 닫는 게 아니라 이런 식으로 쇼트다운을 통해 가지고 상대방에게 나는 더 이상 할 얘기가 없다라는 의사를 먼저 , 이렇게, 표시를 해주게 되고 그러면은 상대방 쪽에서는 뭔가 데이터를 전송을 받을 때 리시브 사이즈가 0으로 오면서 어 얘가 진짜 나한테 더 이상 할 말이 없네 라는 걸 깨닫고 우아하게 더 이상 데이터를 안 보낸다거나 상대방도 마찬가지로 쇼트다운을 보내가지고 우리한테 더이상 자기도 할 말이 없다라는 식으로 패킷을 보내도록 유도를 하는 게 가장 깔끔한 방법이긴 합니다. 그래서 Close Socket 바로 이전에 뭔가 , 이렇게, Shutdown이라는 이런 코드가 1 플러스 1으로 등장하는 경우가 굉장히 많은데 이건 이론상 그렇다는 거예요. , 사실, 우리가 MMO를 만들 때는 , 사실, 그게 크게 신경 쓸 필요 없어요. 왜냐하면 우리 같은 경우에는 뭔가 , 이렇게, 그러니까 파일을 주고 받는 것처럼 정말 100% 모든 그런 정보를 다 서로 받은 다음에 끊고 이런 상황이 아니라 온라인 게임이죠 온라인 게임이다 보니까 정말 별의별 상황이 다 있을 수가 있어요 상대방이 뭐 그냥 하다가 컴퓨터를 강제 종료해가지고 빵 꺼버릴 수도 있고 정전이 될 수도 있고 아니면 우리 서버가 그냥 크래쉬 나가지고 다운될 수도 있고 굉장히 뭐 다양한 상황이 있을 수가 있겠죠 근데 그렇다고 해가지고 , 이렇게, 소켓을 빵! 닫아버린다고 해가지고 뭐 , 사실, 큰일이 일어나는 그런 상황은 딱히 없기는 해요 보통은 그래가지고 뭐 요런 부분이 우아하게 닫을 때는 사용하는 것이다 라는 걸 참고 삼아서만 알아두면 되지만 사실은 더 이상 상대방 입장에 듣기 싫으면 클럽 소켓으로 그냥 빵! 때려버려도 사실은 뭐 큰 문제가 없기는 합니다 이건 어지간히 이론과 현실의 약간 차이라고 보시면 되겠어요 뭐 상대방이 뭐 더이상 할 말이 있어봤자 어차피 연결이 끊어진 다음에 불만이 있으면 다시 재접속을 하게 되면은 우리가 다시 DB에서 정보를 로드해가지고 똑같이 캐릭터가 접속할 수 있게 다시 열어줄 거니까 뭐 크게 상관이 없다는 얘기가 되는 거죠 뭐 어찌됐건 좀 얘기가 새고 있는데 뭐 어찌됐건 이런 식으로 설정할 때 뭐 링거 옵션도 사용하고 아니면 셧다운도 사용할 수 있다라는 뭐 그런 얘기를 하고 있는 겁니다 그 다음에 이제 이어가지고 음 얘는 잠시 주석처리하고 그 다음 이제 알아볼건 뭐냐면은 S1더바 샌드버프 S1더바 리시브 버프 아이고 L.. 리씨.. LCB일겁니다 리시브 버프 얘는 수신 버퍼 크기랑 관련이 있구요 얘는 송신 버퍼 크기랑 관련이 있습니다 이건 좀 중요한 옵션이죠? 경우에 따라서 우리가 커널의 송수신 버퍼의 크기를 알고 싶다거나 아니면 변경하고 싶다거나 할 때 이 옵션을 일단 사용하면 된다고 볼 수 있는 거고 문서에 찾아보면 여기 어딘가 있을 겁니다 , 이렇게, 인트형으로 받아주는 걸 볼 수가 있어요 얘는 인트다 그러면 얘도 예를 들면 우리가 지금 기본 상태로 사용하고 있는 이 버퍼 크기가 굉장히 궁금하니까 , 이렇게, 한번 알아보도록 할게요 인트32 옵션 렌스 사이즈 오브 샌드 버퍼 사이즈라고 한 다음에 , 자, 갯 소켓 옵션 이라는걸 이용해가지고 찾아볼건데 얘같은 경우는 마지막 인자가 인트형 포인터라는걸 볼 수 있습니다 이 크기의 포인터를 받고 있는거죠 왜 그런지는 뭐 저한테 여쭤보시면 안되고 이건 그냥 그렇게 되어있으니까 그렇게 사용하면 됩니다 서버 소켓 SOL 소켓 그 다음에 샌드 버퍼의 크기는 얼마인가 라고 알아보고 싶은 거고 포인터를 넘겨줘야 되니까 캐스팅을 해줘서 샌드버퍼 사이즈에다가 우리가 받아줄 것이고 그 다음에 우리가 방금 넣어준 샌드버퍼 사이즈라는 그 옵션의 크기는 우리가 옵션 렌스라는 걸 받아줬고 그거에 포인터를 또 받아주고 있으니까 , 이렇게, 만들어 주면 되겠습니다 네 , 이렇게, 해가지고 우리가 샌드버퍼 송신버퍼 크기 송신버퍼 크기는 얼마 얼마이다 라는 로고를 , 이렇게, 찍어 보도록 할게요 샌드 버퍼 사이즈 그 다음에 이걸 복사해가지고 한 번 더 만들어 준 다음에 이번에는 리시브 버퍼 사이즈로 똑같은 작업을 한 번 더 해주도록 할게요 그리고 얘는 S on the bar rcb-buff라고 receive-buffer-size는 얼마입니까? 라고 질문을 하는거죠. 그리고 얘는 소신버퍼 크기로 , 이렇게, 바꿔주면 되겠습니다. , 자, 궁금하니까 바로 실행을 해보도록 할게요. 여기다가 breakpoint를 잡고 그냥 한번 실행을 해보도록 하겠습니다. , 자, 그러면은 , 일단은, 기다리면 , 자, 이렇게, 게임서버 6536 64KB로 , 일단은, 기본적으로 설정이 되어 있는 거 볼 수가 있는데 여러분 환경도 아마 , 이렇게, 뜰 것으로 일단 예상이 됩니다 근데 물론 우리가 원한다면 이 값을 우리가 바꿀 수 있기는 해요 근데 바꾼다고 하더라도 그냥 말도 안 되게 큰 값으로 4GB를 해주세요 라는 말도 안 되는 요청을 하면은 얘가 내부적으로 그냥 무시를 할 수가 있어요 그래서 Set Socket Option으로 설정할 수 있긴 하지만 너무 큰 값을 우리가 멋대로 할 수는 없으니까 진짜로 적용이 되었는지를 살펴보고 싶으면 Set Socket Option으로 바꿔준 다음에 다시 한번 Get Socket Option으로 살펴보면 되겠습니다. 그래가지고 , 사실, 가장 중요한 애들은 , 이렇게, 사용하면 되고요. 사용방법은 굉장히 단순하죠. 그냥 여기다가 문서를 보고 어떤 애들을 사용해야 할지를 정해준 다음에 거기에 맞는 크기에 따라가지고 옵션을 넣어주면 된다라는 그런 결론을 얻을 수가 있겠습니다. 나중에 다른 애들이 필요하면 문서를 보고 , 이렇게, 조금씩 찾아보면서 하면 된다고 보시면 되겠어요. , 자, 그리고 그 다음으로 이제 뭐 중요한 거 몇 가지만 더 해보자면 리우스 어드레스라는 게 하나가 있습니다. 이것도 이제 굉장히 중요한 기념인데 여기 있죠. 불리언을 받아주고 있는데 여기서 보면은 어떤 소켓에 그러니까 어떤 주소를 사용 중인 주소를 재사용할 수 있다라고 설명이 되어 있는데 이게 은근히 중요한 개념입니다. 그래서 다음으로 알아볼게 so__reuseaddress 이라는 건데 얘는 말 그대로 ip 주소 및 포트를 재사용한다는 의미입니다. , 자, 이거는 정확히 이게 왜 필요한지를 알려면은 , 사실, tcp에 대한 이론을 좀 알아야 되는데 지금은 그렇게 뭐 장황하게 tcp에 대한 이론을 설명하지 않기로 했으니까 간단하게 설명을 드리자면 우리가 tcp에서 소켓을 만든 다음에 그 다음에 주소를 만들어 가지고 바인드를 해서 그 주소에다가 우리가 원하는 ip랑 그 포트 번호를 , 이렇게, 바인딩 해 줘 가지고 묶어 줬었죠 근데 경우에 따라서 그 주소가 이미 사용 중인 경우가 있을 수 있습니다 뭐 다른 프로그램이 사용하는 경우도 있을 수 있고 아니면은 그냥 우리가 서버를 켰다가 뭔가 강제 종료하고 다시 서버를 켜고 이런 상황이 되면은 이게 아직까지 그 찌끄레기가 정리가 되지 않아 가지고 남아있는 상태가 될 수가 있어요 그러다 보면은 바인딩이 실패해 가지고 한 3분 정도 기다리지 않으면 우리가 서버를 띄울 수가 없게 됩니다 그런 상황은 우리 입장에서 굉장히 귀찮은 상황이 되겠죠. 그래가지고 이런 걸 예방하기 위해서 강제로 그냥 우리가 해당 주소를 재사용하겠다라고 땡강을 부린 방법이 있는데 그게 바로 s on the bar reuse address라는 요 아이입니다. 그래서 얘는 어지간해서는 그냥 세팅을 해주는 게 좋습니다. 여기서는 이제 분리원을 받는다고 했으니까 enable를 true로 해주고 예를 들면 pointer와 sizeofenable 이라고 해가지고 크기를 , 이렇게, 넣어주면 얘가 혹시라도 이미 사용중인 주소가 있다고 해도 걔를 이제 강제로 내가 점령하겠다라고 재사용을 할 수 있게 돼요 제가 이거를 예전에 몰라가지고 그냥 맨 처음에 소켓 프로그램을 공부를 할 때 서버를 띄우다가 뭐 어떤 이런저런 디버깅을 하고 강제 종료하다 보니까 그 두 번째로 띄울 때 서버가 뜨지 않는 문제가 있더라구요 그러면 아 그때서야 부랴부랴 클라이언트랑 서버와의 포트도 바꾸고 막 이랬던 기억이 있는데 그럴 필요가 전혀 없이 , 이렇게, 소켓 옵션만 뿅 켜주면 된다라고 볼 수가 있겠어요 , 사실, 이건 개발 단계에서 좀 편하라고 하는 거라고 볼 수가 있겠습니다 그 다음에 마지막으로 얘는 이제 이 소켓 쪽이 아니라 ip, proto, underbar, tcp 쪽 그러니까 tcp 쪽에서 설정하는 옵션 중 굉장히 중요한 게 하나가 있는데 이거는 이제 꼭 알아야 되는데 tcp no delay라는 게 있습니다 이거는 네이글이라는 알고리즘 작동 여부랑 관련이 있어요 , 자, 네이글도 이제 정확히 얘가 뭘 하는지 알려면 또 TCP에 대한 이론을 실컷 설명을 해야 되는데 이걸 한 줄 요약하면 그냥 이런 겁니다 데이터가 충분히 크면 보내고 그렇지 않고 좀 작다 싶으면 데이터가 충분히 쌓일 때까지 대기한다 라는 이런 아이디어라고 보시면 되겠어요 최대한 데이터를 뭉쳐 보내 가지고 회선 낭비를 줄이고 좀 효율적으로 보내겠다는 아이디어입니다 근데 , 이렇게, 뭉쳐 보낸다고 하면은 장점은 당연히 너무 작은 패킷이 불필요하게 많이 생성되는 일을 방지할 수 있다는 장점이 있긴 하지만 단점은 무엇이냐면은 반응 시간의 손해를 보게 되겠죠 애당초 얘가 멋대로 뭉쳐가지고 보낼 테니까 우리는 분명히 샌들을 했는데 걔가 보내지 않고 그냥 지 멋대로 더 올 때까지 대기를 타는 행위가 사실은 마음에 안 듭니다 그래가지고 이제 일반적으로 게임에서는 이 네이글을 항상 꺼주는게 일반적이에요 우리는 무조건 반응시간이 더 중요하고 진짜로 필에 따라가지고 우리가 샌드를 했는데 TCP 레이어에서 막 네이글 알고리즘이 켜졌다고 이걸 안보내는건 우리가 용납할 수가 없기 때문에 이제 이거를 설정을 해주게 됩니다 NO DELAY를 TRUE로 켜면은 네이글 알고리즘이 작동하지 않는겁니다 그래가지고 이것도 마찬가지로 이런식으로 SET SOCKET OPTION에서 SOCKET과 IP PROTOTCP TCP NO DELAY 그 다음에 마찬가지로 캐릭터 포인터 이네이벌 사이즈오프 이네이벌 이런 식으로 설정해서 이제 이 노 딜레이 옵션을 끄고 켤 수가 있어요 네이글 알고리즘을 켜고 끌 수 있다 , 자, 그러면은 아니 그렇게 되면은 반응 시간에는 이득이 되지만 작은 패킷을 너무 많이 보내는 거 아닙니까라고 생각할 수도 있지만 그 패킷을 보내고 말고는 , 사실, 우리가 유저 레벨에서도 충분히 관리를 할 수가 있어요 우리가 원한다면 당장 샌들을 호출하는 게 아니라 우리가 유저 레벨에서 충분히 원하는 만큼 패킷을 쌓아가지고 샌드로 호출할 수 있기 때문에 굳이 이거를 우리가 전혀 알 수 없는 자기만의 방법으로 뭔가 , 이렇게, 뭉쳐가지고 보내게 놔두지 않고 우리가 관리하는 게 , 사실, 훨씬 더 효율적이라는 얘기가 되는 거죠 그래서 게임 쪽에서는 오지간에서는 네이벌 알고리즘을 사용하지 않게끔 이 TCP 노 딜레이를 2로로 딜레이 없이 보내라고 켜주는 게 일반적이라고 보시면 되겠습니다 뭐 , 이렇게, 해가지고 간단하게 그냥 소켓 옵션을 이것저것 건드리고 설정하는 방법에 대해서 알아봤는데 기회가 되면은 뭐 나머지 부분들에 대해서도 그냥 간략하게 한번 살펴보고 뭐 굉장히 재미있는 게 많습니다 예를 들면 우리가 블록킹 계열의 함수를 이용해가지고 send랑 receive를 했을 때 데이터가 있을 때까지 기다리는 뭐 이런 경우가 있었는데 , 이렇게, 타임아웃을 설정해가지고 무조건 빠져나오도록 설정할 수도 있고 굉장히 다양한 옵션이 , 일단은, 있다는 걸 볼 수가 있어요 물론 이게 꼭 우리가 만드는 MMOTCP 서버에만 관련이 있는 건 아니다 보니까 생각보다 옵션이 굉장히 많다는 것도 알 수가 있습니다. , 이렇게, 해가지고 이번 시간에 엄청 중요한 내용은 아니었지만 나중에 우리가 네트워크 서버코어 쪽으로 이런 내용들을 라이브러리로 옮길 때 이 옵션을 설정하는 부분도 다시 한번 만들면서 중요한 옵션을 다시 넣게 될 테니까 그때 가서 한번 더 알아보긴 할 거예요. 그래서 , 일단은, 간단하게 , 이렇게, 옵션을 설정하고 가져오는 방법에 대해서 알아봤습니다.