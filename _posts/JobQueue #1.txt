자, 이제 본격적으로 잡큐를 연구하기에 앞서서 간단하게 커맨드 패턴이 무엇인지에 대해서 일단 언급을 하고 넘어가고자 하는데요 커맨드 패턴 언급은 제가 예전에 C샵 서버 강의수도 했었고 C샵 파트 7 컨텐츠를 만들 때도 한번 했었는데 이제 이번에 세 번째입니다 그래서 제 강의를 한번 쭉 보신 분이라면 굉장히 지겹게도 이 PPT를 많이 보셨을 것 같은데 그 정도로 제가 개인적으로 엄청 중요하다고 생각하는 그런 부분이어가지고 이거를 또 다시 한번 복습을 하고 있어요 네 그래가지고 일단 디자인 패턴에서 커맨드 패턴이란 애가 굉장히 굉장히 유용하게 쓰이는 경우가 많은데요 우선 우리 식당이 예제로 지금 다시 돌아와서 살펴보도록 하면은 어 지금 이제 손님이 밖에서 지금 통신을 하고 있는 겁니다 뭐 식당 예제로 치면은 안내원의 안내를 받아가지고 식당 찍기랑 지금 통화를 하고 있는 뭐 그런 상황이 되겠죠 , 자, 그래서 요 상황에서 일반적인 식당에서 만약에 우리가 주문을 한다고 가정을 해보도록 할게요 그럼 이제 서빙을 담당하는 직원이 달려와 가지고 주문을 받겠죠? 벨을 눌러 가지고 주문을 받은 다음에 식당이 만약에 크지 않다, 한두 명이서 운영하는 그런 작은 식당이라고 하면 주문을 받은 사람이 그냥 식당까지 가서 요리를 만들기를 시작할 겁니다 그리고 이게 , 사실, 우리가 지금까지 만들고 있던 서버 방식이기도 하죠 우리로 치면 지금 테이블에 있는 앉아있는 사람이 , 사실, 세션이라고 볼 수가 있는 거고 그 다음에 주방이 룸이라고 볼 수가 있는 거죠 그래서 만약에 클라이언트 쪽에서 어떤 패킷을 보내서 요청을 줬다라고 하면은 우리는 지금까지 세션이 요청을 받은 애가 바로 실행까지 룸에 가서 add라거나 leave라거나 broadcast라거나 하는 함수들을 직접적으로 실행을 했어요 이게 작은 규모라면 문제가 없고 괜찮을 수도 있는데 만약 이제 경업이 심해지는 경우 즉 굉장히 굉장히 많은 손님들이 다 하필이면 똑같은 메뉴를 시켜가지고 모든 애들이 다 같은 주방 공간에 가가지고 요리를 만들어야 된다고 가정을 해볼게요 그러면 당연히 주방은 공간이 한정되어 있다 보니까 그렇게 운영을 할 수 없겠죠 그래가지고 다들 대기를 하고 있는 겁니다 지금 실질적으로 요리를 하는 애는 한 명밖에 없고 나머지 애들은 그냥 하염없이 맨 먼저 들어간 애가 끝나기를 , 이렇게, 기다리고 있는 거예요 근데 설상가상으로 요리를 만드는 게 지금 오래 걸리고 있다 보니까 나머지 직원들은 그냥 뭐 월급만 축내고 월급 루팡을 하면서 그냥 계속 기다리고 있는 셈이 되는 거죠 그리고 만약에 C-Sharp 서버였다고 하면 여기서 설상가상으로 쓰레드들이 정상적으로 회수가 되지 않으면은 쓰레드풀에서 쓰레드를 늘려가지고 더 밀어 넣는 작업까지 있었는데 뭐 우리는 그나마 다행히 C++ 서버로 작업하고 있으니까 요런 일까지는 일어나지 않긴 하지만 그럼에도 불구하고 주방이 몰려가지고 굉장히 오래 기다린다라는 거는 별남이 없는 겁니다 그러면 우리가 실상에서 과연 이제 식당을 운영할 때 어떻게 하는지를 곰곰히 생각을 해보면 어느 정도 현실에서 해답을 얻을 수가 있는데요 만약에 이게 그냥 간단한 아주 작은 식당이 아니라 뭐 패밀리 레스토랑 이라거나 부패급의 굉장히 굉장히 큰 식당이라고 가정을 하면은 일처리를 어떻게 하는지를 잘 상기를 해봅시다 그러면은 그냥 쉽게 말해서 주방장이 따로 있고 그리고 서빙하는 직원이 따로 있을 겁니다 그래가지고 결국 주문을 받는 직원은 주문을 받자마자 그걸 쪼로로 달려가가지고 요리를 만드는 게 아니라 그냥 주문서를 받는다는 게 가장 핵심입니다 주문서를 받아가지고 그 주문서를 주방장한테 건네주는 거죠 물론 요즘은 주문서가 좀 전자화 돼가지고 그거 주문을 이제 전자기기에다가 넣으면은 그 신호가 자체로 뭐 주방장한테 가고 그러긴 하지만 그래서 좀 기본적으로 생각하면은 어찌됐건 이런 주문서를 만들어서 권해주는게 가장 핵심인거죠 그리고 이 주문서에는 손님이 직접 만든 건 아니지만 손님이 요청한 사항 그대로를 다 주문서로 우리가 적을 수가 있을 겁니다 예를 들면 햄버거를 주문했는데 고기는 웰던으로 하고 야채는 빼달라고 하셨습니다 등등의 요구사항을 우리가 주문서에 그대로 넣어 가지고 주방장이 직접 주문을 받은 건 아니지만 나중에 요리를 할 때 그 주문서를 보고 똑같이 요구사항에 맞게 만들 수가 있다는 게 생기는 거죠 그럼 , 이렇게, 우리가 이 정책을 했을 때 , 사실, 정책이라고 하기도 뭐한 게 너무 당연한 얘기일 수도 있죠 그 식당 입장에서는 근데 이 방식의 장점을 곰곰이 생각을 해보면 일단 뭐 크게 두 가지로 생각할 수가 있는데 주문서를 만들어 가지고 주방장한테 던져 줄 수 있다 이제 서로 영역이 완전히 분리가 되어 가지고 어 한쪽은 주문서를 만들고 한쪽은 요리를 하는 식으로 집중을 할 수 있다는 굉장히 큰 장점이 생깁니다. 뿐만 아니라 주문서를 만드는 시점과 요리를 하는 시점이 분리가 되어가지고 둘로 나뉠 수가 있다는 것도 굉장히 중요한데 이를테면은 만약에 지금 요리가 너무 많이 밀렸다라고 하면은 주문서가 한참 후에 실행이 되겠죠? 그러니까 주문서를 한참 후에 보고 순차적으로 처리를 쫙 해줄 겁니다. 그리고 만약에 뭐 주문서가 들어간 후에 조금 짧은 시간 후에 이제 갑자기 고객이 변심해가지고 메뉴를 바꿔달라 취소해달라고 했다고 하면은 만약에 이제 실질적으로 요리가 들어가지 않은 상황이라고 하면은 그 주문서도 취소할 수가 있겠어 뭐 굉장히 다양한 장점이 있는데 이게 , 사실, 커맨드 패턴이 가장 핵심이라고 생각하시면 돼요 커맨드 패턴은 결국에는 어떤 요청을 캡슐화 해가지고 요런 주문서로 만드는 게 일단 가장 핵심입니다 근데 물론 말이 주문서지 프로그램에서는 주문서라는 게 없으니까 이걸 클래스라거나 함수 객체라거나 하는 식으로 functor라거나 하는 식으로 이걸 담고 있겠지만 결국에는 어떤 요청을 이런 식으로 다른 객체로 담고 있다가 그거를 건네준다가 가장 핵심인 거고 , 이렇게, 해주게 되면은 우리가 락을 잡고 매번마다 이런식으로 모든 애들이 다 똑같은 장소에 경합을 하면서 들어가는게 아니라 순차적으로 주문서를 만들어가지고 요리는 한 명만 계속 담당해서 하고 나머지들은 주문서만 만들고 던지고 그냥 바로 빠져나와서 계속 자기가 할 일을 할 수 있다는 굉장히 큰 차이가 생기게 됩니다 그래서 이 그림을 잘 기억을 해주셔야 돼요 우리는 이제 앞으로 락을 걸어가지고 모든 걸 다 실행하는 게 아니라 그냥 일감만 툭 넘기고 그걸 이제 소위 우리가 잡이라고 부를 겁니다 뭐 잡이라고 하는 경우도 있고 테스크라고 하는 경우도 있고 이건 뭐 프로젝트만 다른데 이런 식으로 어떤 요청사항을 담아가지고 건네 준다가 일단 두고두고 이번 단원이 핵심이 될 거예요 그래서 이 부분을 굉장히 확실하게 이해를 하셔야지만 앞으로 좀 작업하는데 수월할 겁니다 , 자, 그래서 뭐 , 이렇게, 간단하게 커맨드 패턴이 무엇인지에 대해서 알아봤으니까 이제 본격적으로 잡큐를 만드는 코드를 만들어 보면서 이걸 어떻게 우리가 게임에서 응용할 수 있는지 한번 체크를 해보도록 할게요 , 이렇게, 간단하게 동작하는 채팅 프로그램까지는 완료를 해 봤는데 너도 나도 다 락을 걸어 가지고 지금 접근하는 굉장히 원시적인 방법으로 만들어 봤습니다 그리고 지난번에도 언급을 드렸지만 이 방식이 작은 프로젝트라면 딱히 상관이 없기는 하지만 큰 규모라고 한다면 큰 문제를 이야기할 수 있다고 제가 말씀을 드렸습니다 경합이 굉장히 심해지기 때문이죠. 경합이 굉장히 심한데 설상 가상으로 그 중에서 일을 하는 애는 한 명밖에 없고 나머지 애들은 다 경합을 하면서 사실상 진행할 수도 없음에도 불구하고 스피락을 돌면서 CPU만 고갈하고 있는 굉장히 슬픈 상황입니다. 그래서 오늘 알아볼 방법은 잡방식으로 이걸 수정을 해볼 건데 이게 또 할 얘기가 굉장히 많습니다 이게 약간 만드는 방법도 굉장히 다양하고 그리고 컨셉 자체도 처음에는 좀 이야기가 난해한 부분이 있어요 저도 굉장히 이걸 깨우치고 이해하는데 오래 걸렸기 때문에 이거를 최대한 단계별로 풀어 가지고 하나씩 하나씩 보여드릴까 합니다 결국에는 다시 이제 얘기를 하자면 우리가 여기서 입장하고 나가고 브로드 캐스팅하는 지금 이 굉장히 간단한 세 가지 동작만 만들어 봤는데 이걸 이제 잡 방식으로 한번 수정을 해보도록 하겠습니다 그래서 이제 어떻게 진행을 해볼 거냐면 먼저 잡이라는 것에 대해서 한번 그냥 간단하게 고민을 해보도록 할게요 그리고 오늘 이제 실습한 코드는 게임 컨텐츠 산하에 job이라는 클래스를 만들어가지고 여기다가 일단 작업을 해보도록 하겠습니다. 그래서 잠시 job이라는 클래스를 만들어 놓고 여기 게임 컨텐츠 쪽에다가 밀어 놓고 작업을 해보도록 할게요. 요렇게 cpp는 딱히 필요 없을 것 같지만 일단 오른쪽에 놓고 그 다음에 게임 서버 여기서 , 일단은, 잠시 임시로 작업을 해보도록 하겠습니다. test job 그리고 더미 클라이언트는 당장은 뭐 켤 필요 없기 때문에 우클릭해서 시작 프로젝트로 게임서버만 실행을 하도록 일단 만들어 주도록 할게요 , 자, 그러면 이제 어떤 의뢰가 , 일단은, 왔다고 가정해봅시다 어떤 일감이라는 개념 일감의 의뢰 내용은 뭐 예를 들면은 1번 유저한테 10만큼 힐을 줘라 라는 요청이 클라이언트한테서 왔다고 가정을 해볼게요 , 자, 그러면은 이거를 다시 한번 쪼개서 생각을 해보면 어떤 행동 자체는 힐을 주는 그 행동을 의미하는 것이고 인자 자체는 1번 유저 그리고 12라는 힐량 , 이렇게, 일단 두가지 내용을 포함하고 있을겁니다 이거를 우리가 커맨드 패턴으로 만들어가지고 이전에서 한다는 방식대로 바로 요청을 받자마자 실시간으로 호출을 하는게 아니라 이거를 , 일단은, 일감으로 일단 한번 묶어 보도록 할게요 근데 이거를 이제 만드는 방법이 굉장히 다양한데 , 일단은, 가장 원시적인 방법으로 하나를 보여드리도록 하겠습니다 먼저 i job 이라고 해가지고 이런 인터페이스를 하나 만들어 주도록 할게요 execute 어떤 일감이라는 개념은 그냥 뭔가 무엇인가를 실행하는 것이다 라고 , 일단은, 정의를 해주고 그 다음에 얘를 상속을 받아 가지고 이제 일감을 만들어 줄 겁니다 예를 들면은 지금 우리가 여기서 의뢰받은 일감은 힐을 주는 일감을 의뢰를 받았기 때문에 힐 job 이라고 , 일단은, 예를 들어, 보도록 할게요 그러면 모든 애들은 이 iJob이라는 인터페이스를 상속을 받아가서 만들 것이고 그 다음에 virtual void execute라는 함수는 반드시 갖고 있어야 되니까 얘를 이제 오버라이트 해가지고 여기서 뭔가를 만들어주도록 하겠습니다. , 자, 그래서 여기서 힐하는 함수를 호출해주면 될 건데 근데 의뢰하는 내용 자체가 그냥 힐을 아무한테나 해달라는 게 아니라 1번 유저한테 10만큼의 힐을 주라고 요청을 해줬습니다. 그러니까 결국에는 이런 인자들 자체도 같이 어딘가에서는 들고 있어야 된다는 얘기가 드는 거죠. 뭐 예를 들면은 타겟, 유저, 그리고 힐 밸류 뭐 이런 식으로 , 일단은, 인자를 두 개를 만들어 줄 수가 있을 겁니다. 그래가지고 실질적으로 실행을 할 때는 뭐 타겟을 찾아서 타겟에다가 뭔가 addhp를 해가지고 힐 벨류만큼을 뭐 체력을 추가한다거나 하는 식으로 이제 응용을 해볼 수가 있을 겁니다. 근데 지금은 뭐 이런 함수가 없으니까 그냥 뭐 로그로 찍어보도록 할게요. 뭐... 타겟 한테 힐 줌 너무 성의가 없나요? 한테 힐 얼마얼마 줌까지 일단 포함해 해주도록 합시다. 힐 벨류만큼 힐을 얼마 얼마 만큼 쯤 , 자, 이렇게, 일단 로그를 찍어 보도록 하겠습니다 그러면 이제 여기서 의뢰한 일감을 우리가 요런 식으로 만들어줄 수 있다는 거죠 뭐 일단 잡 헤더를 추가를 해주도록 하고 잡 헤더를 추가하고 얘가 의뢰한 내용은 이제 힐 잡이라는 걸 요렇게 만들어 줄 수가 있을 건데 힐 잡에 뭐 타깃을 예를 들면 1로 1로 설정을 하고 그 다음에 힐 잡에 힐 벨류, 10이라는 힐량이니까 이걸 , 이렇게, 만들어 준 다음에 이제 이 힐잡이라는 거를 그냥 다른 애한테 막 건네주면 되겠습니다. 물론 이걸 뭐 스택 메모리에다가 들고 있기보다는 동적할당해가지고 스마트 포인터 형태로 넘겨주는 게 조금 좋긴 하겠지만 뭐 그건 나중에 생각할 문제고 , 일단은, 이렇게, 힐잡이라는 거 자체를 만들었다는 거에 , 일단은, 큰 의미를 둘 수가 있는 거죠. 그래가지고 나중에, 아주아주 나중에 때가 되면은 이제 힐잡을 execute 를 호출해 줘 가지고 이제 이거를 실행할 수가 있게 되는 겁니다 , 사실, 이런 컨셉이에요 요청사항을 어떤 클래스로 만들어 가지고 해당 행동들이랑 내가 해야 하는 행동들이랑 인자들을 다 저장하고 있어서 이걸 나중에라도 호출할 수 있게 만든다는 게 , 일단은, 이 잡의 가장 핵심적인 개념이라고 볼 수 있는 겁니다 이게 가장 기초에요 그래서 이걸 뭐 간단하게 한번 실행을 해서 여기서 브레이크 포인트를 여기서 아래서 잡아 가지고 얘가 호출된 다음으로 , 일단은, 넘어가서 딱 잡아 보면은 , 자, 그러면은 브릭포탄 잡히면서 1한테 힐만큼 힐을 10만큼 줌 이라고 일단 로그가 정상적으로 뜨는 걸 볼 수가 있습니다 그래서 요런 콘셉트로 만드는 거죠 , 자, 그러면은 그 다음으로 이제 얘기할 내용은 뭐냐면은 이 방식이 지금 우리가 만들고 있는 이 원시적인 방법이 굉장히 직관적이긴 합니다 이 잡을 실행해라 라는 함수가 있고 여기서 구현부를 만들어주고 있고 그 다음에 내가 필요한 인자들을 여기서 , 이렇게, 뿅 저장하고 있죠 이 방식의 단점이라고 한다면 우리가 어떤 일감을 필요해 가지고 일감을 만들 때마다 , 이렇게, 클래스를 늘려 줘야 되는 게 정말로 끔찍하게 느껴집니다 근데 굉장히 놀랍게도 , 이렇게, 실제로 만드는 프로젝트가 꽤 많습니다 진짜로 일감이 필요할 때마다 클래스를 하나하나씩 늘려 가지고 작업하는 프로젝트가 제가 들어본 것만 한두 개가 아니에요 그래서 진짜로 뭐 간단하게 만들자고 하면 , 이렇게, 만들 수도 있다는 얘기가 되는 거죠 그래서 오늘은 뭐 첫 시간이니까 이거를 뭐 템플릿 흑마법을 이용해 가지고 더 발전시키기 보다는 그건 이제 다음 시간에 계속 이어서 할 거니까 그렇게 하진 않고 그냥 간단하게 이 원시적인 방법을 이용해 가지고 우리가 기존에 작업했던 채팅 프로그램을 그냥 수정을 해보고 마치도록 할 겁니다 , 자, 그래가지고 , 일단은, 그 다음으로 필요한게 뭐 , 이렇게, 샘플로 잡을 , 이렇게, 만들면 된다라는 걸 알았고 이제 잡큐라는 걸 만들어가지고 이 잡을 순차적으로 처리할 수 있게끔 우리가 유도를 해줄 겁니다 , 자, 그래가지고 job ref를 , 일단은, shearedptr의 i job으로 , 일단은, 정의를 해줄 것이고 그 다음에 job q라는 클래스를 간단하게 요렇게 만들어 보도록 할게요 job q 그래서 뭐 얘가 들고 있는 인자들은 일단 lock을 사용할 거에서 use lock을 추가해주고 그 다음에 그냥 q를 job ref라고 해가지고 뭐 요렇게 , 일단은, q 형태로 들고 있다고 가정을 해 보도록 할게요 그 다음에 얘가 지원하는 기능은 푸쉬팝 두 가지가 있는데 잡을 밀어 넣을 때 그리고 잡을 꺼내서 사용할 때 , 이렇게, 두 가지가 있다고 가정을 해봅시다 먼저 푸쉬를 하는 쪽에서는 락을 먼저 잡아준 다음에 그 다음에 잡스에다가 잡을 , 이렇게, 넣어주면 끝나요 얘는 뭐 굉장히 단순합니다 잡을 , 이렇게, 넣어주고 끝나고 팝을 하는 입장에서는 얘도 똑같이 락을 걸어준 다음에 먼저 잡큐를 확인해서 얘가 비어있는지를 확인해서 비어있으면 그냥 널 BTI를 예선해줄 것이고 그게 아니라고 한다면은 뭐 잡스를 꺼내가지고 팝을 해준 다음에 리턴을 뭐 이런 식으로 해줄 수가 있겠죠 그래서 요 잡큐라는 걸 이용해가지고 이제 일감을 순차적으로 다 하나씩 하나씩 의뢰서를 이제 받아줄 겁니다 주문서를 순차적으로 받아준 다음에 하나씩 하나씩 꺼내가지고 이제 실행을 하게 된다는 거죠 그러면은 이거를 이제 다시 룸에 가가지고 우리 룸에 가가지고 살펴보면은 , 자, 지금은 우리가 룸을 뭐 하나만 활용하고 있습니다 그러니까 간단한 간단하게 하나만 사용하는 걸 기반으로 만들어 볼 건데 먼저 지금 행동이 3가지가 있어요. 입장, 퇴장, 그리고 브로드캐스트 , 이렇게, 일감이 3개가 있는데 우리의 구닥다리 무식한 방법에서는 그냥 이거를 하나하나씩 다 클래스로 만든다고 했었죠. 그러니까 여기다가 룸과 관련된 잡을 하나씩 정리를 해보도록 할게요. 먼저 엔터 잡을 만들어줄건데 i 잡을 상속을 받아가지고 만들 것이고 , 자, 잡을 모르고 있으니까 여기다가 잡 패널을 추가를 해주도록 할게요. , 자, 그러면은 여기서 엔터 잡에서는 이제 필요한게 무엇이냐 오히려 인자들부터 생각을 해보면 되겠죠 룸을 참조값으로 받아주고 플레어 레프를 레퍼런스로 , 이렇게, 받아주러 갑시다 레퍼런스 카운팅을 해가지고 , 자, 그래가지고 여기서 참조값으로 룸을 들고 있을 것이고 플레어 레프로 스마트 포인터로 플레어를 받아준 다음에 생성자에서는 룸을 건네주고 플레이어도 건네준 채로 , 이렇게, 인자로 들고 있으면 되겠죠 요런 느낌으로 그러면 이제 엔터잡 생성자는 완료가 되었습니다 요렇게 일단 만들어봤어요 딱히 뭐 내부적으로 할 건 없을 것 같고 그 다음에 virtual void execute override를 한 다음에 얘가 내부적으로 이제 실행해야 되는 거는 룸에 입장을 시켜줘야 되는데 뭐 이왕 이 함수를 만들었으니까 room.enter를 그대로 활용을 해주도록 할게요 어 애당초 , 이렇게, 할 거면은 그러면 왜 굳이 이 잡을 만들었느냐 , 자, 요 부분이 이제 달라지는데요 우리가 기존에는 이 룸을 사용할 때 use lock을 해가지고 매번 마다 락 락 락을 잡아 가지고 활용하고 있었습니다 근데 이제 이 잡큐방식으로 바꿔지기가 되면은 내부적으로 더이상 락을 사용하지 않을 거예요 이게 굉장히 큰 차이점입니다 , 자, 그래가지고 요런 기본적인 함수들은 마치 싱글 스레드 스레드 환경인 마냥 코딩을 해주게 됩니다 요런 부분들은 그리고 실질적으로 멀티 스레드와 관련된 애들은 그럼 이제 어떻게 처리하느냐 환경에서는 그리고 환경에서는 밀감으로 잡으로 무조건 접근을 해야 돼요. 그렇기 때문에 여기서 뭐 , 일단은, 잡큐를 , 이렇게, 일단은, 하나를 만들어 주도록 하겠습니다. 잡큐를 만들어 주고 실질적으로 푸쉬 잡이라는 걸 이용해 가지고 잡을 만들어 가지고 여기 이런 식으로 잡스에다가 잡을 밀어 넣고 그리고 플러스 잡을 해가지고 누군가는 이제 이 일감을 실행하는 역할을 맡게 될 겁니다 그리고 이건 정책이 여러가지로 갈리는데 내가 일감을 밀어넣는 너와 동시에 아무도 지금 실행을 하지 않고 있으면 내가 담당해서 실행을 하는 경우도 있고요 아니면 그냥 애덩초 분리를 해가지고 , 이렇게, 푸쉬하는 애 따로 그리고 실행하는 애 따로 , 이렇게, 배치하는 경우도 있습니다. 그러니까 예를 들면은 요리사를 따로 고용해가지고 요리사는 요리만 전문으로 하고 나머지 이제 뭐 서빙을 담당하는 직원들이 주문서만 받아가지고 주문서만 요리사한테 건네주는 경우도 있고 아니면은 그냥 뭐 작은 식당이라고 하면은 내가 주문을 받아가지고 요리까지 하는 경우도 있겠죠. 그러니까 그건 이제 상황에 따라 다르다는 얘기입니다. 기본적으로 지금 오늘 배우는 내용의 컨셉의 핵심은 락을 더 이상 사용하지 않고 모든 걸 잡방식으로 동작을 시킨다는 굉장히 큰 차이가 생기게 된 거예요 그럼 물론 이걸 처음에 공부하면 이해가 안 가는 게 어떻게 싱글셋인 것 마냥 코딩할 수 있을까 애당초 그래도 지금 멀티셋 환경이니까 누군가가 이거를 동시에 접근할 수 있지 않을까라고 생각할 수 있지만 애당초 이 잡방식을 사용하는 순간 이 엔터 리브 브로드 캐스팅은 직접적으로 접근해가지고 막바로 호출하면 안되고 무조건 이런 일감을 통해 가지고만 접근할 수가 있게 됩니다 그게 가장 큰 차이가 있다고 보시면 되겠어요 그래서 만약에 이런 걸 외부에서 호출하는 게 불안하다고 하면 예를 들면 프라이메이스로 만들어주고 뭐 이런 애들만 프렌드 클래스로 엔터잡이라거나 이런 애들 만들어 주는 것도 고려할 수 있겠죠 너무 불안하다 싶으면 , 자, 그리고 뭐 , 일단은, 엔터 잡을 요렇게 만들어놨으니까 그 다음에 leave 잡이랑 , 자, 두개를 더 복사한 다음에 얘는 이제 leave 잡이라고 바꿔치기를 해주도록 할게요 떠나는 잡 얘는 아마 우리가 이전 코드에서 뭐 딱히 해주지 어 아직 호출하는 경우가 없었던 것 같긴 한데 뭐 그래도 그냥 간단하게 요렇게 , 일단은, 만들어 보도록 하겠습니다 리브 플레이어 , 자, 그리고 여기서도 막 리브 잡 그리고 뭐 브로드 캐스트 잡 이런식으로 프렌드 클래스를 늘려주도록 하겠습니다 브로드 캐스트 네 요런식으로 마지막 브로드 캐스팅 잡이 가장 지금 테스트할 때는 중요한데, 브로드 캐스팅 잡 같은 경우에는 룸과 함께 플레어 랩을 받아주는 게 아니라 샌드 버퍼를 받아줘야 되겠죠. 샌드버퍼랩프를 , 이렇게, 받아준 다음에 얘를 샌드버퍼라는 멤버 변수에다가 건네주도록 하겠습니다 요 부분을 긁어가지고 , 자, 요렇게 , 일단은, 바꿔치기를 해준 다음에 언더바를 붙여주면 되겠죠 그럼 얘는 broadcast 한 다음에 샌드버퍼를 건네주면 되겠습니다 우리가 이미 엔터리브 브로드캐스트를 만들어놨기 때문에 똑같은 브로드캐스트 함수를 호출하게 했지만 꼭 , 이렇게, 함수를 파줘야 된다는 얘기는 아닙니다. 여기다가 그냥 기능을 직접적으로 만들어도 안될 건 없어요. 근데 뭐 최대한 코드를 재생하기 위해서 , 이렇게, 일단 만들어봤고 , 자, 이렇게, 해가지고 이제는 잡을 여기다가 만들어가지고 푸쉬를 할 준비가 끝났으니까 이제 이걸로 한번 수정을 해보도록 할게요 지금 이 상태에서 만약에 빌드를 하면은 우리가 프라이베트로 막아놨기 때문에 이제 엔터 리브 브로드캐스트를 사용하는 쪽에서 다 빠바밤 에러가 날겁니다 그 부분을 찾아가지고 아이고 찾아줬네요 여기서 수정을 해보도록 하겠습니다 엔터게임을 할 때 원래 우리가 처음에 하던 방식을 살펴보면은 여기서 락을 걸어가지고 엔터를 했었는데 , 자, 이 부분이 이제 , 이렇게, 되는 게 아니라 요렇게 막바로 호출해주는게 아니고 이제는 잡을 만들어가지고 호출해줘야 됩니다. 요거 그냥 삭제할게요. 좀 이상한데? , 자, 이렇게, 해가지고 여기서 위에가지고 잡을 , 일단은, 헤더를 추가를 해줄것이고 어... 잡은 필요 없을까요? 잡은 필요 없을 것 같고 이미 잡 자체가 요기 안에 들어가있기 때문에 엔터잡에 들어가있기 때문에 요기다가 일단 막바로 만들어 보도록 할게요. groom에다가 push 잡을 할것인데 포시즈 잡을 하는데 여기다가 메이크 쉐어들 통해 가지고 엔터 잡이라는 걸 우리가 만들어주고 인자로는 룸이랑 플레어를 , 이렇게, 건네주면 되겠죠 그래가지고 아까와는 조금 달라진 게 이제는 룸을 바로 입장시키는 걸 여기서 실행한 다음에 그 다음 부분이 실행이 되는 게 아니라 , 사실, 일값만 우리가 예약을 해준 상태고 그 다음에 그 다음으로 바로 넘어가게 될 겁니다 , 사실, 이 엔터게임을 지금 당장 답장을 주는게 조금 이상해지는 경우도 생기게 되겠죠 왜냐면 얘는 아직 실행이 된게 아니고 , 일단은, 일감을 만들어서 예약만 한 상태입니다 나중에 누군가가 얘를 실행해주게 되겠죠 그래서 이게 정말 거슬린다고 하면 얘도 엔터게임 다음에 이쪽에서 호출이 되게끔 이사를 시켜준다거나 하는 식으로 바꿔주면 되겠습니다 일단 그 부분은 가장 핵심이 아니기 때문에 일단 넘어갈 것이고 그 다음에 두번째로 엔터 다음에 , 자, 브로드 캐스팅 하는 부분도 마찬가지에요 여기서 이런식으로 락을 잡아가지고 브로드 캐스팅을 하는게 아니라 이제는 얘는 사용하면 안되고 G룸에다가 푸쉬 잡을 해가지고 일감을 밀어 넣어줘야 되는데 이번에는 메이크 셰어드로 브로드 캐스팅 하는 일감을 만들어주고 여기다가 룸이랑 샌드 버퍼를 각각 요렇게 건네주도록 할게요 그러면 이제 요 두 문제는 해결이 되었고 우리가 이제 일감을 계속 밀어넣는 식으로 작업을 하게 된 겁니다 그러면 일감을 밀어넣는 거는 좋은데 누군가는 여기에 있는 일감을 꺼내서 실행해주긴 되어야 되겠죠? 즉 요리사가 필요한데 오늘은 뭐 간단하게 만드는 게 목표니까 요리사를 메인 스레드가 담당하게 만들어 보도록 하겠습니다 그래서 게임 서버에서 아래로 쭉 내려가지고 그냥 여기다가 무한 루프를 계속 돌면서 디스 스레드 sleep for 뭐 한 1ms 씩마다 잠자면서 계속 groom에 flush job을 , 이렇게, 계속 때려준다고 가정을 해보도록 할게요 , 자, 위에 가가지고 room.header 추가를 하고 오도록 하겠습니다 room.header 그래서 다시 와서 보면은 이제 이 흐름을 이해하시는 게 굉장히 중요한데 결국에는 누군가는 일을 넣고 있고 누군가는 그 일을 꺼내가지고 순차적으로 이제 실행을 하게 되는 겁니다 , 자, 그 다음에 여기 이제 구현부를 안 만들어놨는데 implementation에 가가지고 그러면 flush job을 할 때는 무엇을 해야 되느냐 뭐 얘도 여러가지 방법을 만들 수 있겠지만 그냥 간단히 , 이렇게, 만들어 보도록 할게요 일감이 있을 때까지 계속 뺑뺑이를 돌면서 jobs에 pop을 해가지고 여기서 만약에 job이 없다 더 이상 일감이 없으면 잠시 브레이크를 할 것이고 그게 아니라고 하면은 얘를 계속 실행을 하도록 할게요 이걸 이제 밖에서 무한으로 호출하고 있으니까 그냥 일감이 있을 때마다 계속 호출을 해주게 되겠죠 , 자, 이게 , 일단은, 가장 핵심적인 차이라고 보시면 되겠어요. 그래서 , 일단은, 게임 서버 다시 빌드해서 문제가 없는지 한번 테스트를 해보고 문제가 , 일단은, 없다고 하면은 다시 두개를, 아이고 뭐 하나가 문제가 있었는데 지금 뭐가 문제인지 살펴보면은 엔터 잡 프라이벳 멘더 선언에 할 수가 없다고 하네요. , 자, 이거는 다시 보면은 엔터 잡에 프라이벳 맵 아 이거를 지금 우리가 생성자를 퍼블릭으로 안 열어줘서 그런 거네요 생성자랑 엑세큐트 부분은 퍼블릭 퍼블릭으로만 밀어줘야 되겠죠 요런 식으로 , 이렇게, 다시 한번 빌드를 해보도록 하겠습니다 그러면 별다른 문제가 없으면 통과가 될 것이고 , 자, 그 다음에 이게 통과가 되었으면은 다시 속성에 가가지고 여러개의 프로젝트 시작 게임 서버 더밋 클라이언트를 같이 실행해서 이전과 마찬가지로 그냥 채팅 메세지가 쫙 뜨는 것만 확인을 하면 일단 정상적으로 수정이 되었다고 결론을 내릴 수가 있겠죠 정상적으로 잘 보는지 되는지 한번 살펴보면 이런 식으로 헬로월드가 열심히 열심히 뜨는 걸 볼 수가 있습니다 아직은 딱히 개선사항이 있었는지 없었는지 모르겠지만 일단 1차적으로 스레드의 경합을 최대한 줄일 수 있는 방법을 일단 만들어놨다는 게 가장 큰 차이가 생기게 된 거고 이 컨셉을 반드시 잘 이해를 하시고 넘어가셔야 되겠습니다 다음에서도 계속 이런 내용들이 등장할 것인데 그럼 이제 결론적으로 요약을 하면은 이제 설명을 할 수가 있어야 돼 이게 어떤 차이가 있는지 근데 이제 한 가지 이상하게 생각할 수 있는 거는 진짜 여기서 푸쉬만 해줘도 되는 건가 락을 걸지 않는 게 맞는 것인가 라고 생각할 수 있는데 이게 락을 걸지 않는 거는 아닙니다 그냥 락을 굉장히 짧게 걸어준 셈이 되는 거죠 왜냐면은 다시 한번 살펴보면 이 잡큐에다가 일감을 밀어넣고 꺼낼 때는 잠시나마 락을 , 일단은, 걸기는 걸기 때문에 그렇기 때문에 얘가 멀티셋 환경에서도 안전하게 , 일단은, 사용할 수 있는 거예요 즉 이 잡큐는 멀티셋 환경에서 잘 돌아가는 스레드 세이프한 큐이기 때문에 이런 코드가 만들어질 수 있는 거죠 그리고 실질적으로 엔터, 리브, 브로드캐스트 등 , 이렇게, 컨텐츠 코드를 실행하는 쪽에서는 얘가 그냥 고지곳대로 외부에서 호출할 수 있는 애들이 아니라 반드시 일감을 일감을 하나씩 하나씩 꺼내 가지고 엑세큐트를 실행하는 쪽으로 실행이 되고 있기 때문에 얘는 어차피 한 번에 한 스레드만 접근해 가지고 해주고 있기 때문에 아무런 문제가 없다라고 , 일단은, 결론을 내릴 수가 있는 겁니다 근데 물론 이제 플러시 잡도 실수해가지고 여러 스레드가 동시에 얘를 실행한다고 하면 똑같은 문제가 일어나겠죠? 이거는 절대로 하면 안 되고 무조건 한 명만 담당해가지고 요리사는 한 명만 배치해가지고 지금까지 예약된 일감을 순차적으로 하나씩 꺼내가지고 실행한다는 게 굉장히 큰 차이가 생기게 된 거예요 그러면 이제 또 얘기를 해보자면 일감을 푸쉬를 한 순서대로 예약을 한 순서대로 순차적으로 꺼내가지고 실행한다는 것도 이 방식의 특징이라고 , 일단은, 볼 수가 있겠습니다 , 자, 이렇게, 해가지고 간단하게 이제 잡방식으로 만들어 봤고요 실질적으로 다시 한번 말씀을 드리지만 , 이렇게, 클래스를 늘려가지고 작업하는 프로젝트도 덜어 있습니다 제가 본 프로젝트만 해도 두세개는 돼요 , 자, 그래가지고 , 이렇게, 일단 작업을 해봤는데 근데 만약에 여러분들이 이제 앞으로 컨텐츠를 , 이렇게, 작업을 해야 된다고 가정을 해볼게요 굉장히 끔찍하죠 실질적으로 코드를 작업하는 게 2-3배가 되는 겁니다 , 이렇게, 일반적인 컨텐츠 코드를 만드는 것 뿐만 아니라 매번 마다 멀티세드 환경을 생각해 가지고 이런 클래스를 만들어 가지고 인자를 넘겨주고 즉 함수를 만들 때마다 얘도 이제 대칭적으로 같이 만들어 줘야 하는 데는 굉장히 끔찍한 작업이 생기게 되는 거죠 그리고 저는 개인적으로 , 이렇게, 클래스를 무한으로 늘리는 걸 굉장히 혐오합니다 그래서 이미 프로젝트가 그렇게 만들어져 있다고 하면 어쩔 수 없이 수능을 해야 되겠지만 우리처럼 그냥 새로 이것저것 서버를 만들 수 있다고 가정을 하면 여러가지 다양한 방법들로 이거를 조금 더 쉽게 만들 수 있는 방법에 대해서 일단 학습하면 굉장히 큰 도움이 되겠죠 , 자, 이렇게, 해가지고 다음 시간에는 이런 1세대 방식보다 조금 더 우월하게 잡을 만들고 관리할 수 있는 그런 여러가지 방법에 대해서 , 일단은, 학습을 해 보도록 하겠습니다.