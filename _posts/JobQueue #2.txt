자, 이렇게, 지난 시간까지 잡큐를 관리하고 그 다음에 일감으로 만들어 가지고 밀어 넣고 진행하는 부분까지 , 일단은, 실습을 해봤습니다 정말로 그야말로 1세대 잡 방식이라고 볼 수 있는 거죠 음 지난번에도 얘기를 드렸지만 이런 식으로 클래스를 하나하나씩 늘리는 것 자체가 , 사실, 이 방식이 가장 큰 단점이라고 볼 수 있겠습니다 뭐 장점이라고 한다면 그래도 코드가 좀 그나마 직관적이다 클래스 자체를 , 이렇게, 멤버 변수로 우리가 인자로 넘겨줄 애들을 들고 있고 그 다음에 실행하는 부분은 그나마 직관적이긴 한데 뭐 어찌됐건 나중에 컨텐츠를 만들게 되면 굉장히 방대한 코드를 만들게 될 것인데 , 이렇게, 하나하나 클래스를 만드는 거는 , 사실, 저는 별로 그렇게 좋은 방법이라고 생각하지 않습니다 아주 오늘 이제 알아볼 2세대 방법은 조금 이걸 수정을 해가지고 공용 클래스로 만들어 가지고 일감을 관리하는 그런 방법에 대해서 알아볼 건데 뭐 , 사실, 결론부터 말씀을 드리자면 표준에 있는 std 펑션이랑 람다를 최대한 잘 활용을 하면은 요런 부분을 굉장히 쉽게 구현할 수 있기는 합니다 근데 오늘 알아볼 부분은 그 부분은 아니고 어떻게 보면 약간 2세대 같은 느낌이라고 보시면 되겠어요 조금 더 지난번에 비해서는 많은 발전이 있긴 하지만 이것도 완벽하지는 않다 근데 , 이렇게, 좀 중간 단계를 거치는 이유는 바로 람다에 대한 내용을 람다 캡처에 대한 내용을 다루기보다는 이게 어떠한 원리가 있고 어떠한 장단점이 있는지를 파악하는 게 중요하니까 약간 중간 과정이라고 일단 보시면 되겠어요 , 자, 그래가지고 오늘 실습은 어디서 할 것이냐 여기 잡에서 뭔가를 추가로 만들어 볼 것이고 우리가 지난 시간에 만들었던 요 부분에서 계속 작업을 이어서 테스트를 해보고자 합니다 일단 이 힐 잡은 필요 없으니까 여기서 여기까지 일단 날리고 여기서 계속 이어서 사용을 해볼게요 , 일단은, 공용으로 클래스를 만들어 가지고 클래스에서 뭔가를 들고 있게 만들어 줄 예정인데 이런 식으로 클래스 잡이라는 걸 일단 만들어 봅시다 일단 여기까지 경기선 지난 시간 내용은 여기까지였고 오늘 다룰 내용은 여기부터 한다 라고 , 일단은, 선을 그어 보도록 할게요 , 자, 그래가지고 결국에는 뭐 우리가 지난 시간에 했던 거를 곰곰이 생각을 해보면 어떤 행위 자체를 인자랑 같이 묶어가지고 넘겨주는 개념이었고 사실은 그게 단순히 생각하면은 그냥 함수자의 개념이기도 합니다 함수자 소위 functor라고 하는 거죠 어떤 클래스인데 어떤 객체인데 그 객체가 사실상 함수의 역할을 한다라고 볼 수가 있는 거죠 그래가지고 뭐 예를 들면은 우리가 지금 사용해야되는 함수가 뭐 Static Void , 이렇게, 전역으로 만들어 볼게요 전역으로 만들어가지고 Heal by Value라는 함수가 있다고 가정을 하고 여기서 뭐 타겟 아이디랑 힐 할 뭐 값을 뭐 , 이렇게, 인트 64 인트 32로 받아준다고 합시다 그래가지고 이거를 뭐 타겟한테 힐 얼마만큼을 줬다 Value 만큼 줌 이라고 간단하게 로고를 찍어보고 요 함수를 우리가 이제 잡으로 만드는게 이제 오늘의 목표입니다 뭐 여기까지는 굉장히 단순하죠 , 자, 그래서 이제 이 함수자에다가 , 일단은, 요걸 만들려고 하면은 일단 필요한게 여러가지가 있는데 이 함수 자체도 얘가 들고 있어야 될 것이고 그 다음에 이 함수가 실행할 인자들도 사실상 이 잡한테 넘겨줄 필요가 있다고 볼 수가 있겠죠 먼저 이 잡을 템플릿을 이용해가지고 이런저런 장난을 치면은 뭐 예를 들면은 요런식으로 아이고 그냥 리턴만 일단 만들어 볼게요 원래 기본적으로 함수자에서 얘가 함수처럼 동작하려면은 요 오퍼레이터를 우리가 , 이렇게, 오버로딩 해가지고 뭔가를 구현을 할 수가 있을 거예요 , 이렇게, 떼서 보면은 요 오퍼레이터를 사용할 수 있다라는 얘기가 되는 거죠 그래서 만약에 기본적으로 우리가 어떤 잡을 만든 다음에 이런 식으로 함수마냥 호출을 할 수 있는 거고 이거를 우리가 지금까지 함수자라고 불렀습니다 , 자, 여기서 잡에서 그냥 보이드 타입을 리턴하는 타입이다 라고 해가지고 뭐 이런 식으로 만들 수 있겠죠 근데 이제 만약에 이 함수를 여기다가 연결시키자고 하면은 이제 조금 더 문제가 하나씩 하나씩 더 복잡해지기는 합니다 단계별로 , 일단은, 생각을 해보면 요 함수가 , 이렇게, 이 리턴 값으로 이 리턴 타입을 뱉어준다라고 , 일단은, 먼저 , 이렇게, 만들어줄 수가 있을 것이고 근데 이제 함수에서 이런 식으로 인자를 여러 개를 받아주는 상황도 종종 생기게 되겠죠 , 자, 그러면은 이제 이 부분이 조금 까다로울 수가 있는데 예를 들면 인자가 두 개라는 게 굉장히 확실하다고 하면은 이런 식으로 추가적으로 인자를 두 개를 늘려가지고 첫 번째 인자 두 번째 인자를 뭐 이런 식으로 받아줄 수가 있을 거예요 그러면 이 상태에서 요 잡에다가 뭐 두 개의 숫자를 넣어주면 되겠죠 여기서 예를 들면은 uint64 int32를 받아준다 라고 하고 여기서 뭔가 100번 유저에 대해서 12라는 값을 우리가 전달해주면 뭐 , 이렇게, 일단은, 함수를 호출해 줄 수가 있을 겁니다 비슷한 느낌으로 그리고 , 사실, 이 operator 요 괄호가 사실상 우리로 치면은 이 execute랑 , 사실, 똑같은 의미죠 , 이렇게, 하나 뭐 , 이렇게, 하나 , 사실, 뭐 똑같은 얘기라는 겁니다 요런 식으로 return을 받아주고 t1, t2 , 자, 그런데 여기서 한 가지씩 또 추가를 해보자면 인자가 몇 개가 될지 우리가 예측을 할 수 없죠? 이런 함수도 있을 거지만 아무것도 안 받는 함수도 있을 것이고 인자를 10개를 받는 함수도 존재할 겁니다 그러면은 이 타입을 계속 늘려야 되느냐 뭐 쉽게 생각해서 , 이렇게, 만들면 될 것 같다는 생각도 들긴 합니다 아무 인자를 안 받아주는 버전 인자를 한 개 받아주는 버전 인자를 두 개 받아주는 버전 , 이렇게, 쭉 늘리면 되지 않을까 싶지만 애석하게도 템플릿 문법에서는 동일한 클래스 이름으로 , 이렇게, 각기 다른 개수의 타입을 받아주는 템플릿 클래스를 만들 수가 없습니다. 그냥 에러가 날 거예요. 그래가지고 예전에 C++11 이전에는 이런 부분을 처리하기 위해서 굉장히 골머리가 아팠는데 이제 모던 C++에서는 이런 부분이 많이 많이 개선되어가지고 우리한테 굉장히 우월한 문법이 하나가 있죠. 바로 이 문법입니다. 점점점 Variadic template이라고 해가지고 여기 있는 뒤에 오는 템플릿 인자는 가변 길이다. 아예 없을 수도 있고 한길일 수도 있고 두길일 수도 있고 여러길일 수도 있다는 얘기가 되는 거죠. 그래서 , 이렇게, 일단은, 템플릿을 사용할 수가 있다고 보시면 되겠어요. 그러면 이제 이 함수 같은 경우는 거꾸로 실질적으로 사용을 할 때 이 argument를 거꾸로 , 이렇게, 찍어주게 됩니다. 인자를 우리가 여러 개를 받아 줄 것이다 라는 느낌으로 그러면 예를 들면 이 잡 같은 경우에 아까와 마찬가지로 보이드를 뱉어주고 인자를 두 개 받아주는 잡이다라고 하면 아까와 마찬가지로 , 이렇게, 그냥 그대로 사용할 수 있고 인자가 하나 늘어난다고 해도 아무런 문제 없이 여기서 뭐 추가를 해줄 수 있다는 얘기가 되는 거죠 이런 느낌으로 그래가지고 일단 잡의 모양은 이런식으로 템플릿을 이용해가지고 여러개의 인자를 받아줄 수 있게 만들어주면 된다라고 일단 중간 결론을 내리시고 있는데 근데 아직 갈 길이 멀었죠 우리가 하고 싶은거는 여기 내부에서 여기 오퍼레이터 내부에서 이런 실질적인 코드를 넣어주고 싶은게 아니라 그냥 어떤 함수를 여기에다가 연결을 시켜주고 싶은겁니다 이 잡 안에서 이 함수를 알아서 호출하도록 그러면 여기서도 여러 가지 방법이 당연히 존재하겠지만 가장 쉽게 생각할 수 있는 방법은 함수 포인터를 이용하는 거죠 함수자라는 것도 펑터도 가장 기본적으로 함수 포인터를 이용하는 경우가 많으니까 그런 식으로 수정을 해보도록 할게요 이거는 이제 잡이라고 하지 않고 펑크잡이라고 , 일단은, 이름을 살짝 수정해보도록 할게요 나중에 잡이라는 게 또 다시 등장해가지고 사용할 것이기 때문에 일단 얘는 펑크잡이라고 하고 , 자, 이제 함수를 정의를 해주도록 합시다 얘가 받아줄 함수 타입은 무엇이냐 이제 말 그대로 이 func 타입은 return을 뱉어주는 함수인데 인자로는 요 argument를 여러 개를 받아주는 타입이다 라고 우리가 일단 이 함수의 타입을 정의를 해줄 수가 있을 겁니다 , 이렇게, 그러면 이제 멤버 변수로 함수를 , 이렇게, 들고 있도록 할 것이고 실질적으로 우리가 이런 Operator라는 것을 실행할 때 이 함수를 호출해주게 될 겁니다. 이 Veredic Arguments를 넣어주면서 이 함수를 호출해주세요 라고 건네주는 거죠. 이게 일종의 콜백 함수라고 볼 수가 있겠습니다. 그래서 요렇게 만들어 주면은 이제 힐 바이 벨류라는 거를 이 잡이랑 연결을 할 수 있게 된 겁니다 다만 여기서 조심해야 되는 거는 여기 있는 타입을 맞춰 줘야 되겠죠 인트 64 하나랑 인트 31을 인자로 받아주는 함수입니다 라고 했으니까 생성자에서 힐 바이 벨류를 요렇게 , 일단은, 넣어 줄 수가 있을 거예요 아 근데 생성자를 안 만들어 놨네요 참 생성자를 만들어 줄 때도 마찬가지로 펑크 잡을 받아 줄 건데 이 func 타입을 받아 줄 건데 이 함수를 받아 가지고 여기다가 기억을 하고 있겠습니다 라고 만들어 주면은 이제 이 문법이 통과가 될 겁니다 그리고 잡을 115으로 호출해주게 되면은 여기서 110이 들어가가지고 호출이 되겠죠 물론 이제 경우에 따라가지고 이걸 굳이 명시하지 않아도 컴파일러가 똑똑하게 얘를 이제 자동으로 잡아주는 경우도 있긴 한데 이거는 이제 테스트를 해보시면 돼요 근데 여기서는 , 일단은, 얘를 알아야지만 되니까 , 이렇게, 넣어주시고 그 다음에 이 잡을 실행해가지고 , 일단은, 게임 서버만 우클릭 시작 프로젝트 설정에 가가지고 얘를 일단 실행을 해보도록 할게요 그럼 이 잡 이라는거 110으로 호출이 되게 되면은 이제는 정상적으로 호출이 되면은 힐 바이 밸류라는게 호출이 될 것이고 타겟 밸류는 아까 값으로 이제 들어가게 될 겁니다 그래가지고 100한테 힐 10만큼 줌이란 로그가 정상적으로 뜨는걸 볼 수가 있어요 , 자, 이렇게, 해가지고 일단 첫번째 단계로 요 펑터라는 애한테 우리가 지정한 함수를 들고 있게 만들었는데 근데 아직 부족한 건 뭐냐면은 우리가 결국에는 잡을 만들어 줄 때 잡을 만들어 줄 때 여기 있는 인자들도 같이 전달해 줘 가지고 얘가 기억을 하고 있게 만들어 줘야 되겠죠 나중에 뒤에 호출이 될 때쯤이면은 애당초 이 인자가 뭐였는지 기억을 못할 수도 있습니다 우리가 결국에는 이 룸에서 사용하던 것도 이 잡을 만들어 줄 때 여기를 다시 보면은 , 이렇게, 인자들을 다 기억을 하고 있고 걔를 이용해 가지고 우리가 원하는 함수를 호출해 줬었죠. 그러니까 지금은 우리가 여기서 엔터 함수를 호출할 것이다 라는 것만 기억을 하게끔 만들어놨지만 이 인자들은 아직 기억을 하지 않고 있는 상태라고 볼 수가 있는 겁니다. 그러면 다시 돌아가가지고 그 부분도 추가를 하면 될 것 같은데 근데 여기서 이제 살짝 애매한 부분이 있어요 그게 뭐냐면은 우리가 뭔가 하고 싶은 게 요런 문법이 없을까 이런 아규먼트를 여러 개를 들고 있겠다라는 문법이 있으면 굉장히 아름답겠지만 요런 문법은 존재하지 않습니다 불행하게도 그래가지고 이걸 이제 그럼 우회해가지고 처리할 방법이 여러 가지가 있는데 일단 C++11 기준으로 요런 애가 있어요 튜플이란 애를 묶어가지고 인재를 하나하나씩 , 이렇게, 들고 있는 방법이 하나가 있습니다 그래서 이제 아귀먼트들을 이 튜플이라는 애로 , 이렇게, 들고 있도록 할 거예요 그러면 여기서 이제 인자로 다시 위에 가가지고 인자를 여러 개를 , 이렇게, 받아줄 수가 있는데 아귀먼트를 얘를 그냥 그대로 튜플에다가 전달을 해줘서 , 일단은, 보관을 하고 있을 겁니다 그러면은 이제 거꾸로 요 오퍼레이터에서는 , 이렇게, 인자를 받아주는게 아니라 얘가 내부적으로 저장하고 있었던 요 변수들을 이용해가지고 거꾸로 호출해주면 되겠죠 그러면 얘를 뭐 이런 식으로 쓰는 것인가 근데 그건 또 아닙니다 그래서 이게 잠깐 문법이 헷갈리는데 , 일단은, C++17을 기준으로 17을 기준으로는 여기 sdapply라는 애가 있는데 여기다가 function이랑 tuple을 그냥 바로 , 이렇게, 꽂아줄 수가 있어요 이런 식으로 호출하는 게 가능합니다 얘는 일단 삭제를 하도록 할게요 , 자, 근데 만약에 여러분 컴파일러가 C++17으로 이게 만들어지지 않았다고 하면은 여기서 에러가 날 거예요 그래서 우클릭해가지고 속성에 가가지고 살펴보면은 어... C++에서 여기 일반 어디였더라 아 여기 언어 있네요 언어 표준에서 기본값 C++14 표준으로 되어있는데 얘를 17까지 , 이렇게, 올려놓은 다음에 적용을 시켜줘야 됩니다 그래야지만 이 버전이 호출이 될 거예요 , 자, 이렇게, 해가지고 인자들을 저장한 다음에 우리가 원하는 함수에다가 같이 전달해 줘가지고 , 이렇게, 한번에 호출할 준비가 된 거니까 이제 , 이렇게, 바뀌게 되면은 여기서 생성자에서 같이 인자를 요렇게 만들어 줘가지고 전달을 하고 실질적으로 호출을 뭐 이런 식으로 할 수 있다는 거죠 , 자, 요 버전 말고 이제 Execute라는 버전으로 계속 진행을 해보도록 하겠습니다 헷갈리니까 그래서 , 이렇게, 잡을 만들어 가지고 내용들을 잘 저장을 하고 있는 거고 일종의 주문서를 만들어 준 다음에 실질적으로 요리 시간이 오면은 그 주문서를 그대로 실행을 할 수 있게 되는 거죠 그래서 이 방식으로도 똑같이 브레이크 포인트를 잡아 가지고 한번 실행을 해 보도록 할게요 근데 뭐 당연히 별다른 문제가 없다면은 지난번과 마찬가지로 백이라는 유저한테 힐을 준다라는게 호출이 되겠죠 어... 그런데 지금 잠시 에러가 나고 있는 거는 아 여기다가 아귀먼트에다가 점점점을 찍어줘야 됩니다. 베리딕 템플릿은 문법이 조금 헷갈리는데 요렇게 , 일단은, 작성을 해주시면 되구요 , 자, 그리고 다시 한번 실행을 해보도록 할게요 그럼 이제 이 부분이 정상적으로 실행이 됐다고 하면 똑같이 100한테 힐 10만큼 중까지 정상적으로 뜬다는 걸 볼 수가 있습니다 그런데 굉장히 재미있는 사실은 그러면 이게 C++17까지 와가지고 얘가 지원을 했는데 그러면 예전에는 어떻게 했을까요 이게 굉장히 궁금하죠 C++11으로 맞춰가지고 작업하는 프로젝트들도 굉장히 많은데 이 부분에 대해서 , 일단은, 간단히 한번 살펴보도록 할게요 이제부터는 약간 템플릿 흑마법의 영역으로 들어가는데 이게 한 번쯤은 분석할 만한 가치가 있는 것 같아요, 개인적으로. 이걸 자주 쓰진 않겠지만 공부하다 보면 템플릿에 대한 이해도가 굉장히 많이 늘어나기 때문에 이걸 그냥 보여드리는 게 좋을 것 같고. 여기서 위에서 한번 보여드리도록 하겠습니다. 소위 C++11 버전의 어플라이를 우리가 직접 만들어 보겠습니다. 근데 이게 코드를 보면은 처음에는 약간 멘붕이 들 수가 있는데 뭐 , 일단은, 감안하시고 따라 치시면 되겠습니다. 그리고 제가 이어서 설명을 드려보도록 할게요. , 자, 이거 오타를 내면 안되니까 만약에 오타낼까 두렵다 싶으면은 그냥 소스코드를 받아가지고 그냥 복붙을 해주시면 되겠고 어 인트랑 리메인스라는 걸 , 이렇게, 만들어 줄 것인데 , 자, 젠 시퀀스라는 걸 , 이렇게, 만들어 주도록 할 거예요 어 , 일단은, 코드를 다 만든 다음에 잘 동작하는 걸 확인하고 그 다음에 일단 설명을 하는 게 조금 더 나을 것 같아 가지고 그렇게 진행을 해보도록 하겠습니다 , 자, 그래서 두 개를 만들어 줄 것이고 아직까지는 뭐 하는지 모르겠는데 굉장히 이상한 헬퍼 클래스들을 , 이렇게, 만들어 주고 있습니다 젠 시퀀스를 또 만들어 줄 것인데 0번에 리메인스.. 근데 얘는 상속을 받고 있는데 이 시퀀스에 remains..을 상속을 받고 있다. 아직까지도 뭔 소리인지 하나도 모르겠죠? 그 다음에 이제 대망의 우리가 사용할 apply 함수를 만들어 줄 것인데 return을 뱉어주고 그 다음에 argument를 veredict로 , 이렇게, 받아주는 어플라이 만들어줄 것인데 X 어플라이라고 이름을 지어보도록 합시다 이게 표준 어플라이랑 겹치지 않게 그래서 얘는 , 일단은, 요런 함수를 하나를 받아주는데 return을 뱉어주고 argument를 받아주는 요런 타입의 함수를 인재로 받아준다 즉 여기까지가 이제 함수 타입이고 요게 그 함수의 이름이죠 이게 굉장히 헷갈리는 C++ 문법인데 뭐 , 이렇게, 만들어주고 그 다음에 이어서 튜플을 요렇게 받아주겠다 라고 만들어주면 되겠습니다. 튜플을 , 이렇게, 받아준 다음에 , 자, 그 다음에 여기서 바로 또 호출하는 게 아니라 여기서도 또 템플릿 하나를 더 만들어가지고 헬퍼를 하나를 더 만들어 줄 거예요. f, 타임네임, 점점점, 아귀먼트, 인트 점점점, ls라고 할게요. 리스트라고 해가지고 약자. 그 다음에 요 헬퍼를 하나를 더 만들어줄 것인데 어떤 함수를 인자로 받아줄 것이고 ls.. 이거 ls에.. 점점점을 받아줄 것이고 그 다음에 튜플에 아귀먼트 점점점 참조 튜플을 요렇게 받아주고 얘가 최종적으로 어떤 함수를 이제 호출해주게 될 겁니다 이 함수를 호출하는데 sdcat ls를 , 이렇게, 해주고 tuple를 넣어준 다음에 ... , 이렇게, 해주고 여기서는 return xapplyhelper 라고 만들어 준 다음에 이 함수랑 gensequence sizeof... argument 타입의 튜플을 , 이렇게, 넣어주도록 할거에요 , 자, 아직까지 뭔 내용인지 하나도 이해 안가도 당연한거구요 그래서 결국에는 이 어플라이 버전이랑 굉장히 유사하게 얘가 , 일단은, 된다는 것만 , 일단은, 확인을 해봅시다 펑션이랑 튜플을 넣어주면은 아까와 마찬가지로 요 함수를 호출해준대 과연 진짜일까 궁금하죠? 여기서 한번 브릭 포인트를 잡아가지고 실행을 해보도록 할게요 , 자, 그러면은 이제 조금 기다려가지고 살펴보면은 별다른 문제가 없다보면은 얘가 실행이 되면서 굉장히 신기하게도 아까랑 똑같이 우리가 C++11에서 사용하는 요 라이브러리랑 이 함수랑 똑같이 동작을 한다는 걸 알 수가 있습니다 그런데 도대체 이 코드가 왜 동작을 하는 건지 굉장히 묘하죠 이게 뭔 외계형 같긴 한데 , 일단은, 단계적으로 한번 분석을 해보자면 먼저 튜플이라는 애가 뭘 하는 거냐면 이런 식으로 여러 개의 데이터를 그냥 모아놓는 거라고 일단 생각하시면 되겠습니다 뭐 SD 페어와 비슷하게 이런식으로 1이라는 데이터랑 2라는 데이터를 한번에 , 이렇게, 튜플로 만들어 줄 수가 있구요. 그 다음에 실질적으로 데이터를 꺼냈을 때는 std get 이라고 해가지고 여기서 0번째 데이터를 꺼내 쓰고 싶다 라고 하면 , 이렇게, 만들어 줄 수 있고 첫번째 데이터 1번 데이터를 두 번째 데이터죠? 1번 인덱스의 데이터를 꺼내주고 싶다고 하면 요렇게 , 일단은, 또 추출할 수가 있어요 그럼 얘를 실행해보면 1이랑 2를 각각 우리가 사용할 수 있게 된 겁니다 이게 일단 튜플의 개념이다 라고 볼 수가 있는 거예요 그래가지고 여기서 최종적으로 최종적으로 호출하는 거 보면은 여기서 템플릿으로 우리가 어떤 콜라블 타입 그러니까 어떤 함수를 넣어준 거고 이 함수를 호출해줄 것인데 인자들을 요렇게 요렇게 만들어주고 있는 거죠 즉 이거를 계속 무한으로 해주고 있는 겁니다 0번도 해주고 1번으로도 해주고 2번으로도 해주고 이런 식으로 모든 인자들을 하나하나씩 꺼내가지고 그거를 함수에다가 넘겨주는 부분이 여기 실행이 되고 있는 거예요 근데 굉장히 신기하게도 어떻게 보면 이 Sequence라는 S-E-Q는 도대체 뭘 하는 애길래 이게 그렇게 되는지 굉장히 신기하죠 , 자, 그래서 이 코드를 다시 한번 분석을 해보면 먼저 예를 한번 들어봅시다. genSequence라는 걸 만들어 볼 건데 3이라는 인자로 우리가 , 이렇게, 만들었다고 가정해볼게요. 그러면 별다른 문제가 없고 얘는 그냥 하나의 구조체라는 걸 알 수가 있습니다. 템플릿 타입으로 정의된 구조체고 우리가 인자로 3을 넣어준 셈이 되는 거죠. 그냥 그것뿐이에요. 근데 얘가 굉장히 신기한 게 이제 이 흐름을 잘 분석을 하시면 되는데 이거를 한번 보여드리기 위해서 제가 굳이 이 수업을 하고 있는 겁니다. 굉장히 신기했어요, 처음에 봤을 때. genSequence라는 게 다시 한번 , 이렇게, 상속을 받고 있어요 상속 구조를 한번 따져보도록 합시다 우리가 GenSequence3 이라는 걸 만들어 놨더니만 얘가 상속을 받고 있대요 근데 이 상속 받는 공식을 살펴보면은 우선 여기 n이 지금 3인 상태입니다. n이 3인 상태이고 여기 나머지들은 없을 수도 있는데 지금은 3 하나밖에 없으니까 여기 있는 부분은 아무것도 없어요. 그러다보니까 여기 있는 n-1, n-1만 채워지게 되는 거고 그러다보니까 얘가 사실상 2랑 2를 상속을 받고 있다라는 것까진 일단 알 수가 있는 겁니다. 그러면은 다시 한번 gensequence 2, 2라는 애가 이런 struct가 만들어질 건데 얘는 또다시 이 공식을 다시 한번 살펴보면은 지금은 n이 2인 상태고 나머지 찌끄레기가 remains라는 애가 , 사실, 요 부분이 지금 요 부분으로 들어가게 되는 겁니다 그러니까 똑같이 공식을 한 번 더 대입을 해주면 gensequence가 만들어지는데 여기서 n-1이 두 번 등장하고 있죠 그러다 보니까 1,1이 등장하고 마지막에 찌끄레기들은 뒤에 부분으로 , 이렇게, 이어져서 만들어지게 되기 때문에 1,1,2로 얘가 확장이 됩니다 그리고 또다시 112라는 애를 한 번 더 확장을 하면은 똑같은 공식을 이용하면은 이제 1이라는 애가 n이고 나머지 찌끄레기가 1,2 요 부분이 remains가 될 겁니다 그래서 얘도 다시 한번 공식을 대입하면은 0,0,1,2 까지가 만들어지게 되겠죠 재미있게도 그러면은 여기부터는 이제 0 이라는 애로 시작을 하는데 그 부분은 정확히 얘가 지금 가장 가깝기 때문에 요 버전으로 인지를 해가지고 이제 이 부분으로 호출이 될 건데 얘는 마지막 공식은 무엇이냐? GenSequence가 0으로 시작하면은 얘가 Sequence라는 애 그러니까 GenSeq가 아니라 이제는 그냥 Sequence네요 Sequence의 Remains 개만큼으로 얘가 상속을 받고 있다라고 해가지고 결국 이 공식으로 까고 까고 가다 보면은 이런 식으로 지금 상속 구조가 만들어져 있는 겁니다 그래서 GenSequence라는 이 struct 자체가 , 사실, sequence012라는 애를 지금 상속을 받고 있다는 얘기가 되는 거죠 그래가지고 여기서 XApplyHelper에다가 우리가 사실상 XApplyHelper는 이 Sequence라는 애를 , 이렇게, 받아주고 있는데 우리가 GenSequence를 만들어가지고 결국에는 이 Sequence라는 애를 만들어 준 겁니다 즉 길이가 3짜리인 애를 만들어 주세요 라고 하면은 얘가 0, 1, 2라는 숫자를 순차적으로 풀어 가지고 만들어주는 Sequence를 만들어 준다는 거죠 여기 있는 SizeOf__은 여기 베레딕 템플릿이랑 사용하는 문법인데 말 그대로 여기 넣어준 아귀먼트의 개수를 반환하게 됩니다 즉 우리가 요 상황에서는 지금 2개가 있죠? 2개가 있기 때문에 요기 sizeof OOO argument는 이제 2라는 숫자로 얘가 바꿔치기가 될 겁니다 요런 느낌으로 그러면은 gensequence 2라는 애는 결국에는 sequence에 0,1 , 이렇게, 2개로 만들어지게 될 겁니다 똑같은 공식을 응용하면 그렇게 되겠죠? 그러면 결국에는 이 시퀀스가 만들어지게 되면은 그 아이가 지금 여기 , 이렇게, 들어가기 때문에 얘가 이제 요 부분을 긁어가지고 얘도 Veredict 템플릿으로 이제 인지를 하고 있기 때문에 그 부분을 그대로 풀어 쓸 겁니다 그래가지고 아까 얘기한 대로 std get 0번, std get 1번 이런 식으로 이게 하나씩 하나씩 풀린다는 얘기가 되는 거죠 그리고 그 모든 애들을 여기서 이 문법을 이용해가지고 펑션에 , 이렇게, 전달을 해준다 즉 요런 문법인 거죠 결국에는 1번도 전달해주고 더 있으면 2번도 전달해주고 하는 식으로 풀어 써가지고 그거를 여기 펑션에다가 같이 전달해준다라는 코드가 실행이 된다고 보시면 되겠어요 그래서 굉장히 마법적으로 이제 요 코드에 의해 가지고 우리가 요 C++17에서는 그냥 간단하게 제공하는 요 어플라이를 우리가 , 이렇게, 만들 수도 있다는 얘기가 되는 겁니다 그래서 이런 코드를 보다 보면 템플릿에 대한 경외함이 조금씩 생기게 돼요. 이런 걸 어떻게 발견했는지도 굉장히 신기하고 이 문법만 딱 보면 약간 외계어 같긴 한데 굉장히 재밌게 만들어져 있죠, 문법이. 뭐 , 이렇게, 해가지고 이런 부분을 좀 보여드리고 싶었어요. 그래서 결국에는 이제는 최종적으로 요 부분에서 우리가 어떤 함수랑 인자들을 , 이렇게, 넘겨주게 되면은 이제 그거를 , 이렇게, func job라는 functor에서 얘를 저장하고 있다가 걔를 이제 호출해주는 부분까지 , 일단은, 완료가 되었다고 볼 수가 있는 겁니다 뭐 , 이렇게, 일단은, 만들어 줄 수가 있겠죠 , 자, 그런데 여기서 한 가지 문제는 뭐냐면은 우리가 만들어준 요 function 타입이 요렇게 되어있습니다. return을 뱉어주고 argument를 받아주는 이게 설령 베레딕으로 만들어줬다고 해도 이게 모든 타입의 함수를 다 받아줄 수 있는 건 아니에요. 어, 이거 이제 C++ 파트 1에서 잠시 다룬 내용이긴 한데 함수가 여러가지 종류가 있습니다. 예를 들면은 어떤 night라는 객체 안에 뭐, healme라는 함수가 있다고 가정해볼게요. 여기서 어떤 value를 줘가지고 호출을 해줄 것이고 힐 미 라고 할게요 그 다음에 로그를 찍어 보도록 합시다 얼마만큼 힐이 되었어 라고 요 함수 같은 경우에는 요 함수랑 이제 완전히 다른 다르죠 왜냐면은 요 함수 같은 경우에는 , 일단은, 그냥 전역으로 , 이렇게, 사용하는 것인데 얘는 어떤 나이트에 지금 소속이 되어 있다고 보시면 되겠습니다 여기에 만약에 스태틱이 붙었다고 하면 사실상 요아이랑 요아이랑 똑같겠지만 지금은 그게 아니기 때문에 애당초 함수 호출 규약이 다릅니다 얘는 디스콜이라는 규약을 따른 것이고 이 함수가 호출이 될 때 디스포인터까지 넘겨줘야 되고 뭐 하는 부분이 있기 때문에 얘랑 얘는 완전히 통일해가지고 사용할 수가 없어요 그래서 만약에 요 경우에 우리가 두번째 테스트를 해볼건데 이제 이 나이트를 대상으로 어떤 나이트라는 객체를 만들어 준 다음에 뭐 똑같이 이 펑크 접을 만들어주고 싶다고 하면은 뭐 어떤 식으로 해도 얘가 통과가 되지 않을 겁니다 에덩초 요 시그니처 함수의 시그니처가 다르기 때문이죠 그래서 이 버전은 안 되고 그럼 이제 어떻게 해야 되느냐 뭐 , 일단은, funk.job 요 부분을 하나를 더 만들어 주도록 할게요. , 일단은, 통으로 복사해서 독붙한 다음에 두번째 아이는 멤버잡이라고 할게요. 멤버함수를 호출해주는 그런 잡이다 라고 일단 이름을 요렇게 지어보도록 하겠습니다. 그리고 여기서는 추가로 타임네임 T라고 이 객체 타입을 하나를 더 받아주도록 하겠습니다. 그러면 이제 함수 타입이 이 타입이 아니라 어떤 클래스 안에 소속된 함수이다라고 해가지고 , 이렇게, 일단은, 추가를 해줘야 됩니다. 이 클래스 안에 포함된 멤버 함수이다라고 얘기를 하고 있는 거죠. 그리고 그 해당 객체도 예를 들면 이런 식으로 우리가 포인터로 들고 가 있을 거예요. 이런 느낌으로 이제 3개가 필요한 거죠. , 이렇게, 일단은, 만들어줄 수가 있을 거고 그러면 여기 첫 인자로는 이 오브젝트의 포인터를 그대로 받아준 다음에 저장을 해주도록 할게요 이걸 스마트 포인터로 나중에 바꿔도 되고 그거는 나중에 생각할 일이고 , 일단은, 지금 당장은 메모리를 신경쓴 게 아니라 이 잡을 신경쓰는 거기 때문에 , 이렇게, 간단하게 포인터로 들고 있도록 하고 , 자, 그 다음에 마찬가지로 이 x-apply 같은 경우에도 우리가 처음에 만들어줄 때는 요 버전으로 만들어줬는데 얘를 이제 하나 버전을 더 늘려주면 되겠죠 요런 식으로 그리고 이제는 똑같이 type name t를 하나를 더 받아주는 버전을 더 늘려준 다음에 처음에 요렇게 t-object를 받아줄 것이고 그 다음에 얘는 그냥 요런 타입의 펑션이 아니라 요 t 멤버에 있는 함수이다 라고 , 일단은, 요렇게 만들어주면 되겠습니다 그러면은 XApplyHelper에도 이 오브젝트를 전달해주고 얘도 마찬가지로 첫번째 인자가 이제 뭐 하나가 추가가 되면 되겠죠 type name t 라고 해가지고 t 타입의 오브젝트를 받아준 다음에 실질적으로 함수가 호출이 될 때는 오브젝트에다가 요 func를 실행해주세요 라고 요렇게 만들어주면 되겠습니다 그래서 이 엑슬라이 헬퍼를 뭐 , 이렇게, 일단은, 만들어주면 된다라고 볼 수가 있는 거죠. 아 그리고 참고로 여기 엑스 어플라이 헬퍼에서 지금 , 이렇게, 펑크만 해줘가지고 그냥 , 이렇게, 호출하고 있는데 얘가 만약 리턴 타입이 있다고 하면은 당연히 여기서 리턴을 해주도록 , 일단은, 추가를 해주면 됩니다. 지금은 여기 리턴을 안 해주도록 할게요. 이 리턴을 똑같이 받아가지고 XApplyHelper에서도 그냥 걔를 만들어주면 똑같이 리턴할 수 있긴 한데 지금은 그냥 간단하게 만들어 보도록 하겠습니다. 그래서 뭐 , 일단은, XApplyHelper까지 정상적으로 , 이렇게, 실행이 되면은 요런 코드가 만들어지게 될 것이다 라는 걸 일단 알 수가 있는 거죠. 함수가 실행했고 그 함수를 대상으로 인자를 전달해줘라 그리고 오브젝트는 , 이렇게, 정상적으로 저장이 되어있다 라고 볼 수가 있는 거니까 이제는 똑같이 이 x-apply라는 애를 지금 여기서 지금 활용을 하고 있는데 이제는 멤버 같은 경우에는 여기다가 첫 인자로 이 오브젝트만 , 이렇게, 전달해 주면 얘도 똑같이 정상적으로 실행이 될 겁니다 그래가지고 이제 이 나이트 같은 경우에 그럼 이제 어떻게 응용하느냐 멤버 잡을 만들어주는데 이걸 뭐 잡2라고 할게요 편의상 그럼 여기다가 k1 포인터를 넘겨주고 그 다음에 나이트의 heal me라는 함수를 넘겨주고 그 다음에 뭐 10이라는 값을 넘겨줘 가지고 10만큼을 힐해달라고 해서 , 이렇게, Execute를 호출해줄 수 있다는 얘기가 되는 거죠. 그래서 , 이렇게, 함수가 여러 개가 있는데 함수 종류에 따라서 , 이렇게, 각각 구분을 해야 될 필요가 , 일단은, 생기게 된다고 볼 수가 있는 거고요. 이 함수를 똑같이 실행을 해보면 여기서 그냥 실행을 통해 보도록 할게요. 그러면 여기서 브레이크 포인트가 지금 잡힐 것이고 여기서 엔터를 눌러서 브레이크 포인트가 잡힐 것이고 힐 미 10까지 정상적으로 실행이 된다는 것도 볼 수가 있습니다. , 이렇게, 해서 멤버 잡으로도 만들어봤고 일반적인 함수 타입으로도 만들어봤고 , 이렇게, 일단은, 함수자에 대한 내용을 계속 공부하고 있는 거예요, functor를 그래서 어떤 클래스에다가 어떤 함수랑 인자들 그리고 경우에 따라서 만약에 멤버 함수라고 하면은 그 해당 극지까지 , 이렇게, 담고 있다가 걔를 호출해준다가 가장 핵심적인 내용이고 이게 사실은 커맨드 패턴의 기본이라고 볼 수가 있는 거죠 , 자, 그래가지고 굉장히 장황한 내용에 대해서 설명을 했는데 그러면은 이전에 우리가 만들었던 요 잡방식을 오늘 배운 2세대로 한번 수정을 해보도록 할게요 간단하게 그러면 , 일단은, 여기 있는 클래스 잡을 일단 맨 위에다가 뭐 대충한 이쯤에다가 함수자 바로 아래다가 요렇게 정의를 해주고 그 다음에 얘네들은 공통적인 요 아이잡 인터페이스를 구현을 하도록 유도를 해주도록 하겠습니다 그 다음에 여기서 return execute가 아니라 virtual void execute override를 추가해주고요 , 이렇게, 추가해주고 여기서도 , 이렇게, 추가를 해주면 되겠죠 여기서 return을 굳이 받을 필요가 없는 이유는 애당초 이 job이라는 것 자체가 당장 내가 return을 받을 목적으로 뭔가를 던져주는 게 아니라 거의 대부분은 일감을 만들어 준 다음에 나중에 호출해주세요 라고 하는 거죠 당장 return 값을 받아주고 뭐 하는 개념이 아니기 때문에 대부분은 그냥 void로 만들어도 충분합니다 , 자, 이렇게, 해가지고 , 일단은, 이 두가지 타입의 잡을 , 이렇게, 간단하게 만들어 봤구요 그러면 이제 이거를 어떻게 사용하느냐 다시 게임 룸으로 일단 한번 가보도록 할게요 게임 룸 쪽에서 우리가 , 이렇게, 엔터 잡, 리브 잡, 브로드캐스트 잡 , 이렇게, 잡잡잡을 계속 우리가 만들고 있었는데 이제는 요런 부분이 필요 없습니다 그래서 일단 싸그리 다 날려주고 시작을 하도록 할게요 그 다음에 요 부분도 다시 퍼블릭으로 열어주고 잡이 없어졌으니까 요 부분도 일단 삭제를 해주도록 할 거예요 , 자, 근데 물론 여기까지만 놓고 보면은 아직까지 이제 어떻게 사용해야 될지가 와닿지가 않는데 이제 푸쉬 잡을 할 때 잡을 만들어 준 다음에 여기다가 어떤 함수를 호출해야 될지를 같이 지정해 주면 되긴 하는데 이거를 조금 더 편하게 만들기 위해서 여기다가 헬퍼 함수를 하나를 만들어 주도록 할게요 예를 들면 여기 같은 경우에 테스트로 타임네임 t, 타임네임 return, 타임네임... argument, 베리에딕 템플릿을 넘겨주고 push.job 이라는걸 만약에 호출하고 싶은데 니가 호출하고 싶은 함수가 요런 함수 였습니까? 라고 물어보는거죠. main.function을 argument..으로 , 자, 요렇게 , 일단은, 봐줘도록 하겠습니다. , 자, 요게 다시 말씀드리지만 멤버 함수의 시그니처고 그 함수 이름을 우리가 지금 멤버 func 라고 , 일단은, 내부적으로 변수로 담고 있는 거고 그렇다고 하면은 여기서 잡을 만들어 줄 때 make shared로 잡을 만들어 주고 있는데 여기다가 멤버 잡을 만들어 줄 것이고 인자로는 , 일단은, 템플릿은 t type return type argument argument..을 , 이렇게, 그대로 전달해 줄 것이고 이런 타입의 멤버 잡을 만들어 주세요 근데 생성자에서는 뭐 스태틱 캐스트를 해 줘 가지고 자기 자신을 , 이렇게, 넘겨 줄 것이고 그 다음으로는 이제 여기서 넘겨 받은 맨 펑크를 그대로 적고 그 다음에 아귀먼트 점점점을 찍어 주시면 되겠습니다 요렇게 해 가지고 , 일단은, 잡을 만들어 준 다음에 그 잡을 푸쉬를 할 수 있다라는 얘기가 되는 거죠 요런 느낌으로 , 자, 그러면 이제 이걸 어떻게 사용하느냐 다시 한번 일단 빌드를 하면 어차피 잘못된 부분은 컴파일 에러가 날테니까 바로 잡아줄 수가 있겠죠 컴파일한테 떠넘기고 , 자, 여기서 지금 에러가 나고 있는데 그 부분을 이어가지고 수정을 해보도록 할게요 , 자, 여기 지금 푸쉬 잡으라고 할 때 여기서 바로 메이크 셰어드 뭐 이런 식으로 만드는 게 아니라 이제는 조금 방식이 달라져 가지고 이 방식이 아니라 잠시 주석 처리를 하고 g 룸에다가 푸시 잡을 할 때 , 사실, 이 잡을 만들어 가지고 넘겨주는 부분이 이제 필요가 없고 이걸 막바로 사용하게 될 겁니다. 그래서 푸시 잡을 할 때는 룸에 엔터를 해주세요. 플레이어를 대상으로 라고 요렇게 일단 인자를 넘기게 되는 거죠. 그러면 요 코드에 의해 가지고 요 함수랑 해당 아귀먼트들이 정상적으로 잡으로 만들어져가지고 잡큐 안에다가 들어가게 될겁니다 요런 느낌으로 그리고 마찬가지로 한군데가 더 있었던 것 같은데 다시 한번 빌드해가지고 찾아보도록 할게요 , 자, 엔터 말고 아마도 브로드캐스팅하는 브로드캐스트 잡을 사용하고 있던 곳에서도 똑같이 에러가 날텐데 그 부분을 일단 찾아보도록 하겠습니다 요 부분에서도 이제 마찬가지로 얘를 g-room에다가 점을 찍어가지고 푸쉬잡을 한 다음에 룸에 브로드캐스텔을 호출해줘 샌드버퍼라는 인자랑 더불어서 라고 한 다음에 얘를 , 일단은, 다시 한번 빌드를 해주도록 할게요 , 자, 그런데 지금 에러가 나고 있는 이유는 여기 멤버잡에다가 여기 퍼블릭 아이잡을 연결 안해놔서 그런 것 같습니다 요렇게 해가지고 다시 한번 빌드 시도를 해보도록 할게요 , 자, 요렇게 해가지고 지금 다시 빌드를 하고 있구요 그래서 결국에는 그럼 우리가 무엇을 고친 것이냐 , 자, 요런 식으로 잡 이라는 걸 만들어 줄 때 매번마다 브로드캐스트 잡, 무슨 무슨 잡 , 이렇게, 해가지고 그걸 룸에서 우리가 만들고 있었던 부분을 싹을 날리고 그냥 일반적으로 우리가 코딩하는 거와 마찬가지로 그냥 함수 단위로 , 이렇게, 만들어 준 다음에 다만 그 함수를 호출을 할 때 바로 쌩으로 호출하는 게 아니라 , 이렇게, 푸쉬 잡을 해가지고 해당 함수를 간접적으로 호출해주는 개념이 되겠습니다 , 이렇게, 만들어 주면 얘가 내부적으로 잡으로 만들어져 가지고 잡큐 안에다가 들어갈 테고 누군가가 따로 , 이렇게, 체크를 하면서 플러쉬를 해가지고 그 잡을 누군가가 실행을 해준다라고 볼 수가 있는 거죠 그래서 결국에는 , 사실, 원리 자체는 지난 시간에 만들었던 거랑 뭐 딱히 달라지지는 않기는 하는데 그럼에도 불구하고 이제 작업을 할 때 우리가 매번마다 잡을 만들지 않고도 , 이렇게, 편하게 그냥 함수로 호출하듯 만들 수 있다라는 부분만 일단 달라졌다고 볼 수가 있겠습니다. 그래서 제가 이거를 이제 뭐 2세대라고 부르는 이유가 좀 그런 이유라고 보시면 되겠어요. 그래서 이제 이거를 뭐 아이고 이제 다시 똑같이 실행을 하면은 뭐 딱히 당연한 얘기지만 뭐 딱히 코드가 바뀐 건 없기 때문에 당연히 룸에다가 뭔가를 밀어 넣은 다음에 그 다음에 실드 쪽으로 플러쉬를 하는 부분이 정상적으로 실행이 될 테니까 뭐 기존과 마찬가지로 그 헬로 메세지가 막 로고로 뜨게 되겠죠 물론 지금은 어마어마하게 많이 더미 클라이언트를 호출하고 있으니까 살짝 부담이 되긴 하는데 뭐 지금은 별다른 문제 없이 , 이렇게, 막 호출이 되고 있다는 것도 확인할 수가 있습니다 그래서 이 방식을 잘 기억을 해주시면 되겠어요 물론 이런 코드들을 세세하게 중요한 게 아니라 역시나 중요한 거는 이 잡으로 만들어 가지고 하는데 잡으로 만든다고 해도 매번 마다 클래스를 꼭 만들어야 되는 건 아니다 굉장히 여러 가지 방법이 있는데 이런 식으로 기존과 비슷하게 함수 호출을 하는 식으로 만드는 것도 충분히 가능하다라고 , 일단은, 보시면 되겠습니다 여기서 그냥 멤버 함수가 아니라 뭐 스태틱 함수를 호출해야 된다고 하면은 이 멤버 타입이 아니라 일반적인 함수도 호출할 수 있게끔 똑같이 만들어주면 되겠죠 근데 그 부분은 생략을 하도록 할게요 그래서 오늘 수업은 , 사실, 최종 코드는 아닙니다 우리 최종 코드는 이 방식으로 하진 않을 거고 좀 더 간단한 방법을 일단 만들어 본 건데 제가 이제 이런 코드를 보면서 굉장히 많은 도움이 됐고 특히나 이 functor에 대한 고찰을 많이 할 수가 있었어요 그래서 , 사실, 다음 시간에는 이런 코드들을 이제는 람다 캡쳐를 이용해서 하도록 만들어 볼 건데 여러분들은 람다 캡쳐에 대해서 진지하게 생각을 해보신 적이 있는지 모르겠는데 람다 캡쳐라는 것도 결국에 내부적으로는 이런 식으로 어떤 내가 호출에 대한 어떤 함수랑 그 나머지 변수들을 다 , 이렇게, 멤버 변수로 들고 있는 것이기 때문에 결국에는 원리로 놓고 보면은 , 사실, 이런 식으로 함수자를 만드는 거, 펑터를 만드는 거랑 별반 다를 바가 일단 없다고 볼 수가 있겠어요 , 자, 이렇게, 해가지고 뭐 약간 실력 향상을 위해서 좀 불필요하게 좀 장황하고 그리고 굉장히 어려운 그런 강의를 뭐 해봤는데 이런 코드들을 살펴보시면서 이거 아마 오타를 중간에 어딘가에 내셨겠지만 그런 부분들도 잘 살펴보시고 분석을 하면서 이게 어떻게 돌아가는지 한번 다시 한번 복습을 해보시기를 바라겠습니다 , 자, 이렇게, 해가지고 잡큐 2탄에 대해서 마치도록 할게요.