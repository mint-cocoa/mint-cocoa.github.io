자, 이렇게, 해가지고 스마트 포인터에 대한 내용을 어느정도 마무리를 짓고요 어 이제 이번 시간에 다룰 내용은 메모리 관리 특히 이제 메모리 할당에 대한 내용을 다뤄보고자 합니다 그래서 이걸 왜 다루냐면 , 사실, 우리가 C샵으로 서버를 만들었을 때는 C샵에서 모든 메모리 관리를 다 알아서 해주니까 , 사실, 이런 부분에 대해서 딱히 깊게 생각할 필요가 없었어요 근데 C++ 같은 경우에는 이게 뭐 장점이자 단점일 수도 있지만 우리가 굉장히 세부적으로 커스터마이징을 할 수가 있습니다 그래서 지금까지 우리가 뭐 별 생각 없이 예를 들면 어떤 나이트란 개체를 , 이렇게, new를 이용해 가지고 만든 다음에 그 다음에 뭐 이런 식으로 삭제를 했었죠. 물론 쉐어드 포인터를 사용한다고 해도 딱히 다를 건 아닙니다. new delete를 이용해 가지고 우리가 메모리의 동적할당과 해제를 , 이렇게, 사용했었는데 서버쪽에서는 특히 2000년도 초반에 사용하던 프레임워크에서는 , 이렇게, 생으로 뉴 딜리트를 하는게 아니라 이 메모리를 우리가 직접 관리해가지고 사용을 하는 경우가 굉장히 많았습니다 이제 소위 메모리 풀링이라고 하는거죠 아니면 오브젝트 단위로 풀링을 해도 되고 그리고 이제 그러면 메모리를 왜 그냥 생으로 new delete를 하지 않고 이 흐름을 가로채 가지고 우리가 왜 행동을 바꿔줬냐면은 뭐 여러가지 있을 수 있겠지만 크게 일단 두가지 이유로 구분을 할 수가 있어요 잠시 그립판을 켠 다음에 , 자, 이게 일단 우리 메모리라고 가정해봅시다 그러면은 우리가 어떤 메모리를 사용을 하기 위해서 new를 한다고 가정을 할 때 만약에 용량이 뭔가 지금 당장 우리가 사용할 수 있는 용량이 부족하다고 하면은 어찌되건 이 뉴랑 딜리트라는 것 자체가 유저 레벨에서만 처리할 수 있는 그런 건 아니겠죠. 메모리를 할당하는 것 자체는 결국에는 서버가 아니라 커널 쪽에서 운영체제가 관리를 해주는 영역이기 때문에 경우에 따라 가지고 우리가 메모리를 요청하기 위해서 커널 레벨로 컨택 스위칭을 해가지고 커널 쪽에서 우리한테 메모리를 할당해 준 다음에 그걸 다시 받아오는 형태로 동작을 할 수도 있을 거예요 물론 할 수 있다는 얘기는 이게 100%로 항상 그렇다는 건 아닙니다 우리가 하는 뉴 딜리트가 항상 매번만 그렇게 무식하게 동작하진 않아가지고 얘도 어떻게 보면 내부적으로 메모리를 어느 정도 관리하는 기법이 있기는 한데 그거는 , 일단은, 둘째 치고 어찌됐건 이 컨택 스위칭의 확률이 일단 있다는 것 자체가 문제가 되는 거죠. 그게 아니라 우리가 애당초 처음부터 굉장히 큰 사이즈의 메모리를 막 기가바이트 단위로 평생 사용해도 충분한 그런 공간을 , 이렇게, 크게 할당해서 한 번만 요청을 한 다음에 그 다음에는 여기서 우리가 원하는 대로 , 이렇게, 쪼개 써가지고 필요한 만큼 , 이렇게, 잘라 먹으면 되겠죠 이런 식으로 만약에 우리가 구현을 하게 되면 커널에다가 다시 메모리를 갖다 주세요 라는 요청을 할 필요 없이 그냥 계속 우리가 유저 레벨에서 , 이렇게, 잘라 먹을 수가 있을 겁니다 뭐 요런 상황 일단 하나가 있구요 그 다음에 두 번째 이유는 뭐냐면은 이제 메모리가 아주 큰 단위로 우리가 할당을 요청하면 그나마 괜찮은데 경우에 따라 가지고 아주 짜잘짜잘한 요런 메모리들을 우리가 요청하게 되는 경우가 있어요 예를 들면 우리가 벡터를 하거나 그런 STL 같은 컨테이너를 사용하다 보면은 내부적으로 복사가 빈번하게 일어나다 보면서 , 이렇게, 영역이 바뀌고 다시 할당하다 보면은 제각각 우리가 할당하는 메모리가 다 , 이렇게, 크기가 다를 수가 있겠죠. 근데 예를 들면 지금 이 상태에서 이제 여기 맨 처음에 우리가 할당했던 공간이 더 이상 필요 없어져가지고 우리가 이걸 프리했다고 가정해봅시다. 그래서 이 메모리 공간이 다시 빈 상태가 되는 거예요. 근데 이 메모리와 이 메모리가 반납되어서 사용할 수 있다고 해도 굉장히 아쉬운 부분은 뭐냐면 이 메모리와 이 메모리가 반납이 되었지만 중간에 있던 메모리는 여전히 사용할 수 있기 때문에 얘네들을 당장 합칠 수는 없고 그렇다는 것은 얘가 지금 , 이렇게, 쪼개진 채로 두 개의 자유로운 공간이 분리된 상태가 되는 거죠 만약에 그 다음에 우리가 한 이 정도 사이즈의 그런 메모리를 할당하고 싶은 상황이 왔다고 하면은 , 사실, 요 왼쪽이랑 오른쪽을 합하면 얘가 들어갈 만한 충분한 공간이 됨에도 불구하고 얘네들이 , 이렇게, 쪼개져 있기 때문에 사실상 뭔가 메모리가 비어있긴 한데 사용할 수 없는 그런 좀 슬픈 상황이 올 수도 있다는 얘기가 되는 겁니다 네 그래가지고 뭐 요런 상황도 발생할 수 있고 여러가지 이런저런 이유 때문에 메모리를 그냥 크게 할당해가지고 이걸 우리가 직접적으로 관리해서 뭔가 좀 성능적으로 어... 좀 이점을 보려는 그런 시도들이 여러번 있었어요 근데 요즘 프로젝트에서는 제가 좀 수소문을 해본 결과 요즘 이제 마소에서 잘 이걸 뭐 개선했는지 요즘은 딱히 그렇게 할 필요 없이 속도가 어느정도 잘 나와가지고 그냥 , 이렇게, 기본 요 딜리트를 사용하는 프로젝트도 굉장히 많다고 들었습니다 네 그래가지고 이게 이제 뭐 메모리 풀을 사용할 것인지는 약간 옵션이라고 볼 수 있기는 한데 그럼에도 불구하고 기술을 이해하는 것은 또 어느정도 중요하긴 하죠. 이게 우리가 선택적으로 안하는거랑 몰라서 못하는거랑 느낌이 다르니까 이런 메모리 관리에 대해서 이제 총체적으로 다뤄보고자 합니다. 그래서 오늘 맨 먼저 , 일단은, 할 것은 뭐냐면요. , 자, 이렇게, 뉴 딜리트를 우리가 하고 있는데 굉장히 놀랍게도 뉴와 딜리트도 이게 이제 오버로딩 대상입니다. 굉장히 놀랍죠? 이 흐름을 우리가 고지고때로 뉴 딜리트를 하는게 아니라 이 흐름을 우리가 가로챌 수 있어요. 그래서 이걸 하는게 여러가지 방법이 있는데 뉴 오퍼레이터를 그냥 글로벌하게 모든 뉴 딜리트를 우리가 흐름을 가로챌 수 있습니다. 예를 들면 , 자, 요런식으로 아이고 오퍼레이터 뉴를 얘가 기본적으로 사이즈를 , 이렇게, 받고 있는데 얘를 그대로 다시 재정리를 해가지고 뭐 지금은 딱히 별걸 해줄지는 않을 거지만 그냥 요렇게 로그를 하나 찍어 보도록 할게요. 그 다음에 포인터는 우리가 C에서 사용하던 멀록이라는 함수를 이용해가지고 메모리를 할당을 한 다음에 그대로 그 주소를 요렇게 다시 리턴을 해주도록 하겠습니다. 마찬가지로 Operator Delete 같은 경우도 얘도 , 자, 이런 식으로 포인터를 받아가지고 그 다음에 착제했다 라고 Delete 로그를 찍고 그 다음에 Free를 다시 해줘 가지고 , 이렇게, 포인터를 다시 날려 주도록 하겠습니다 , 자, 그리고 이런 것 뿐만 아니라 이제 버전이 또 여러 개가 더 있습니다 예를 들면은 뭐 우리가 이런 식으로 개체를 여러개를 만들때 배열같은거처럼 한번에 빵 여러개를 만드는 경우도 있었죠 요런 경우도 Operator가 다 마련이 되어있어요 Delete도 마찬가지입니다 , 자, 이런 느낌 그래가지고 이제 만약에 요 상태에서 우리가 요 Knight를 이제 다시 New를 해가지고 실제로 한번 Ctrl F4로 이걸 한번에 실행을 해보면 이제 굉장히 재밌게도 U, Delete , 이렇게, 로그가 찍히는 걸 볼 수가 있어요 여기 사이즈가 지금 1로 되어 있는데 그 사이즈는 이 Knight의 사이즈를 의미를 하는데 지금 아직 내부적으로 데이터가 아무것도 없기 때문에 지금 1x2로 잡힌 거겠지만 만약에 여기다가 뭐 예를 들면 HP를 100으로 놓고 그 다음에 MP도 뭔가 뭐 한 10 정도로 , 이렇게, 세팅을 해가지고 다시 한번 실행을 해보면 얘가 이제 8바이트로 잡히는 걸 볼 수가 있습니다. 그래가지고 결국 여기서 중요한 거는 우리가 지금까지 사용하던 이 뉴랑 딜리트도 충분히 우리가 재정의해가지고 흐름을 가로채서 여기서 뭐 로그를 찍건 아니면은 뭔가를 하는 추가작업을 해줄 수 있다는 얘기가 되는 거죠. , 자, 그리고 어 , 이렇게, 했을 때 근데 쫙 약간 문제가 있는데 어 뉴랑 딜리트 대상으로 우리가 좀 커스터마이징을 해가지고 우리가 원하는 형태로 동작하는 것까지는 굉장히 아름다운데 이게 모든 뉴에 대해서 , 이렇게, 동작을 하는 건 조금 문제가 있겠죠 우리가 뭐 외부 라이브러리를 사용할 수도 있을 것이고 그 다음에 어떤 경우에는 이거를 이제 그냥 원래 기본 디폴트 상태로 동작하게끔 만들어 주고 싶을 수도 있는데 , 이렇게, 글로벌한 오버로딩을 해주게 되면 모든 애들이 다 적용이 되다 보니까 이게 , 사실, 그렇게 좋은 방법은 아닙니다 그래서 , 이렇게, 전역으로 해가지고 그냥 모든 애들을 다 교체하는 거는 좀 위험하니까 이렇게는 하지 않을 것이고 또 다른 방법은 뭐냐면은 , 사실, 뭐 굉장히 느낌이 비슷하긴 한데 잠시 얘를 보관해서 여기 안에다가 넣는 방법이 있습니다. 요렇게 그럼 사실상 어떤 클래스 안에 들어가게 되면은 얘는 사실상 요렇게 스태틱이 붙은 거랑 마찬가지에요. 얘를 딱히 안 붙인다고 해도 요 Operator U는 굉장히 특이하기 때문에 그냥 스태틱인 것처럼 동작을 하게 됩니다. 그래가지고 여기다가 예를 들면은 나이트 뉴, 나이트 딜리트 , 이렇게, 두 개의 로그를 한번 추가를 해본 다음에 똑같이 Ctrl F4를 눌러서 실행을 해보면 이제는 나이트 뉴랑 나이트 딜리트가 호출이 되는 걸 볼 수가 있습니다 그래가지고 만약에 객체 단위로 우리가 메모리가 할당되고 그리고 소멸되는 이 부분을 만약에 좀 특이하게 관리하고 싶다고 하면 이런 식으로 관리를 해도 일단 괜찮습니다 나중에 오브젝트 풀링을 할 때도 이런 느낌으로 해도 , 일단은, 되기는 해요 , 자, 그 다음에 두번째로 궁금한 점은 뭐냐면은 생성자랑 소멸자가 여전히 잘 호출되고 있다는 걸 알 수가 있었습니다. 그래서 애당초 이 유를 할 때 무슨 일이 벌어지는지 잠시 브레이크 포인트를 잡은 다음에 , 자, 여기서 어 디버그 창 Disassembly 가서 살펴보면은 , 사실, 우리가 New Knight를 빵 때린 순간에 얘가 하고 있던 걸 보면은 Operator New를 이용해가지고 일단 이 New라는 Operator를 이 크기를 개선해가지고 , 일단은, 얘를 호출해준 다음에 그 다음에 여기서 생성재를 , 이렇게, 같이 호출해주게 됩니다 그러니까 , 사실, 얘가 한 번에 뭔가 우리가 요청을 했지만 사실상 메모리를 할당한 다음에 생성재를 호출해준다라는 부분을 , 이렇게, 알아서 호출해주고 있었던 것이죠 마찬가지로 딜리트를 할 때도 여기서 똑같이 딜리트를 , 이렇게, 호출해주는 요런 부분이 들어가게 되는데 얘도 내부적으로는 메모리를 날린 다음에 그 다음에 소멸자를 호출해주는 그런 부분이 이제 들어가게 될 거예요 그래가지고 1 플러스 1으로 두 가지 일을 한 번에 해주고 있는 상황이라고 볼 수 있는 거죠 , 자, 그런데 요 방법이 뭐 나쁘진 않은데 그럼에도 조금 아쉬운 건 뭐냐면 우리가 매번 마다 클래스가 , 이렇게, 한두 개가 아니라 어마어마하게 늘어날 수가 있을 텐데 그때마다 요런 코드들을 막 좀 특이하게 넣어주는 것 자체가 또 굉장히 귀찮을 수도 있겠죠 물론 이걸 매크로를 만들어 준다거나 하는 방법이 있기는 하겠지만 그것도 약간 귀찮다 싶으면 이제 이걸 조금 더 다른 방법으로 관리를 하는 게 좋을 수도 있습니다 그래가지고 제가 이제 뭐 작업하던 여러 프로젝트에서는 , 이렇게, 기본적으로 New Delete를 사용하는 게 아니라 여기다가 이제 이름을 바꿔가지고 조금 우리가 원하는 방식으로 동작하는 New Delete는 다른 이름으로 바꿔가지고 , 일단은, 그걸 사용을 했었어요. 그래서 , 일단은, 그 부분을 살짝 보여드리고 싶은데 오늘 일단 메모리 쪽에다가 클래스를 두 개를 일단 만들어 보도록 하겠습니다. 첫 번째는 Allocator라는 클래스를 만들어 줄 것이고요. 그 다음에 Memory라는 클래스를 , 이렇게, 만들어 주겠습니다. 두 개를 요렇게 넣어 주도록 할게요 , 자, 얼록테이터 같은 경우는 이제 우리가 앞으로 할당 정책을 여기다가 정의를 해주게 될 거예요 정책이 지금 여러 개가 동작하게 되겠지만 뭐 오늘은 첫 시간이니까 딱히 뭔가를 이제 뭐 어마하게 어마어마하게 신기한 건 하지 않을 거고 얘를 그냥 베이스 얼록테이터라고 해가지고 그냥 기본적으로 디폴트로 사용할 그런 할당자를 하나를 , 이렇게, 만들어 주도록 하겠습니다 그래서 얘는 BaseAllocator라고 이름을 바꿔줄 것이고 , 자, 이런식으로 Alloc이라고 해가지고 메모리를 할당하는 그런 함수 하나랑 그 다음에 Release라고 메모리를 해제해주는 함수 하나를 각각 , 이렇게, 정의를 해주도록 하겠어요 그 다음에 컨트롤 점 엔터 이것도 컨트롤 점 엔터 해줘가지고 구현부를 만들어 준 다음에 아까와 마찬가지로 , 일단은, 얘는 그냥 기본적인 그런 애다 보니까 이런식으로 멀로그를 해줘가지고 사이즈를 할당하고 그 다음에 프리를 해주는 코드만 , 이렇게, 넣어주도록 할텐데 여기서 나중에 우리가 로그를 찍어줄 수도 있을테고 아니면은 카운팅을 해줘가지고 우리가 할당한 개체수를 테스트해볼 수도 있을 것이고 아니면 메모리 릭이 일어나는지 보고 싶으면은 이 unlock을 하는 거랑 release하는 짝을 맞춰줘가지고 이 짝을 카운팅해줘가지고 진짜로 내가 할당한 메모리들이 다 삭제가 되었는지를 테스트해볼 수 있을 거고 굉장히 여러가지 디버깅 기법들을 여기다 넣어줄 수가 있을 겁니다. , 자, 그런데 , 일단은, 뭐 그건 그렇다 치고 그 다음에 이제 메모리 쪽으로 돌아가 가지고 어 요 메모리 쪽에서 우리가 아까 얘기한 그 뉴를 좀 다른 방식으로 다시 사용할 수 있게 재정의를 해주게 될 거에요. 재정이라기 보다는 그냥 다른 뉴를 만들어 주는 거죠. 그래가지고 이전 프로젝트에서 사용하던 이름이 xnew , 이렇게, 우리가 사용을 했었는데 경우에 따라가지고 예를 들면 프로젝트 이름이 r1이다 그래서 r1이라는 프로젝트 이름이면 r1-new라는 매크로로 사용하는 경우도 있었어요 여러가지 네이밍 컨벤션이 있겠지만 저는 역시나 맨 첫 프로젝트에서 했던 이 방식이 조금 더 눈에 익어가지고 이걸로 , 일단은, 한번 네이밍 컨벤션을 맞춰서 만들어 보도록 하겠습니다 , 자, 그 다음에 요 코드는 이제 뭐 처음 보시면은 아마도 약간 어... 굉장히 낯설게 느껴지실 수도 있기는 한데 이건 이제 이어가지고 설명을 드릴거고 이 점점점 뭐 , 이렇게, 하는거는 이어서 설명을 드릴거고 이건 이제 보편참조 입니다. 이거는 뭐 C++ 시간에 다룬거니까 다시 언급을 하진 않을 것이구요. , 자, 그 다음에 그 다음에 여기서 메모리를 할당을 해줄건데 , 자, 스태틱 캐스트 우리가 원하는 타입으로 만들어줄 것이고 여기서 할당 정책은 , 일단은, 베이스 얼로케이터에 얼록을 이용해가지고 만들어줄 것인데 이거는 이제 나중에 뭐 환경 설정에 따라가지고 다른 애들을 하게끔 이제 교체를 해주게 될겁니다 그래서 , 일단은, 지금 당장 사이즈 오브 타입을 여기다 넣어줘가지고 요 아이의 크기만큼을 , 일단은, 할당하게 바꿔주도록 할겁니다 메모리를 뱉어주도록 하고 그 다음에 역시나 이 타입이 똑같이 타입에 대해서 이제 삭제를 해줄 때는 이 X Delete라는 걸 우리가 사용을 해줄 건데 어떤 오브젝트를 건네주게 되면은 여기서 음 일단 베이스에 월러케이터를 우리가 만들어줬으니까 여기다가 메모리를 , 이렇게, 일단은, 날려주게 될거에요 , 자, 여기까지는 뭐 , 사실, 딱히 다른 부분이 없죠 우리가 여기 내부에서 요 오퍼레이터 안에다가 월러프리를 했던거랑 완전히 똑같은데 이제 여기서 달라지는 부분은 뭐냐면은 요 안에서 우리가 생성자랑 소멸자를 호출해줘야 됩니다 이게 무슨 말이냐면은 이제 어떻게 이거를 사용할 예정이냐면은 여기 나이트를 , 이렇게, 뉴를 해주는게 아니라 이 메모리를 애당초 할당을 할 때 문법 자체가 요 New를 해주는 게 아니라 이런 식으로 X New를 이용해 가지고 이런 식으로 만들어 주게 될 거예요. 그리고 삭제를 할 때도 마찬가지로 여기서 X Delete를 이용해 가지고 이런 문법으로 우리가 삭제를 해주게 될 겁니다. 그럼 이제 이 X가 붙은 거는 어떻게 보면 우리가 직접적으로 관리해주는 New와 Delete니까 우리가 원하는 정책으로 할당과 해제를 해준다라는 의미가 되는 거죠. 위에다가 메모리 헤더를 일단 추가를 해주도록 할게요. 그래서 원하면 나중에 이걸 재생할 수 있게 풀링을 한다고 하는 식으로 우리가 충분히 바꿔줄 수가 있을 겁니다. 흐름을 가로채는 거죠. 근데 이 방식으로 바꿔주면은 하나 문제가 원래 우리가 new를 딜리트를 했을 때 아까 어셈블리어로 까본 결과 operator new를 호출해준 다음에 그 다음에 생성자를 호출해줘가지고 사실상 메모리를 할당한 다음에 이 아이의 생성자와 소몰자가 그 메모리 대상으로 호출이 되었던 걸 우리가 확인할 수 있는데 만약에 , 이렇게, 만들어주면 얘는 이제 메모리만 그 영역만 할당해주는 것이지 생성자를 직접적으로 호출해주지 않습니다 여기서 문제가 일어나는 거죠 근데 이것도 여러분들이 , 사실, 한 번도 사용할 일이 없어서 모를 수도 있겠지만 메모리가 먼저 할당된 상태에서 그 메모리 위에다가 우리가 어떤 객체를 객체의 생성자를 호출하는 문법이 하나가 더 있어요 굉장히 놀랍게도 그게 placement new라는 문법입니다 그래가지고 코드를 보면은 여기다가 new Memory Type , 이렇게, 하는게 , 일단은, placement new인데 얘는 우리가 일반적으로 U를 할 때는 메모리를 할당한 다음에 거기에다가 생성자를 호출해주세요였다고 하면 얘는 일단 메모리는 이미 있으니까 굳이 새로 만들 필요 없고 이 메모리 위에다가 생성자를 호출해줘 라는 문법이라고 보시면 되겠습니다 , 자, 그런데 여기까지 플레이스맨 U 문법은 신기하지만 여기서 또 아쉬운 점은 뭐냐면 생성자가 인자가 없는 경우도 있겠지만 뭐 인자가 여러개 , 이렇게, 있는 경우도 있겠죠 예를 들면 뭐 HP만 따로 받아가지고 , 이렇게, 세팅을 한다거나 하는 다양한 버전이 존재할 수가 있을 겁니다 뭐 요런 느낌으로 , 자, 그런데 그때는 여기다가 이제 인재를 추가를 해주면 돼요 똑같이 , 자, 그래서 만약에 우리가 이 HP가 백인 버전으로 호출하고 싶다고 하면은 요런 식으로 뭔가 추가적으로 인자를 여기다가 넣어주면 된다는 얘기가 되는 건데 여기서 문제는 얘가 어디까지나 템플릿으로 우리가 만들어주고 있는 그런 함수이다 보니까 어떤 인자로 호출할지 전혀 예상을 할 수가 없죠 그래서 지금 등장하는 게 요 뒷부분입니다 여기 타임네임 argument 얘가 , 사실, 우리가 넘겨줄 인자를 얘기하고 있는 거예요 근데 역시나 인자가 없을 수도 있고 하나 있을 수도 있고 뭐 경우에 따라서 두 개 있을 수도 있고 여러 가지가 있을 수 있겠죠 심지어 매번 마다 인트 타입이 아니라 어떤 거는 뭐 스트링 어떤 거는 플로트 이런 식으로 매번 마다 바뀔 수가 있을 겁니다 그래서 이게 C++11 이전에는 요런거를 우리가 이제 어떻게 처리를 했었냐면은 그냥 방법이 없으니까 버전마다 하나씩 하나씩 , 이렇게, 만들어 줬어요 예를 들면 이게 인자를 안 받는 버전 뭐 , 이렇게, 하나를 만들어 주고 그 다음에 두번째로는 인자를 하나만 받는 버전을 또 요렇게 만들어 줍니다 예를 들면 type name t1 이라고 해가지고 어 type name t1 얘는 이제 말그대로 인자를 딱 하나만 뭐 받아주는 그런 버전이겠죠? 그럼 여기다가 이제 뭐 인자를 어떻게든 수단과 방법을 가리지 않고 받아가지고 그거를 여기에다가 넣어주고 이런 식으로 만들어 줬구요 근데 여기서 T1뿐만 아니라 T2, T3, T4, T5 이런 식으로 인자 개수만큼을 우리가 얘를 늘려줘야 되는 겁니다 그래서 예전에 제가 작업했던 그 서버가 2000년도에 처음에 만들어져 있었기 때문에 옛날 코드를 보면은 함수가 최대 14개를 인자를 받아줄 수 있다고 가정해가지고 이런걸 14개씩을 만들어 줬어요 T1 버전 하나 T1 T2가 있는 버전 하나 뭐 이런식으로 계속 늘려주는 거죠 이거를 요런 느낌으로 이제는 2개짜리 요렇게 근데 당연한 얘기지만 C++11에 넘어오면서 이걸 , 이렇게, 무식하게 할 필요 없이 요런 문법이 추가되었습니다. 타이프 네임에다가 점점점을 찍어가지고 베리에직 템플릿이라고 해가지고 이제 인자의 개수가 가변적으로 변하는 그런 버전이라고 볼 수가 있는 거죠. 그럼 요 버전 자체가 얘가 하고 싶은 얘기가 인자가 없을 수도 있고 하나 있을 수도 있고 두 개 있을 수도 있고 세 개 있을 수도 있다라는 얘기가 되는거죠. 그래가지고 여기다가 이제 , 이렇게, 점점점을 찍어가지고 사용하면 얘가 좀 가변 길이다라고 , 일단은, 받아주시면 되겠어요 , 자, 그 다음에 이 가변 인자 얘가 인자가 몇 개가 될지는 모르겠지만 그 인자를 그대로 여기다가 이제 전달을 해주고 싶을 경우가 생기겠죠 만약 얘가 왼값이었으면 왼값을 넘겨줄 것이고 오른값이었으면 오른값을 넘겨줘야 되는데 그때 사용하는 게 이 forward라는 걸 , 이렇게, 사용해주게 됩니다 그리고 argument가 지금은 하나가 아니라 , 이렇게, variadic, 즉 사이즈가 가변적인 길이기 때문에 문법이 조금 재밌는데 요렇게 만들어 주시면 됩니다 뭐 요 std는 뭐 경우에 따라서 좀 보기 싫으면 빼주셔도 되구요 , 자, 그래가지고 결국 요 버전이 지금 의미하는 바는 이제 우리가 xnew를 할 때 우리가 원하는 개수가 , 이렇게, 없어도 되고 하나 짜리를 넣어 줘도 되고 두 개를 넣어 줘도 되고 우리가 원하는 방식으로 얘를 만들어 주면 그거를 우리가 템플릿에서 얘가 알아서 판단을 해 줘 가지고 그 인자 개수에 맞는 버전으로 이제 호출이 된다는 게 일단 핵심인 거죠 그래가지고 , 일단은, 뭐 좀 길고 길었는데 아까 얘기하고 싶었던 게 요 부분입니다 이제 인자가 몇 개가 되던 간에 그냥 그대로 우리가 new를 했던 문법이랑 굉장히 비슷하게 첫 번째 인재를 100으로 호출하는 생성재를 만들어주세요 근데 이제 객체 자체는 night입니다 라는 걸 이제 , 이렇게, 호출해주게 되면은 이제 다시 한번 디버깅을 해주면 이제 요 코드에 딱 정확하게 들어오게 될 겁니다 요 hp를 받아주는 요 버전에 들어오게 된다는 얘기가 드는 거죠 아 그리고 여기서 에러가 나는 이유는 요 버전 때문에 지금 에러가 일어나는 건데 얘는 이제 주석처리를 해주시면 되겠습니다 , 사실, 이 뉴를 다룰 때 뭐 제가 말은 안했지만 이 뉴가 버전이 굉장히 여러개가 있어요 그래서 여기서 배드 얼룩이라고 해가지고 메모리가 만약에 더 이상 없어가지고 뭐 하는 그런 상황에 대해서 어떻게 처리할 것인지를 처리해주는 그럼 또 다른 버전도 , 이렇게, 오버리딩 할 수 있는데 이 버전이 여러개가 있어가지고 그거에 따라서 지금 얘가 충돌이 일어나가지고 일어난 문제니까 얘를 , 일단은, 주석처리해 주도록 하겠습니다. 그 다음에 어... 이제 다시 빌드를 해보도록 할게요. , 자, 서버 코어도 빌드하고 그 다음에 게임 서버도 빌드를 한 다음에 그 다음에 다시 여기다 브레이크 포인트를 잡아가지고 실행을 하면은 , 자, 요런 식으로 정확하게 딱 요 부분에서 지금 잡힌 걸 볼 수가 있습니다. , 자, 여기서 메모리를 만들어 준 다음에 요 메모리 자체가 베이스 얼로케이터 즉, 우리가 , 이렇게, 멀록으로 만들어 주어서 할당한 그 메모리를 이용해가지고 거기 위에다가 우리가 원하는 placement 류를 이용해가지고 생성자를 호출해줬고 그 다음에 그 해당 객체를 지금 , 이렇게, 뱉어주고 있다는 얘기가 되는거죠 그래서 얘가 이제 실링 완료가 되면은 짜잔 하고 지금 사실상 우리가 기본 U로 했던 거랑 완전히 똑같이 객체가 만들어지게 됩니다. 그쵸? 잘 만들어졌죠? 그 다음에 딜리트를 할 때도 역시나 요 버전이 이제 호출이 될 텐데 이때도 우리가 마찬가지로 소멸자를 호출해줘야 되는데 소멸자는 조금 더 간단합니다. 소멸자는 그냥 일반 함수로 호출하는 것과 마찬가지로 명시적으로 호출해주면 돼요. 별게 없어요. , 자, 이렇게, 해가지고 타이프를 그냥 소멸자를 호출해 , 이렇게, 해주면 됩니다 이 문법을 , 사실, 우리가 직접적으로 호출할 일은 지금까지 없었기 때문에 아마 처음 보시는 그런 문법일 수도 있겠지만 , 이렇게, 해주게 되면은 이제 메모리를 날리기 전에 그 메모리를 대상으로 일 때는 아 메모리 대상이 아니라 이 객체를 대상으로 소멸자를 호출해준 다음에 그 메모리를 이제 반납하겠다라는 코드가 이어가지고 실행이 된다고 보시면 되겠습니다 , 자, 이렇게, 해가지고 이게 할당자의 글 어떻게 보면 기본이라고 볼 수가 있는 거죠. 우리가 이제 , 이렇게, 할당하고 해제하는 부분을 우리가 원하는 버전으로 가로채가지고 여기다가 뭐 지금까지는 딱히 뭐 어마어마한 코드를 넣어주진 않지만 이걸 이제 이런저런 버전을 만들어 줘가지고 우리가 다양한 옵션을 줘가지고 이제 메모리 할당 자체를 어떻게 할지를 가로채게끔 일단 만들어줬다고 볼 수가 있는 겁니다. 그리고 여기다가 지금 뭐 베이스 얼러케이터라는 게 이제 뭐 하드코딩 되어있지만 이것도 혹시나 나중에 가면은 뭐 매크로로 따로 빼가지고 버전 따라가지고 우리가 원하는 옵션에 따라가지고 선택을 할 수 있게 만들어주면 되겠죠. 예를 들면은 우리가 매크로는 다 코어 매크로에다가 관리하고 있으니까 , 자, 여기 락 아래다가 메모리와 관련된 두번째 버전을 하나를 요렇게 만들어주도록 하고 어 그 다음에 대충 요기다가 딥 디버그일 경우라고 한다면 if def 디버그일 경우에는 무어무엇을 하고 else 그 다음에 and if , 자, 이런식으로 옵션에 따라가지고 분기를 해주면 만들면 되겠죠 지금 같은 경우에는 뭐 예를 들면은 X얼록을 해가지고 우리가 어떤 사이즈를 할당했다고 하면은 그게 Base Allocator의 Alloc을 의미하는 거니까 이걸로 바꿔치기를 해주면 , 일단은, 되겠습니다. x-release를 한다고 하면은 어떤 포인터를 대상으로 base-allocator의 release를 그러니까 ptr을 호출해주세요 라는 의미로 받아줄 수 있을 테니까 일단 , 이렇게, 만들어줄 수 있을 겁니다. 지금은 다른 버전이 없으니까 뭐 그냥 디버그는 release는 다 얘로 호출해줄텐데 나중에 이런저런 옵션에 따라가지고 여러개를 일단 만들어주면 되겠죠. 그러면은 이제 이 xalloc을 다시 여기 안에다가 , 이렇게, 바꿔치게 해주면 완성입니다. xrelease , 자, 이렇게, 해주가지고 , 일단은, Allocator의 기본에 대해서 알아봤고요. 요런 문법들이 이제 처음 보시면은 굉장히 신기할 수가 있을 건데 이게 없었을 경우에 코드를 먼저 보면은 이게 굉장히 감동적인 코드이긴 합니다. 내가 가변적인 인자를 받아가지고 그것을 넘겨주겠다 라는 의미가 되는 거죠. , 자, 이렇게, 해가지고 , 사실, 뭐 별다른 내용은 하지 않았는데 , 이렇게, New랑 Delete가 오버로딩 대산이었다라는 것도 알게 되었고요 그 다음에 나중에 혹시 모를 메모리 풀링이라거나 다양한 기법들을 하기 위한 그런 어떻게 보면 인터페이스를 먼저 파줬다고 일단 볼 수가 있는 겁니다 그래서 제 경우에는 이제 앞으로 서버에서 우리가 원하는 방식의 메모리 할당을 할 때는 XNew랑 XDelete를 이용해 가지고 이런 식으로 , 일단은, 만들어주게 될 겁니다 , 자, 이렇게, 해가지고 그냥 간단한 수업을 마치도록 할게요.