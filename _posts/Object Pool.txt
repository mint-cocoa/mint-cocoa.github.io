자, 이렇게, 해가지고 지난 시간까지 열심히 메모리 풀링에 대해서 알아봤구요 실질적으로 제가 이전에 일어난 프로젝트에서도 대충 이런 비슷한 느낌으로 메모리 풀을 사용했었어요 그래서 뭐 이 정도까지도 충분하다는 얘기가 되는 건데 다만 이 메모리 풀이 조금 아쉬운 점이 한 가지가 있습니다 그게 뭐냐면은 물론 여기서 성능 같은 거를 개선할 수 있는 여러 가지 방법이 있겠지만 그거를 제쳐두고 여기서 지금 얘가 할당하는 방법을 보면은 비슷한 크기의 메모리 들을 같은 메모리 풀에다가 밀어 넣어 가지고 공용으로 사용을 하죠 그게 뭐 딱히 문제라는 건 아니지만 예전에 제가 어떤 일이 있었냐면은 메모리 오염과 관련된 문제가 하나가 있었어요 그런데 메모리 오염이 바로 터지지 않고 , 이렇게, 메모리 풀을 사용하다 보니까 그 메모리 풀에 다시 들어가 가지고 다른 애가 또 그 메모리를 꺼내 써 가지고 오염된 메모리를 쓰다 보니까 크래쉬가 한참 후에 엉뚱한 곳에서 일어나는 문제가 있었는데 그럴 때 살짝 아쉬운 점은 누가 애당초 범인인지를 찾기가 굉장히 힘들었다는 얘기죠 왜냐면은 이게 애당초 단일 클래스 하나가 하나의 메모리 풀을 점유해 가지고 개만 사용하는 거였다면은 그 해당 메모리 풀이 뭔가 오염됐거나 깨졌다는 것은 그 코드와 관련된 그 클래스와 관련된 코드를 우리가 뒤져보면 언젠가는 범인을 찾을 수가 있겠다는 생각이 드는데 그게 아니라 , 이렇게, 서로 공유해 가지고 막 방을 이 메모리 풀을 쓰다 보니까 실질적으로 크기가 얼마짜리인 애가 문제를 일으킨 것까지는 알았는데 어떤 클래스가 정말로 그 문제를 일으켰는지 찾기가 정말 힘들었다는 얘기가 되는 거죠 그래가지고 요런 상황을 보면은 메모리 풀을 사용하더라도 경우에 따라가지고는 특정 클래스들은 자기끼리만 , 이렇게, 모아가지고 사용하면 어떨까라는 뭐 그런 후회가 약간 있었는데 오늘 얘기할 부분은 오브젝트 풀링입니다 , 사실, 메모리 풀이 우리가 만든 것 자체가 오브젝트 풀보다 조금 더 넓은 범위에요 이게 어떻게 보면 오브젝트 풀을 포함하고 있다고도 볼 수 있기는 한데 오늘 이어서 만들어 볼 거는 동일한 크기는 무조건 이 메모리 풀에 들어가는 게 아니라 정말로 그 동일한 클래스끼리를 모아 가지고 관리하는 또 다른 그런 풀을 하나를 더 만들어 볼 건데 이제 그거를 우리가 object 풀 이라고 이름을 지어 보도록 하겠습니다 네 그래서 , 사실, 이건 굳이 안 만들어도 되기는 하지만 , 이렇게, 같은 애들끼리 모아주고 싶을 때 유용할 수 있다라고 , 일단은, 생각을 해주시면 되겠어요 근데 , 사실, 그거를 제외하고는 우리가 이전에 사용하던 풀링 방법이랑 , 사실, 별반 차이가 없이 똑같이 만들 수가 있습니다 여기서 사용한 여러가지 방법이 있었죠 우리가 처음에 할 때는 락을 걸어 가지고 뭐 큐나 스택 벡터 같은 그런 컨테이너에다가 넣어 놨다가 그걸 다시 꺼내 쓰는 형태로 만들었어도 됐었고 아니면은 요런 s-list 헤더 s-list 엔트리 를 이용해 가지고 객체 앞에다가 우리가 원하는 그 노드의 정보를 같이 낑겨 넣어 가지고 그거를 실질적으로 리스트로 관리를 하는 두 가지 방법을 알아봤는데 어느 쪽으로 해도 크게 상관이 없어요. 그래서 오늘은 이어서 메모리 풀을 만들어 보도록 할 건데요. , 일단은, 메모리 풀 같은 경우에는 템플릿으로 , 이렇게, 만들어 주도록 하겠습니다. object 풀 이라고 해서 예를 들면 우리가 나이트라거나 아니면 몬스터라거나 같은 클래스끼리 이 동일한 옵젝트 풀에다가 밀어 넣게끔 이제 , 이렇게, 템플릿을 만들어 가지고 이 옵젝트 풀은 클래스 별로 우리가 만들어 주겠다라는 지금 정책을 사용하고 있는 겁니다 , 자, 그래가지고 위에다가 , 일단은, 여기 types랑 그리고 memory pool 헤더를 추가를 해줄거구요 얘가 이제 지금 템플릿이다 보니까 cpp에다가 우리가 정의를 하지 않기 때문에 실질적으로 요 types 헤더같은거를 누락하면은 어... 여기 이제 memory pool이라거나 아니면은 우리가 type에다가 정의한거를 이제 사용하지 못해가지고 얘를 , 일단은, 잠시 추가를 한거구요 빌드를 했을때 에러가 났을때 뭐 그것도 상관없지만 , 일단은, 미리 , 이렇게, 넣어주도록 하겠습니다 , 자, 그 다음에 , 일단은, private , 자, 일단은, 옵젝트 풀은 다 스태틱으로 내용물을 만들어줄건데 스태틱이라고 해가지고 s-bar라는 이름으로 , 이렇게, 한번 지어보도록 하겠습니다. unlock size랑 그 다음에 우리가 사용할 메모리 풀을 , 이렇게, 각각 갖고 있을 거에요. , 자, 그래가지고 , 사실, 우리가 지난 시간에 , 이렇게, 메모리 풀을 만들어 준 다음에 그거를 메모리 클래스에서 메모리 풀들을 각각 관리해 가지고 내가 원하는 개수만큼을 만들어 준 다음에 어떤 특정 사이즈에 따라 가지고 원하는 우리가 풀에다가 그거를 넣어주는 방식을 채택했는데 그게 아니라 요 object 풀 같은 경우에는 얘 전용으로 요 type 전용으로 하나의 풀을 만들어가지고 관리를 하겠다라는 정책을 사용하게 될 겁니다 그래서 , 이렇게, 일단은, 만들어 주도록 할 거고요 , 자, static이다 보니까 여기 아래다가 요런 식으로 실체를 만들어 주도록 할 건데 object 풀 타입에 s-alloc-size는 size-of-type에다가 size-of-memory-header 두 개를 더한 만큼으로 사이즈를 잡아줄 것이고 그 다음에 memory-full도 , 이렇게, 만들어주도록 하겠습니다 type에 s-full 그리고 요 아이는 원래 우리가 생성자에서 크기를 받아줬는데 alloc-size를 , 이렇게, 넣어주도록 할게요 네 , 이렇게, 해가지고 , 일단은, 풀을 만들어 주도록 하겠습니다. 아 메모리 풀이죠. 그러니까 메모리 풀에서 얼룩사이즈를 받아가지고 사용하고 있으니까 그 부분을 여기다가 , 이렇게, 넣어줬다고 보시면 되겠습니다. 뭐 그건 그렇고 요 아이 같은 경우는 템플릿으로 , 이렇게, 만들게 되면은 이게 설령 스태틱이라고 해도 얘가 진짜로 딱 하나만 존재하는 건 맞지만 클래스별로 하나씩 존재합니다 근데 우리가 옵젝트 풀에다가 나이트를 넣어주는 거랑 옵젝트 풀에다가 다른 클래스를 넣어주는 거랑은 아예 실질적으로는 별개의 클래스로 구분이 되어서 인식이 되기 때문에 실질적으로 각자 이 풀이랑 얼룩사이즈를 갖게 됩니다 , 자, 그 다음에 여기다가는 이런 식으로 어떻게 만들어줄까 좀 고민을 하다가 여기서 우리가 실질적으로 꺼내가지고 쓰는 부분을 만들어주도록 할게요 여기서 이런식으로 타입에 팝을 해가지고 팝을 할 때는 내가 어떤 생성자를 만들어가지고 쓸지도 같이 건네주도록 하겠습니다 , 사실, 요 코드를 살짝 벗겨가지고 요 비슷한 코드를 이쪽에다가 만들어 본다고 생각하시면 되겠습니다 메모리는 static cast type type 으로 , 이렇게, 바꿔줌과 동시에 그 다음에 , 사실, 여기서 하는 부분은 메모리 헤더에서 attach 헤더를 함과 동시에 풀에다가 pop 을 해가지고 메모리 를 꺼내 쓰도록 하겠습니다 그 다음에 Attach Header 할 때는 원래 우리가 사이즈를 같이 넣어 놨으니까 이 얼룩 사이즈를 같이 이용해 가지고 데이터를 꺼내 온 다음에 거기다가 Attach Header를 해 가지고 이런 식으로 캐스팅을 해 놨어요 그 다음에 이어서 여기 있는 비슷한 코드를 , 이렇게, 넣어 놓을 겁니다 이런 코드가 들어가게 될 거고요 placement new를 이용해서 생성자를 호출한 다음에 걔를 뱉어주겠다라는 내용이 되는거죠 그래서 이 풀에서 해당 메모리를 꺼내가지고 거기에다가 헤더를 붙여놓은 다음에 그 다음에 최종적으로 , 이렇게, 생성자를 호출해가지고 뱉어주겠다라고 만들어줄거고 반대로 push를 하겠다라고 할 때는 오타가 좀 자주 나는데 요거랑 똑같이 이제 만들어 보도록 할게요 , 일단은, 요 오브젝트에 소멸자를 호출한 다음에 그 다음에 이 풀에다가 푸쉬를 해가지고 다시 반납을 해주면 될텐데 반납할 때는 메모리 헤더에 디테치 헤더를 해가지고 헤더를 다시 꺼내 가지고 그 헤더를 푸쉬하는 방식으로 , 이렇게, 만들어 주도록 하겠습니다. 즉 메모리에서 우리가 사실상 여기 allocate 랑 release 를 할 때 사용하던 이런 코드들을 지금 같이 , 이렇게, 넣어 줬다고 보시면 되는 거고 여기서는 요 아이의 크기를 계산을 해 가지고 그 아이의 크기에 맞는 그런 풀에다가 , 이렇게, 넣어주는 방식을 채택을 했는데 얘 같은 경우에는 어차피 사이즈별로 공통으로 묶어서 하는 게 아니라 같은 타입별로 무조건 하나의 풀에다가 우리가 들어가게끔 만들어 줄 것이기 때문에 살짝 코드가 달라졌다고 , 일단은, 볼 수가 있겠습니다 네 그래가지고 뭐 , 일단은, 이렇게, 일단 오브젝트 풀을 간단하게 구현을 할 수가 있겠어요 , 자, 그러면 이제 이거를 뭐 어떻게 사용하느냐 한번 예시를 한번 들어보도록 할게요 다시 게임 서버 쪽으로 돌아가 가지고 요 코드는 , 일단은, 그냥 빌드를 한번 해가지고 문제가 없는지 체크를 해보고 문제가 일단 없는 것 같으니까 아 그 다음에 여기서 웬만해서는 이 Object Pool을 사용할 확률이 높으니까 여기 어딘가에 Core PCH같은 데다가 얘를 포함시켜 놓도록 할게요. 아래쯤에다가 포함을 시켜주도록 하겠습니다. Object Pool 오케이 그 다음에 다시 한번 빌드를 해보고 그 다음에 이어가지고 메인 CPP에 가가지고 간단하게 클래스 나이트가 있으니까 나이트랑 몬스터를 , 이렇게, 만들어 보도록 할게요. 얘는 뭐 그냥 간단하게 이런 식으로 int64 뭐 id 같은 걸까? 있다고 가정을 해보도록 합시다. 그러면 이제 실질적으로 얘를 활용을 할 때는 , 자, 여기서 일단 요 부분을 무시하고 위쪽에다가 우리가 메모리 풀을 한번 사용을 해볼 건데 , 자, object 풀에서 우리가 night를 사용하고 싶다라고 하면은 뭐 이런 식으로 팝을 해가지고 사용을 해주면 돼요 여기다가 이제 뭐 우리가 어떤 생성자를 호출할지에 따라가지고 이 나이트의 생성자가 뭐 여러가지 어 인자를 받는다면 여기다가 이제 팝에다가 같이 넣어주면 되는데 그게 아니라 없다고 하면은 그냥 요렇게만 넣어주면 , 일단은, 되겠죠 그래가지고 요기에다가 뭐 예를 들면 이런 식으로 나이트를 팝을 한 다음에 릴리즈를 해줄 때는 거꾸로 요 나이트 풀에다가 다시 푸쉬를 해줘가지고 요런 식으로 , 일단은, 넣어줄 수가 있을 겁니다 네 그래가지고 이제 팝을 할 때마다 이미 안에 있는 애가 있으면은 걔를 다시 재생할 것이고 없으면은 실시간으로 만들어서 사용하겠다 그리고 반납할 때는 거꾸로 똑같은 옵젝트 풀에다가 , 이렇게, 반납을 하겠다는 코드가 실행이 될 겁니다 , 자, 그런데 여기서 살짝 아쉽게 생각할 수 있는 부분이 그런데 , 이렇게, 짝을 맞춰서 해야 되는가 만약에 내가 까먹고 이 K를 , 이렇게, 할당했는데 까먹고 나중에 이런 기본 버전의 릴리스를 한다거나 아니면 우리가 만든 이 메모리 풀을 이용하는 버전을 사용한다거나 하면서 실수할 수 있지 않느냐라고 일단 반문하실 수도 있어요. 물론 그것도 맞는 얘기입니다. 그래서 실질적으로 , 이렇게, 수동으로 관리하는 경우는 별로 없을 거예요. 이런 부분 같은 경우에는 , 사실, 메모리 풀도 마찬가지지만 애당초 우리가 쉐어드 포인터를 이용해가지고 쉐어드 포인터에서 이 옵젝트 풀을 이용해가지고 할당한 애들은 이 소멸자를 이용해가지고 소멸이 될 때 다시 메모리 풀에 들어가게끔 우리가 유도를 해줄 겁니다 근데 이걸 어떻게 해주느냐 사실은 여러분들이 지금까지 배웠던 쉐어드 포인터를 예로 들어보면은 포인터를 , 이렇게, 만들어줄 때 우리가 지금까지 사용하던 방식은 이런 거였죠. Make Shared를 이용해가지고 , 이렇게, 만들어주는 버전이 하나가 있었는데 이 버전 같은 경우에는 문제가 뭐냐면 그냥 기본적인 New Delete를 이용합니다, 기본적으로. 그래서 우리가 이런 식으로 메모리 풀링이 들어가거나 옵젝트 풀링이 들어갈 경우에는 이 기본 버전으로 , 일단은, 하면 안 돼요. 그래서 얘를 만들어줄 때 인자를 두 개를 받아주는 버전이 있습니다 예를 보면 , 이렇게, 인자를 두 개를 넣어줄 건데 하나는 이 아이의 포인터를 직접 만들어서 넣어줄 거고요 예를 들면 , 이렇게, 만들어주고 그 다음에 여기 두 번째 인자로 이제 딜리터를 넣어줄 수가 있어요 내가 어떻게 이제 삭제될 때 어떤 식으로 삭제가 될지를 , 이렇게, 넣어줄 수가 있습니다 이 버전이죠 이 해당 객체를 커스텀 딜리터를 이용해서 삭제를 해둘라 그러면 삭제될 때는 실질적으로 여기에서 넣어준 이 딜리터를 이용해서 삭제가 된다고 보시면 되겠습니다 그래가지고 이 버전을 이용한다고 하면 이 코드를 , 이렇게, 일단 합쳐줄 수가 있어요 여기다가 팝을 하는 부분이랑 그 다음에 어떤 식으로 무엇을 이용해서 삭제를 할 것인지를 , 이렇게, 1 플러스 1으로 , 이렇게, 넣어주게 되면 이제 이 객체가 소멸될 때쯤이면 알아서 이 오브젝트 풀에 다시 들어가게 될 거에요 그래서 요런 방식으로 , 일단은, 만들어줘야 되겠습니다 근데 이것도 매번마다 타이핑 얘기가 귀찮으면은 뭐 요런데다가 일단 함수를 뭐 만들어 줄 수가 있겠죠 예를 들면은 요 타입에 대해서 Make Shared라는 걸 만들어 줄 것인데 뭐 얘가 하는 거는 그냥 간단하게 어.. 요렇게 팝을 하고 삭제될 때는 푸쉬를 해주는 요런.. 요런 느낌으로 얘를 Shared Point를 만들어가지고 , 일단은, 반환을 해주면 되겠습니다. 그럼 이제 앞으로 사용할 때는 Object Pool에 Knight에다가 Make Shared를 통해가지고 요런 식으로 바로 이 객체를 만들어가지고 사용하게 되면은 알아서 Pooling이 들어갈 수가 있다는 얘기가 되는 거죠. 네 그래가지고 뭐 이거를 뭐 더 깊이 테스트를 해보고 싶으면 뭐 여러가지 테스트를 해볼 수가 있는데 예를 들면은 , 자, Knight를 100개를 만들어 본 다음에 이런 식으로 어 100개를 만들고 100번 동안 나이트에 옵젝트 풀 나이트에 팝을 했다가 그러면 이제 100개가 만들어지게 될테고 그 다음에 다시 한번 루프를 돌면서 이제 넣어주면 되겠죠 옵젝트 풀에 나이트에다가 푸쉬를 해주겠다 그리고 ki는 null로 다시 밀어주면 이제 되겠습니다 그러면 여기서 이제 이런식으로 하게되면은 아이고 나이트로 했죠 객체를 100개를 만들어 준 다음에 팝을 해가지고 100개를 다시 반하는 셈이 되는 겁니다. 그러면 요 Object Pool 내부에 보면은 이 S Pool 이쪽에다가 , 자, 이쪽에다가 우리가 다시 넣어준 데이터가 들어가게 되겠죠 그러니까 처음부터 데이터를 어느정도 한 100개에서 1000개 사이로 객체를 만들어가지고 넣어준 다음에 걔네들을 까먹는 방식도 있고요 아니면 그냥 처음에는 아무것도 없는 상태에서 시작을 해가지고 필요할 때마다 새로 만들고 나중에 만든 거를 다시 반납하는 등 여러가지 , 일단은, 정책으로 우리가 이거를 이제 만들어 줄 수가 있을 겁니다 그리고 참고로 여기 지금 _allocCount라고 해가지고 우리가 몇 개를 지금 추출해가지고 사용하고 있는지를 나타내고 있지만 여기다가 추가적으로 지금 이 메모리 풀 안에 몇 개가 남아있는지 등등 정보도 남기면 좋을 것 같습니다. 근데 이 이름이 조금 헷갈리니까 얘를 이름을 useCount라고 일단 바꿔놓도록 할게요. 실질적으로 사용 중인 개수를 표현을 할 것이고 그 다음에 컨트롤 뒤로 복붙 해가지고 Reserve Count라고 해가지고 실질적으로 이 메모리 풀에 저장이 되어 있는 애들은 또 별도로 카운팅을 해가지고 나중에 디버깅을 할 때 좀 보도록 합시다 Fetch Add를 통해가지고 여기다가 하나를 증가시키면 되겠고 그 다음에 이쪽에서는 Reserve Count를 여기서 하나를 줄여주면 되겠죠 Fetch Sub을 통해가지고 1을 빼주도록 합시다 여기서는 그냥 만들어주는 거니까 예약이 다시 들어가진 않는 거니까 여기서는 숫자를 안 줄여줘도 되고 대략적으로 , 이렇게, 만든 다음에 이제 테스트를 해보면 되겠죠 여기서 나이트가 100개가 만들어지고 다시 들어간 다음에 우리가 새로 , 이렇게, 나이트를 만든다고 가정을 하면은 그 다음에 여기다가 브레이크 포인트를 잡아가지고 살펴보면은 100개가 만들어질테고 여기다가 타고 타고 들어가가지고 , 이렇게, 들어가다 보면은 팝을 하게 되는데 팝에서는 , 일단은, Reserve Count가 100개로 있고 Use Count가 0개인 걸 볼 수 있습니다 뭐 이런 식으로 숫자가 정상적으로 , 이렇게, 늘어난다는 걸 볼 수가 있는 거죠 Reserve Count가 줄었고 메모리는 줄고 이런 식으로 , 일단은, 응용할 수가 있다고 보시면 되겠습니다 그리고 당연한 얘기지만 여기서 우리가 나이트 대상으로 만든 Object Pool이랑 만약에 이제 이 몬스터를 대상으로 똑같이 Object Pool을 이용해가지고 이 몬스터를 만약에 대상으로 우리가 새로 만든다고 하면은 이 오브젝트 풀이랑 이 몬스터드에 대한 오브젝트 풀은 완전히 별개의 개념이다 보니까 얘도 얘만의 오브젝트 풀을 갖고 똑같이 다시 동일한 로직이 실행이 될 겁니다. 뭐 , 이렇게, 해가지고 다양한 오브젝트끼리 우리가 따로따로 별도를 관리하고 그 다음에 이 나이트와 관련된 메모리가 해제될 때는 자기 자신의 오브젝트 풀로 돌아가는 이런 방식으로 구현을 할 수 있다고 , 일단은, 보시면 되겠어요 , 자, 그래서 , 사실, 오브젝트 풀에 대한 내용은 이게 전부입니다 우리가 메모리 풀에 대한 내용을 쭉 알아봤으니까 그걸 응용하면 이런 식으로 오브젝트 다디로 묶어주는 오브젝트 풀링도 충분히 구현을 할 수 있다라고 결론을 , 일단은, 내릴 수가 있습니다 그래서 이쯤에서 마치도 되긴 하지만 저 같은 경우에는 그럼에도 불구하고 메모리 풀이나 옵젝트 풀을 사용할 때 가장 큰 단점은 메모리가 재생이 되다 보니까 우리가 스톰프 알로케이터랑 얘랑 병행해서 사용할 수 없는 게 좀 굉장히 아쉽다고 했었죠 그래서 실질적으로 개발을 할 때는 특히 이런 서버 코어 같은 걸 만들 때는 초창기의 버그를 잡는 게 굉장히 중요한데 이런 부분이 솔직히 개인적으로는 굉장히 아쉽게 느껴집니다 그래가지고 이건 이제 여러분들이 선택을 해가지고 어떤 정책을 할지를 어느정도 골라줘도 되기는 하는데 저같은 경우에는 이거 살짝 수정을 해보도록 할게요 여기서 우리가 코어 매크로에서 요 부분에서 , 일단은, 풀얼로케이터를 사용하고 여기서 , 이렇게, 나누고 있었는데 그게 아니라 , 일단은, 무조건 풀얼로케이터 코드를 실행을 하되 여기 풀얼로케이터 내부에서 내부에서 이제 진짜로 우리가 메모리 풀링을 적용시켜가지고 할지 아니면 스톰프 얼로케이터를 적용시켜가지고 할지를 다시 나눠주도록 하겠습니다. 그래가지고 한마디로 다시 뒤로뒤로 가가지고 이 메모리 쪽에서 X얼록으로 하던 부분을 잠시 다시 복원을 시켜주도록 할게요. 이런식으로 얼록으로 다시 복원을 시켜주도록 하고 그 다음에 릴리스를 하는 부분도 역시나 풀 얼로케이터 릴리스로 , 일단은, 얘를 그냥 바꿔치기 해준 다음에 이 내용은 , 일단은, 잠시 삭제를 해서 날려주도록 할 것이고 실질적으로 이제는 오브젝트 풀이나 메모리 풀 둘 중 하나를 골라 가지고 우리가 사용할 수 있게 되겠죠 그러면 그 내부에서 이제 다시 분기를 해주게 될 겁니다 그래가지고 , 일단은, 얘부터 작업을 해보자면 뭐 예를 들면 여기 팝을 할 때 , 자, if define 스톰프 얼로케이터를 사용할 것이냐 if define 스톰프가 있냐 없냐에 따라 가지고 else and if 이거에 따라 가지고 우리가 코드를 분기를 해줄 거예요 만약에 스톰프 얼로케이터라는 게 define 되지 않았다라고 하면은 그냥 기본적으로 메모리 풀링을 적용하겠다라는 의미가 되는 거니까 요 코드를 , 이렇게, 위로 다시 넣어주면 되겠고요 그게 아니라 만약에 스톰프 얼로케이터를 사용하겠다라고 하면은 , 자, 이제 조금 달라져야 될게 이 Pool을 이용할 게 아니기 때문에 먼저 이런 식으로 한 단계를 더 거쳐가지고 Reinterpret Cast Memory Header로 변환해주고 Stomp Allocator를 여기서 적용을 시켜주도록 합시다 Alloc 그 다음에 sAlloc Size는 그대로 , 이렇게, 이용을 해주고 이 포인터를 받아준 다음에 이거를 여기다가 넣어주고 이 Memory Header는 , 사실, Stomp로 할 때는 딱히 필요 없긴 하지만 코드의 일관성을 위해서 , 일단은, 이렇게, 만들어 주도록 할게요 그 다음에 팝을 할 때는 요렇게 될 것이고 푸쉬를 할 때도 마찬가지로 똑같은 코드 end if 그래서 스톰프를 쓸 것이냐 말 것이냐를 골라준 다음에 스톰프를 안 쓸 거면 메모리 풀링이 적용되어가지고 이 풀에다가 넣어줄 것이고 그게 아니라고 한다면 스톰프 알로케이터에 릴리즈를 해가지고 여기는 똑같죠 메모리 헤더에 디테지 헤더를 이용해가지고 요렇게 스톰프 알로케이터에다가 반환을 해주도록 할게요 사실상 말만 옵젝트 풀링이지 우리가 스톰풀을 사용하겠다고 하면은 이걸 디버깅을 해가지고 잡기 쉽게끔 이 스톰풀 로켓을 이용해주겠다라는게 되는거죠 나중에 가면은 이거를 더 개선시켜가지고 뭐 특정 객체 대상으로만 스톰풀을 이용하고 나머지 객체들은 그냥 일반 뭐 메모리 풀링이 적용되게끔 한다거나 하는 식으로 더 세분화 해가지고 관리하게 되면은 우리가 진짜로 어떤 나중에 메모리 오염이 일어나가지고 어떤 애가 의심이 될 때 그 아이만 요런 식으로 정밀 검사를 해주는 뭐 그런 방법을 이용할 수도 있을 겁니다 네 , 이렇게, 해가지고 , 일단은, 스톰프로 , 일단은, 살짝 바꿔치기를 해놨구요 요 스톰프 매크로 같은 경우에는 이제 나중에 요기 서버 속성에 가가지고 요런 쪽에다가 우리가 옵션을 넣어줘도 되구요 아니면은 그냥 뭐 간단하게 하고 싶다고 하면은 대충 뭐 , 이렇게, 자주 쓰는 타입같은 데다가 , 이렇게, 디파인을 해가지고 얘가 디파인이 되어있으면은 스톰프를 쓸 것이고 아니면은 추측 처리를 하는 식으로 어 개발 차원에서 빠르게 관리를 해보도록 할게요 지금은 스톰프를 , 이렇게, 한번 켜보도록 하겠습니다 그러면 짜잔 하고 위에 버전이 이제 실행이 되면서 이제 스톰프 얼로케이터를 사용해 가지고 사실상 뭐 메모리 옵젝트 풀링이 들어가지 않고 그냥 요 방식으로 만들어주는 방식이 이제 실행이 될 겁니다 , 자, 그 다음에 마찬가지로 어 메모리 쪽에 돌아가 가지고 메모리 쪽에서도 똑같은 작업을 해줄 건데요 , 자, 이쪽에다가 한번 펼쳐놓고 여기서 얼로케이트를 할 때 원래 여기가 이제 메모리 풀링이 들어가는 부분이었는데 여기다가도 똑같이 if define 스톰프가 만약에 정의되었으면 엘스 그 다음에 엔드잎을 해가지고 요 코드를 만들어 볼 것인데 만약에 적용이 되지 않았으면 기존과 마찬가지로 요 코드를 그대로 집어 넣을 것이고 그게 아니라 스톰프가 정이 되었다고 하면은 얘도 re-interpret-cast-memory-header 그 다음에 스톰프 얼로케이터에 얼로케이스를 요렇게 해주도록 합시다 얼룩 사이즈로 계산된 사이즈만큼을 얼룩 해주라 네 , 이렇게, 일단은, 만들어 주면 되겠습니다 그 다음에 마지막 마지막으로 이쪽에서도 , 자, 여기서도 마찬가지로 if define stomp else 그 다음에 end if 만약에 스톰프를 쓰지 않는다고 하면 이 코드를 그대로 넣어 줄 것이고 그게 아니라고 한다면 stomp allocator release를 해가지고 이 헤더를 그대로 넣어주면 이제 완성이라고 볼 수가 있는 거죠. 빌드를 한번 해보도록 할게요. 그래서 , 이렇게, 해서 스톰프를 사용할 것인지 말 것인지를 여러분들이 이제 뭐 유도 있게 결정을 해가지고 이걸 조속 처리하거나 냅두거나 해가지고 이제 앞으로 버그를 개발 단계에서 빠르게 잡을 수 있도록 , 이렇게, 만들어 봤고요. 뭐 지금은 뭐 맨 오브젝트 풀링과 관련한 내용을 다루고 있었으니까 이걸 잠시 꺼두도록 할게요 그러면 역시나 예정대로 이제 오브젝트 풀링이 잘 들어갈 것이고 아 그리고 마지막으로 어 셰어드 ptr 대상으로 뭐 이런식으로 만들 때 x new 를 유행해서 똑같이 만들 때도 동일한 문제가 발생합니다 그러기 때문에 우리가 이런식으로 메이크 셰어드를 통해 가지고 요런식으로 팟 푸쉬를 한번 넣어줬던 것과 마찬가지로 사실상 실제로 메모리 풀을 이용할 때도 비슷한 작업을 해줘야 됩니다 이거를 고지곳대로 우리가 xnew를 xdelete를 매번마다 해주진 않을거고 메모리 쪽에 돌아가가지고 대충 여기다가 아래다가 얘도 만들어 주도록 할게요 타입을 만들어 준다고 가정을 하고 sharedptr type make shared 그 다음에 Shared PTR Type , 이렇게, 만들어 주고 X New Type 그 다음에 X Delete Type을 , 이렇게, 넣어 줘 가지고 얘 같은 경우에도 역시나 똑같이 이 make sure를 이용해가지고 바로 메모리 풀을 이용하는 버전을 요렇게 만들어주도록 합시다 그럼 이제 진짜진짜 완성이 된거고 만약에 옵척트 풀을 이용할거면은 요 버전을 만들었고 그리고 그게 아니라 어 옵척트 풀이 아니라 그냥 메모리 풀을 이용하는 버전이라고 한다면 이제 앞으로 요 버전으로 , 일단은, 만들어주면 된다는 얘기가 되는거죠 그리고 여기다가 night를 이용해가지고 이런식으로 네 그래가지고 오늘 다룰 내용은 다 끝난 것 같구요 네 , 이렇게, 해서 오브젝트 풀링의 기념을 간단하게 알아봤습니다.