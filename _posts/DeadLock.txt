자, 이제 이번 시간에도 지난 시간에 이어서 락과 관련된 내용 특히나 이제 데드락과 관련된 내용에 대해서 다시 한번 얘기를 해보고자 하는데요 뭐 지난 시간에 살짝 언급을 드렸지만 우리가 뮤텍스를 활용한 상태에서 락을 걸고 언락을 해서 이 뮤텍스를 잠그고 풀어주는 행위가 이제 짝을 맞춰가지고 락을 한 다음에 꼭 언락을 해야 되는데 요거를 이제 누락하게 되면은 뭐 교착상태 데드락 상태가 발생할 수 있다고 했었죠 그리고 요 문제를 해결하는 뭐 굉장히 우아한 방법은 락가드를 이용해 가지고 이제 이 락가드라는 객체 자체가 소멸이 될 때 뮤택스를 알아서 풀어주게끔 만들어주면 된다고 언급을 했습니다 하지만 그렇다고 해서 락가드를 활용한다고 해서 세상에 존재하는 그런 모든 데드락들이 사라진다는 것은 또 아닙니다 , 사실, 이렇게, 락이랑 언락 짝을 안 맞춰 가지고 발생하는 그런 데드락 상황은 굉장히 1차원적이고 어떻게 보면 자주 일어나지 않는 그런 부분들이고요 만약 이런 상황이 발생한다고 하면 진짜 프로그래머 문제라고 봐야 되겠죠? 그건 너무나도 부주의한 것인데 근데 그런 상황 말고도 조금 더 까다롭게 데드락이 발생하는 상황이 또 존재하는데 이거는 실무에서도 굉장히 자주 발생하는 문제입니다. 그러니까 일반적으로 MMO 서버에서 만약에 이제 서버가 뻗는다, 크래시가 났을 때 일어나는 각종 버그들이 있겠지만 가장 높은 확률로는 널포인터 크래시가 일어나는 거고요 포인터인데 널포인터 가지고 걔를 잘못 참조해서 뻗는 그런 문제가 가장 많이 일어나고 그 그 외에도 이런 데드락 문제도 꽤 상위권 탑5 안에 들 정도로 심심치 않게 등장하는 그런 버그라고 보시면 되겠습니다 근데 이게 조금 이야기가 까다롭기 때문에 , 일단은, 예제를 한번 들어보도록 할게요 , 자, 오늘 오늘 실습할 그런 클래스를 일단 두 개를 추가할 것인데 오늘만 실습하고 얘네들은 날릴 거니까 뭐 크게 관리를 하실 필요는 없습니다 , 일단은, 어카운트 매니저라는 걸 하나를 만들어 줄 것이고 그 다음에 이제 유저를 관리하는 유저 매니저라는 애가 있다고 , 이렇게, 가정을 해볼게요 뭐 온라인 게임이라고 하면은 처음에 게임에 입장을 할 때 어 이제 계정이라는 게 있을 거고 그 계정을 토대로 내 캐릭터를 받아오고 하는 일련의 작업들이 들어가게 될 텐데 그 어카운트라고 보시면 되겠습니다 네 그래서 , 일단은, 이렇게, 어카운트 매니저가 있을 것이고 , 일단은, 잠시 뮤택스를 추가를 해주고 그 다음에 여기서 어카운트라는 클래스가 있다고 가정을 해볼게요 뭐 지금은 딱히 그냥 테스트를 하기 위해서 간단하게 만들었으니까 여기는 내용물을 비워두겠지만 여기다가 나중에 뭐 아이디라거나 아니면 그 해당 계정의 이름이라거나 생성일자 뭐 등 온갖 정보들이 다 여기 들어가게 될 겁니다 , 자, 우리 어카운트 매니저는 이제 싱글톤으로 언제 어디서든 쉽게 꺼내서 사용할 수 있고 실질적으로 지금 게임에 접속해 있는 모든 어카운트들을 정보들을 추출할 수 있는 그런 굉장히 편리한 클래스라고 가정을 해봅시다 , 일단은, 간단하게 싱글톤을 이 버전으로 만들어 주도록 할게요 그 다음에 예를 한번 들어봐가지고 getAccount라는 함수가 있는데 아이디를 줘가지고 해당 어카운트에 아이디를 주면은 여기서 이제 뭔가를 찾아가지고 뱉어주는 그런 기능을 한다고 , 일단은, 가정을 해봅시다 그리고 실질적으로 얘가 멀티스레드 환경에서 동작을 해야 되기 때문에 , 이렇게, 멤버 변수를 뮤택스를 하나를 들고 있을 겁니다 그러면 , 일단은, getAccount 같은 걸 할 때 뭐 예를 들면 여기서 1년의 아이디와 뭐 어카운트 짝을 뭐 이런 식으로 들고 있다고 , 일단은, 가정을 해볼 수가 있겠죠 네 이런 느낌으로 그래서 여기서 결국에는 멀티스레드 환경에서 돌아가야 되니까 lockGuard를 , 이렇게, 걸어 줘 가지고 크래시가 나지 않게 동시다발적으로 접속할 수 있게 만들어줄 겁니다. 그래서 여기서 뭔가를 갖고 와가지고 여기서 어카운트 아이디를 추출해가지고 해당 어카운트를 뱉어주고 하는 요런 기능들을 이제 이 getAccount란 함수가 담당한다고 보시면 되겠습니다. , 자, 그 다음에 여기서 process login 이라고 해가지고 실질적으로 이 account manager 를 통해 가지고 어떤 어떤 유저가 처음에 게임에 로그인을 했을 때 룸과 로그인하는 코드를 여기다가 넣어놓는다고 가정해 볼게요 , 사실, 로그인할 때 뭐 이런 account 정보도 필요하고 그런 온갖 정보들이 필요할 테니까 뭐 여기 , 일단은, process login을 account manager 에다가 배치시키는 것도 나름 일리 있는 선택이 될 수 있겠죠 그래가지고 여기다가 어카운트 매니저가 또 , 이렇게, 등장을 하고 있고 프로세스 로그인이라는 함수가 여기서 이제 만들어 줄 것인데 얘도 마찬가지로 어찌됐건 이런 정보를 참조하고 싶으면 얘가 이제 멀티스레드 환경에서 돌아가야 된다고 하면은 락을 잡아 가지고 실행을 해야 되겠죠 그래가지고 , 일단은, 락가드를 뭐 요렇게 , 일단은, 만들어 준다고 가정해 볼게요 , 자, 그 다음에 이제 유저 매니저도 비슷한 느낌으로 똑같이 이제 만들어 줄 건데요 잠시 유저 매니저들로 돌아가 보도록 할게요 얘도 mutex를 , 일단은, 이렇게, 추가를 해줄 것이고요 그 다음에 얘도 어떤 유저 클래스를 , 이렇게, 정보를 들고 있다고 가정을 해볼게요 , 자, 그 다음에 뭐 중복되는 내용이니까 그냥 똑같이 만들어주도록 할게요 얘도 뭔가 , 이렇게, 유저 매니저를 언제 어디서든 사용할 수 있도록 싱글톤 패턴을 이용해 가지고 , 이렇게, 만들어 줄 것이고요 인스턴스라고 해가지고 인스턴스를 , 이렇게, 뱉어주면 될 것이고 그 다음에 역시나 getUser라는 함수가 있는데 얘도 어떤 아이디를 받아 가지고 이제 그 해당 유저의 정보를 뱉어주는 그런 역할을 하게 될 겁니다 근데 얘도 이제 멀티스네더 환경에서 실행이 되야 되다보니까 여기다가 락가드를 먼저 , 이렇게, 해준 다음에 그 다음에 여기서 또 뭔가 갖고 오는 행동을 해줄 것이고 해당 정보를 , 이렇게, 뱉어주는 그런 기능을 한다고 또 가정을 해볼게요 그리고 여기서 뮤트X는 역시나 , 이렇게, 멤버 변수로 들고 있고 얘도 마찬가지로 뭐 이런 저런 기능들이 뭔가 이제 어떤 유저를 플레이 하다가 그 해당 유저의 정보를 이제 그 유저가 나가 가지고 DB에다가 정보를 저장해야 된다거나 하는 그런 기능들을 왠지는 모르겠지만 유저 매니저 내부에 이 프로세스 세이브라는 함수를 만들어 가지고 관리를 한다고 가정을 해봅시다 그래서 얘도 약간 대칭적인 상황이죠. 유저 매니저를 , 이렇게, 만들어 줄 것이고 프로세스 세이브라는 기능이 여기 있는데 얘도 결국에는 멀티세더 환경이다 보니까 라까드를 , 이렇게, 걸어 줄 겁니다 지금까지는 뭐 딱히 어려운 부분은 없습니다 , 자, 그런데 여기서 이제 조금 더 내용이 복잡해지는 거는 다시 어카운트 매니저로 돌아가 가지고 여기서 이제 로그인을 할 때 로그인을 할 때 어 이 어카운트에 관련된 그런 유저들을 뭐 로드하고 또 유저 매니저에 저장하고 하는 등등의 기능들이 필요한 과정을 해볼게요 그래서 결국에는 여기서 유저 매니저를 캐더를 추가해 가지고 여기서 결국에는 유저 매니저에 접근을 해가지고 여기서 , 이렇게, 접근을 해가지고 여기서 getUser 함수를 뭔가를 활용해야 된다고 또 가정을 해봅시다. 예를 들면 100번 아이디에 해당하는 유저를 들고 와주세요 라고 한 다음에 여기서 뭔가를 해주게 되는 거죠. 그러면 결국에는 여기서 해준 게 우리가 account.lock을 지금 , 이렇게, 잡은 상태에서 여기서는 간접적으로 user.lock을 또 잡은 상태가 되는 겁니다. 왜냐면 getUser라는 이 함수 내부에서 lock guard를 이용해가지고 이 mutex를 또 잡아주고 있기 때문이죠. 그러다보니까 지금 어카운트 매니저에도 뮤택스가 하나가 있고 유저 매니저에도 뮤택스가 하나가 있는데 각기 다른 뮤택스 객체입니다 그런데 , 이렇게, 어카운트 락을 잡고 유저 락을 잡고 하는 부분이 이제 , 이렇게, 들어가게 된다는 거죠 락을 딱 하나만 활용하는 게 아니라 , 이렇게, 매니저별로 락이 하나씩 있으면 경우에 따라가지고 , 이렇게, 두 개의 락을 동시에 우리가 잡아야 되는 그런 경우가 종종 생긴다고 보시면 되겠어요 제가 이전에 뭐 실전 프로젝트에서 일할 때도 , 이렇게, 어카운트 쪽에서 이런 데드락 문제가 굉장히 자주 발생했던 기억이 있습니다. 참고 삼아서 말씀드리는 건데 그리고 어찌됐건 이제 유저 매니저에도 마찬가지로 프로세스 세이브라는 이런 기능이 있는데 뭐 어찌어찌 하다 보니까 얘도 뭔가 자신이 속해 있는 그 어카운트 정보를 긁어와야 된다고 가정을 해봅시다. 네 그럼 이건 진짜 어디까지는 예제에요 뭐 , 이렇게, 꼭 구조를 짜라는게 아니고 진짜 이런 상황이 발생한다는 얘기를 하고 있는 겁니다 그래가지고 얘도 똑같이 뭐 100번 아이디에 해당하는 어카운트 매니저 정보를 이용해가지고 어카운트 정보를 추출한다고 가정해볼게요 , 이렇게, 그래서 여기다가 어카운트 정보를 , 이렇게, 일단은, 추출해 준 겁니다 그럼 얘는 이제 거꾸로 유저 락을 잡은 상태에서 어카운트 락을 잡은 다음에 그 다음에 여기서 뭔가 이제 일을 해주게 되겠죠 , 자, 여기까지는 뭐 별다른 문제가 없어 보이는데 사실은 문제가 벌써 존재합니다 이거를 한번 테스트를 해볼 건데 이제 다시 게임 서버 쪽으로 돌아가 가지고 요 부분에서 이제 간단하게 스레드를 두 개를 만들어 보도록 할게요 , 일단은, 어카운트 매니저를 사용할 것이니까 헤더를 추가해주고 그 다음에 유저 매니저도 사용할 것이니까 , 이렇게, 헤더를 추가를 해줄 것이고요. 그 다음에 이제 함수 두 개를 만들어 줄 것인데 펑션 1이라는 애는 뭘 하는 거냐면은 뭐 그냥 , 이렇게, 루프를 돌면서 뭐 한 100번, 1000번 정도 할게요. 1000번 정도 유저 매니저의 프로세스 세이브를 진행하는 그런 굉장히 단순한 기능을 하게 될 겁니다. 얘를 세이브를 하고 있고 그 다음에 이걸 복붙해가지고 하나를 더 만들어 줄 건데 얘는 function2라고 해가지고 얘는 뭘 해주는 거냐면은 거꾸로 account manager에 접근해가지고 프로세스 로그인을 해주는 그런 기능이라고 가정해 볼게요. 이걸 한 번 하면 잘 일어나지 않으니까 여러 번 , 이렇게, 반복해서 해주고 있는 겁니다. 그 다음에 이제 thread 두 개를 만들어가지고 thread 두 개를 만들어 줘가지고 func1을 하나를 실행해 줄 것이고 , 이렇게, 컨트롤 D로 복붙한 다음에 펑션 2를 하나는 담당하게 될 겁니다 그리고 얘네들이 끝날 때까지 , 일단은, 조인을 통해 가지고 기다려 주도록 할게요 그 다음에 이제 끝났으면 끝났다는 의미로 Job's done 이라고 , 이렇게, 채팅을 한번 쳐 보도록 하겠습니다 , 자, 여기까지 뭐 딱히 어려운 코드는 없는데 결국에는 , 이렇게, 유저 매니저와 어컨트 매니저를 각각 다른 스레드에서 지금 접근해가지고 요걸 하고 있는 겁니다 , 자, 근데 , 일단은, 이걸 1000으로 하지 않고 굉장히 적은 숫자 그냥 한 번만 하도록 , 이렇게, 일단은, 코드를 바꿔가지고 여기서 한번 컨트롤 fo 를 이용해서 한번 실행을 해보도록 할게요 그러면 지금 , 이렇게, 경우에 따라서 벌써부터 , 이렇게, 막히는 경우도 생기는데 이걸 여러 번 하다 보면 어쩔 때는 얘가 막히고 어쩔 때는 , 이렇게, 실행이 되는 걸 볼 수가 있습니다 여기서 실행이 되었으면 아무 문제 없이 빠져나온 건데 이제 이 수를 조금 늘려가지고 한 100번 정도만 얘를 실행하게끔 만들어놔도 뭔가 좀 다르게 동작한다는 걸 알 수가 있어요 이 상태에서 다시 한번 실행을 해보면 여기서 영영 끝나지 않고 계속 대기를 타고 있다는 걸 알 수가 있습니다 , 자, 그럼 이게 왜 문제가 되는지 잠시 한번 다시 실행해 가지고 브레이크 포인트를 한번 잡아 보도록 할게요 얘는 끄고 지금 여기서 이 정지 위에 있는 모두 중단 일시정지를 잠시 , 이렇게, 눌러주도록 할게요 그러면 딱 지금 , 이렇게, 멈춘 상태가 되는 거죠 일단 꺼주도록 하고 그러면은 지금 주 스레드는 뭐 상관없고 이제 우리가 T1이랑 T2라는 스레드를 각각 지금 관리하고 있는데 T1에 해당하는 요 아이는 getAccount를 하려고 하는 부분, 여기 콜스택을 보면은 function1을 실행하다가 processAble를 실행하고 있는데 userLock을 잡은 상태에서 이제 accountLock을 획득하려고 시도를 하고 있는데 여기서 지금 멈춘 상태고요. 거꾸로 반대쪽 T2 같은 애는 순서가 뒤바뀌어 가지고 요 account 락을 잡은 상태에서 이제 user 락을 잡으려고 하는데 얘를 잡지 못해 가지고 지금 대기를 타고 있는 상황입니다 그래서 이게 전형적인 데드락 상황이라고 보시면 되겠어요 , 이렇게, 데드락이 발생하면은 양쪽 스레드가 이제 교착 상태에 빠져 가지고 그 스레드들이 서로 기다리는 뭐 그런 상태가 되어 가지고 둘 중 어느 하나도 이제 일을 할 수 없는 최악의 상황이 일단 되었다고 보시면 되겠습니다 , 자, 그러면은 이제 약간 멀티셋 감이 좋으신 분은 이 문제를 보자마자 원인을 파악할 수가 있을텐데 그게 아니라 일반적인 상황이라고 하면 이게 도대체 뭐가 문제가 되는지 약간 알이 달성하겠죠 어 분명히 락을 잡고 여기 락카드를 이용했으니까 락을 해제 안한 것도 아닐테고 얘도 , 이렇게, 잡아주고 있고 그 다음에 얘도 잡아주고 있는데 , 자, 요 문제가 발생한 원인을 , 일단은, 잠시 ppt로 다시 돌아와서 한번 분석을 해보도록 할게요 , 자, 이렇게, ppt로 잠시 돌아왔구요 그래서 오늘 얘기하고 싶은 주제는 데드락입니다 이제 워낙 중요한 얘기니까 이걸 좀 길게 다루고 있는데 , 일단은, 락이라는 것 자체가 화장실에 , 일단은, 제가 비유를 할 수 있다고 했었죠 화장실 문이 있고 화장실에 자물쇠가 달려 있는데 화장실에 들어간 사람이 자물쇠를 잠궈 가지고 사용하는 뭐 그런 굉장히 일반적인 상황이라고 볼 수 있겠습니다 근데 이제 다수의 사람들이 정말 급하게 화장실을 사용하려고 할 때 경험이 붙겠죠? 재빨리 달려갔는데 간발의 차이로 왼쪽에 있는 애가 먼저 들어갔으면 얘가 이제 자물쇠를 잠그고 들어가게 될 겁니다. 반대로 이제 그 사람이 이제 볼일을 다 보고 나와서 자물쇠를 풀어주게 되면은 그제서야 또 대기하고 있던 사람이 들어가가지고 걔가 또 자물쇠를 잠그는 뭐 이런 상황이 되겠죠? , 자, 여기까지는 락을 하나를 사용하는 개념이고 여기까지는 아무런 문제가 없는데 경우에 따라 가지고 , 이렇게, 자물쇠가 2개 짜리인 경우가 생기게 됩니다 뭐 현실상에서는 굳이 , 이렇게, 자물쇠를 2개를 둘 이유는 없지만 뭐 , 일단은, 왠지는 모르겠지만 자물쇠가 2개 있다고 가정을 해볼게요 근데 이때 이제 반드시 두개의 자물쇠를 두개를 동시에 잠궈야지만 그 사람이 안에 들어갈 권한을 일단 얻게 된다고 보시면 되는건데 만약에 운이 나쁘게 첫번째 애는 왼쪽에 있는 애가 위에 있는 자물쇠 1번을 먼저 잠군 상태고 오른쪽에 있는 애는 자물쇠 2번 즉 아래에 있는 자물쇠를 먼저 잠궜다고 가정해볼게요 그러니까 서로 한 부분씩 반쪽짜리 승자가 되었다고 보시면 되겠어요 근데 반드시 두개를 다 내가 획득을 해야지만 내가 최종 승자가 되는 거니까 나머지 하나도 , 일단은, 자기가 획득하려고 시도를 하게 되겠죠 그래서 요런 노란색 화살표로 나머지에도 내가 한번 트라이를 해서 잠궈보겠다라고 지금 시도를 해보고 있는 겁니다 근데 여기서 발생하는 문제는 뭐냐면 애당초 서로 반대쪽 애가 자기가 들고 있던 자물쇠를 해제를 해주기를 기다리고 있는 겁니다 근데 굉장히 불행하게도 서로 양보를 해주지 않고 있는 상황이죠 왜냐면 , 사실, 서로의 존재를 잘 모르기 때문에 왼쪽에 있는 애는 그냥 무조건 기다리다가 내가 아래에 있는 자물쇠도 획득하면 내가 승자가 되어서 들어갈 수 있겠구나라고 굉장히 나이브하게 생각을 하고 있는 거고 순진하게 생각을 하고 있는 거고 오른쪽에 있는 애도 마찬가지로 내가 이미 반쪽짜리 자물쇠 2번을 획득하고 있는 상황이니까 위에 있는 자물쇠만 내가 좀 기다렸다고 획득하면 내가 들어갈 수 있겠구나라고 또 굉장히 기뻐하고 있는 상황이 되는 거죠 하지만 이게 굉장히 교착상태에 빠진 이유는 서로 하나의 자물쇠만 딱 잠궈놓고 반대쪽 애가 서로 놔주기를 지금 기다리고 있는 어떻게 보면 꼬인 상태라고 보시면 되겠습니다 우리가 흔히 운전 같은 걸 할 때 뭐 좀 4차 도로에서 서로 꼬리 물기를 하고 차들이 막 지나가다 보면 결국에는 어떤 차도 다 지나갈 수 없게 서로 막 꼬이는 현상이 종종 발생하게 되는데 정말로 그런 교착 상태가 일어났다고 보시면 되겠습니다 , 자, 그러면 다시 돌이켜가지고 요 문제가 이제 왜 발생했는지를 생각해보면 물론 자물쇠가 두개가 있는 것도 문제긴 하지만 꼭 자물쇠 두개가 있다고 해서 문제가 항상 발생하는건 아니죠 지금 아까 이 문제가 발생한 이유는 서로 순서가 달라서 그렇습니다 즉 첫번째 애 같은 경우는 자물쇠 1번을 먼저 잠그고 그 다음에 2번을 잠그려고 시도를 했고 거꾸로 오른쪽에 있는 애는 2번부터 잠그고 1번부터 잠궜기 때문에 발생한 문제라고 보면 되겠어요 근데 만약에 이제 좀 통일된 규칙을 정해가지고 , 자, 무조건 위에 있는 자물쇠부터 잠궈야 됩니다 라는 규칙을 우리가 둔다고 하면은 이제는 그런 문제가 사라지게 되겠죠 왜냐면은 사실상 위에 있는 자물쇠를 잠군 시점부터 승자가 , 일단은, 결판이 나기 때문에 아까처럼 서로 물고 늘어지는 그런 상황은 이제 발생하지 않을 겁니다 즉 여기서 경쟁을 통해 가지고 맨 위에 있는 자물쇠를 먼저 획득한 애가 나머지 애도 , 이렇게, 잠그어 가지고 걔가 이제 최종 승자가 되는 뭐 그런 상황이라고 볼 수가 있겠습니다 그리고 지금 요 상황이 아까 우리가 유저 매니저랑 어카운트 매니저를 통해 가지고 실습한 상황이랑 굉장히 일단 유사하다고 보시면 되겠어요 , 자, 그래서 다시 코드로 돌아와가지고 결국에는 이제 유저 매니저랑 어카운트 매니저를 , 이렇게, 동시에 살펴보면 얘가 발생한 문제가 굉장히 명확하게 한쪽에서는 유저 락을 먼저 잡고 어카운트 락을 잡고 반대쪽에서는 어카운트 락을 잡고 유저 락을 잡으려고 하기 때문에 서로 반쪽짜리 승자가 등장했기 때문에 발생한 문제죠 하나는 여기를 잡았고 또 하나는 여기를 잡았기 때문에 서로 양보를 해주기를 기다리다가 영영 진행을 못하는 그런 상황이라고 보시면 되겠습니다 그러면 결국에 이 문제를 해결하는 건 , 사실, 이유는 굉장히 간단한데 전체적인 락 순서를 일단 맞춰주면 되겠죠. 예를 들면은 어카운트 락이 무조건 먼저 잡아야 된다라고 해가지고 어카운트 락과 이 유저 락 사이의 순서를 정해가지고 요렇게 , 일단은, 고쳐주면 여기 일어나는 방금 일어나는 데드 락 문제는 , 일단은, 1차적으로 해결이 될 겁니다. 그래서 이 상황에서 다시 한번 실행을 해보면 이제는 항상 빠져나오는 걸 볼 수가 있어요 , 자, 이론상으로는 그렇긴 한데 근데 이제 모든 경우에 대해서 , 이렇게, 순서를 맞춰주는 것 자체가 , 사실, 굉장히 어려운 일이긴 해요 그러니까 데드락이 진짜 이래서 굉장히 짜증나는 게 뭐냐면 일단 첫 번째로 이 데드락이 굉장히 짜증나는 점은 이게 어쩔 땐 발생하고 어쩔 땐 발생 안 하고 이런 상황이 굉장히 빈번하기 때문에 이게 또 짜증납니다 아까 얘기한 대로 이제 한 번씩만 실행하다보면은 이게 또 발생 안하는 문제가 있었는데 이제 그러면 MMORPG 환경을 생각해보면 이게 개발 단계에서는 절대로 일어나지 않다가 꼭 라이브에 가가지고 동접이 많아질 때만 이게 정말 극악의 확률로 일주일에 한 번씩 터지는 그런 버그가 있다고 하면은 개발 단계에서 그 버그를 잡기가 굉장히 힘들게 되겠죠 하지만 버그가 일단 터졌다고 하면은 이제 여기 있는 뭐 콜스택도 추적해보고 얘가 왜 멈췄는지 분석을 하다보면은 의외로 어... 사후 처리는 굉장히 쉬운 편입니다. , 이렇게, 이유가 굉장히 명확하기 때문이죠. 결국에는 이 순서를 항상 맞춰줄 수 있는 방법이 있느냐? 존재하지 않습니다. 그래도 조금 실수를 줄이기 위해서 사람들이 일반적으로 사용하는 방법이 몇 가지가 있기는 한데 , 일단은, 이렇게, 락 사이에 순서를 맞춰주기 위해서 락끼리의 번호를 매겨주는 겁니다. 그러니까 , 이렇게, 락, 뮤택스를 그냥 고지곳대로 바로 사용하는게 아니라 얘도 이제 랩핑을 해가지고 별도의 클래스로 만들어 준 다음에 뭐 일종의 아이디를 부여해가지고 아이디가 무조건 큰 애가 먼저 실행이 돼야 된다라고 해가지고 추적을 하는 거죠 락을 걸 때마다 그걸 추적을 해가지고 내가 1000번째 락을 잡았는데 그 다음에 그거보다 숫자가 더 작은 500번째 락을 잡았으면 문제가 났다고 판별하거나 하는 식으로 뭔가 꼼수를 이용해가지고 할 수 있기는 한데 그것도 또 정확하진 않아요 왜냐하면 결국에는 그 하이라키를 만들어 주는 것도 우리가 손수 하는 것이기 때문에 우리가 방대한 코드에서 모든 경우를 다 예측하고 그 순서를 맞춰주기는 굉장히 어렵기 때문이죠 , 사실, 결론부터 말씀드리면 이 데드락은 뭔가 미연의 예방을 하고 100% 하고 그런 기념이 아니라 그냥 조심하면서 사용을 해야 됩니다 하지만 일단 문제가 일어나면 뭐 고치기는 쉽다고 보면 되겠죠 , 자, 그리고 참고 삼아서 이제 하나만 더 보여드리자면 어... 요렇게 지금은 어카운트 매니저와 유저 매니저의 각각 락이 따로따로 뮤택스가 배치되어 있으니까 뭐 요 상황이랑은 조금 다르긴 한데 만약에 경우에 따라가지고 우리가 동시다발적으로 요 뮤택스 M1이랑 M2를 동시에 지금 딱 활용하고 있다고 하면은 이거를 STD 락이라는 애를 이용해가지고 요렇게 잠그면은 이 M1이랑 M2를 요렇게 입력을 하나 M2, M1을 입력을 하나 얘가 알아서 내부적으로 어떤 일관적인 순서를 이용해가지고 얘를 잠궈주는 기능도 합니다 뭐 이건 , 사실, 실전에서 그렇게 자주 활용할 일은 없지만 뭐 요런 기능이 있다는 것도 이제 알아주시면 되겠어요 그래가지고 이런 식으로 뭐 뮤택스마다 뭐 어떤 특징적인 뭐 아이디라거나 하는 걸 발급을 해가지고 직접 관리해도 되고 아니면 뭐 이런 식으로 STD 락을 이용해가지고 잠가도 되겠습니다 그럼 얘가 , 사실, 내부적으로 하는 거는 M1에서 락을 하고 M2에서 락을 사실상 둘 다 해준 건데 이 순서를 우리가 M1, M2를 넣어줬건 M2, M1을 넣어줬건 내부적으로 뭔가를 이용해가지고 자판별해서 일관적인 순서를 보장한다고 보시면 되겠습니다 , 자, 근데 여기서 락을 풀어주는 건 어찌됐건 직접 해야 됩니다. 그래서 예를 들면 여기서 락 가드를 다시 이용할 것인데 여기서 그냥 고지곳대로 , 이렇게, 하면은 원래 요 부분에서 M1의 락을 잡는 거였는데 여기다가 추가 옵션으로 여기서 Adopt Lock 이라는 걸 딱 하면은 이 힌트를 주는 건데 얘는 힌트를 줘 가지고 이미 해당 뮤테스는 락이 된 상태니까 락까지 해줄 필요는 없고 그냥 나중에 소멸될 때 풀어 주기만 해라는 힌트를 주고 있다고 보시면 되겠습니다 그래가지고 뭐 이런 식으로 활용하게 되면은 아까 우리가 이 순서를 신경 써 가지고 M1, M2, M2, M1을 해야 되는지 이걸 신경 쓸 필요 없이 , 이렇게, 일관적인 순서로 얘를 이제 잠궈 주신다고 보시면 되겠어요 뭐 요런 기능도 , 일단은, 동작을 하긴 합니다 이 락을 보면은 어 얘도 이제 템플릿으로 되어 있고 어 베레딕 템플릿으로 되어 있어 가지고 꼭 두 개뿐만 아니라 여러 개를 , 이렇게, 막 넣는다고 해도 얘가 일관적인 순서를 보정해주는 요런 방법도 있기는 합니다 참고삼아서 그냥 아시라고 표준이 있으니까 이걸 말씀을 드린 거고 , 자, 그래가지고 결국 오늘은 좀 섭섭한 게 결국 문제 제기는 했는데 이게 뭐 뚜렷한 해결 방법이 없었다고 했었죠 그래가지고 유순서를 이제 맞춰주는 거에 따라가지고 버그가 발생할 수도 있다라는 얘기를 하고 있는 거고요 나중에 좀 멀티셋 후반에 가가지고 제 경우에는 그래서 이거를 이제 어떻게 하냐면은 이것도 이제 100% 완벽하게 해결하는 방법은 아닌데 이 락을 실시간으로 추적하는 일종의 락 매니저를 만들어 준 다음에 이게 사이클이 발생하는지 안 발생하는지를 저는 추적을 해가지고 잡는 편입니다 이건 , 사실, 자료구조 알고리즘을 모르시면 이해하기 힘드시겠지만 자료구조 중에서 그래프 알고리즘이 있는데 여기서 지금 이런 식으로 순서에 따라 가지고 뭔가 문제가 일어날 수 있는 상황은 결국 그래프로 치면 사이클이 일어난 상황이라고 보시면 되겠어요 , 자, 이거를 한번 그림판을 켜가지고 잠시 한번 설명을 드려보자면 결국에는 여기 지금 1번 락이 있고 2번 락이 있고 3번 락이 , 이렇게, 있는데 여기서 이제 락을 잡는 순서를 계속 추적을 할 겁니다. 예를 들면 어카운트 락을 잡은 상태에서 유저 락을 잡을 수 있으면 여기다가 그래프로 표현하면 요렇게 1번에서 2번으로 잡는 경로가 일단 있다는 얘기가 되는 거고 마찬가지로 유저 락을 잡은 상태에서 또 다른 락을 잡을 수 있다고 하면은 뭐 이런 식으로 락을 잡고 잡고 잡고 하는 순서가 이제 어떤 일종의 그래프로 만들어지게 된다는 얘기가 되는 거죠 근데 여기서 만약에 우리가 첫 번째 케이스에서 어카운트 락을 잡은 상태에서 유저 락을 잡을 수도 있었고 유저 락을 잡은 상태에서 어카운트 락도 잡을 수 있었다고 하면은 , 자, 요런 식으로 순환 구조가 생기게 됩니다 이게 이제 사이클이 생기게 된다고 표현을 하는 거죠 그래서 우리가 이제 그래프 알고리즘에서 요런 식으로 사이클이 일어나는지 안 일어나는지 판별하는 그런 코드를 만들 수가 있는데 저는 이제 보통 요런 방법을 이제 넣어가지고 디버그 상태에서 얘가 사이클이 일어나는지 안 일어나는지를 판별해가지고 데드락을 잡는 편이에요 뭐 요런 방법도 가능하고 뭐 굉장히 다양한 방법이 있긴 하지만 어쨌든 그럼에도 불구하고 데드락을 100% 방지하고 뭐 그런건 아닙니다 이제 뭐 극하고의 확률로 어쩌다가만 일어나는 그런 경우도 일단 생길 수 있기 때문이죠 뭐 그래가지고 뭐 , 이렇게, 해가지고 , 일단은, 데드락에 대한 내용을 , 일단은, 간단하게 맞춰보고 이 순서에 대한 내용을 꼭 기억을 해주시면 되겠습니다.