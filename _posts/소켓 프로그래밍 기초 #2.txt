자, 그래서 지난 시간에 예고 드린 대로 이제 다시 코드로 돌아온 다음에 오늘부터는 이제 클라랑 서버를 동시에 켜야 되기 때문에 여기 더미 클라이언트를 켜 가지고 왼쪽에다 놨고요 그 다음에 서버 쪽 게임 서버를 켜 가지고 오른쪽에다가 , 일단은, 배치를 해놨고 여기서 이제 코드를 양옆으로 작업을 해주게 될 겁니다 , 자, 이제 클라이언트 쪽에서 헬로월드는 굉장히 오랫동안 우리가 안 지우고 있었는데 얘를 , 일단은, 삭제를 해주도록 할 거고요 그 다음에 서버 쪽에서도 지난 시간에 했던 이런 타이플리스트와 관련된 그리고 뭐 필요 없는 내용들은 일단 싹을 날리고 진행을 한번 해보도록 할게요 메모리 얼러케이터 랩 카운팅 뭐 이런 것도 다 , 일단은, 필요 없으니까 일단 날려주고 여기서 이제 새로운 마음으로 시작을 해보도록 하겠습니다 윈도우즈 쪽에서 네트워크 프로그래밍을 시작하기 위해서는 추가해야 될 라이브러리가 대표적으로 윈속2라는 아이를 , 일단은, 추가를 해주셔야 돼요 윈도우 소켓이라 이거죠 원래는 이 소켓 라이브러리가 리눅스의 조상이라고 할 수 있는 유닉스 쪽에서 먼저 시작이 되었어요 그래가지고 나중에 가가지고 마이크로소프트에서도 윈도우즈 버전의 소켓 프로그래밍 라이브러리를 만들었는데 그게 이제 윈속이라고 보시면 되겠습니다 윈도우즈 소켓이다 뭐 이런 얘기죠 그래서 이 윈속을 추가를 해주신 다음에 그 다음에 여기다가 추가적으로 중간중간에 사용할 애들을 미리 추가를 해줄 건데 mswsock.h라는 것도 일단 추가를 해주시고요 참고로 이 대서문자는 뭐 크게 상관이 없습니다 이거를 뭐 그냥 , 이렇게, 소문자로 해도 똑같아요 그리고 마지막으로 ws2, tcp, ip, h , 이렇게, 세 개를 , 일단은, 사용할 거니까 얘네들을 , 일단은, 추가를 해주도록 하겠습니다. 그 다음에 얘네들만을 추가하면 안 되고 여기다가 추가적으로 라이브러리 파일을 하나를 갖고 와야 되는데 우리가 기존에도 여기 pth 같은 거 보면은 우리가 만든 이 lib 파일을 여기 속성에 가가지고 막막 링크를 하고 이런게 너무 복잡하니까 이런식으로 프레그마 커멘트 모식이라고 코드상에서 얘를 , 이렇게, 사용을 하게끔 유도를 해줬는데 이걸 그대로 복붙을 한 다음에 요 부분에서 이제는 ws2 언더바 32 립 이라는걸 요거를 , 일단은, 포함을 해주셔야 됩니다 아니면 이제 뭐 에러가 날 거예요 그래서 이 삼총사를 , 이렇게, 똑같이 복붙을 양옆에 해주도록 할게요 예전에 처음에 코딩할 때 이걸 빼먹어 가지고 진짜 고생한 적이 있어요 아무리 봐도 왜 에러가 났는지 이해를 못했는데 뭐 이거 빼먹지 않도록 조심하시고 , 자, 그 다음에 우리가 아까 설명한 그 그림대로 , 일단은, 진행을 해볼 건데 먼저 이 민속을 사용하기 위해서는 이 민속 라이브러리를 , 일단은, 초기화를 해줘야 됩니다 그리고 초기화를 해줄 때는 wsastartup 이라는 함수를 이용을 해주면 돼요 여기서 인자를 두 개를 받고 있는데 이 인자를 무슨 의미인지를 MSDN이 찾아보면 , 이렇게, 나오고 있습니다 참고로 말씀을 드리자면 이거는 , 사실, 게임뿐만 아니라 마찬가지지만 IT 업계에서는 구글링이 거의 손과 발처럼 자유롭게 항상 할 수가 있어야 됩니다 왜냐하면 이런 함수들에 대한 질문을 이제 가끔 제가 C잡 강의에서 느낀 건데 이 함수는 무엇을 하는 함수입니까? 라는 질문을 올리는 분들이 계세요 근데 처음이니까 이해를 해서 제가 답변을 드리곤 있지만 , 사실, 프로그래머라면 그런 질문은 해서는 안 됩니다 왜냐면 , 사실, 모든 답변은 다 구글에 있기 때문이죠 이래서 저보다 당연히 이 함수를 직접 만든 마이크로소프트에서 이게 어떤 함수인지를 더 잘 알고 있을 테고 여기서 w-startup 해서 보면은 이 마이크로소프트의 공식 msdn 사이트로 딱 , 이렇게, 들어가 가지고 여기서 굉장히 친절하게 얘가 뭘 하고 있는지를 설명을 해주고 있습니다 그래서 어쨌든 이 WSA 스타트업을 하면은 버전이랑 뭐 , 이렇게, 두가지 인재를 받아주고 있는데 어 요 버전 자체는 이제 뭐 얘가 이제 실패했을 때는 무엇을 리턴한다 등등 굉장히 장황하게 지금 설명을 해주고 있어요 이런걸 한 번씩 참고로 해보면 굉장히 많은 도움이 됩니다 그리고 영어에도 당연히 너무 공포를 가지시면 안 돼요 영어도 읽다 보면은 이제 독해 능력이 좀 향상이 되고 문서를 보다보면 어쨌든 영어 실력도 굉장히 중요하기 때문에 웬만해서는 한국어가 아니라 영어로 , 이렇게, 읽어보시기를 바랍니다 , 자, 어쨌든 이제 우리가 사용할 소켓이 버전이 이제 여러가지가 있는데 가장 최신 2.2 버전을 일단 요즘 사용을 해요 , 사실, 이전 버전은 전 듣도 보도 못했으니까 무조건 2.2 버전을 사용할 건데 그거를 첫 번째 인자에다가 , 일단은, 넘겨주면 되는 거고 그 다음에 온갖 설정 값을 여기 두번째 인재를 통해 가지고 우리가 받아온 다음에 그거를 참조할 수 있는데 , 사실, 이 두번째 인자는 거의 활용할 일이 없기는 할 겁니다 , 자, 그래가지고 여기다가 , 일단은, make word라는 걸 해가지고 e를 , 이렇게, 입력을 해주신 다음에 그 다음에 wsa data라는 거를 , 이렇게, 받아가지고 wsa data라고 할까요 여기다가 , 이렇게, 넣어 주시면 됩니다 이 메이코드 같은 경우에도 굳이 정확히 어떤 걸 하는지 살펴 보셔도 되고 해도 되고 안 돼도 되지만 이것도 아까 유시맥 보면 여기 사용하는 샘플 코드가 다 , 이렇게, 들어가 있습니다 여기 있죠 그래가지고 이런 코드는 당연히 외울 필요가 없고 그냥 공식 문서를 보면서 이런 거를 조금씩 보다 보면 언젠간 눈에 익으니까 이것도 외울 필요가 전혀 없다고 일단 보시면 되겠어요 그 다음에 여기서 wsstartup을 한 다음에 이제 우린 이제 윈속을 사용할 준비가 되었다라고 초기화를 해주고 어 여기서 에러를 뱉어주는데 에러가 0이 아닌지를 봐가지고 얘가 성공했는지 아닌지를 판별할 수 있고 그 다음에 마지막으로 프로그램이 종료되기 전에는 우리가 , 이렇게, 할당한 거를 해제하듯 WSA 클린업을 호출해야 된다는 걸 또 알 수가 있습니다 그래서 얘는 약간 어떻게 보면 세트라고 볼 수가 있는 거예요 근데 굳이 WSA 클린업을 안 한다고 하더라도 뭐 딱히 프로그램이 뻑거나 하진 않는데 이왕이면 이 표준에서 나온 방법을 지켜주는 게 좋겠죠 그래서 , 이렇게, 일단은, 만들어 주시면 돼요 그래서 결국에는 맨 처음에 했던 게 윈속 라이브러리 초기화를 하는 부분이구요 이게 사실상 요 아이를 라이브러리 초기화를 하는 부분이다 라고 , 일단은, 기억을 해주시면 되겠고 그리고 관련 정보가 , 사실, 두 번째 인자인 ws의 데이터에 채워지긴 하는데 뭐 요 데이터를 굳이 우리가 볼 일은 없긴 합니다 그러니까 이렇게만 , 일단은, 넣어 주되 얘는 뭐 딱히 사용을 안 할 예정이에요 여기다가 얘가 만약에 실패했으면은 얘가 0이 아닌 값으로 뜬다고 했으니까 그러면은 뭔가 이제 뭐 리턴을 해주거나 아니면 뭐 로그를 찍어주거나 하는 식으로 만들어 주면 되겠죠 , 일단은, 요렇게 시작을 하고 넘어가도록 할게요 , 자, 그 다음에 다시 이제 아까 PPT 기준으로 보면은 얘가 이제 클라이언트고 얘가 서버 입장이 되는 겁니다 그래서 이제 정신을 차려 가지고 하나씩 진행을 해볼 건데 클라이언트 쪽에서 먼저 해야 되는 거는 클라이언트도 어쨌든 전화를 걸어야 되니까 단말기를 준비해야 된다고 했었죠 자신의 휴대폰 하나를 준비해야 되는데 소켓을 만들어야 됩니다 소켓을 만드는 방법이 여러 가지가 있는데 기본적으로 사용할 수 있는 함수가 이 소켓이라는 함수가 있어요 , 이렇게, 소문자로 되어 있는 거는 리눅스 환경에서도 똑같이 동작하는 그런 동일한 인터페이스 함수가 있을 확률이 높고요 대문자로 뭔가 , 이렇게, 되어 있는 거는 이제 윙 속 특유의 그런 추가된 함수라고 , 일단은, 기본적으로 생각하시면 됩니다 뭐 이게 항상 맞지는 않지만 그래가지고 , 일단은, 소켓이라는 걸 사용해가지고 우리가 사용할 전화기를 만들 것이다 라는 걸 , 일단은, 예고를 드리고 있는 거고 소켓도 역시나 , 이렇게, 찾아보면은 얘가 뭘 하고 있는지가 친절하게 나와 있는데 , 일단은, 인자를 3개를 받고 있어요 AF라고 해가지고 얘가 address family라고 해가지고 주소체계를 먼저 받을 것이고 그 다음에 우리가 소켓을 어떻게 사용할 것인지를 타입으로 받고 있고 어떤 프로토콜을 사용할 것인지 , 이렇게, 세 가지 인자를 받고 있는데 사실상 우리는 이 첫 두 가지 인자만 세팅을 해도 되긴 합니다 첫 번째 인자 같은 경우에는 요 아이는 우리가 주소체계를 어떤 거를 활용할지를 이제 입력을 해주는데 결국에는 이 IP버전 6인지 아니면 4인지를 선택을 해줘야 됩니다 이거는 또 뭘 하는 거냐 잠시 cmd 커맨드에 가서 이걸 살짝 보여드리자면 ipconfig를 치면 이게 우리가 소위 IP주소라고 하는 아이들이죠 , 이렇게, IP주소가 있는데 IP주소가 두 가지 버전이 있어요 옛날 버전, 신규 버전 , 이렇게, 있습니다 이게 일반적으로 우리가 생각하던 IP 주소고 좀 알 수 없는 뭔가 희한한 거로 돼 있는 게 최신 방법입니다 그래서 이 주소로 해도 충분하니까 우리는 IPv4로 진행을 할 건데 이 아이는 왜 굳이 사용을 하느냐 옛날에는 , 사실, 다 이 IPv4만 사용을 했었어요 근데 이 서버, 네트워크 통신 자체가 꼭 우리가 게임을 만들 때만 사용하는 게 아니라 굉장히 다양한 용도로 이제 활용이 되겠죠 우리가 뭐 어떤 무선 장치를 통해 가지고 명령을 내린다거나 아니면 그냥 온갖 기기끼리 네트워크 통신을 해야 된다고 했을 때 , 이렇게, 네트워크 통신을 하기 위해서는 어떤 주소를 발급받아 가지고 그 주소를 대상으로 우리가 연결해야 되는데 이게 기기가 하도하도 많아지다 보니까 이 주소가 고갈이 되었습니다. 어느 순간부터 고갈이 되었습니다. 그래가지고 이 주소로는 부족하니까 주소체계를 좀 늘려가지고 더 많은 주소를 표시할 수 있게끔 한 게 이제 이 윗버전이라고 , 일단은, 생각하시면 되겠습니다. 이거는 나중에 뭐 우리 소켓 프로그램을 다 한 다음에 좀 이론 시간에 대해서 이론을 할 때 좀 더 깊이 알아볼 내용이니까 , 일단은, 간단하게 그냥 IP 주소다라는 것만 , 일단은, 생각을 해주시면 되겠습니다 IP 주소에 대한 기념은 어렴풋 다들 알고 계실 거라고 생각을 해요 영화를 보거나 드라마를 보면 IP 주소로 접근을 하고 해킹하고 이런 장면이 있으니까 그런 부분은 어느 정도 이해가 가실 거라고 생각을 하고 그래서 이 IP 주소 어떤 걸 사용할지를 정해주는데 기본적으로 이 AFINET이라고 하는 게 IPv4를 이용하는 것이다라는 걸 알 수 있는 거죠 그리고 굉장히 다른 애들도 많다는 걸 볼 수 있는데 저도 나머지 애들은 사용해본 적이 없습니다 , 자, 그리고 두번째로 타입이라는 것도 정해줘야 되는데 요같은 경우에는 이제 소위 말해서 우리가 TCP로 통신할지 UDP로 통신할지를 이제 골라주게 됩니다 이제 이게 굉장히 중요한 차이를 보이게 돼요 그런데 이것도 역시나 조금 나중에 더 깊이 다룰 문제여 가지고 그냥 뭐 스킵을 할 건데 기본적으로 우리는 tcp 로 이제 앞으로 쭉 만들게 될 거에요 mmorpg 에서는 특히나 한국에서는 거의 다 tcp 로 만드는데 tcp 같은 경우에는 그냥 한 줄 요약을 하자면 좀 통신을 안전하게 해줍니다 그래가지고 만약에 중간에 통신을 하다가 패킷이 유실되었으면 그거를 TCP 프로토콜 단계에서 우리가 따로 처리해주지 않아도 다시 재전송을 하고 그 다음에 뭔가 데이터가 오염이 되지 않았는지도 체크해주고 하는 그런 추가적인 기능이 있어요 반면 UDP라는 애는 그냥 무조건 재빨리 막 보내는 거에 핵심이 맞춰져 있고 그러다 보니까 중간에 패킷이 유실되거나 하는 문제는 전혀 처리를 해주지 않습니다 진짜 완전 퀵 서비스라고 볼 수가 있는 거죠 그런 약간 미세한 차이가 있는데 어쨌든 우리는 TCP를 사용할 것이기 때문에 속 스트림이라는 걸 사용해 줄 것이고 만약에 UDP 서버를 만들게 되면 이 두 번째 옵션을 이 D-Gram이라는 애로 바꿔주면 되겠습니다 그 다음에 마지막 인자는 프로토콜에 입력을 하는 건데 얘는 그냥 0으로 일단 우리는 세팅을 해주면 돼요 여기 나와 있는 바와 같이 0으로 입력하면 그냥 네가 알아서 정해주세요 라는 우리가 옵션을 주고 있는 건데 어차피 우리가 이 윗버전에서 IPv4 버전으로 TCP를 사용하겠다고 했으면 프로토콜은 굳이 정해주지 않아도 이미 , 사실, 한 가지 케이스밖에 없기 때문에 굳이 여기다가 모순적인 다른 애를 입력하는 실수를 하기보다는 그냥 0으로 입력하면 얘가 알아서 골라주게 됩니다 뭐 여기까지 , 일단은, 소켓을 만드는 그런 간단한 함수에 대해서 알아봤어요 , 자, 그래서 결국에는 간단하게 적어 드리자면 얘가 주소체계 address family를 입력을 할 것이고 afinet 이라는게 ip v4 그리고 6번이 ipv6 라고 , 일단은, 요약을 할 수가 있고 소켓 타입 얘가 이제 소켓 타입이 되는데 tcp 혹은 UDP 중을 , 일단은, 기본적으로 하나를 골라준다 라고 , 일단은, 요약할 수 있고 마지막 프로토콜은 그냥 0을 입력하면 된다 그럼 이제 알아서 골라준다 라고 , 일단은, 결론을 내릴 수가 있겠습니다 그 다음에 마지막으로 얘가 리턴하는 값이 소켓 데스크립터라는 걸 이제 뱉어주게 되는데 , 자, 이거는 일단 좀 이어서 알아보도록 할게요 결국에는 af inet 그 다음에 속 stream 그리고 0 , 이렇게, 입력을 해주면 되고 여기서 socket 이라는 아이를 뱉어주고 있습니다 그럼 얘를 이제 받아와야 되겠죠 클라이언트 소켓이라고 , 이렇게, 해보도록 합시다 근데 요 소켓이라는 것 자체가 여기 보면은 그냥 uint라는 걸 볼 수가 있어요 그냥 정수 하나에 불과합니다 근데 이 정수를 이용해가지고 뭘 할 수 있냐면은 나중에 우리가 운영체제한테 야 요 소켓번호 몇번 몇번에 해당해서 우리가 데이터를 보내고 싶어라고 하면은 운영체제가 찰떡같이 알아들어가지고 그 번호에 해당하는 소켓 리소스를 이용해가지고 어 실제로 우리가 원하는 그 리소스를 이용해가지고 이제 작업을 할 수 있게 돼요. 그러니까 이건 말 그대로 어떻게 보면 번호 같은 거죠. 우리가 구분할 수 있는 그런 번호를 이용해가지고 이제 운영체제한테 요청을 할 때 요 번호로 요 소켓을 대상으로 뭔가를 해달라고 요청을 한다라고 일단 볼 수가 있는 거예요. 왜냐면 우리는 어차피 다 유저 레벨이다 보니까 여기서 뭔가 우리가 중요한 거를 직접 건드릴 순 없고 항상 운영체제를 통해 가지고 커널 레벨에다가 요청을 하는 식으로 이제 작업을 하게 되기 때문에 이런 식으로 디스크립터라고 해가지고 그냥 일종의 정수를 받아가지고 사용한다라고 볼 수가 있는 거죠 요 정수가 사실상 뭔가 포인터처럼 실제 그 리소스를 가리키고 있는 그런 상태로 일단 생활해주시면 되겠습니다 , 자, 그 다음에 여기가 만약에 혹시라도 실패했다 라고 하면은 invalid socket 이라는 걸로 이제 체크를 할 수가 있구요 이런 식으로 뭔가 잘못 일어났을 때 대한 처리를 한두 번씩 해주면 좋습니다 만약에 실패했다고 하면은 여기서 공통적으로 wsa get last error 라는 걸 이용해가지고 어떤 이유로 우리가 방금 요청한게 실패했는지를 요 에러 메세지를 받아줄 수가 있습니다 요 에러 코드를 그래서 나중에 가면은 이제 이 에러 코드를 보고 어떤 상황에 의해가지고 우리가 뭐 요구한게 실패했는지 등등을 여기서 찍어볼 수가 있어요 그래서 뭐 하는 김에 소켓 에러 코드는 얼마였다 에러 코드는 에러 코드라고 요렇게 한번 쳐보도록 할게요 그 다음에 뭐 , 사실, 여기서 뭐 실패할 일은 , 사실, 거의 없긴 한데 그냥 안전빵으로 , 이렇게, 일단 만들어 주도록 하겠습니다. 그래서 앞으로 이제 요 소켓이라는 아이를 이용해 가지고 우리가 뭐 연결을 하고 전송 데이터도 전송하고 한다라고 일단 볼 수가 있는 거죠. 한마디로 그냥 얘가 이제 우리의 단말기다라고 일단 쉽게 생각할 수가 있겠습니다. , 자, 그리고 그 다음에 다음 순서로 이제 전화기가 준비가 되었으니까 그 다음에 하는 건 뭐냐면은 우리가 식당에 전화를 하기 위해서 식당 번호를 이제 여기다가 기입을 해가지고 연락을 해주면 되겠죠 , 사실, 어... 우리 핸드폰에 이제 그 번호를 기입한다기 보다는 그 전화를 걸기 위해서 그 번호를 이제 우리가 핸드폰에 입력한다는 표현이 좀 더 맞을 것 같네요 근데 그러려면 어찌됐건 상대방의 그 전화번호 자체를 표현해가지고 그 아이를 이용해가지고 전화를 걸어야 된다고 볼 수가 있겠습니다. , 자, 그래가지고 , 일단은, 목적지 주소를 , 이렇게, 만들어줄건데 얘는 SOCK ADDRESS UNDERBAR IN 이라는걸 일단 이용을 할거에요. , 자, 이게 조금 복잡한데 이어서 좀 설명을 드릴거고 얘는 참고로 이제 우리가 이 버전 4를 이용할 때 요 아이를 사용하고 IPv6라고 하면은 이제 다른 버전을 이용하게 됩니다. , 일단은, 다 통일해가지고 , 이렇게, 만들거고 , 일단은, 이 구조체를, 초기화를 한번 0으로 쫙 밀어주도록 할게요. memset이라고 해가지고 여기는 내용물을 다 0으로 쫙 밀어주겠다라는 이거는 약간 네트워크 쪽이 아니라 그냥 C에서 제공하는 그런 함수고 , 자, 그 다음에 이 구조체가 조금 생각보다 복잡하게 되어 있어요. , 일단은, 코드를 먼저 작업한 다음에 분석하는 게 조금 나을 것 같아가지고 , 자, 여기 딱 찍어도 뭔가 굉장히 채울게 많은데 scene-family는 afi-net 이거를 똑같이 입력을 해주면 되고 얘가 아까 위에서도 소켓을 만들 때 넣어줬던 이 address-family를 그대로 넣어주고 있습니다 그 다음에 여기다가 추가적으로 server-address에 여기서 이제 좀 잘 쳐야 되는데 sn-address.sunderbar-addr 이라고 친 다음에 inet-address , 이렇게, 일단은, 따라 쳐 보시도록 할게요 1.2 127 001 , 이렇게, 일단 만들어 볼 것이고 그 다음에 씬포트는 h2ns 7777 일단 , 이렇게, 만들고 이걸 분석을 해드리도록 할게요 여기다가 일단 타고 들어가서 요 아이를 살펴보면은 일단 얘가 address family라는 걸 받아주고 있구요 씬포트 address , 이렇게, 일단 3가지를 채워주게 될 거고 얘는 사용을 안하기 때문에 그냥 0으로 쫙 밀어주면 됩니다 그 다음에 얘는 그냥 unsigned short이다 보니까 얘는 뭐 설명할 게 없을 것 같고 이 address family는 아까 우리가 본 그 주소 체계를 입력하면 되는 거니까 얘도 뭐 딱히 신경 쓸 게 없고 그 다음에 in address라는 게 있습니다 얘도 이제 타고 가서 살펴보면은 좀 복잡하게 되어 있는데 union 문법이 또 등장을 하는데 결국에는 얘가 하고 싶은 말은 unsigned long이라고 , 일단은, 되어 있는 게 이거 이거 자체만 채워주면 되는데 이거를 더 정밀하게 채우기 위해서 , 이렇게, 캐릭터 단위로 즉 byte 단위로 , 이렇게, 하나씩 하나씩 접근해 가지고도 보여주고 있고 아니면은 short 단위로 이런 식으로 2byte 2byte씩 끊어 가지고 보여주기도 한다는 걸 알 수가 있는 거죠 하지만 결국에는 얘는 그냥 new long 하나다 그냥 4byte짜리 정수다라는 걸 우리가 , 일단은, 알 수가 있습니다 그래서 생각보다 어려운 내용은 아니었고 , 이렇게, 정보를 채워가지고 넣어주면 된다라는 걸 일단 알 수가 있었는데 그 다음에 이제 설명을 해야 될 것은 뭐냐면은 여기서 , 이렇게, 변환하는 함수가 여러가지가 있다는 걸 우리가 알 수가 있어요 여기서는 결국에는 얘가 내부적으로 받아주는 거는 결국에는 어떤 4바이트 정수를 받아줘야 되는데 우리가 소위 IP를 표현할 때는 정수로 표현하면 우리가 이해하기가 굉장히 힘드니까 1바이트씩 끊어가지고 1바이트 1바이트 1바이트 끊어가지고 127 001 이런 식으로 , 일단은, 통상적으로 많이 표현을 합니다 아까 우리가 CMD에서 ipconfig을 쳐서 알아본 그 주소도 , 이렇게, 문자열 형식으로 나와 있었죠 그래서 걔를 변환하는 함수가 요 버전이라고 일단 보시면 되는 건데 근데 이게 약간 슬픈게 이 상태에서 빌드를 하면은 요 inetaddr 이라는 요 함수가 너무 구식이어가지고 사용하지 말라 즉 deprecated 라고 경고 메시지가 뜹니다 그래서 이거를 뭐 조금 더 현대적인 그리고 이제 좀 잘 통과되는 버전으로 바꿔보자면 얘를 요렇게 바꿔주시면 돼요. inet p2n af inet 그 다음에 127.0.0.1 그 다음에 여기다가 주소를 서버 어드레스에 scene 어드레스를 요렇게 넣어주는 버전으로 바꿔주시면 되겠습니다. 이거는 이제 책에 보통 요렇게 나와있는데 요게 이제 좀 더 현대적인 버전이다라고 일단 생각해주시면 되겠어요. , 자, 그건 그렇고 여기 있는 주소 자체가 여러분들의 환경에서는 그럼 다른 주소를 입력해야 되는 거 아니냐 물론 이제 그럴 확률도 있기는 한데 이게 127 001이 기본적으로 루프백 주소라고 해가지고 그냥 한마디로 표현하면 여러분들의 스스로 컴퓨터에 다시 요청을 보내는 그런 느낌이라고 보시는 데 있습니다 스스로한테 그렇기 때문에 우리가 테스트할 때는 클라랑 서버를 같은 컴퓨터에서 띄워가지고 테스트할 것이기 때문에 그냥 그대로 127.0.0.1을 입력해가지고 접근을 하면은 여러분들이 사용하는 그 컴퓨터에 똑같이 붙게 되기 때문에 아무런 문제 없이 테스트할 수 있어요 만약에 그게 아니라 나중에 진짜 온라인 게임을 배포하게 되면은 이 주소가 실질적으로 여러분들이 서버를 실행하는 그 주소로 박아줘야 되겠습니다 물론 주소를 그냥 하드코딩에서 박아주는 건 조금 안 좋은 거고 나중에 가면 DNS라는 걸 이용해가지고 주소를 이용해가지고 그 IP를 찾아주는 방법을 이용해야 됩니다 예를 들면 우리가 막 요런 네이버라는 요 아이를 이용해가지고 DNS 서버를 이용해가지고 얘가 뭐 해당하는 주소를 막 찾아주게끔 유도를 해줘야 되는데 이것도 역시나 이론 시간에 다룰 내용이니까 , 일단은, 토스가 그냥 넘어가도록 하고 , 일단은, 주소를 여기다가 박는다라는 것만 일단 이해를 해주시면 되겠어요 그 다음에 마지막으로 여기다가 포트를 정해주는데 포트는 포트가 창구라는 그런 영어 단어... 항구라는 단어가 있죠? 말 그대로 어떤 의미의 번호를 지정해주면 됩니다 근데 이 번호가 그냥 아무 번호는 아니고 나중에 서버를 띄워줄 때도 이 똑같은 포트 번호를 지정해주게 될 거예요 그러니까 한마디로 연결할 목적지는 어디냐라는 질문을 했을 때 IP 주소랑 포트가 어떻게 보면 한 쌍이라고 볼 수가 있는 거죠 이게 약간 이런 느낌입니다 어디어디아파트 몇몇호 요렇게 우리가 주소를 표현하는 것처럼 어디어디라는게 IP주소고 거기서 몇몇호라는게 포트라고 생각하시면 되겠어요 그래서 이 두 개가 반드시 일치해야지만 붙을 수 있는 거고 포트 번호가 만약에 다르다고 하면은 이제 접근을 할 수가 없게 되겠습니다. 그래서 이 포트라는 것과 이제 굉장히 중요하게 서버 쪽에서 열어준 포트로 동일한 포트로 이제 접근을 해야 된다. 그리고 참고로 모든 번호를 다 사용할 수 있는 건 아니고 예를 들면은 80번은 보통 이제 웹통신, HTTP 통신을 위해서 예약이 되어 있는 등 이게 일부 번호는 특정 목적에 따라 가지고 이제 예약이 되어 있는 경우가 많기 때문에 조금 더 상의 그런 본들 진짜 안겨칠 것 같은 애들을 몇천 번 때를 이용하는 게 조금 더 좋습니다 그래서 이 번호를 일단 저는 777이라는 걸 좋아해서 이 번호로 일단 사용을 해보도록 할 거예요 IP 주소 그리고 포트 번호 , 자, 이렇게, 해가지고 연결할 목적지는 , 이렇게, 찍어 줬고요 이제 목적지가 결정이 된 거고 아 그리고 한 가지 말씀을 안 드렸는데 H2NS는 뭐하는 것이냐 , 자, 이거는 뭐하는 거냐면요 h라는 게 호스트를 의미하는 거고 n이 네트워크를 의미하는 겁니다 그래서 얘가 host to network short라는 걸 의미하는데 이거는 왜 굳이 그냥 777을 바로 넣어주면 안 되고 얘를 호출해서 넣어주냐면 이게 엔디언 이슈가 있습니다 엔디언 이슈? 원래 엔디언이라고 해가지고 우리가 숫자를 저장할 때 두 가지 방법이 있어요 little-endian과 big-endian , 이렇게, 두 가지가 있는데 어떤 숫자가 있다고 가정해볼게요 1, 2, 3, 4, 5, 6, 7, 8 이라는 16진수 숫자가 있다고 가정했을 때 얘가 4바이트 정수죠 그런데 이거를 저장하는 방식이 , 이렇게, 7, 8부터 5, 6 그 다음에 3, 4 1, 2 요렇게 저장하는 방식이 하나가 있구요 이게 로우 어드레스부터 높은 주소라고 가정하면 요렇게 하는게 있고 두번째 방법은 이걸 거꾸로 뒤집어가지고 그냥 순서대로 1, 2, 3, 4 5, 6, 7, 8 , 이렇게, 저장하는 방식이 있습니다 , 이렇게, 두 가지 다른 방법이 각기 있는데 얘가 리틀 엔디언이고 얘가 빅 엔디언이라고 , 일단은, 볼 수가 있는 거예요 근데 이거는 딱히 어떤 게 더 낫다라는 건 없는 거고 여러분들이 사용하는 CPU에 따라 가지고 어떤 애는 리틀 엔디언이고 어떤 애는 빅 엔디언 환경으로 동작합니다 근데 물론 요즘 대부분의 모바일 기기나 컴퓨터 같은 PC 같은 경우에는 이 리틀 엔디언을 사용할 거예요 인텔 칩 같은 걸 사용하시면 무조건 리틀 엔디언인데 그러면 나는 리트랜딩을 사용할 것이니까 뭐 그냥 무조건 리트랜딩을 사용하면 되느냐 그건 또 아닙니다 왜냐면은 만약에 나는 요 방식으로 표현하는데 받아주는 상대방 기기 측에서는 다른 방식으로 받아주면은 서로 생각하는 데이터가 완전히 다르게 되겠죠 그러니까 둘 중 하나를 정해가지고 우리가 이제 사용을 무조건 해야 되는데 어 네트워크에서 사용하는 표준은 요 아랫방식인 빅엔디언 방식을 표준으로 생각합니다 이게 왜 중요하냐면은 우리가 넣어준 요 포트를 이용해가지고 나중에 중간중간에 라우터라거나 이런저런 네트워크를 보내주는 걸 담당하는 장치들도 얘네들을 참고해가지고 그 주소로 뭔가를 보내주고 하는 식으로 동작을 해야 되는데 걔네들도 마찬가지로 기기다 보니까 이 두가지 방식 중 하나를 골라가지고 사용을 하도록 되어 있다는 얘기가 되는 거죠 그래가지고 한가지 정책을 골라가지고 그걸 일관성 있게 우리가 사용하는데 어쨌든 요 네트워크 상에서 사용하는 공식적인 규칙은 이제 빅 엔디언으로 보내는 것이기 때문에 얘를 네트워크 방식으로 요 빅 엔디언으로 일단 바꿔줘야 됩니다 그래가지고 그거를 호스트는 여러분들의 컴퓨터를 말하는 거고 호스트에서 네트워크 방식의 엔디언으로 맞춰주겠다라는 함수가 요렇게 , 일단은, 실행이 된다라고 보시면 되겠어요 그래가지고 실질적으로 제 컴퓨터에서는 만약에 , 이렇게, 얘를 입력을 하면 순서를 뒤바꿔줘가지고 원래 , 이렇게, 됐던 걸 뒤바꿔줘서 이 형식으로 일단 절정해 주게 될 겁니다. 이건 뭐 궁금하시면 진짜 뭐 해보셔도 돼요. 예를 들면 여기다가 뭐 이런 식으로 어떤 숫자가 있는데 1, 2, 3, 4, 5, 6, 7, 8 이런 숫자가 있다고 가정을 하고 여기다 브레이크 포인트를 잡아가지고 일단 얘를 실행해 보도록 할게요. 이거 지금 서버가 실행된 것 같은데. 아 둘 다 켜놨죠 네 , 이렇게, 해서 실행이 된 상태에서 여기 넘버가 딱 잡혔는데 여기다가 위에서 넘버를 보여달라고 하면은 , 자, 이게 어떻게 됐나요 지금 7 8 5 6 3 4 1 2 순으로 잡혀있다는 거 볼 수가 있습니다 얘가 작은 주소에서 큰 주소로 넘어가는데 지금 딱 요 상태로 지금 저장이 되어 있고 그렇다는 건 제 환경이 리틀 엔디언이라는 걸 확실히 알 수가 있는 거죠 , 이렇게, 일단 테스트를 해볼 수가 있어요 이걸 뒤집어져서 저장을 해줘서 네트워크에 맞는 이 빅 엔디언으로 바꿔주겠다라는 부분을 이제 h2ns라고 하고 있는 거죠 host to network short 그래서 이런 함수들은 외울 필요가 없고 host랑 network short , 이렇게, 의미를 파악을 하면 얘가 굉장히 분석하기가 쉽습니다 그리고 당연한 얘기지만 이제 반대 버전도 있어요 네트워크에서 host의 short로 변환한다고 하는 식으로 다른 이랜들의 함수도 굉장히 많이 존재하고요 얘가 s가 아니라 뭐 얘가 뭐 끝에 L로 끝난다고 하면은 호스트드 네트워크 롱 이런 식으로 그 의미만 파악을 하면 얘는 이제 어떤 의미인지 쉽게 분석이 가능합니다 , 자, 이렇게, 가지고 네트워크 목적지를 만드는 함수를 , 이렇게, 일단은, 설명을 해봤구요 그 다음에 이제 해야 되는 거는 주소가 정해졌으니까 그 주소로 전화를 걸어야 되겠죠 , 자, 전화를 걸기 위해서는 이제 커넥트라는 함수를 이용하게 되는데 여기다가 소켓을 넣어줄 것이고 어떤 핸드폰으로 내가 전화를 건다 라는 의미를 일단 생각해 줍시다. 그 다음에 두번째 인자로 소켓 어드레스 즉 우리가 전화를 걸 대상을 이제 두번째 인자로 받아주고 있습니다. 그래서 여기다가 소켓 어드레스 에고 소켓 ADDR 포인터로 아 쏘크 아드레스네요. 네 이겁니다. 죄송합니다. 서버 어드레스를 , 이렇게, 두 번째로 넣어주고 사이즈 오브 서버 어드레스 , 이렇게, 세 번째로 , 이렇게, 만들어주면 되겠습니다 Connect 같은 경우에도 얘는 직관적인데 얘는 왜 굳이 우리가 , 이렇게, 만들어 준 걸 다시 캐스팅해 가지고 만들어 주는가 싶죠 Connect가 , 일단은, 그렇게 되어 있습니다 소켓 어드레스 타입의 포인터를 받고 있고 우리가 지금 얘는 IPv4를 채우기 위해서 이 구조체를 이용해 가지고 만들어 주는데 아시다시피 우리가 IPv4 뿐만 아니라 굉장히 다양한 주소 체계를 이용해 가지고 소켓을 만들어 줄 수가 있었죠 그러다 보니까 얘가 꼭 이 타입만 받아주는 것은 아니기 때문에 이런 식으로 두 개의 인자를 따로 받아가지고 내가 지금 넣어줄 그 주소 체계에 맞는 주소를 , 이렇게, 지금 받아주고 있다고 보시면 되겠어요. 그래서 , 이렇게, 캐스팅을 해준 다음에 넣어주는 것도 있고 그 다음에 사이즈옵을 이용해가지고 이 크기를 같이 넣어줘야 된다고 보시면 되겠습니다. 이 부분도 역시나 커넥트를 보면은 친절하게 나와 있어요 소켓을 받아주고 무언 무엇을 해줘야 된다라고 , 이렇게, 쭉 살펴보시면 시간이 나실 때 지금 당장 안 해도 되지만 언젠가 시간이 나실 때 쭉 읽어보시면 , 일단은, 도움이 되겠습니다 그리고 깨알같이 샘플 코드도 있으니까 기억이 안 날 때는 , 이렇게, 샘플 코드를 보고 오시면 되겠어요 그래서 커넥트를 해줄 것인데 얘도 마찬가지로 연결을 시도했는데 만약에 실패했으면 소켓이 내려가 뜰 텐데 여기서 소켓 에러가 떴다는 건 뭔가 이제 어떤 상황에 의해 가지고 문제가 일어났다는 얘기가 되는 거고 그럴 때는 역시나 깨알같이 요 코드를 복붙 해가지고 커넥트가 왜 실패했는지를 커넥트 에러 코드를 출력을 하고 종료를 해보도록 할게요 물론 더 깔끔하게 하려면 여기서도 ws-cleanup 등등을 여기다가 넣어주긴 해야 되는데 뭐 거기까지는 , 일단은, 챙기지 않을 것이고 여기까지 해가지고 일단 통과가 되었다고 하면은 이제 굉장히 행복한 상황이 된 거죠 연거리 성공했다 이제부터 데이터 송수신이 가능하다라는 얘기가 되는 거예요 그래서 나중에 게임을 만들게 되면은 , 이렇게, 커넥트가 성공했다고 하면은 이제 여기서 막 데이터를 보내주고 뭐 게임을 진행하는 식으로 뭔가를 이제 진행을 해주면 되겠죠? 근데 우리는 지금은 그럴 단계는 아니니까 간략하게 Connected to Server 라고 , 이렇게, 로그를 하나를 찍어 보도록 합시다 그 다음에 여기서 와일트롤 해가지고 나중에는 여기서 뭐 데이터를 전송하거나 하는 거를 해야 된다고 일단 볼 수가 있는 거죠 이런 식으로 네 디스스레드 아이고 3 4 , 자, 그리고 마지막으로 어 이것도 약간 뭐 약간 너무 디테일한 부분이지만 소켓을 만약에 다 사용했으면은 얘도 마찬가지로 우리가 WS 클린랩을 해가지고 우리가 처음에 초기였던 거를 좀 정리해 준 것과 마찬가지로 얘도 이런 식으로 클로즈 소켓을 통해 가지고 요 소켓을 다 사용했으니까 정리해달라고 운영체제한테 요청을 해줘야 됩니다 이게 좀 깔끔하게 정리하는 그런 방법인거죠 소켓 리소스 반환 그리고 얘는 이제 윈속 종료 라고 보시면 되겠어요 원칙상으로는 WS의 스타트업이 호출된 수만큼 얘도 똑같이 호출을 해줘야 됩니다 이런저런 이유로 만약에 요 함수가 뭐 3번 호출이 되었으면 얘도 원래 3번을 호출해야지 맞기는 한데 이거는 딱히 안 지킨다고 해도 뭐 우리 뭐 컴퓨터가 망가지거나 하지는 않아요 그냥 권고사항입니다 그래 , 이렇게, 해가지고 , 일단은, 클라이 조금 완성이 된 거예요 되게 뭔가 머리가 복잡하죠? 저도 이제 성향이 좀 완벽주의여가지고 모든 걸 다 완벽히 이해하고 넘어가자는 주의였는데 그래가지고 처음에 , 이렇게, 소켓 프로그램을 공부할 때 굉장히 좀 찝찝했어요 너무 함수가 막 등장하다 보니까 정신이 없고 내가 잘 이해하는 게 맞는지 막 의심을 갖기 시작했죠 다시 말씀을 드리지만 어차피 이 분야가 분야인지라 이런 함수 단위로 진짜 세분화해가지고 다 이해를 할 필요가 없고 전체적인 큰 흐름만 이제 이해를 하시면 진짜 됩니다 그래가지고 아까 제가 PPT로 보여드렸던 이제 고객 입장에서 접근하는 그 순서를 공공히 생각해주면 지금 순서가 다 지켜져 있다는 거 볼 수가 있습니다 전화기를 만들고 연결할 목적지를 찍어가지고 그 다음에 전화를 건다 그러면 전화가 만약 상대방이 전화를 받았으면 여기부터 이제 연결이 성공이 된거죠 그래서 이렇게까지 , 일단은, 클라쪽을 만들어 봤고 근데 얘를 이제 테스트하기 위해서는 얘를 빌드해가지고 빌드 통과한다고 해서 뭐 실행해봤자 , 사실, 더이상 진행이 이제 안될겁니다 애당초 여기서 커넥트를 한 다음에 누군가가 전화를 받아줘야지만 얘가 성공을 해가지고 받아줄 수 있다는 얘기가 되는거고 그렇지 않다면 여기서 뭔가 에러코드를 뱉어주면서 얘가 끝나게 되겠죠 , 자, 그래가지고 반대쪽에 넘어가서 서버 쪽도 작업을 할 건데 서버 쪽은 조금 더 내용이 복잡하다고 일단 말씀을 드렸습니다 근데 이제 겹치는 내용도 굉장히 많아요 , 일단은, 여기 윈속 초교화를 하고 그 다음에 윈속 종료를 하는 부분은 똑같이 들어갑니다 이거는 공통적으로 윈속을 사용할 때 공통적으로 들어가는 부분이고요 그 다음에 여기서 우리가 소켓을 만들어주는 부분이 , 이렇게, 들어갔는데 얘도 굉장히 유사하게 , 일단은, 복붙을 하고 이 이름만 클라이언트 소켓이 아니라 리슨 소켓이라고 바꿔주도록 할게요 이 부분이 다시 상기를 해보면 이제 우리가 식당을 운영을 할 때 먼저 문직이라고 해야 되나요? 상담을 받아주는 안내원을 고용을 해가지고 그 안내원한테 우리가 핸드폰을 딱 쥐어 줬었죠 근데 그 핸드폰은 아무 핸드폰은 아니라 이제 회사에 그 공식 대표 번호가 찍힌 그 핸드폰을 우리가 건네줘야 되는데 그 부분을 지금 만들고 있다고 보시면 되겠습니다 일단 어찌됐건 핸드폰이 있어야 되긴 하니까 그 핸드폰을 만들어 주고 있다라고 똑같이 이 소켓 stream으로 , 이렇게, 만들어 주고 있는 상태라고 볼 수가 있는 거죠 , 자, 그 다음에 여기서 소켓이 , 일단은, 만들어질 것이고 그 다음에 연결할 목적지를 원래 우리가 요런식으로 클라이언트 쪽에서는 작업을 했는데 이제는 연결할 목적지가 아니라 나에 대한 즉 회사의 주소를 여기다가 찍어줘야 되겠죠 살짝 달라집니다 그래가지고 여기서 IF인해까지 설정하는 건 똑같은데 그 다음에 살짝 뭐 이렇게도 상관없긴 한데 좀 바뀌어야 될 부분은 요 부분을 좀 수정을 해보도록 할게요 , 자, 여기서 얘를 h2nl 이라고 해가지고 in address n 이라는걸로 얘를 바꿔치기 해주도록 할거고 얘가 뭘 의미하는 거냐면 그냥 니가 알아서 골라줘 라는 의미를 하고 있는 겁니다 이걸 왜 , 이렇게, 하면 편하냐면은 만약에 우리가 이런식으로 우리가 진짜로 사용할 이 주소를 그냥 하드코딩 해가지고 딱 집어 넣는다고 하면은 만약에 우리가 네트워크 카드가 여러개여가지고 주소가 여러개가 있다고 하면은 딱 우리가 지정한 그 주소로만 연결이 될 거예요. 예를 들면 우리가 127.001로 만약에 얘를 세팅했다고 하면은 그 주소로만 연결이 될 텐데 그게 아니라 , 이렇게, 알아서 해주라고 하면은 사실상 이론적으로 말이 되는 그런 모든 주소가 다 연결이 되어가지고 뭐 이런식으로 루프백 주소로도 연결이 될 것이고 아까 제가 ipconfig에서 찾아본 그 주소로도 연결이 될 것이고 하는 식으로 좀 유동적으로 이제 동작을 하게 됩니다. 서버를 띄워줄 때는 일단 요렇게 세팅을 해주도록 할게요 , 자, 그리고 어... 그 다음에 이제 이어서 해야 될 거는 이 연결할 목적지가 아니라 이건 나의 목적지죠 나의 주소는 이제 회사의 대표 주소는 무엇이냐를 요렇게 알아낸 것이고 , 자, 그 다음에 이어가지고 우리가 안내원의 폰을 개통을 시켜준 다음에 얘가 실제로 식장의 그 대표 번호라고 제가 말씀을 드린 그 부분을 연결해줄 것이고 그걸 바인드라는 함수로 연동을 시켜준다고 했었죠 바인드랄 때는 이제 약간 모양이 굉장히 뭐 좀 어느 정도 유사하게 만들어지는데 소켓이랑 소켓 어드레스를 , 이렇게, 두 개를 받아주고 있다는 걸 볼 수가 있습니다 그래서 얘도 마찬가지로 리슨 소켓을 , 이렇게, 넣어 줘 가지고 요 소켓에서가 요 주소를 묶어주겠다 바인딩을 해주겠다라는 부분이 실행이 될 것이고 얘도 마찬가지로 소켓 어드레스 포인터를 받아주고 있고요 서버 어드레스를 넣어준 다음에 사이즈 오브 서버 어드레스로 우리가 만든 구조체 크기를 그대로 , 이렇게, 넣어주면은 이제 요 소켓이랑 이 주소가 딱 연동이 된 거라고 보시면 되겠습니다 전화번호를 이제 연동시켜 준 거죠 그리고 얘도 만약에 실패했다 소켓 에러가 떴다고 하면은 뭔가가 문제가 있는 상황이니까 깨알같은 로그를 , 이렇게, 찍어보고 얘도 바인드 에러 코드라고 , 이렇게, 안내 메시지를 찍어 보도록 하고 근데 여기까지는 어지간해서 실패하지는 않을 거예요 그냥 얘는 우리가 만들어준 소켓에다가 번호를 연동하는 부분이 실행이 된 거고 그 다음에 이제 영업을 시작해야 되겠죠 그 다음 순서 영업 시작 영업을 시작하기 위해서는 listen이라는 함수를 이용해주게 되는데 listen에서 역시나 이 socket을 입력해준 다음에 backlog라는 걸 입력을 해주는데 얘는 그냥 어떤 정수를 입력해주면 됩니다 이 backlog라는 게 뭘 하는 거냐면은 우리가 예를 들면 식당에 갔는데 일단 식당에 자리가 없다고 할 때 대기열이 생기겠죠 그래서 어... 대기열이 생겨가지고 그 대기열에 우리가 대기한 순서대로 자리가 나면 바로 입장할 수가 있을텐데 그 대기라는 것도 무한대로 막 늘릴 순 없겠죠 보통 어느정도 한 10자리 10팀만 더 추가적으로 대기를 할 수 있다고 우리가 정책을 지정해주게 되면은 10팀이 넘어가가지고 막 11번째 12번째 13번이 온다고 하면은 더이상 자리가 없기 때문에 애당초 들어오지 못하게 그냥 바로 끊어버릴 겁니다 그래서 얘는 말 그대로 그 대기열에 최대 한도라고 , 일단은, 생각을 하실 수가 있겠어요 그리고 이거는 뭐 , 사실, 나중에 가면 꽤 큰 숫자로 바꾸게 되는데 이런저런 테스트를 통해 가지고 그 테스트에서 적당한 값을 나중에 골라주게 될 겁니다 근데 지금은 뭐 그냥 간단하게 아무 숫자나 10이라는 숫자로 일단 입력할 것이고 어차피 우린 지금 1대1로 테스트를 하고 있기 때문에 뭐 아무런 상관이 없다고 일단 생각하시면 되겠어요 그래서 리슨을 해 줘 가지고 영업을 시작한다 라는 부분이 여기 들어가는 거고 얘도 마찬가지로 소켓 에러가 떴다고 하면은 뭔가 어떤 이유로 인해 가지고 실패한 거니까 복붙해 가지고 여기다가 에러 코드를 찍어 보도록 하겠습니다 , 자, 그럼 여기까지 왔으면은 얘도 조금 단계가 더 길었지만 얘도 여기까지 왔으면은 , 일단은, 사실상 영업을 시작하고 있는 상태입니다 그래가지고 누군가가 요 상태에서 커넥트를 요청해가지고 나한테 붙었다고 하면은 걔를 이제 처리를 해줄 준비가 완전히 끝났다고 볼 수가 있는 거예요 그래가지고 뭐 이런 식으로 계속 무한 루프를 돌면서 손님이 올 때까지 막 처리를 해주고 이런 부분을 여기다가 이제 넣어주면 되는데 이때는 accept라는 함수를 이용하게 됩니다 손님이 문의를 해줬으면 걔 손님에 대한 처리를 해주겠다 , 자, 그래가지고 여기다가 리슨소켓을 넣어주고 , 자, 그 다음이 중요한데 여기서 어떤 주소를 받고 있습니다 어? 주소를 받고 있으면은 아까 요조수를 의미하는 건가? 하는 건가? 근데 이 주소는 아니에요 여기서 이제 사용할 주소는 뭐냐면은 나한테 연결한 그 클라이언트가 있겠죠? 그 클라이언트의 주소를 지금 여기다가 받아주고 있는 겁니다 그래서 얘는 클라이언트 어드레스라고 , 이렇게, 이름을 바꿔주도록 할게요 만약에 우리가 MMO 기준으로 하면은 이 어드레스를 잘 관리해가지고 뭔가 너무 패킷을 이상하게 보내거나 이상한 짓거리를 하는 애들을 우리가 IP 밴을 때리고 싶다고 하면은 이 주소를 이용해가지고 이제 걔를 밴을 때려줘야 되는 얘기가 드는 거죠 얘도 나중에 중요하게 사용이 될 그런 정보니까 중요하게 어딘가에 관리를 해야 된다라는 얘기를 드리고 있는 거고 여기서 결국 받아주고 있는 게 속 address라는 걸 이용해가지고 이제 연결된 아이의 주소를 여기다가 return으로 받아줄 것입니다. 그 다음에 여기다가 추가적으로 얘는 좀 특이하게 이 두 번째로 우리가 넣어준 이 주소의 사이즈의 주소를 또 받아주고 있어요. 왠 짓거리인가 싶은데 결국에는 이 address 랜을 원래는 그냥 우리가 사이즈 오브를 했는데 얘를 한 번 더 걸쳐가지고 이 클라이언트 어드레스를 받아가지고 그 주소를 여기다가 , 이렇게, 넣어주면 일단 된다는 얘기가 되는 거죠 이런 부분도 역시나 살펴보면은 바인드랑 리슨, 억셉트가 순차적으로 제가 다 검색을 해본 부분을 , 이렇게, 보여드리고 있는 거고 이런 부분도 시간이 나실 때 한번 쭉 읽어보시면 도움이 됩니다 리슨도 마찬가지로 , 이렇게, 있고요 억셉트도 마찬가지로 다 , 이렇게, 있습니다 그래서 생각이 안 날 때 얘를 찾아보면 역시나 친절하게 다 지금 어떻게 사용해야 될지 이런 샘플 코드를 보면서 이제 사용하면 되는 거니까 이런 코드들은 역시나 절대로 외울 필요가 없다는 게 한 번 더 증명이 되는 거죠 그래서 BIND, LISTEN, ACCEPT 이 세 가지 순서로 지금 진행이 되고 있다라는 걸 일단 설명을 드리고 있는 겁니다 그래서 이 주소를 참고로 여기 두 개는 얘네들은 옵션입니다 넣어주지 않아도 일단 크게 상관은 없어요 우리가 이 주소가 뭔지 너무 궁금해가지고 얘를 추출하고 싶을 땐 , 이렇게, 넣어주면 되고 아니면 그냥 널로 밀어줘도 되긴 합니다 근데 이 억세트가 뱉어주는 게 중요한데 얘가 뱉어주는 게 바로 소켓이라는 애를 뱉어주고 있죠 클라이언트 소켓 얘도 이제 아까 본 그 소켓이랑 마찬가지인데 요 클라이언트 소켓이라는 걸 이용해가지고 얘가 사실상 클라이언트랑 연동이 된 그 단말기라고 제가 표현을 한 그 아이라고 일단 볼 수가 있는 거죠 대리인이 들고 있던 그 단말기가 여기서 자동으로 , 이렇게, 만들어지게 됩니다 그럼 이제 나중에 요 연결한 클라이언트랑 우리가 통신하고 싶다고 하면은 요 클라이언트 소켓을 이용해 가지고 데이터를 전송하면 되는 거고요 처음에 만들어준 요 리슨 소켓은 다시 말씀을 드리지만 얘는 뭔가 데이터를 주고받을 때 사용하는 게 아니라 말 그대로 문지기처럼 처음에 대표 번호로 연락을 하는 애의 그 연락을 받아줄 때만 사용하고 있는 앱니다 그래서 얘는 좀 별도로 있는 애고 실시간으로 억셉트가 끝날 때 우리가 클라이언트랑 연결이 되어 가지고 뭔가 패킷을 주고 받을 수 있는 소켓이 만들어진다는 이 흐름을 잘 이해를 하셔야 돼요 그리고 여기도 당연히 얘기지만 뭐 어떤 사유로 인해 가지고 Invalid socket이 떴다 뭔가 문제가 생겼다고 하면은 여기서도 똑같이 뭐 에러 코드를 찍어주면 좋겠죠 짜잔 하고 이런 식으로 Accept가 왠지 실패했어요 라고 할 수 있는 거고 , 자, 여기 통과했으면은 이제 뭐 손님이 입장한 상황이 되는 겁니다 손님 입장 그럼 이제 궁금하니까 그 사람의 IP를 찍어볼 건데 IP를 찍어볼 때 뭐 굉장히 여러가지 함수가 있는데 이것도 생각이 날 때 그냥 구글링을 해가지고 찾아보시면 되겠습니다 저도 외우고 있진 않아요 요 버전으로 일단 만들어 줄 것이고 , 자, 여기다가 ip 어드레스를 찍어보기 위해서 16바이트 , 일단은, 캐릭터 배열을 만들어놨구요 그 다음에 클라이언트 어드레스에 요 아이가 어 원래는 이제 문자열이 들어간게 아니라 정수가 들어가 있었죠 아까 우리가 살펴봤을 때 뭔가 굉장히 묘한 유어롱 4바이트짜리 정수가 하나가 들어가 있으니까 그거를 다시 우리가 알기 쉬운 문자열로 바꿔주는 그런 기능을 하는 함수라고 , 일단은, 보시면 되겠습니다 그래서 여기다가 ip-address랑 sizeof ip-address라고 해가지고 이 문자열을 , 이렇게, 넣어주면 얘가 끝나게 되면 여기가 채워지게 될 것이고 그러면 우리는 클라이언트가 접속했다 클라이언트 커넥티드 그리고 ip는 얼마얼마입니다 라고 , 일단은, 로고를 한번 찍어 보도록 할게요 엔딜라인 여기서 뭔가를 이어서 해주면 되겠죠 , 자, 이렇게, 해가지고 조금 내용이 길었는데 요거 만약에 에러가 나면은 그냥 제 코드를 다운받아가시고 좀 비교를 정밀 비교를 해보시면 되겠습니다 그래서 얘가 만약에 잘 실행이 됐다고 하면은 클라이언트가 붙어가지고 서버 쪽에서는 클라이언트가 입장했습니다 라는 로고가 뜰 것이고 클라이언트 쪽에서는 Connected to server라는 게 , 일단은, 생성이 되겠죠 요렇게만 , 일단은, 진행을 해보도록 할게요 , 자, 그래가지고 다시 한번 우클릭 속성에 가가지고 게임 서버랑 더미 클라이언트가 다 시작으로 되어있는 걸 확인하시고요 동시에 킬 것이고 그 다음에 경고 메시지가 뜨는데 제가 설명을 드리다가 얘를 L로 바꾼 다음에 바꿔치기를 다시 안 해놨네요 host-to-network-short 로 바꾸는게 맞으니까 얘는 s 로 하는게 맞습니다 그래서 요 부분은 h2n-s 가 되어야 된다고 보시면 되겠고 다시 한번 빌드를 해주도록 할게요. 빌드 빌드 빌드 해주면 이제 경고 메세지가 없어졌고 이 상태에서 F4를 눌러가지고 실행을 하면은 , 자, 이런 식으로 얘가 서버죠. 서버 쪽에서는 클라이언트 커넥티드 그 다음에 IP가 뜬 걸 볼 수 있는 거고 클라이언트 쪽에서도 커넥티드 투 서버라고 친절하게 서버에 연결을 성공했다라고 지금 , 이렇게, 안내해 주고 있습니다. 이 코드가 , 일단은, 뜰 때까지 혹시 안 뜨면은 뭔가 문제가 있는지 비교를 해보시길 바라고 이 흐름이 굉장히 굉장히 중요하니까 잘 이해가 안 가신다고 하면은 , 사실, 세부적인 함수는 이해할 필요 없지만 흐름 자체는 좀 복습을 하면서 이게 어떤 흐름으로 지금 얘가 연결을 하고 있는지를 살펴보시기 바라겠습니다 그 다음에 이제 다음 시간에 이어서 여기서 뭔가 데이터를 보내고 바꾸는 부분을 좀 추가를 해주면 되겠죠 그리고 이제 나중에 가면은 이 서버가 조금 더 커져가지고 클라이언트가 한 명만 붙는 게 아니라 몇 천 명씩 붙는다고 하면은 여기서 지금 , 이렇게, 클라이언트 어드레스랑 클라이언트 소켓 같은 거를 스택 메모리에다가 잠시 사용하고 날리는 게 아니라 얘를 어딘가에다가 잘 보관을 해 줘 가지고 그 소켓을 이용해 가지고 우리가 데이터를 보내주게 되면은 언제 어디서든 연결된 클라이언트랑 계속 통신을 할 수 있게 된다고 , 일단은, 볼 수가 있겠습니다 , 자, 이렇게, 가지고 소켓 프로그래밍 첫 시간이었는데 조금 머리가 어지럽긴 하겠지만 뭐 이런 내용들이 다 기초가 되는 거니까 너무 스트레스를 받을 건 없지만 그래도 한번 다시 한번 복습을 천천히 해 보시기를 바라겠습니다.