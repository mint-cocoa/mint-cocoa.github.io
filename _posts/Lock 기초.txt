지난 시간에 아토믹을 사용하는 그런 실습을 한번 진행을 해봤는데요 아토믹도 굉장히 좋은 방법이긴 하지만 , 사실, 더 일반적인 상황에서는 락을 걸어 가지고 접근을 하는게 조금 더 일반적인 상황에서 활용할 수가 있습니다 그래서 오늘은 그런 쪽으로 실습을 해볼 건데 , 자, 이제 문제의 상황을 또 한번 가정을 해볼게요 오늘 해볼 것은 뭐냐면은 뭐 벡터가 , 일단은, 이렇게, 하나 있다고 가정해 볼게요 공유하는 데이터가 단순한 정수가 아니라 이제 뭐 어떤 자료구조 어떤 컨테이너인 경우를 생각해 봅시다 이게 뭐 벡터일수도 있고 리스트일수도 있고 맵일수도 있고 그냥 온갖 컨테이너가 다 동일한 문제가 있는데요 , 자, 일단은, 요런 상황에서 오늘은 푸쉬라는 함수를 하나를 만들어줄것인데 푸쉬라는 함수 내부에서는 무엇을 해줄거냐면은 만번동안 선 만번동안 뺑뺑이를 돌면서 벡터에다가 푸시백으로 그냥 데이터를 , 이렇게, 하나씩 넣는 그런 굉장히 단순한 함수를 , 이렇게, 만들어 놨습니다. 그 다음에 여기서 , 자, 이제 스레드 2개를 만들어 줄 것인데 둘 다 푸쉬를 실행을 하게 될 겁니다 T1 T2 모두 푸쉬를 실행하게 될 거고 즉 만 번 만 번 이니까 총 데이터가 2만 번이 되지 않을까 라는 헛된 희망을 품고 있는 거죠 그래가지고 2개의 스레드가 끝날 때까지 기다리기 위해서 조인을 해준 다음에 조인이 끝났으면 사이즈를 한번 간단하게 출력을 해 보도록 할게요 이런 간단한 코드가 있다고 가정해 봅시다 이제는 단순한 정수가 아니라 좀 더 복잡한 구조가 된 거죠 이 상태에서 F5를 눌러서 실행을 하면 데이터가 2만개가 되기는 커녕 바로 크래쉬가 나는 걸 볼 수가 있습니다 굉장히 묘한 상황이죠 그리고 여러분들이 아셔야 될 게 , 사실, 우리가 이제까지 배운 STL에서 사용하던 자료구조 컨테이너들은 멀티스레드의 환경에서 동작하지 않는다고 , 일단은, 가정을 해야 됩니다 기본적으로 그렇기 때문에 지금 얘가 왜 문제가 발생했을지 곰곰히 생각을 해보도록 할게요 벡터 같은 경우에는 기본적으로 동적 배열인데 얘가 어떻게 동작하는지를 생각을 해보면 이런 식으로 데이터가 들어가는 그런 배열이 하나가 만들어질 것인데 만약에 이 배열이 꽉 찼다고 하면 어떻게 하나요? Capacity를 늘려 가지고 더 큰 영역을 , 이렇게, 할당을 받아 가지고 데이터를 , 일단은, 다 복사를 하고 시작을 하죠 그 다음에 원래 있던 메모리 공간은 날려주는 방식으로 , 일단은, 동작을 합니다 여기까지만 딱 설명을 드려도 , 사실, 뭔가 아차 싶은 경우가 생기게 될 텐데 우리가 지금 얘기하고 있는 멀티스레드 환경이라는 것은 굉장히 친절하게 다른 스레드를 기다려주거나 하지 않습니다 그래가지고 우리가 인트 정수를 가지고 ++, -- 실습을 할 때도 문제가 발생했던 것이죠 그럼 이 상황에서 만약에 예외적인 케이스를 들어보자면 여기서 1,2,3까지 다 꽉 찬 상태에서 동시다발적으로 푸시푸시가 양쪽에서 동시에 진행이 된다고 가정을 해볼게요 그럼 첫번째가 간발의 차이로 이제 푸시백을 실행을 할 때 아 내가 이제 용량이 꽉 찼으니까 늘려야 되겠구나 라고 더 큰 메모리를 할당을 받고 여기 있는 내용물을 이쪽에다가 복사를 하고 얘를 삭제를 하려고 시도를 할 겁니다 그런데 그와 동시에 T2라는 다른 스레드에서도 똑같은 짓거리를 하려고 얘가 이미 꽉 찼으니까 나도 더 큰 영역을 받고 기존에 있던 영역을 지워야 되겠구나라고 이제 똑같이 실행할 텐데 이 영역을 지우려고 보니까 하필이면 이전에 T1이라는 애가 먼저 얘를 선수를 쳐가지고 딜리트를 해서 이 메모리를 이미 삭제한 상태가 될 수도 있다는 얘기가 되는 거죠 그렇게 되면은 이미 삭제된 메모리를 또 딜리트를 하려고 하니까 이제 더블 프리 문제가 발생해가지고 그래서 이제 크래시가 난다고 예측을 할 수가 있을 겁니다 , 자, 요런 식으로 뭐 물론 이게 리스트거나 다른 자료 구조라고 하면은 다른 이유로 크래시가 나겠지만 어찌됐건 하나 확실한 거는 기본적으로 각기 동작하는 방식이 싱글스레드 방식에서만 동작하는 것이기 때문에 항상 문제가 일단 일어나도 가정을 하시면 됩니다 그러면 이 문제를 해결하기 위해서 그러면 , 이렇게, 실시간으로 복사되는 부분을 없애기 위해서 가령 벡터에다가 리설브를 해 줘 가지고 애당초 2만 번이 안전하게 옮겨지지 않고 실행되게끔 리설브를 해주면 아까 크래쉬 나는 건 없어지지 않을까 라고 합리적인 판단을 할 수가 있는데 이 상태에서 실행을 해보면 이제 크래쉬는 나지 않지만 뭐 어찌됐건 데이터가 2만개가 아니라 조금 몇 개가 분실되었다는 걸 알 수가 있습니다 이 경우에도 왜 문제가 똑같이 일어나냐면 역시나 우리가 이제 Reserve를 해 줘 가지고 굉장히 큰 영역을 준비해 줘 가지고 이제는 여기 있는 데이터를 옮기는 일은 없고 그냥 뒤에다가 추가는 일만 생기긴 할텐데 기본적으로 벡터가 동작하는 방식은 내가 지금까지 데이터를 몇 개를 집어 넣었는지 이 사이즈를 관리하다가 내가 지금 예를 들면 3개짜리 지금 벡터죠 그러면은 다음에 추가돼야 될 이 인덱스는 현재 사이즈가 3 이니까 인덱스 3번 즉 여기다가 데이터를 추가해야 된다는 걸 알고 , 이렇게, 추가를 하게 될 겁니다 하지만 역시나 멀티스레드 환경에서는 다른 애들을 고려를 하지 않기 때문에 만약에 거의 동시에 다발적으로 T1이랑 T2가 지금 이 상황에서 또 호출이 됐다고 가정해 볼게요 그러면은 여기서 이제 사라는 데이터를 서로 밀어 넣어야 되는데 첫 번째 스레드는 내가 지금 데이터가 여기 1, 2, 3 이니까 여기다가 데이터를 집어 넣어야 되겠구나 라고 생각을 할 테고 그 다음에 동시다발적으로 하필이면 얘가 완전히 완료되지 않은 상태에서 똑같은 애도 똑같은 판단을 해가지고 데이터가 3개 있으니까 난 여기다가 넣어야 되겠구나라고 생각을 한다면 서로 똑같이 같은 위치에 데이터를 두 번 기입하는 상황이 발생할 수도 있겠죠 그렇기 때문에 결국에는 데이터가 2만개가 완전히 채워지지 않는 그런 상황이라고 볼 수가 있겠습니다 네 그래서가지고 , 사실, 크래쉬가 나지는 않았지만 사실은 이런 경우에는 크래쉬가 나가지고 원인을 찾는게 훨씬 더 좋은거지 , 이렇게, 어거지로 통과를 시켰더니만 일부 데이터가 분실이 되었습니다 라는 상황은 더 버그를 찾기 어렵고 더 끔찍한 상황이라고 볼 수가 있는 거죠 , 자, 그래가지고 결국에는 , 이렇게, 공유해가지고 사용하는 그런 데이터를 동시에 접근을 해서 사용하는거는 말이 안되고 이제 그렇다고 해가지고 우리가 뭐 아토믹을 사용했는데 이 아토믹이 일반적인 데이터에서 동작을 한다는거지 막 요렇게 벡터라거나 굉장히 이상한 애들을 막 넣어놓는거는 또 얘기가 조금 다릅니다 이런 경우는 , 사실, 쓸 수가 없어요 얘가 얘기하고 있는거는 이 아토믹 변수에다가 뭐 스토르나 로드 같은 거를 집어넣어 가지고 뭔가를 하는 얘기지 이 벡터에 있는 세부적인 기능을 활용할 수 있다는 얘기가 아니기 때문에 이 아토믹은 여기서는 사용할 수가 없습니다 이제 우리가 여기서 해야 되는 거는 뭐냐면은 내가 푸시백을 하는 동안에 즉 내가 얘를 건드리는 동안에 다른 애들은 이 벡터를 건드리지 못하도록 서로 신호를 정해주는 것처럼 순서를 정해가지고 한 번에 한 명만 접근을 하도록 유도를 해줘야 되는데 그게 기본적으로 락의 개념이라고 보시면 되겠습니다 이 락도 역시나 운영체제 마다 예를 들면 윈도우즈에서는 크리티컬 섹션을 사용하고 이런 식으로 다 분할이 되어 있었는데 얘도 마찬가지로 C++11에서 통합이 되면서 mutex라는 헤더를 추가해가지고 사용을 하게 됩니다 그리고 이 mutex 를 활용하는 방법은 뭐 굉장히 단순한데요 , 자, 일단은, 공유해서 사용할 뮤텍스를 하나를 요렇게 만들어 줍니다 그 다음에 얘가 이제 일종의 자물쇠라고 생각을 하시면 돼요 일반적으로 우리가 비행기를 탈 때 그 기내에 있는 화장실을 생각하시면 되는데 그 화장실을 보면 , 일단은, 1인실로 되어있죠 굉장히 작습니다 그 다음에 안에 들어가 가지고 자물쇠를 땅 잠그면은 이제 밖에 있는 사람한테는 그 화장실이 이미 누군가가 있다고 빨간색으로 뜨게 되겠죠 그 다음에 안에 있는 사람이 자물쇠를 풀고 나오면 이제 그제서야 다음 사람이 들어갈 수 있는데 그런 일종의 화장실 어 자물쇠 같은 개념이라고 보시면 되겠습니다 그래가지고 먼저 들어갈 애가 락이라는 걸 요렇게 실행을 해주게 될 거에요 락 만약에 락을 해서 내가 넘어갔으면은 이제 내가 화장실의 주인 즉 내가 화장실을 차지하는 셈이 되는 거니까 나 말고 다른 애들은 다 접근을 할 수가 없는 상태가 되는 겁니다 네 그래가지고 여기서 한마디로 얘는 자물쇠 잠그기라고 생각하시면 되는거고 내가 볼일을 다 봐가지고 데이터를 다 건드렸으면 그 다음에는 이제 풀어줘야 되겠죠 언락을 해줘가지고 자물쇠를 이제 풀어주면 되겠습니다 그래서 락과 언락이 요렇게 세트로 동시에 등장을 한다고 보시면 되겠어요 , 자, 요렇게 하면은 그럼 만약에 내가 이미 자물쇠를 획득한 상태에서 다른 애가 똑같은 코드를 또 동작을 얘를 실행하면 어떻게 되느냐 걔는 그냥 여기서 계속 대기를 타게 됩니다 다른 애가 언락으로 얘를 풀어주기 전까지는 , 사실, 접근을 하지 못한다고 보시면 되겠어요 자물쇠로 생각을 해도 되고 일종의 신호등이라고 생각을 해도 되고 정말로 순차적으로 접근을 하게끔 보장을 해주는 그런 잠금 장치라고 보시면 되겠습니다 근데 물론 얘를 막 사용한다고 무조건 좋은 건 아닌 게 이게 경합이 너무 심해져 가지고 여기서 한 번에 한 명만 통과를 할 수 있기 때문에 실질적으로 이 코드 자체는 싱글스레드로 동작하는 그런 개념이라고 볼 수 있는 겁니다 그래가지고 뭐 결국에는 여기서 리절브를 일단 없애고 이 푸시백을 이제 똑같이 만 번씩 실행해서 살펴보면 이젠 정상적으로 데이터가 2만 개가 들어가는 건 볼 수 있지만 그럼에도 불구하고 , 이렇게, 락과 언락을 하는 그리고 상대방이 락을 풀어주는 경험이 있기 때문에 일반적인 상황보다는 조금 느리게 동작을 할 수밖에 없게 됩니다 하지만 , 일단은, 이게 기본적인 락의 개념이라고 볼 수가 있겠어요 이 락은 특징적으로 Mutual Exclusive, 즉 상호 베타적이라는 특징이 있어가지고 내가 먼저 이 락을 획득했으면 다른 누군가는 절대로 동시에 등장할 수 없다 나만 사용할 거야 라고 이기적으로 락을 잠그는 것이기 때문에 상호 베타적이라는 특성을 갖고 있습니다 , 자, 이게 락의 기본적인 개념인데 여기서 몇가지 조심해야 되는 부분이 있습니다 뭐냐면은 , 일단은, 나중에 우리가 또 락을 락은 이제 워낙 중요한 개념입니다 참고로 우리가 멀티스레드 환경에서 , 사실, 대부분의 그런 공유 데이터 접근을 락으로 일단 접근할 것이기 때문에 락을 이제 구현하는 방법에 대해서도 실습할 것이고 다양한 락의 종류에 대해서도 실습할 것인데 , 일단은, 1차적인 스포일러를 드리자면 여기서 중요한 것이 몇가지가 있는데 이 락을 재귀적으로 걸 수 있느냐도 굉장히 중요한 문제가 됩니다 근데 , 일단은, 이 뮤택스 같은 경우에는 , 이렇게, 재귀적으로 호출할 수가 없어요. 그래서 만약에 이런 상황이 된다고 하면은 바로 일단 크래쉬가 난다는 걸 알 수가 있고요. 재규적으로 허락을 하는 Recursive Mutex라는 게 이제 또 따로 등장을... 따로 이제 존재합니다. 다른 버전을 사용해야 된다는 얘기가 되는 거고 이런 부분도 일단 언제든 주의깊게 볼 부분이죠 내가 재기적으로 얘를 호출할 수 있는지 물론 이 자물쇠를 재기적으로 잠글 필요가 있을까 싶긴 하지만 , 이렇게, 간단한 코드가 아니라 나중에 진짜로 MMO처럼 코드가 복잡해지면 여기서 그냥 간단하게 푸시백을 하고 끝내는 게 아니라 여기 내부에서도 다른 함수를 호출하고 다른 함수가 또 다른 함수를 호출하고 , 이렇게, 서로 서로 물고 물고 물고 이어서 호출해주는 경우가 있는데 이 상태에서 이 함수 내부에서도 또 락을 잡을 수가 있기 때문에 웬만해서는 재규적으로 락을 허용하는 경우가 조금 더 컨텐츠 개발을 할 때 훨씬 더 편안합니다 그래야지 우리가 이미 , 이렇게, 만들어 놓은 함수를 재사용해서 다른 데서도 호출할 수 있겠죠 , 자, 그게 이제 첫번째로 승려술 문제고 두번째로는 만약에 내가 락을 잡았는데 어떤 실수를 해가지고 여기서 락을 안 풀어준다고 하면은 이런 상황이 어떻게 되는 거냐면은 어떤 사람이 화장실에 딱 들어가가지고 문을 잠근 다음에 어 문을 열고 나와야 되는데 문을 열지 않고 뭔가 창문으로, 창문으로 못 들어와가지고 화장실에서 나온 뭐 그런 느낌이라고 보시면 되겠습니다. 즉, 그 화장실은 영영 다른 사람들은 더 이상 접근을 할 수 없는 그런 끔찍한 상황이 발생한다는 얘기가 되는 거죠. 그런데 그런 초보적인 실수를 누가 하나 싶기는 하죠 당연히 락을 걸었는데 락을 안 풀고 이런 거는 요즘엔 심지어 비주얼 스튜디오가 얘로 잡아주기까지 하네요 이러니까 , 사실, 자주 안 할 것 같지만 이게 그럼에도 종종 실수를 하게 되는 이유는 뭐냐면 , 이렇게, 락이랑 언락 세트를 , 일단은, 만들어놨던 것처럼 해봅시다 근데 어떤 이유에서인가? 예를 들면은 뭐 여기 위쪽에다가 예외 처리가 되어 있어 가지고 만약에 이제 뭐 I가 5000이라고 하면은 여기서 브레이크를 때린다고 가정을 해볼게요 어떤 예외적인 케이스에서 브레이크 하는 상황이 종종 등장할 수 있겠죠 뭐 널 포인터 체크를 하거나 하는 등등의 상황에서 , 자, 근데 여기서 또 여기 비주얼 실료가 살짝 힌트를 주고 있지만 여기서 이제 문제가 보이시는지 모르겠는데 원래는 락을 하고 언락을 하고 반드시 이 세트를 지켜줘야 되는데 만약에 아이가 5000번에 들어와 가지고 브레이크를 여기서 때려준다고 하면은 불행하게도 언락을 안 하고 바로 지금 빠져나가는 상황이 되고 있는 겁니다 그렇기 때문에 얘를 지금 이 상태에서 실행을 해보면 프로그램이 영영 끝나지 않고 지금 계속 돌아간다고 볼 수가 있는 거죠 여기서 잠시 모드 중단을 해가지고 잠시 멈춰주게 되면은 스레드가 지금 여기서 락까지 실행해가지고 여기서 더 넘어가고 싶은데 이전에 락을 잡은 애가 얘를 풀어주지 않기 때문에 얘 이제 여기서 무한 대기를 하고 있는 그런 상황이라고 볼 수가 있는 겁니다 그러면은 이제 여기서 문제가 됐던 거는 결국에는 브레이크를 하기 전에 내가 락을 잡았으면 반드시 이 락도 풀어줘야 되니까 요 부분이 누락이 되었기 때문에 발생한 문제라고 볼 수가 있는 거죠 하지만 여기서 이프가 또 이프엘스 이프엘스 하고 여기 또 이프가 또 등장하고 이 코드가 또 굉장히 복잡해질 수가 있는데 그때마다 한 땀 한 땀 락을 풀어줬나 위에 락이 있나 보는 것도 굉장히 피곤한 일이 될 거예요 , 이렇게, 간단한 경우가 아니라 MMO 기준으로는 막 복잡한 그런 함수는 몇천 줄까지 갈 수 있는데 그 락이 맨 위에서 걸었는데 그걸 아래서도 락을 걸었는지 안 걸었는지를 위에서 계속 올리면서 체크하는 건 말이 안 되겠죠 그러다 보니까 , 이렇게, 수동으로 락을 잠그고 풀고 하는 거는 굉장히 작은 함수라면 솔직히 뭐 괜찮긴 한데 조금 규모가 큰 경우라고 하면 , 이렇게, 수동으로 관리를 하는 거는 굉장히 나쁜 습관이라고 볼 수 있겠습니다 , 자, 그러면은 이걸 어떻게 해야되느냐 어.. C++의 굉장히 유명한 패턴 중에서 R-A-I-I 솔직히 이거 뭐라고 읽는지도 모르겠는데 이 라이라고 할게요 일단 라이 패턴이라는게 있습니다 이거 약자는 뭐냐면은 Resource Acquisition is Initialization 이라는 약자입니다 뭐 이걸 외울 필요는 없구요 대충 요런 아이가 있는데 얘가 하고 싶은 얘기는 뭐냐면은 어떤 래퍼 클래스를 만들어가지고 생성자에서 잠그고 그 다음에 소멸자에서 풀어주고 하는 그런 행동을 하게 될 거예요 물론 이게 락에 대해서만 하는 게 아니라 뭐 다른 리소스나 DB 연결이나 할 때도 다 똑같이 동일한 패턴으로 사용하게 될 겁니다 , 자, 이게 무슨 얘기인지 잘 이해가 안 가실 테니까 보여드리자면 뭐 간단하게 한번 예제를 들어볼게요 락 가드라는 클래스를 만들어 줄 것인데 어 그 클래스는 기본적으로 요렇게 내부적으로 뷰텍스를 , 이렇게, 들고 있을 거에요 근데 물론 이 뷰텍스가 락을 어떤 식으로 만들었는지 모르니까 템플릿으로 만들어 줄 것이구요 그래서 락가드의 생성자에서는 , 일단은, 요렇게 우리가 잠굴 그 락을 , 일단은, 잠시 받아 줄 것이고 그 다음에 생성자에서 락을 직접 호출해 주게 될 겁니다 반대로 소멸자에서는 얘가 하는 역할은 이 뮤택스의 언락을 호출해 주게 될 거예요 말 그대로 이 객체는 여기 해당하는 이 뮤택스를 자동으로 잠궈주고 자동으로 열어주는 역할을 하기 위해서 존재하는 래퍼 클래스라고 볼 수 있겠습니다 그럼 얘를 이제 어떻게 활용하냐면은 여기서 Lock과 Unlock을 직접 우리가 명시적으로 호출하는게 아니라 여기다가 그냥 LockGuard라는 요 아이를 만들어주는거죠 std mutex LockGuard 라고 해가지고 여기다가 인자로 아까 m을 요렇게 넣어주면 되겠습니다 그러면은 얘가 이제 지금 유효한 범위가 여기서 여기까지 유효하죠 얘는 일단 삭제를 해야되겠죠 , 자, 그러기 때문에 얘가 여기서 딱 들어오는 순간 이 객체가 생성이 되면서 이 M을 받아가지고 이 코드가 호출이 되면서 락을 잡아줄 것이고 뭐 수단과 방법을 가리지 않고 여기서 빠져나오건 뭘 하건 이 리턴이 되건 이 범위에서 빠져나가지고 이 락가드라는 객체가 더 이상 유효하지 않다 싶으면은 걔가 알아서 자폭을 하면서 이 뮤택스를 풀어주게 될 겁니다 뭐 굉장히 똑똑하죠 , 자, 이렇게, 해가지고 이거를 어떻게 보면은 자동으로 잠궈주는 그런 자동문을 우리가 만들어 줬다고 보시면 되겠습니다 이런 상황이라고 한다면 아까처럼 뭔가 무한으로 대기 타는 상황이 없이 자동으로 락이 풀어 질 것이기 때문에 실질적으로 코드를 실행해 보면 정상적으로 종료가 된다는 것도 이제 확인을 할 수가 있을 겁니다 이런 식으로 락가드를 이용해 가지고 뷰텍스를 이제 활용을 하는 게 훨씬 더 좋다고 일단 보시면 되겠어요 물론 이 객체를 만드는 부하가 아주 조금 추가되긴 하겠지만 안전한 코드를 짜는 게 훨씬 더 우리한텐 중요하기 때문에 이 뮤텍스를 그냥 생으로 사용하는 것보다는 이런 가드를 사용하는 걸 일단 추천을 드립니다 그리고 물론 매번마다 이런 락가드를 우리가 직접 만들어야 되는 건 아니고 이게 당연한 얘기지만 표준에도 다 들어가 있습니다 std, lock, guard 똑같은 코드예요 , 이렇게, 해도 아까랑 똑같이 동작을 하게 될 겁니다 그래가지고 이 RAII 패턴에 맞는 그런 락가들을 이용해가지고 이 뷰텍스를 자동으로 잠그고 풀게 되면은 아까 얘기한 이 언락을 빼먹거나 혹은 짝을 안 맞춰주는 요런 상황을 이제 예방을 할 수 있다는 걸 알아두시면 되겠습니다 참고로 이 LockGuard라는 에러를 사용해도 되구요 또 하나의 버전이 하나가 더 있는데요 유닉락이라는 게 하나가 더 있습니다 유닉락 그러면 이제 똑같은 기능을 왜 두 개를 만들어 놨을까 당연히 이제 뭐 완전히 똑같진 않구요 만약에 , 이렇게, 만들어놨으면 아까랑 완전히 똑같은데 이 유닉 락은 락 끝에다가 플러스 알파로 추가적으로 세부적인 기능이 더 있습니다 그게 뭐냐면은 당장 락을 잠그지 않고 여기다가 옵션을 줘가지고 예를 들면 여기다가 딥퍼 락이라는 옵션을 주면은 당장 락은 잠그지 않을 것이고 , 일단은, 이 인터페이스만 준비를 해준 다음에 실질적으로 유닛 락에서 , 이렇게, 명시적으로 잠그는 순간에 얘가 이제 똑같이 동작을 하게 됩니다. 얘를 만들자마자 잠기는 게 아니라 여기서 이 잠기는 시점을 뒤로 미룰 수가 있다는 얘기가 되는 거죠 그 다음에는 이제 똑같이 이 유닉 락이 소멸될 때 아까와 마찬가지로 여기서 언락을 호출해주는 부분까지는 똑같고 뭐 , 이렇게, 좀 유도리 있게 동작을 하는 버전이라고 보시면 되겠습니다 근데 물론 그런 유도리 있게 동작하기 위한 추가적인 인자가 필요하기 때문에 이 락가드보다는 용량이 아주 조금 변수가 더 많기 때문에 조금 더 느리기 때문에 간단한 경우라면 락가드를 사용하고 뭐 이런식으로 경우에 따라 가지고 다른 옵션에 의해 가지고 락을 잠궈버리는 시점을 미뤄야 된다고 할 때는 유닛 락을 사용해주시면 되겠습니다 , 자, 이거는 일단 참고삼아서 , 일단은, 알아주시면 되겠어요 , 자, 이렇게, 해가지고 , 일단은, 락에 대한 굉장히 기초적인 부분에 대해서 , 일단은, 알아봤는데요 근데 이 락이 굉장히 단순하면서도 생각할 부분이 많습니다 예를 들면 우리가 이런식으로 폼은 내부에서 , 이렇게, 락을 잡아도 되겠지만 사실은 아예 푸쉬를 하는 순간에 요렇게 락을 크게 잡아도 되겠죠 그래가지고 뭐 이거는 케바케로 어떤 게 더 좋고 나쁘고가 아니라 이제 코드가 어떤 식으로 동작하냐에 따라 가지고 정답이 달라지게 되는데 이 락을 거는 범위에 따라 가지고 굉장히 많은 것들이 달라지게 될 거라는 것도 , 일단은, 참고 삼아 알아주셔야 되겠습니다 , 이렇게, 크게 잡아주면 여기 안에 있는 모든 일감이 완료될 때까지는 다른 애들은 이 입구에서 커트가 되가지고 여기서 , 일단은, 대기를 해야 되는 상황이 되는 거고 그게 아니라 만약에 아까처럼 , 이렇게, 여기 내부에서 잠갔다고 하면 이제는 락 범위가 여기서 여기까지 있기 때문에 이 for문에 매번 들어올 때마다 락을 걸었다가 풀었다가 걸었다가 풀었다가 하는 부분이 실행이 되겠죠 이런 식으로 범위가 왔다 갔다 하게 된다는 것도 잘 유의깊게 보시면 되겠습니다 , 이렇게, 해가지고 , 일단은, 락에 대한 굉장히 단순한 실험을 해봤고 이제 락은 앞으로도 계속 두고 두고 다룰 주제니까 , 일단은, 참고 삼아서 기초만 일단 맛보기를 하고 넘어가 주시면 되겠습니다.