이렇게, 해서 굉장히 긴 내용이지만 멀티스레드에 관한 내용을 이쯤에서 마무리를 짓도록 할 거고요 , 사실, 지금까지 배운 내용이 많다면 많을 수도 있고 적다면 적을 수도 있지만 이런 내용들이 피와 살이 되어서 계속 반복해서 사용이 될 겁니다 그래서 여러분들이 서버 쪽을 작업을 하시게 된다면 특히나 서버 엔진 쪽을 작업을 하시게 되면 항상 멀티스레드와 관련한 이슈들이 계속 터지게 될 것이고 그럼과 동시에 멀티셰드 코딩에 좀 더 익숙해지시게 될 겁니다 근데 이거는 어느 정도 경험이 필요해요 , 사실, 문법적인 것만 놓고 보면 우리가 락을 사용하는 것 외에는 크게 그렇게 어마어마하게 새로운 거에 대해서는 알아보지 않았죠 나머지들은 약간 어떻게 보면 기본 소양 지식에 불과한 것이었고 그런데 이제 알게 모르게 크래쉬와 그런 굉장히 라이브에서만 일어나는 이슈들이 일어나면 이제 이런 쪽이 많은 도움이 된다고 보시면 되겠습니다 , 자, 그건 그렇고 일단 이제 더 이상 필요 없는 거 여기 어카운트 매니저랑 플레어 매니저는 실습할 때 사용했으니까 얘네들은 이제 삭제를 해서 날려주도록 할 거고요 이제 다음 시간부터 본격적으로 서버 엔진을 개발하기 위해서 스마트 포인터와 관련된 이슈들에 대해서 좀 알아보고 그 다음에 메모리 관리를 하는 거에 대해서 알아보고 이어서 네트워크 파트로 넘어가서 본격적으로 네트워크 통신에 대한 공부를 할 겁니다 근데 그 전에 이왕 멀티스레드에 관한 내용을 끝낸 김에 잠시 연습문제 하나만 풀어보고 넘어가도록 할게요 지금까지 배운 내용을 간략하게 복습할 만한 문제를 하나를 준비를 했고요 그렇게 어려운 문제는 아닙니다 일반적으로 프로그래머 코딩 면접을 볼 때 여러분들이 공부한 어마어마하게 복잡한 자료구조나 알고리즘들이 나오는 게 아니라 거의 30분 이내로 간략하게 할 수 있는 기본기를 테스트할 수 있는 문제들이 주로 나오게 됩니다 그래가지고 오늘 이제 할 실험은 뭐냐면요 , 일단은, 뭐 새로운 프로젝트를 만들어서 간략하게 연습하셔도 되고 그냥 기존의 게임 서버 여기서 그냥 작업을 하셔도 상관없는데 소수 구하기 문제입니다 소수 구하기 , 자, 소수라고 함은 어떤 숫자가 1과 자기 자신으로만 나뉘면 그것을 소수라고 합니다 그것을 소수라고 함 그래서 지식백과를 좀 갖고 와 가지고 살펴보면요 1과 자기 자신만으로 나눠 떨어지는 1보다 큰 양의 종수라고 합니다 1은 , 사실, 해당이 안되는 거고 2부터 시작을 할 것이고 2, 3, 5, 7 뭐 요런 애들은 자기 자신과 1로만 아니니까 소수이고 예를 들면 여기서 8이라는 숫자는 2로 나눠 떨어지다 보니까 소수가 아니고 그래가지고 1에서 100 사이 소수는 뭐 이런 식으로 2, 3, 5, 7, 11, 13, 17, 19 뭐 이런 식으로 딱 나올 겁니다 소수 구하기 문제는 뭐 크게 어려운 문제는 아닌데 이제 여기서 왜 멀티스레드에서 이런 걸 해보냐면은 이게 한두개를 구하는게 아니라 , 자, 요런식으로 어떤 큰 숫자를 하나를 정의를 하도록 할게요 예를 들면 100만까지 , 이렇게, 있다고 하면 여러분들의 미션은 1에서 요 맥스 넘버까지의 사이에 있는 소수의 개수를 구하는 겁니다 근데 당연한 얘기지만 , 이렇게, 100만 단위까지 가기 시작을 하면 여러분들이 이걸 만약에 싱글 스레드로 이 모든 것을 처리하면 굉장히 오래 걸릴 거니까 최대한 지금까지 배운 그런 멀티 스레드들을 활용하기 위해서 스레드들을 여러 개를 만들어 준 다음에 일감을 적절히 배분해 가지고 이거를 병렬로 실행해서 결과만 합칠 수 있게 , 일단은, 만들어 주시면 되겠습니다 이게 일단 문제인데요. 그렇게 어마어마하게 어려운 문제는 아니니까 일단 염수 삼아서 강의를 멈추고 한번 해보시기를 , 일단은, 추천을 드리겠습니다. 일단 해보시고 돌아오셔도 되고 그냥 이어서 그냥 계속 프리를 보셔도 되는데 일단 이어서 프리 해설을 간단하게 보여드리도록 할게요. , 자, 그래서 다시 소수 구하기 문제를 한번 풀어 보자면 만약에 여러분들이 새로운 프로젝트를 만드셨다면 여기서 뭐 우리가 사용할 그런 애들을 추가를 해줘야 되겠죠 뮤택스 활용한다고 치면 뮤택스를 활용할 수 있고 여러가지를 활용할 것인데 일단 기본적으로는 벡터는 들어가야 되고요 그리고 스레드 , 이렇게, 두개는 확실하게 사용을 해주도록 합시다 , 자, 그래가지고 , 일단은, 소수를 구해야 되니까 소수를 구하는 함수부터 만들어 줍시다. isPrime 이라고 해가지고 어떤 숫자가 있을 때 걔가 나눠 떨어지는지를 체크 해가지고 소수인지 아닌지를 판별하면 되겠죠. 근데 , 일단은, 확실한 거는 어떤 수가 자연수가 아니라거나 넘버가 1보다 작으면은 확실히 소수가 아니라는 걸 알 수 있고요. 그 다음에 넘버가 2이거나 아니면은 3이라고 하면은 여기는 뭐 볼 필요도 없이 일단 2로라는 걸 알 수가 있습니다. , 자, 그 외의 숫자는 이제부터 다시 한번 시작을 해볼 건데 2부터 자기 자신 마이너스 1까지 계속 체크를 하면서 만약에 U 숫자가 우리가 체크하고 있는 요 i라는 숫자랑 나누기를 해가지고 정확히 나누기가 0이 되었다 나머지가 0이 되었다 나누어 떨어졌다고 하면은 걔는 소수가 아니라는 얘기가 되는 거고 여기까지는 실패했으면은 소수라는 얘기가 되겠죠. 물론 이 공식을 조금 더 개선하기 위해서는 자기 자신까지 가는 게 아니라 여기서 루트 넘버까지 하고 이런 식으로 좀 최적화를 할 수 있긴 하지만 그건 지금 당장 우리한테 중요한 건 아니고요. 우리는 이제 이거를 적절히 멀티셋 환경에서 배분하는 게 핵심입니다. , 자, 그래가지고 count prime 이라는 함수를 만들어 줄 것인데 얘는 어떤 시작과 끝을 , 이렇게, 정해 주게 될 거에요 둘 다 포함이라고 가정을 합시다 스타트에서 엔드까지 포함 그래가지고 카운팅을 해 줄 것인데 여기서 넘버는 스타트에서 number가 end까지 포함을 해가지고 , 이렇게, 하나씩 하나씩 체크를 할 것이고요 만약에 isPrime을 체크했더니만 얘가 prime number다 소수다라고 하면은 count를 1 늘려준 다음에 이걸 최종적으로 return을 해주면 되겠죠 , 자, 이렇게, 일단은, 구할 수가 있을 겁니다 근데 여기서 이제 핵심적인 그런 부분은 뭐냐면은 결국에는 어떤 소수를 구하는 문제가 서로 연관성이 있는지를 생각을 해봐야 됩니다. 이걸 이제 멀티셋 환경에서 우리가 덕을 볼 수 있으면 서로 어떤 숫자를, 두 개의 숫자를 각각 소수인지 아닌지를 판별할 때 어떤 숫자가 소수라고 해도 그게 다른 숫자한테는 전혀 영향을 주지 않는 경우에 우리가 이거를 병렬로 빵 뿌릴 수 있었죠. 그래가지고 소수 같은 경우는 결국 이 넘버가 소수라고 해가지고 다른 애가 소수가 아니라는 그런 어떤 법칙이 있는 게 아니기 때문에 모든 애들을 다 독립적으로 우리가 체크를 해볼 수가 있을 겁니다. 그럼 이제 일감을 대충 우리가 쪼개가지고 던져줄 수 있다는 얘기가 되는 거죠? 그러니까 이거를 만약에 싱글스레드에서 우리가 그냥 고지곳대로 뭐 예를 들면은 카운트 프라임을 뭐 요렇게 1부터 맥스 넘버까지 실행을 했다고 하면은 이게 뭐 안되는 건 아니지만 요 결과가 굉장히 오래 걸릴 텐데 그게 아니라 우리는 지금까지 배운 이제 스레드를 여러 개를 만들어가지고 얘를 병렬로 빵 뿌릴 수가 있겠죠? , 자, 그래가지고 요렇게 스레드를 여러 개를 만들어줄 것이고 , 일단은, 코어 카운트는 하드코딩 해도 되긴 하지만 우리가 배운 것 중에서 여기 Thread에 Hardware Concurrence라는 걸 이용해가지고 대충 우리 코어 개수를 실시간으로 병렬로 실행할 수 있는 코어 개수를 구해올 수 있었으니까 이걸 한번 이용해 보도록 합시다 그리고 일감의 개수는 몇개인지를 체크해보니까 대충 맥스 넘버에다가 코어 카운트를 나눈 숫자만큼이겠죠? 여기다가 반놀림을 하기 위해서 1을 더해주도록 합시다. 이게 뭐 예를 들면 6.7개 이런식으로 떨어지면 얘는 자동적으로 정수이다 보니까 반내림을 하게 될텐데 그게 아니라 반놀림을 하기 위해서 그냥 일단 1을 강제로 , 이렇게, 더해줬어요. 뭐 이건 , 사실, 크게 중요한 부분은 아니구요. 그 다음에 여기서 이제 우리가 코어 개수만큼 루프를 돌면서 이제 일감을 적당히 분배해주도록 할거에요 , 자, 분배를 해줄것이고 스타트는 대충 i 곱하기 잡 카운트에다가 1 더한거부터 시작을 하도록 하고 그 다음에 끝나는거는 뭐 대략적으로 i 플러스 1에다가 곱하기 잡 카운트를 해가지고 여기까지 , 일단은, 해주면 되겠지만 혹시라도 얘가 우리가 예상한 맥스 넘버를 초과할 수도 있으니까 여기다가 민을 이용해가지고 한번 걸러주도록 합시다 최소한 맥스 넘버보다는 커질 수 없도록 , 이렇게, 적당히 끊어주도록 할게요 그 다음에 Thread.Pushback을 해가지고 여기서 직접 Thread를 만들어주면 되겠죠. 뭐 함수를 만들어줘도 되고 아니면 그냥 람더로 해도 되지만 , 일단은, 람더로 스타트랑 엔드를 복사할 것이고 그 다음에 결과물을 최종적으로 이런 아토믹 타입으로 인트에다가 더해주도록 합시다 프라임 카운트라고 해가지고 얘같은 경우에는 복사할 건 아니고 진짜 이 원본 프라임 카운트를 건네줘가지고 요 아이를 대상으로 결과물을 더해주도록 할게요 , 자, 그 다음에 람다의 구현부는 그냥 간단하게 프라임 카운트에다가 카운트 프라임의 결과물을 , 이렇게, 뱉어 달라고 해주면 되겠죠 그러면 이제 각각의 스레드들이 병렬로 요 아이를 실행을 해가지고 그거를 프라임 카운트한테 더해주게 될 겁니다 , 자, 요렇게 해서 짝을 맞춰주고요 그 다음에 요렇게 실행이 됐으면은 이제 일감이 다 들어가게 됐을 테니까 우리는 최종적으로 메인 스레드에서는 모든 일감들이 끝날 때까지 t.join을 해가지고 t.join을 해가지고 일감이 끝나기를 기다려준 다음에 최종적으로 프라임 카운트를 요렇게 뭐 출력을 해보면 되겠죠 그러면 이제 각각의 코어들이 열심히 일을 하다가 최종적으로 우리가 프라임 카운트가 다 구했으면 여기다가 합쳐가지고 결과물을 여기다가 건네주게 될 겁니다 뭐 이런식으로 일을 병렬로 처리할 수 있게 유도를 해줄 수가 있겠죠 물론 엄밀히 말해서 초반부는 이 카운트 프라임이 별로 부담이 없다가 숫자가 커지면 커지기 때문에 나중에 가면 갈수록 얘가 부담이 커지기 때문에 뒤늦게 시작하는 뒤에 있는 후반부 스레드들이 더 일이 몰리게 되긴 하겠지만 어쨌든 그것까지 신경 쓰지 않고 적당히 일감을 쪼개 가지고 , 이렇게, 실행을 해보도록 할게요 그럼 이 상태에서 100만 개를 대상으로 이제 실행을 하면은 대략적으로 한 10초? 20초? 정도 걸릴 것으로 예상을 하는데 이제 살짝 기다려주면 결과가 나오게 될 겁니다 그럼 여러분들은 이제 뭐 재밌으니까 이게 다른 방식으로 풀었다고 해도 결과가 뭐 비슷하게 나오는지만 체크를 해주시면 되겠어요 , 자, 이게 지금 7, 8, 9, 4, 8 그래서 결과가 만약에 100만개를 대상으로 했으면 7, 8, 4, 9, 8이 나와야 되구요 그 다음에 어... 개수를 줄여가지고 , 이렇게, 만개를 대상으로 하면은 1, 2, 2, 9 그리고 1,000개를 대상으로 하면은 168 , 자, 요렇게 , 일단은, 나오는게 정상적일겁니다 뭐 실제로 테스트를 해보면 1,000개를 대상으로 다시 한번 실행을 해보면 이 경우에는 조금 빨리 뜨겠죠 1, 2, 2, 9가 , 이렇게, 나오는것도 볼 수 있습니다 뭐 이런식으로 , 일단은, 일감을 던져줄수가 있을겁니다 그래서 여기서 결국에는 멀티스레드 덕을 볼 수 있었던 이유는 이 카운트 프라임이라고 해가지고 어... 어떤 숫자가 소수인지 아닌지는 서로 다른 숫자나 영향을 전혀 주지 않기 때문에 이걸 병렬로 빵떵질 수가 있었던 겁니다 그래서 요즘 GPU값이 그냥 엄청 솟아오르고 있죠 그 암호화폐 때문에 암호화폐라는 것도 결국에는 , 사실, 이런 느낌으로 어떤 숫자에 대해서 그게 어떤 공식을 만족하는지 안 만족하는지를 테스트를 해야 되는데 그 숫자들이 결국 서로 영향을 전혀 주지 않기 때문에 병렬로 실행할 수 있기 때문에 우리가 그걸 GPU를 이용해가지고 병렬로 실행해서 그 결과물을 , 이렇게, 합산하는 느낌이라고 보시면 되겠습니다 , 자, 요런 정도의 난이도라고 하면은 뭐 간단한 코딩 문제로 딱 적합할 것 같기도 하고 어... 이제 실제로 서버 프로그래머 만약에 코딩 문제를 냈다고 하면 이 정도 난이도까지는 뭐 대충 나올 수가 있을 것으로 생각을 하시면 되겠습니다 , 자, 이렇게, 해가지고 뭐 그냥 간단하게 소수 구하기 소수 개수 구하기 문제를 한번 풀어 봤구요 여기서 이제 뭐 꼭 이 방법이 아니라도 다양한 방법으로 만드셔서 뭐 결과물이 비슷하게 똑같이 나온다고 하면은 , 일단은, 맞았다고 생각을 하시면 되겠습니다. , 자, 이렇게, 해가지고 지금까지 배운 그런 스레드에 대한 내용을 열심히 활용을 해가지고 간단하게 , 일단은, 연습문제 하나를 풀어 봤어요. , 자, 이어서 다음 시간에는 멀티 스레드에 대한 내용을 마치고 이제 새로운 단원으로 넘어가도록 하겠습니다.