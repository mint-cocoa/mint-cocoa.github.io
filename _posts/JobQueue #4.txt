자, 이렇게, 여러가지의 강의를 통해 가지고 이제 우리가 드디어 이 잡이라는 것을 여러가지 방법으로 만드는 그런 방법에 대해서 알아봤습니다. 세가지 방법에 대해서 알아봤었죠. 그냥 쌩으로 클래스로 매번 하나하나씩 만들어 가지고 잡을 직접 만드는 방법도 있었고 그 다음에 뭔가 함수 포인터랑 인자들을 튜플로 묶어가지고 같이 하나의 클래스에다가 관리하는 일명 functor라는 함수자를 우리가 직접 만들어가지고 관리하는 방법 그리고 요런 식으로 lambda식을 최대한 활용해가지고 lambda capture 기능을 이용해가지고 자동으로 사실상 함수자를 만들어가지고 관리하는 방법 , 이렇게, 3가지 방법에 대해서 알아봤는데 뭐 이 중에서 어떤 걸 선택하시던 , 사실, 크게 상관이 없습니다 이건 진짜 여러분들의 선택이에요 다만 이제 조심해야 될 몇 가지 부분은 지금도 뭐 , 사실, 엄밀히 말해서 일어나고 있긴 하지만 캡쳐를 하건 아니면 펑터를 만들건 어떤 아니면은 그냥 클래스에서 들고 있건 셰어드 포인터를 , 이렇게, 들고 있는 순간 생명 유지에는 굉장히 도움을 주기는 하지만 이게 사이클이 일어나게 될 경우에는 메모리 릭이 일어날 수 있다라는 걸 항상 염두에 둬야 됩니다 저 지금도 예를 들면은 여기서 막 잡을 밀어 넣고 있으면은 요 버전 같은 경우에는 어... 섀도우 포인터를 같이 이제 잡 안에다가 포함해가지고 들고 있다 보니까 , 이렇게, 되면 사실상 객체가 소멸되지 않겠죠? 네, 자기 자신의 어... 섀도우 포인터를 들고 있는 상태가 되는 거니까 그래서 요런 거를 만약에 이제 그러면 끊어주고 싶다 라고 하면은 뭐 이걸 애당초 위크 포인터로 넣어주거나 그것도 아니라고 하면은 이제 이 객체가 필요 없어져가지고 뭔가 삭제가 일어나야 된다고 했을 때 한번 뭐 , 이렇게, 클리어 잡 같은 함수를 이용해가지고 잡큐를 그냥 , 이렇게, 싹 밀어주면 되겠죠 이런식으로 물론 우리가 지금 아직 안 만들어놨는데 뭐 이런 느낌으로 , 일단은, 다 밀어준 다음에 셰어드 포인터의 그 사이클을 끊어주는 게 , 일단은, 필요합니다 , 자, 그건 그렇고 오늘 얘기할 주제는 , 사실, 이것보다는 조금 더 까다로운 부분이긴 한데 지금 우리가 이 방식에서 살짝 마음에 안 드는 부분은 뭐냐면은 잡을 넣는 애 따로 실행하는 애 따로 , 이렇게, 배치를 해놨었죠 그래가지고 넣는 애들은 그냥 실컷 넣고 실질적으로 게임 서버 메인 스레드가 , 이렇게, 계속 루프를 돌면서 룸을 플러쉬를 해주고 있습니다. 얘를 이제 비워주고 실행을 해주고 있는 거죠. , 자, 근데 이게 뭐 룸이 지금 , 이렇게, 한두 개면은 뭐 딱히 , 이렇게, 해도 상관이 없겠지만 나중에 가면은 요렇게 잡을 실행하는 애들을 정말 많이 배치할 수 있다고 했었죠 이제 이거는 어떤 스타일로 만들 것이냐에 따라 다르지만 seamless MMO를 만들 때는 액터 단위로 다 배치하는 경우도 있다고 했습니다 액터 단위라고 해가지고 예를 들면은 플레이어, 몬스터, NPC는 물론 프로젝트 타일처럼 날아가는 투사체 같은 것도 다 , 이렇게, 잡 큐 같은 걸 배치해가지고 잡을 일렬로 , 이렇게, 하나씩 하나씩 밀어 넣어서 실행하게끔 만들어주는데 그러니까 한마디로 , 이렇게, 지금 플러쉬를 해야되는 대상이 막 몇십만 단위가 될 수 있다는거죠 동접이 5천명이고 몬스터도 막 몇만 단위고 해가지고 그러면은 애당초 이걸 누가 이걸 계속 뺑뺑이를 돌면서 이걸 실행을 해야될지가 굉장히 난감해진다는 얘기가 되는겁니다 50만개를 일일이 순회를 하면서 일일이 실행하는 것도 좀 귀찮은 작업일 뿐더러 만약에 일감이 없는데도 굳이 매버마다 무한 루프를 하면서 체크하는 것도 굉장히 좀 미련한 짓이 되겠죠 물론 우리가 멀티스레드 시간에 알아본 condition variable 같은 조건변수를 이용해 가지고 필요 없을 때는 그냥 대기를 하고 뭔가 일감이 떨어졌을 때만 동작하고 하는 식으로 만들 수도 있겠지만 그것도 한두개 해야 말이 되지, 객체가 50만 단위로 넘어가기 시작하면 조건변수로 일일이 배치하는 것도 말이 안되는 일이 될겁니다. 이것도 , 사실, 정책이 굉장히 많이 갈려요 그런데 저는 이제 가장 좋아하는 스타일은 뭐냐면 이 푸시 잡을 할 때 얘가 같이 실행까지 담당을 하게끔 만드는 거를 선호합니다 우리가 결국에는 이 네트워크 쪽에서 세션도 약간 비슷한 케이스가 있었죠 이거를 샌드를 할 때 진짜로 얘가 실행까지 할 것인지 아니면 그냥 샌드큐에다가 놓고 빠져나올지를 이제 갈린 길이 있었는데 여기서 처음으로 들어온 애가 즉 이 리지스터 상태를 보고 얘가 아직 false 상태라고 하면은 얘가 실행까지 담당을 하게 했는데 이런 형태를 만들어 주면은 굉장히 편리하게 작업을 할 수 있게 됩니다 샌드를 막 뿌려줘도 결국 누군가가 처음으로 들어온 애가 처리해주고 이런 식으로 동작을 할 수 있게 된다는 얘기가 드는 거죠 그래서 오늘 할 주제는 이 잡이라는 요 아이도 그런 식으로 , 일단은, 바꿔 보도록 할 거예요 그게 일단 오늘의 주제인데 , 자, 근데 지난번에 하던 거에서 조금 몇 가지만 정리를 하고 가자면은 이 잡큐라는 거를 이제 또 다른 곳에서도 종종 활용할 일이 생길 수가 있습니다 요런 락을 잡는 큐 같은 느낌으로 그래가지고 이거를 좀 이름을 수정을 해보도록 할게요 그냥 잡큐라고 하지 말고 락큐라고 좀 중의적인 이름으로 , 이렇게, 만들어 준 다음에 템플릿으로 만들어 줘 가지고 이거를 이제 그냥 공용으로 락을 거는 큐로 그냥 활용을 하도록 합시다 그래서 템플릿 , 이렇게, 걸어주고 잡큐가 아니라 락을 거는 큐다 라고 이름을 바꿔 주도록 할게요 , 자, 그리고 이네들도 다 TT로 바꿔주면 되겠죠 , 일단은, 네 어떤 타입이 들어올지는 모르니까 그리고 잡이 아니라 그냥 아이템 같은 좀 너무 특색이 없는 좀 중의적인 이름으로 다시 , 이렇게, 수정을 해보도록 할게요 , 이렇게, 일단은, 바꿔놨구요 아 그리고 참고로 아까 뭐 클리어 같은 함수가 있었죠 요런 것도 일단 추가해주면 좋을 것 같고 요 아이 같은 경우에는 락을 건 다음에 아이템을 날려주면 되겠죠. 근데 일부 STL은 클리어 같은 기능이 없는 경우도 있어요. 만약에 없으면 그냥 얘를 빈큐로 다시 밀어주시면 되겠습니다. 뭐 , 사실, 얘는 굳이 뭐 필요 없었는데 아 그리고 대문자 큐로 바꿔가지고 우리의 그 stl 얼러케이터를 이용해 가지고 사용하게끔 , 일단은, 유도를 해주도록 할게요 , 자, 그 다음에 지금 우리가 t타입으로 바꿔놓은게 이걸 바꿔놓고 그리고 널프 ETR이 아니라 그냥 T타입으로 , 이렇게, 반환하게 유도를 해줄 것이고 그 다음에 경우에 따라가지고 모든 애들을 그냥 한 번에 다 추출하고 싶다 라는 뭐 그런 필요가 생길 수도 있기 때문에 얘도 하나를 , 이렇게, 팝 올이라는 이름으로 파주도록 하고 락을 건 다음에 하나씩 하나씩 추출해서 그냥 건네주도록 합시다 요런 느낌으로 푸쉬 백 아이템 해서 여기다가 , 일단은, 다 건네 주도록 할 거예요 , 이렇게, 일단은, 뭐 간단하게 템플릿 형태를 이용해 가지고 락큐로 , 일단은, 바꿔 놨구요 , 자, 위에다가 락큐 cpp 에서는 락큐로 얘를 이제 바꿔치기를 해야 문제가 해결이 될 것이고 얘는 이제 잡 쪽에다 넣지 말고 아래로 이동해서 유틸 쪽에다가 일단 넣어 가지고 관리를 해 주도록 할게요 그럼 얘를 이제 바꿔놨으니까 온갖 군데에서 에러가 날텐데 그건 이제 컴파이너한테 떠넘기고 잡아주도록 합시다 , 일단은, 하나씩 보면은 , 자, 여기 잡지얼라이서에서 Lock Queue라고 , 일단은, 바꿔줘야 될 것이고요 네 그래서 요 부분도 잡큐가 아니라 이제 락큐가 되겠죠 락큐인데 내부적으로 잡 래프를 사용하는 아이다 라고 요렇게 , 일단은, 바꿔치기를 해주면 되겠어요 , 자, 또 문제가 없는지 간단하게 서버코어를 빌드를 해보도록 할게요 다 됐구요 그 다음에 뭐 제가 이전에 C샵 강의랑 네이밍 컨베이션을 좀 맞추기 위해서 job-serializer라는 용어를 활용하긴 했는데 막상 하다보니까 좀 너무 이름이 긴 것 같아가지고 원래 사용하던 job-queue라는 이름을 이 serializer한테 그냥 건네주도록 하겠습니다 그냥 이 이름을 사용하도록 할게요 앞으로 Ctrl-R, R 이름 바꾸기 해서 job-queue로 일단 얘를 수정을 해보도록 하겠습니다 이런 느낌으로 , 자, 그러면 잡시랄에서 cpp에 가서는 잡큐로 얘를 바꿔치기를 해주면 되겠고 여기 파일 이름도 하나씩 수정을 해주도록 하겠습니다. 그래서 앞으로는 너는 이제 잡큐라고 부르도록 하겠습니다. 네 그 부분은 이제 요렇게 , 일단은, 수정이 됐고요. 어 그 다음에 여기 잡큐도 그냥 얘도 뭐 바꾸는 김에 잡스라고 일단 이름을 , 이렇게, 싸그리 수정을 해보도록 할게요. 딱히 큰 의미는 없지만. , 자, 그리고 이제 오늘 이어가지고 필요한 것은 무엇이냐면은 바로 요 부분인데 이제 플러쉬를 어 플러쉬 잡을 우리가 앱스텍트로 만들어 나가 주고 예를 상속을 받아 가지고 니가 알아서 만들어 나라 라고 했었는데 어 이제는 그렇게 하는 게 아니라 여기 푸쉬 잡을 할 때 잡을 만들어 가지고 경우에 따라서 내가 처음으로 첫 일감을 내가 밀어 넣은 애라고 하면은 실행까지 담당하게끔 살짝 코드를 수정해 보도록 할게요 , 자, 그래서 아래다가 , 일단은, 프라이빗 영역으로 어 푸쉬라는 걸 요렇게 만들어 줄 건데 음 뭐 요런 요렇게 만들어 볼게요 , 일단은, 그냥 오른값으로 잡을 받아 가지고 바로 무브를 해서 밀어 넣도록 하고 그 다음에 Execute라는 함수를 하나를 파주도록 하겠습니다. 그리고 이제 FlashJob은 얘는 삭제를 할 거예요. 외부에서 따로 얘를 제정해서 사용하고 오버라이드해서 사용하고 이런 개념이 아니라 그냥 여기 내부에서 이 Push를 사용해주게 될 겁니다. 그래서 여기서 이제 이 Job을 , 이렇게, 만들어줬는데 걔를 바로 내부적으로 만들어준 이 Push라는 함수로 다시 , 이렇게, 토스를 해주도록 하겠습니다. 그리고 마찬가지로 여기서도 이 job을 만들어 준 다음에 바로 공용으로 이 push 함수에다가 , 이렇게, 집어 넣어 주도록 할게요. 공용으로 이제 함수를 하나를 만들어 가지고 관리해야지 두 번 작업할 필요 없으니까 , 이렇게, 일단 만들어 준 것이고 그 다음에 오른쪽에 job queue 영역을 , 이렇게, 만들어 줬고 그 다음에 push를 , 일단은, 정의를 해 주도록 하겠습니다. execute도 같이 implementation을 추가를 해 주도록 할게요. 그래서 이 함수를 push job을 호출하면 이제 앞으로 이쪽에다 떠넘기게 될 것이고 푸쉬잡이라고 하니까 뭔가 이름이 그냥 잡만 밀어넣고 나오는 이름이 들죠 그래가지고 이 이름도 toAsync라는 이름으로 수정을 할건데 이게 제가 예전에 일하던 프로젝트에서 사용하던 이름이어가지고 제가 좀 정들어서 이 이름을 좋아합니다 뭔가 비동기로 일을 실행한다 비동기라는 것 자체가 지금 실행할 수도 있고 나중에 실행할 수도 있고 이런 느낌이 드는데 실제로도 그런 컨셉으로 진행한다고 보시면 되겠어요 , 자, 그래서 , 이렇게, 일단은, 바꿔놨구요 , 자, 그럼 이제 오늘의 하이라이트는 무엇이냐 여기 푸쉬를 이제 어떻게 작업할 것이냐가 이제 관건인데 먼저 내가 처음으로 일감을 진행하는지를 추적하기 위해서 아톰이구로 변수를 하나를 두도록 하겠습니다 잡카운트라고 해가지고 0부터 시작을 하게 될 거에요 , 자, 그래서 맨 먼저 2를 들어올 때 얘가 뭔 먼저 해볼 거냐면은 , 자, 여기서 잡카운트에다가 Fetch Add를 해가지고 1을 더해줄 거에요 즉 아톰이크하게 잡카운트를 1 증가시켜주는데 Fetch Add가 반환하는 값은 원래 이전에 있던 값입니다 이전에 있던 값이기 때문에 여기서 만약에 이 프리프 카운트가 0이라고 하면은 내가 맨 처음으로 일감을 밀어 넣은 상태가 된다고 확신을 할 수가 있겠죠 그 다음에 여기서 카운팅하는 거와는 별개로 잡을 이쯤에다가 , 이렇게, 넣어주도록 하겠습니다 얘가 내부적으로 지금 라이트 락을 잡아가지고 넣어주고 있는 거죠 그러면은 여기서 이제 프리프 카운트가 0이라는 말은 무엇이냐 내가 결국에는 첫번째 잡을 넣은 쓰레드라는 얘기죠 첫번째 잡을 넣은 쓰레드가 실행까지 담당을 한다 라는게 굉장히 중요합니다 그래서 만약에 프릴 카운트가 0이면은 나는 이제 엑세큐트까지 빵 때리게 될 거에요 그럼 이제 Execute를 할 때는 무엇을 하는 것이냐? 그냥 루프를 돌면서 하나씩 하나씩 실행을 할 것인데 , 자, 일단은, 지금까지 쌓여있는 모든 잡을 PopAll 이라는 우리가 아까 만들어준 함수를 이용해가지고 , 일단은, 다 긁어온 다음에 이제 얘네들을 실행을 할 겁니다. 그래서 잡 카운트를 , 일단은, 세본 다음에 static cast를 해가지고 잡스의 사이즈를 , 이렇게, 한 다음에 이제 이걸 이제 하나씩 하나씩 실행을 해줄 겁니다. i는 0번부터 잡카운트 개만큼 i++을 한 다음에 잡스의 i번째를 execute 하겠다라고 , 이렇게, 해서 실행을 하나씩 하나씩 다 해준다는 얘기가 되는 거죠. , 자, 그 다음에 여기서 내가 잡카운트 개만큼을 실행을 했으니까 이제 잡카운트를 다시 줄여 줄 거에요 잡카운트에다가 fetch sub 을 해가지고 빼 줄 건데 잡카운트 개만큼을 빼 줄 겁니다 근데 얘도 마찬가지지만 여기서 리턴하는 값이 원래 내가 지금 아토믹한 이 빼기 연산을 하기 이전에 값을 뱉어 주게 됩니다 그렇다는 것은 만약에 이 잡카운트가 정확히 잡카운트 개만큼 이었다고 하면은 잡 카운트가 이제 딱 0으로 떨어지는 상황이 된다고 우리가 확신할 수가 있는 거죠. 원래 값이 딱 내가 빼준 값이랑 동일했다고 하면 이 결과물 자체가 이제 0이 된다는 얘기가 되는 겁니다. 즉 여기서 확인하고 싶은 거는 남은 일감이 0개라면 종료를 하고 싶다라는 로직을 실행하고 있는 거예요. 그럼 여기서 이제 빠져나오면 되겠습니다. , 자, 굉장히 단순한데 여기서 살짝 조심해야 될 게 몇 가지가 있어요 제가 이제 처음에 요런 코드를 본 다음에 저는 이제 좀 깔끔한 걸 좋아하기 때문에 막 순서를 뒤바꿔서 어 왜 굳이 여기서 프리프 카운트를 여기서 했지? , 이렇게, 막 뒤바꿔 보고 그랬습니다 근데 그러면 안 돼요 그러다가 제가 P를 본 경우가 있는데 어... 항상 , 이렇게, 카운트를 증가시킨 다음에 잡을 푸쉬를 하고 그 다음에 잡을 실행한 다음에 거꾸로 , 이렇게, 잡 카운트를 빼줘야 됩니다 , 자, 이게 어떤 차이가 있냐면은 유심히 보시면 되겠습니다 만약에 가정을 해보도록 할게요 이전에 어... 우선 여기서 한 가지 알아야 되는 거는 내가 만약에 첫 번째로 잡을 넣은 스레드라고 해서 여기 엑세큐트가 실행을 하고 있다고 가정을 하면은 그 와중에 다른 애가 내가 실행하고 있는 그 와중에도 또 일감을 밀어 넣을 수가 있습니다 굉장히 놀랍게도 그러면 지금까지 쌓인 일감이 10개라고 가정을 해볼게요 즉 여기 잡 카운트가 지금 10개가 되는 거죠 그래서 그 10개의 일감을 이제 실행시킨 다음에 그 카운트를 줄여야 되는데 여기다가 그 사이에 누군가가 일감 하나를 뿅 추가해가지고 이제 잡 카운트가 11개가 됐다고 가정해볼게요. 잡 카운트는 11개인데 아직 요 부분은 실행이 되지 않아가지고 잡스라는 요 라큐 자체에는 일감이 10개밖에 들어가 있지 않습니다. 그렇게 되면 이제 어떤 일이 발생하냐면은 잡 카운트를 내가 10개만 처리했기 때문에 여기서 빼주게 되면은 기존에 11개가 등록이 되어 있었기 때문에 11-10, 즉 0으로 떨어지지 않아가지고 리턴을 하지 않고 다시 한번 한 바퀴를 더 돌 수밖에 없게 됩니다 그래가지고 실질적으로 11개의 일감을 완벽하게 처리해가지고 내가 딱 모든 카운트가 0으로 떨어져야지만 리턴해서 빠져나오게 된다는 얘기가 되는 거죠 그러니까 사실상 요 두 흐름이 지금 가장 확실하게 할 거면 이걸 락으로 하나로 묶어 줘 가지고 그냥 무조건 세트를 맞춰 줘도 되고 , 이렇게, 따로따로 지금 변수를 두 개로 지금 분리를 할 거라면 먼저 카운트를 , 일단은, 등록한 다음에 그 다음에 푸쉬 해줘야 됩니다 만약에 순서가 뒤바뀌어 가지고 요렇게 된다고 하면 이제 약간 입장이 바뀌는 게 아까 상황에서 일감이 10개였고 이제 개를 하나씩 꺼내가지고 쓰려고 하는 그 와중에 누군가가 일감을 추가해서 일감이 11개가 됐다고 가정해볼게요. 그럼 여기서 카운트는 지금 11개를 실행했으니까 12일 만큼을 빼주려고 하는데 만약에 운이 나쁘게 요 부분이 아직 실행이 되지 않았가지고 잡 카운트가 아직까지 10개라고 하면은 이제는 이 잡 카운트를 뺐더니만 마이너스 1이 된다고 하는 굉장히 엉뚱한 상황이 발생할 수 있다는 얘기가 되는 거죠. 그래가지고 요 순서를 어지간하면 일단 지키는 게 정신건강에 좋다라고 보시면 되겠습니다. 그럼 요런 코드도 굉장히 흥미로운 코드예요. 그래서 확실히 먼저 들어온 애는 결국에는 이 아톰이칸 카운트가 0으로 딱 떨어질 때까지 계속 일감을 담당하고 실행하겠다는 굉장히 근성있는 형태로 이제 실행을 한다고 보시면 되겠습니다. , 자, 그래서 서머 전체 다시 빌드를 해가지고 문제가 없는지 한번 빌드를 해서 통과를 시켜준 다음에 서머 쪽에서도 당연히 이제 에러가 나겠죠? 우리가 파일 이름도 바꿔놨고 그 다음에 클래스 이름도 바꿔놨고 하다보니까 그 부분을 컴파일런트에다 넘겨가지고 , 이렇게, 잡아보도록 하겠습니다 잡 시리얼러스가 아니라 잡큐라고 하기를 했으니까 얘를 , 이렇게, 바꿔주면 될 것 같고 이거 혹시 만약에 단축키로 안하셨으면 요런 부분들도 에러가 날 테니까 이제 고쳐주셔야 되겠죠? 그 다음에 원래는 우리가 FlushJob이라고 해가지고 얘를 , 이렇게, 꺼내줘서 사용을 했었는데 요런 부분들은 이제 필요 없으니까 FlushJob은 그냥 날려주시면 되겠습니다 이건 필요 없으니까 , 이렇게, 날려주면 되겠죠 , 자, 그 다음에 다시 한번 빌드를 해보도록 할게요 그러면 이제는 PushAsync라고 아이고 DoAsync라고 이름을 바꿔놨으니까 그 부분에서도 또 이제 에러가 날 것으로 예상이 되는데 , 자, 요 부분도 이제 수정을 해보자면 기존에는 우리가 게임 서버 쪽에서 별도로 메인 스레드가 , 이렇게, 돌면서 플러시 잡을 해주고 있는데 이제는 그게 필요가 없었죠 푸쉬를 하는 순간에 밀어 넣는 순간에 같이 이제 실행을 담당하게 될 테니까 요 부분 , 일단은, 필요가 없을 것이고 그 다음에 이제 클라이언트 패킷 핸들러 쪽에 돌아가 가지고 기존에 우리가 여기서 PushJob을 하던 것을 doAsync라는 이름으로 이제 수정을 해주면 되겠습니다 그 부분을 제외하고는 뭐 딱히 달라진 점이 없으니까 , 일단은, 실행을 해보도록 할게요 일단 빌드를 해가지고 빌드가 통과하면은 뭐 , 사실, 뭐 큰 관점에서 보면은 코드가 딱히 달라진 점은 없기 때문에 뭐 정상적으로 일단 실행이 될 것으로 예상이 됩니다 그래서 한번 실행을 해가지고 클라이언트랑 서버랑 양쪽을 다 다시 , 이렇게, 설정을 해가지고 제가 프로젝트 설정을 날려놔서 다시 설정하고 있는데 클라이언트 서버 2개를 OK해서 실행을 하면 정상적으로 메시지가 출력이 될 것이라는 걸 예측을 할 수가 있습니다. 잠시 기다려서 실행을 해보면 실제로도 메시지가 정상적으로 뜨고 있다는 것도 확인할 수가 있었어요. , 자, 그래서 뭐 이런 식으로 바꾸면은 확실히 장점이 많죠? , 이렇게, 뭐 확실히 먼저 선점하는 애가 실행한다라는 개념으로 일단 바꿔놨으니까 누군가가 따로 챙겨가지고 걔를 이제 챙겨가지고 체크를 하면서 걔를 실행하고 하는 부분이 이제 다 날라갔다고 볼 수가 있는 거죠 그래서 굉장히 장점이 많은 방법이다 라는 것까지는 , 일단은, 알았는데 근데 이 방법이 뭐 당연한 얘기지만 아직까지 생각할 부분이 꽤 많습니다 그게 뭐냐면은 그냥 단순하게만 만든다고 하면은 , 사실, 포트폴리오 같은 경우는 , 이렇게, 만들어도 그냥 충분해요 근데 이제 진짜 진짜 MMORPG라고 해가지고 유저가 막 몇천명 몬스터도 몇십만개가 동작한다고 가정해볼게요 , 자, 그런 상태에서 , 이렇게, 잡규 방식으로 지금 처음에 오네가 실행을 한다 라는 로직으로 , 이렇게, 만약에 실행을 하게 되면은 , 일단은, 만약에 일감이 너무 많이 몰리는 상황이 발생하면 이제 어떻게 될까요 그러니까 내가 지금 여기서 실행을 하고 있는데 그 와중에 누군가가 계속 푸쉬 해가지고 여기서 이 일감을 계속 계속 밀어 넣는 거죠 그러면은 나는 여기서 일감이 빠르게 끝나서 0으로 떨어져야지만 리턴을 할 수 있는데 일감을 막 실행하는 와중에 누군가가 계속 넣다보면은 노예가 되고 여기서 아예 빠져나갈 수도 없는 상황이 발생할 수 있는 겁니다 근데 일반적으로 MMO에서는 당연히 워낙 많은 사용자들이 있다 보니까 렉이 걸릴 거라면 공평하게 렉이 걸려야지 한에는 정상적으로 코드가 잘 실행이 되고 잘 움직이는데 나머지 유저들은 렉이 걸려가지고 막 3초 동안 못 움직이고 하는 거는 굉장히 불공평해지겠죠 진짜 렉이 걸릴 거라면 공평하게 다 똑같이 렉이 걸려야 됩니다 그래가지고 한쪽만 , 이렇게, 몰빵해가지고 실행한다는 게 살짝 아쉽긴 합니다 그리고 이게 진짜 발생하지 않을 것 같지만 잘 유심히 생각을 해보면 , 사실, 이번 문제도 어떻게 보면 1번이랑 약간 연장선이라고 볼 수 있는데 우리가 do async라는 걸 지금 호출해줘가지고 뭔가 , 이렇게, 일감을 밀어넣고 실행하는 식으로 만들어놨는데 이거를 타고 타고 가가지고 절대 끝나지 않는 상황이 또 발생할 수도 있어요 일감이 한 스레드한테 올린다는 얘기가 되는 거죠 지금 무슨 얘기냐면 여기서 우리가 예약한 일감이 execute에 의해가지고 이제 실행이 될 겁니다 그래가지고 뭐 우리로 치면 예를 들면 지금 룸에서 뭐 엔터 요런 코드가 실행이 된다고 볼 수가 있는 건데 만약에 어떠한 이유로 여기서 또 똑같이 요 플레이어스에다가 toAsync로 출해가지고 여기서 뭔가를 막 이런 식으로 또 요런 비동기 코드를 막 밀어 넣었다고 가정을 해볼게요 그러면은 결과적으로 다시 타고 타고 가가지고 생각을 해보면 우리 잡큐에서 분명히 엑세큐트를 하고 있는데 이 엑세큐트를 타고 가다보니까 다른 객체, 다른 잡큐에 엑세큐트를 또 실행해가지고 다른 객체도 동일한 스레드가 담당해가지고 여러 명을 지금 내가 담당하게 될 수도 있다는 얘기가 되는 겁니다 정말 운이 나쁘게 첫 번째 스레드가 정말 여유로울 때 걔가 시작을 해가지고 시작을 했는데 그게 약간 나비 효과로 딴 애의 잡규도 건드리고 견드리고 건드리고 해다가 보니까 결국에는 모든 경우에 대해서 걔가 일바로 들어와가지고 다 실행을 해야 된다고 하면은 타고 타고 타고 가가지고 막 모든 일감을 다 실행하다 보니까 결국에는 얘가 영영 끝이 안 나고 계속 실행해야 되는 상황이 발생할 수 있다는 얘기 되는 거죠 반면 다른 스레드들은 뒤늦게 이제 잡을 푸쉬했더니만 어? 누가 이미 있네? 라고 쿨하게 떠넘기고 나는 1바가 아니니까 그냥 가도 되겠구나라고 그냥 빠져나올 수 있다는 얘기가 되는 겁니다 굉장히 끔찍한 얘기죠 그래서 이 방식이 지금까지는 굉장히 단순하긴 하지만 이런 상황에 대해서 어떻게 처리할 것인지에 대해서는 고민을 할 필요가 있다는 거 보시면 되겠습니다 근데 이건 이제 다음 시간에 알아볼 내용이긴 한데 , 일단은, 좀 미리 얘기를 해봤어요 그래서 이왕이면 일감이 좀 배분이 적당히 될 수 있게끔 유도를 해주는 게 좋을 것이다 라고 , 일단은, 볼 수 있겠습니다. 하지만 오늘 뭐 그래도 꽤 많은 그런 발전을 이뤘다고 생각이 되고요. 이런 식으로 이제 앞으로 ToAsync를 통해 가지고 일감을 밀어 넣자마자 실행하는 형태로 코드가 바뀌게 되었습니다. , 이렇게, 해서 이번 강의를 마치도록 할게요.