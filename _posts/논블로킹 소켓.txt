자, 이렇게, 지난 시간에 다양한 소켓 옵션을 우리가 지정할 수 있다는 거에 대해서 간략하게 알아봤고요 이제 이어가지고 우리가 다음 시간부터 우리가 본격적으로 실질적으로 사용할 수 있는 그런 다양한 소켓 모델에 대해서 알아보도록 할 겁니다 근데 이제 그 전에 소켓 모델이 왜 필요한지는 일단 알고 넘어가야 되겠죠 그래서 오늘 수업은 이제 논블록킹 방식의 소켓에 대한 내용을 다뤄보고자 합니다 그래가지고 지금까지 우리가 알게 모르게 사용했던 소켓 방식은 , 사실, 블록킹 방식이에요. 블록킹. 그러니까 블록킹이랑 논 블록킹이 있는데 말 그대로 블록킹은 뭔가 막는다라는 의미고 논 블록킹은 막지 않는다라는 의미가 있겠죠. 그래서 실질적으로 우리가 지금까지 했던 거를 곰곰이 잘 생각을 해보면 이게 왜 블록킹 소켓이냐고 불리냐면은 억셉트를 하거나 connect를 하거나 아니면 send, send to 그리고 receive, receive from , 이렇게, 여러가지 함수에 대해서 우리가 알아봤죠 근데 , 사실, 요 각각이 어떻게 해야지만 함수가 완료가 되는지 성공적으로 return이 되는지를 보면은 얘는 이제 접속한 클라가 있을 때 accept가 성공을 했었죠 그리고 Connect 같은 경우에는 거꾸로 클라가 서버에 접속을 성공했을 때 Connect가 리턴이 되었습니다. 이건 이제 TCP 기준으로 얘기하는 거죠. 그 다음에 Send 같은 경우에는 요청한 데이터를 송신 버퍼에 복사했을 때 비로소 Send가 완료가 될 테고 Receive 같은 경우에는 거꾸로 수신 버퍼에 도착한 데이터가 있고 최소한 1 바이트라도 있고 이를 유저 레벨 버퍼에 복사 했을 때 비로소 완료가 되는 겁니다 , 자, 그래가지고 이거를 뭐 우리가 이전 시간까지 계속 뭐 열심히 실습을 해봤으니까 대충 어떤 느낌인지는 이제 아시리라고 생각을 하고 그래 뭐 당연한 얘기지만 이거를 이용해 가지고 우리가 뭐 게임을 만든다 라고 하면은 굉장히 여러가지 문제가 있다고 했었죠 , 이렇게, 어 뭔가가 완료가 될 때까지 대기를 탄다는 것 자체가 , 사실, 문제인 상황입니다 우리가 MMORPG 기준으로는 막 동접이 5,000명씩이나 될 수 있는데 클라네트가 5,000명이 붙었는데 그 중에서 우리가 샌드랑 리시브를 할 때마다 계속 어떤 프로세스가 대기를 타고 먹통이 되는 그런 현상이 일어난다고 하면은 , 사실, 굉장히 끔찍한 문제가 아닐 수가 없습니다. 그렇다고 쓰레드를 클라이언트 개수만큼 늘려가지고 5,000개를 만들어가지고 1대1 대응을 시켜가지고 한다고 치면은 이제 스레드끼리 컨텍스 스위칭 비용이 너무 심해져가지고 그것도 이제 딱히 좋은 방법은 아니긴 하겠죠 그래서 어찌됐건 언젠가는 이제 논블록킹 방식으로 넘어가야 된다라는 건 이제 여러 차례 말씀을 드렸는데 근데 논블록킹으로 무조건 바꾼다고 해가지고 모든 문제가 당연히 해결되진 않습니다 그래서 오늘은 , 일단은, 간단하게 논블록킹에 대한 실습을 해볼 건데요 , 자, 이제 논블록킹 방식으로 우리가 지난번에 만들었던 요 echo-tcp 서버를 다시 한번 간단하게 만들어 보도록 할게요 좀 반복된 내용이 있긴 한데 뭐 빠르게 만들어 보도록 하겠습니다 소켓을 만들 것이고 af-internet-soc-stream tcp로 만들 것이고 0 그 다음에 listen-socket이 만약에 invalid-socket이다라고 하면은 return을 그냥 때려주도록 할게요 오늘은 그냥 에러핸들은 그냥 뭐 건너뛰도록 합시다 귀찮으니까 , 자, 그 다음에 여기서 그냥 소켓을 만들면은 얘가 이제 원래 블록킹 방식이었는데 얘를 논블록킹 방식으로 만들고 싶으면 굉장히 단순합니다. 그냥 함수 하나만 호출해주면 되요. ioctl socket 이라는 요 함수를 이용해가지고 listen socket fionbio 그 다음에 여기다가 옵션을 요렇게 넣어주면 되는데 얘를 u under bar long이란 타입으로 받아주고 있어요 그래서 얘를 요렇게 해주면 됩니다 그럼 뱉어주는 값은 얘가 만약에 invalid socket이다 라고 하면 역시나 뭔가 문제상황인 거니까 , 이렇게, 리턴을 해주시면 되겠어요 이것도 뭐 기회가 되면은 , 자, mstn을 살펴보면은 ioctl socket이라는 굉장히 친절한 함수가 무엇을 하는 건지 정확히 이제 설명이 나타나 있습니다 그리고 어 이제 대표적으로 우리가 이거를 블록킹 방식에서 논블록킹 방식으로 바꾸고 싶을 때 사용을 하는 것이고 여기서도 이런 식으로 이 옵션을 이용해가지고 사용하라는 예제코드가 있는 걸 볼 수가 있습니다. 그래서 , 이렇게, 하면 이제부터는 논블록킹 방식으로 동작을 한다는 걸 알 수가 있는 거죠. 그건 그렇고 어찌됐건 기존과 마찬가지로 서버 주소를 맵핑하는 것은 똑같이 들어가야 될 테고요. 맵셋, 서버 어드레스를 0으로 , 일단은, 한번 정리를 해 줘 가지고 쓰레기 값을 다 0으로 밀어 주고 그 다음에 서버 어드레스의 SYN FAMILY를 AF INET으로 바꿔 준 다음에 서버 어드레스의 SYN ADDR을 host-to-network-long in-address-any 이걸 해가지고 어떤 애들이 있나 상관없이 맵핑을 알아서 해라 라고 해준 다음에 포트는 우리가 따로 지정을 해줘야 됐었죠 scene-port는 host-to-network-short 7777로 세팅을 해준 다음에 그 다음에 바인드는 그대로 해주도록 합시다 listen-socket socket-address 포인터를 받아주고요 그 다음에 size of server address를 받아주는데 만약에 여기서 얘가 바인드가 실패했다고 하면 소켓 에러가 틀뜨니까 소켓 에러를 체크해서 만약에 이게 실패했으면 리턴을 때리도록 할게요. 그 다음에 역시나 마찬가지로 listen까지는 이게 블록킹이건 아니건 별다른 차이가 없습니다. listen socket을 그 다음에 여기다가 백로고를 입력해도 되구요 명시적으로 숫자를 입력하지 않고 알아서 최대 숫자로 골라 달라고 하면은 so maxcon 이라는게 있습니다 이걸로 그냥 넣어주셔도 되요 이 아이로 maxq, Maximum Q Length 라고 하죠 그 다음에 이게 또 역시나 socket error 라고 하면은 문제가 있는 거니까 , 일단은, return 0을 때려주고 , 자, 여기부터 이제 달라지게 됩니다 여기까지 왔으면 이제 우리가 accept 를 호출해주겠다라고 로고를 찍고 진행을 해보도록 할게요 , 자, 그런데 원래 accept를 할 때 대충 이런 느낌으로 만들었었죠 우리가 accept를 한다 그 다음에 listen-socket을 넣어주고 여기다가 socket-address랑 int-address-length라고 해가지고 이제 받아줄 상대방 클라이언트의 주소를 채워줄 수 있는 그런 sock-address-in을 우리가 여기다가 입력을 해줬습니다 address-length는 size of client-address 그 다음에 얘를 똑같이 속 address 포인터 타입으로 캐스팅해서 클라이언트 어드레스와 어드레스 렌스를 , 이렇게, 넣어 줬던 것은 똑같죠 근데 여기서 이제 달라지는 건 뭐냐면은 원래는 우리가 얘를 체크해 가지고 인벨리 소켓이 떴다고 했을 때 인벨리 소켓이 떴다는 거 자체가 뭔가 문제가 있는 상황이었고 여기서 그냥 우리가 리턴을 때려줬습니다 그런데 그거는 어디까지나 블록킹 방식의 소켓에 대한 얘기고 이제 논블록킹으로 넘어오는 순간 얘가 , 이렇게, 인벨리 소켓으로 뜨는 게 꼭 문제 상황이라고는 볼 수가 없어요 그러니까 우리가 애당초 기다리지 않고 일단 빠져나오라고 했으니까 얘는 분명히 성공적으로 완료가 되지는 않았다는 얘기는 되는 거지만 그게 진짜로 문제가 있어서 그렇다는 보정은 없고 그냥 원래 블록킹을 했어야 되는 상황에서 우리가 논블록킹을 하려고 , 이렇게, 바꿔치기를 해준 덕분에 얘가 그냥 빠져나왔을 수도 있습니다 그러니까 얘가 이제 그냥 뒤끝이 장려를 하는 거죠 원래 블록 했어야 했는데 너가 논블록킹으로 하라며 라고 지금 우리한테 시위를 하고 있는 거죠 그래서 이걸 한 번 더 체크해 가지고 wsa-getlast-error를 이용해 가지고 얘가 옵션 코드가 뭐인지를 봤는데 만약에 wsae-would-block 이라는 요 번호라고 하면은 얘는 , 사실, 문제 상황은 아니고 그냥 데이터가 아직 오지 않았다거나 리시브 샌들을 할 때 뭔가 완료가 되지 않았다거나 아니면 그냥 억셉트를 하는데 나한테 커넥트를 요청한 클라이언트가 없는 그런 상황에서는 얘가 그냥 , 이렇게, 에러가 뜨면서 이 이붓 블럭이라는 에러가 뜹니다. , 사실, 얘는 문제의 상황은 아니고 진짜 말 그대로 우리가 강제로 빠져나오게 했는데 그 빠져나올 때까지 아직 별다른 완료 통지가 되지 않는 그런 상황이라고 볼 수가 있는 거죠. 그렇기 때문에 이거를 한 번만 하면 안 되고 될 때까지 집요하게 계속 우한 루프를 돌면서 시도를 해보게 될 겁니다. wsa-get-last-error 에러코드 같은 것도 종종 필요하게 되는데 이걸 참고해 가지고 혹시라도 문제 상황이 있을 때 이거를 이제 이 넘버 코드를 봐 가지고 이게 어떤 상황인지를 다 , 이렇게, 찾아보시면 되겠습니다. 에러 버그 잡을 때 굉장히 유용하고요. 여기까지 , 이렇게, 왔는데 하필이면 얘가 요 에러라고 하면은 이거는 , 사실, 문제 상황이 아니니까 컨티뉴 해 가지고 다시 시도를 하는 식으로 동작을 할 것이고 근데 여기까지 들어갔는데 이 에러가 아니었으면 진짜 뭔가 문제있는 상황이긴 하겠죠 그러니까 뭔가 그냥 브레이크를 때려주고 여기서는 , 사실, 뭔가 , 이렇게, 에러가 있는 거라고 인지를 할 수 있겠습니다 근데 여기서 일단 여기 안 들어오고 빠져나왔다는 거는 뭔가 접속이 있었다 클라이언트가 접속했다 라는 굉장히 기쁜 신호라고 볼 수 있는 거죠 , 자, 그러면 그 다음에 똑같이 원래 우리가 하던 방식에서는 클라이언트가 메시지를 보낸 다음에 얘가 리시브하고 그 다음에 리시브한 거를 바로 에코 서버처럼 토스해가지고 다시 돌려 보냈고 다시 클라이가 받는 그 작업을 해봤는데 그걸 한번 똑같이 구현을 해보도록 합시다 근데 여기서도 마찬가지로 이게 accept를 위한 루프였다고 하면은 여기서도 이제 똑같은 문제가 발생합니다. receive 같은 경우에도 우리가 receive 함수를 이용해가지고 , 자, 이런식으로 receive 버퍼를 우리가 넣어줬었죠? 대충 뭐 1000바이트 짜리로 넣어주도록 합시다. receive를 해주세요. client-socket을 대상으로 receive-buffer-sizeof-receive-buffer를 , 이렇게, 넣어주고 마지막 플래그는 0으로 , 이렇게, 했으면 이때 Receive Length라는게 , 이렇게, 튀어나왔었죠 근데 역시나 원래는 Receive Length를 확인해가지고 얘가 음수면은 즉 Socket Error라는 마이너스 1로 뜨면은 그냥 문제가 있는 상황이었으니까 원래는 우리가 , 이렇게, 했었죠 이게 0보다 작으면 그냥 무조건 문제 있는 상황이다 라고 인지를 했었어요 근데 이번에도 마찬가지로 얘가 음수로 떴다고 해서 그게 진짜 문제 있는 상황이라는 보장은 없습니다 연결이 진짜 끊겨 가지고 문제가 일어왔을 수도 있지만 그게 아니라 역시나 요 마찬가지로 요 상황과 마찬가지로 우리가 논블록킹으로 바꿔놨으니까 야 너가 논블록킹으로 하라며 그래서 나는 빠져나온 거야 라고 지금 땡깡을 부릴 수가 있어요 그럼 그 상황에서는 역시나 이 에러 코드를 뱉었다고 하면은 이건 딱히 문제상황은 아니고 그냥 아직까지 더미 클라이언스 쪽에서 데이터를 안보내가지고 이쪽에 이제 리시브 퍼퍼가 비어있는 상황이니까 그건 딱히 문제라고 볼 수는 없겠죠 그래가지고 얘도 그냥 컨티뉴을 때려줘야 되고 근데 여기 들어왔으면은 진짜로 뭔가 문제가 있는 상황이겠죠 그리고 마찬가지로 Receive Length가 만약에 0이다 0으로 딱 떨어지게 정확히 0이 왔다고 하면 이거는 그냥 무조건 연결이 끊긴 상황이라고 보면 되니까 그냥 , 이렇게, 브레이크를 해주도록 하겠습니다 아주 벌써부터 좀 짜증나는게 리셉을 할 때마다 얘가 진짜 진짜 에러인지 아니면은 그냥 가짜 에러인지 그러니까 , 이렇게, 원래 블록킹 상황에서 빠져나온 것인지를 계속 구분을 해주다 보니까 코드가 굉장히 더러워지는 걸 벌써 느낄 수가 있습니다 어찌됐건 멘탈을 부여잡고 우리가 원래 하던 걸 계속 진행을 해보자면 여기까지 왔으면 , 일단은, 데이터를 받은 거라고 가정을 할 수가 있겠죠 , 자, 데이터를 받았으니까 대충 로그를 한번 찍어 보도록 합시다 이 정도로 데이터를 받았다 그 다음에 이제 샌드를 똑같이 토스를 해 줘 가지고 다시 반사를 해 줄 건데 샌드도 역시나 똑같은 문제가 있어요 얘도 마찬가지로 샌드를 했다고 해 가지고 바로 성공한다는 보장이 없습니다 어 샌드 실패하는 이유는 뭐 여러가지일 수 있겠지만 내가 상대방 쪽에 이제 보내야 되는데 상대방이 자신의 그 리시브 버퍼를 비우지 않아 가지고 공간이 없어 가지고 내가 못 보내는 상황도 있을 수 있고 뭐 굉장히 다양한 상황이 있을 수가 있겠죠 그렇기 때문에 얘도 마찬가지로 샌드를 하고 싶은데 클라이언트 소켓에다가 리시브 버퍼에 있던 값을 우리가 리시브 렌스만큼 받은 값을 그대로 다시 토스를 하고 싶다라고 했을 때 이게 만약에 또 소켓이 내려가 뜨면 역시나 원래 블록 했어야 되는데 네가 논블록 하라며 라고 불만이 있는 상황이 발생할 수 있다는 얘기가 되는 거죠 만약에 또 여기 들어오면 여기는 진짜 또 문제가 있는 상황이라고 볼 수가 있겠습니다 그래가지고 뭐 이런식으로 하다가 여기서 아래로 넘어왔으면 , 일단은, 성공적으로 데이터를 보낸 상황이겠죠 샌드 데이터 얼마를 보냈나 리시브 램 만큼을 보냈다 라고 한 다음에 샌드에서 , 이렇게, 빠져나오도록 하겠습니다 그래서 이거를 계속 반복해주면 되겠죠 근데 벌써 딱 봐도 코드가 와일문이 일단 3개가 들어간 걸 볼 수가 있습니다 네 그래가지고 , 이렇게, 해가지고 , 일단은, 리시브 받은 거를 그대로 샌드한다라는 코드는 뭐 대충 완료가 되었고요 이제 반대쪽에서도 똑같이 테스트를 하기 위해서 클라이언트도 작업을 해보도록 하겠습니다. 대칭적이죠. , 자, 그러니까 , 일단은, 위에 부터 시작을 하면은 소켓을 만드는 부분 똑같이 복원을 해주고 얘는 이제 클라이언트 소켓이라고 이름을 지어주면 되겠죠. 속 스트림으로 해가지고 tcp 소켓으로 분명히 만들어주고요. 그 다음에 ioctl 소켓이라고 해가지고 이제 논 블록킹으로 얘를 바꿔치기를 해주는 부분을 그대로 복붙을 해주도록 하겠습니다. , 자, 그 다음에 어 서버 어드레스 채워주는 요 부분 서버 어드레스를 일단 맵셋으로 깔끔하게 쓰레기값을 밀어준 다음에 포트 설정 그 다음에 주소는 이게 아니라 이제 상대방한테 내가 붙는 거니까 inetp2n 그 다음에 여기다가 주소를 , 이렇게, 입력했었죠? 001 그 다음에 서버 어드레스에 씬 어드레스를 , 이렇게, 입력을 하면 내가 원하는 주소에 접속할 수 있게끔 세팅이 되었고 그 다음에 얘도 이제 커넥트를 해주도록 하겠습니다 커넥트 같은 경우에도 이런 식으로 커넥트를 하에서 클라이언 소켓을 대성으로 속 어드레스 서버 어드레스로 붙어주세요 라는 요청을 우리가 , 이렇게, 해줄 겁니다 살짝 땡겨서 보여 보도록 할게요 얘가 만약에 어 쏘케 내려다 그 마이너스 1 이다라고 하면은 , 일단은, 당장 성공은 하지 못한 상황이긴 하겠죠 그럼 요 경우에도 뭐 당연히 이제 거의 공식처럼 야 원래 블록 했어야 되는데 너가 논블록키로 하라며 라는 상황이 있을 수도 있어요 그런데 , 사실, 샌드랑 리시브랑 조금 다르게 커넥트 같은 경우에 얘가 woot 블럭으로 떴다는 것은 아직 진행 중이다라는 의미가 되는 겁니다 사실상 커넥트를 계속 지금 시도하고 있는 그 중간 단계라고 볼 수 있는 거예요 그래서 그 상황에서 다시 커넥트를 하면 두 번째에서는 내가 이미 이전에 커넥트 시도를 했으니까 이미 커넥트를 했는데 왜 또 시켜? 라고 불편을 하게 됩니다 그래가지고 두번째 에러메시지 체크를 할거는 라스트 에러가 만약에 wsae iscon 이미 연결중인 상태면은 그냥 성공적으로 연결된 상태라면 그냥 브레이크를 때려주도록 할게요 근데 여기까지 왔으면 진짜로 뭔가 문제가 있는 상황이겠죠 여기서 뭐 로그를 찍는다거나 해가지고 빠져나오면 되겠습니다 물론 그냥 무드 블록으로 떴을 때 뭐 브레이크에도 크게 상관은 없기는 해요 얘는 좀 특이한 경우죠 그래가지고 요렇게 해가지고 어쨌든 우리가 이제 논블록킹 방식에서도 요 커넥트 방식을 그니까 커넥트 함수를 똑같이 사용을 해가지고 성공할 때까지 대기를 탔구요 여기까지 왔으면은 Connected to Server 라는 걸 확신을 할 수가 있는 거죠 , 일단은, 연동은 되었다 연결은 되었다 그러면 이제 우리가 원래 했던게 여기서 샌드 버퍼를 만들어가지고 100바이트짜리로 대충 뭐 헬로월드를 넣어준 다음에 그 다음에 샌드를 이제 보내주면 되는데 얘도 대칭적이다 보니까 요 부분을 똑같이 넣어주면 되겠습니다 , 이렇게, 복붙을 한번 해보도록 할게요 그러면은 샌드 버퍼에다가 사이즈 오브 샌드 버퍼를 즉 100바이트를 그냥 다 싸그리 보내주도록 할건데 여기서 샌드가 실패했다고 하더라도 꼭 문제가 있는 상황은 아니고 그냥 우리가 논블록링 특성상 실패했을 수도 있으니까 , 이렇게, 한 번 더 에러 체킹을 하고 넘어가도록 하겠습니다 여기까지 넘어왔으면 우리가 사이즈오브 버퍼만큼을 보내준 것일 테고 그 다음 턴에는 이제 우리가 거꾸로 상대방이 보내준 거를 어 우리가 이제 리시브를 해야 되는 상황이 되겠습니다 , 자, 근데 이걸 브레이크는 하지 않고 그냥 1초마다 이거를 해보도록 할게요 디스 스레드 슬립 포 1초 그 다음에 여기서 이제 이어서 리시브를 해주면 되겠죠 , 자, 리시브 코드도 어 이제 대충 복붙을 해줄 건데 , 자, 여기서 한 여기까지만 일단 복붙을 해보도록 하겠습니다. 닫아주고 , 자, 여기서 이제 리시브 코드가 실행이 되는데 리시브 버퍼를 1000 바이트만큼 , 일단은, 할당을 했고요. 리시브를 시도했다가 소켓 에러맨은 체크를 해가지고 진짜 에러인지 아니면 그냥 논블록킹 특성상 그냥 에로로 빠져나온 것인지를 체크를 할 것이고 나머지 부분은 동일하고 그 다음에 여기까지 엘스위프까지 통과해가지고 일로 넘어 왔다 가면은 데이터를 성공적으로 받은 거니까 여기 리스윕 데이터 렌스라는 로그를 , 이렇게, 찍어 주도록 하겠습니다 , 자, 이제 뭐 브레이크문도 막 지저분하게 이리저리 막 놀고 다니고 이러다 보니까 어 요 코드를 뭐 한방에 맞아 떨어질 수도 있지만 아니면 그냥 뭐 올려놓은 코드를 보고 혹시 다른 점이 있는지를 체크해 주시면 되겠습니다. 그 다음에 속성이 가가지고 클라이언트랑 서버가 동시에 켜져 있는 것을 확인한 다음에 이제 F5로 한번 테스트를 해 보도록 할게요. 그래가지고 양쪽에 보면은 지금 서버랑 클라이언트가 정상적으로 데이터를 주고 받고 하는 거는 , 일단은, 힘들게 복구를 해서 진행이 된다는 건 알 수가 있었습니다. 근데 이제 성능을 측정해보면 원래 우리가 블록킹 방식으로 하던 거에 비해서 , 사실, 더 효율이 안 나올 겁니다. 그러니까 무조건 블록킹 방식을 논블록킹 방식으로 바꿨다서 뭔가 좋아진다는 보장은 전혀 없다는 얘기가 되는 거죠 사실상 데이터가 뭔가 오지 않았다거나 아니면 내가 보낼 상황이 아니었다거나 하는 등등의 상황이 있거나 혹은 내가 억세트를 하는데 아직 나한테 붙은 커넥트 요청을 한 클라이언트가 아무도 없다고 하면 , 사실, 굳이 , 이렇게, 뺑뺑이를 돌면서 계속 여러번 체크하기보다는 진짜로 누군가가 올 때까지 대기를 하는게 이 상황에서는 훨씬 더 깔끔했겠죠 왜냐면 지금 우리가 만들고 있는 이 코드는 1대1인데다가 얘가 붙고 send, receive, send, receive라는 굉장히 명확한 순서가 있다 보니까 이런 경우에는 , 사실, 이걸 굳이 , 이렇게, 논블록킹으로 해줄 필요가 없었을 겁니다 오히려 이게 이런식으로 무한 루프를 돌면서 불필요하게 계속 체크를 하는 요런 부분이 굉장히 CPU 사이클을 많이 소모하고 있는 거죠 그러니까 우리가 예전에 락을 만들 때도 , 사실, 비슷한 문제가 있었는데 우리가 스피드 락이라고 해가지고 약간 근성 메타라고 제가 표현을 한 루프를 계속 돌면서 야 됐냐 됐냐 됐냐 체크하는 그 방법이 사실상 우리가 지금 만들고 있는 요 방법이라고 볼 수가 있는 거고 그게 아니라 원래 우리가 이전에 사용했던 블록킹 방식은 어... 소위 직원한테 부탁하는 그 갑질 메타였죠 다시 난 자리로 돌아갈테니까 뭔가 일감이 어... 화장실이 비면 알려줘 일감이 뭔가 생기면 알려줘라는 그 방식으로 사용했었는데 이런 상황이라고 한다면 , 사실, 후자가 훨씬 더 깔끔한 방법일 겁니다 지금 딱 봐도 , 이렇게, 불필요하게 내가 안 되는 상황이라는 걸 체크하기 위해서 굳이 빠져나와 가지고 할 필요가 전혀 없었고 그 다음에 이거를 무한 루프로 돌면서 하다 보니까 성능도 안 좋을 뿐더러 코드도 지금 굉장히 난잡해졌다는 걸 볼 수 있습니다 뭔가 , 이렇게, 보내고 받고 보내고 하다 보니까 루프가 벌써 와일 3중 루프로 되어 있는 굉장히 끔찍한 상황이라는 걸 볼 수가 있습니다 , 자, 그래가지고 결국 여기서 얻을 수 있는 결론은 뭐 두가지인데 , 일단은, 뭐 논블록킹 소켓이라는게 뭐 그렇게 어마어마하게 어렵진 않구나 일단 , 이렇게, 옵션 하나만 설정하면은 얘가 이제 논블록킹 방식으로 동작한다는 것이구나 라는걸 , 일단은, 첫번째로 알았고 두번째로는 결국에는 그냥 논블록킹만으로 바꾸면은 문제가 다 알아서 해결이 되는게 아니라 이제 요런 부분을 어떻게 케어할지를 곰곰히 생각을 해봐야 된다는게 되는거죠 지금 역시나 가장 문제가 되는 것은 애당초 불필요하게 , 이렇게, 우리가 루프를 돌면서 무한 루프를 돌면서 체크를 하는 것 자체가 , 사실, 굉장히 마음에 안 듭니다 나중에 소켓이 하나만 있는 게 아니라 얘가 막 진짜 어마어마하게 소켓이 많아져 가지고 연결을 몇 천명씩 받아줘야 되는 상황이라고 한다면 이런 식으로 무한 루프를 돌면서 모든 소켓을 대상으로 계속 , 이렇게, 체크를 하면서 리시브 왔냐? 샌드 하고 싶은데 나 샌드 성공했냐? 라는 거를 , 이렇게, 루프를 돌면서 하는 건 , 사실, 미친 짓거리일 겁니다 , 이렇게, 할 수가 없다는 얘기가 되는 거죠 그래가지고 뭔가 어떤 우리가 만들건 아니면 시스템에서 제공을 하건 , 이렇게, Woodblock이지 않은 애들만 뭔가 , 이렇게, 집어 가지고 실행할 수 있게끔 뭔가 , 이렇게, 만들어 주면 우리가 노블록킹 방식의 이점도 활용할 수 있으면서 게다가 이런 식으로 불필요한 CPU 사이클 낭비를 방지할 수 있지 않을까 라는 생각이 드는데 당연한 얘기지만 그런 것들이 다 존재합니다 근데 이제 그게 여러가지 방식이 있어요 그래가지고 그걸 소위 소켓 모델이라고 하는데 다음 시간부터 본격적으로 여러가지 소켓 모델에 대해서 이제 알아보면서 어떤 식으로 작업을 할지 이제 또 살펴보도록 하겠습니다.