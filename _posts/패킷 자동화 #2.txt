자, 이렇게, 패킷 직렬화에 대한 내용을 우리가 한동안 쭉 다뤄봤구요 이번이 이제 마지막 시간인데 지난번에 , 이렇게, 만들었던 코드들을 자동화하는 툴을 만들어 보는 것으로 이 패킷과 관련된 내용을 이제 마무리를 짓도록 하겠습니다 그래서 지난 시간까지 우리가 서버 패킹 핸들러라는 걸 만들어 가지고 , 이렇게, 잘 사용을 하고 있었다 까지 , 일단은, 끝냈었는데 이제 나중에 가면은 이거를 우리가 손수 한 땀 한 땀 만들기 보다는 자동화된 코드로 이 파일을 만들어주면 굉장히 좋을 것 같다는 생각이 들죠. 특히나 이제 해야 될 일이 그럼 오늘 해야 될 일이 무엇인지를 곰곰히 생각을 해보면 여기 있는 프로토 파일, 이 프로토 파일을 우리가 뿅 건네주면은 얘를 파싱 해가지고 여기 메시지 모시기 모시기로 되어 있는 부분을 인지해가지고 s-test, s-login 이런 식으로 패킷을 각각 인지해가지고 이제 이 파일을 쫙 만들어주면 됩니다 그래서 여기 2도 자동화 하라고 했는데 엄밀히 말하면은 , 자, 자동화 해야 될 부분이 어딘지를 먼저 생각을 하고 2를 만들어 보도록 합시다 여기가 아니라 사실은 정확히 말하면 여기 안쪽이죠 여기 안쪽에 패킷 목록이 이제 쭉 들어가게 될 겁니다 아 그리고 오늘은 이제 C 언더바 테스트라고 해가지고 클라이언트 쪽 패킷도 , 일단은, 하나를 뭐 , 이렇게, 간단하게 만들어 놓고 시작을 하도록 할게요 그럼 여기 자동화되는 부분에서 나중에 이제 뭐 클라이언트와 관련된 부분도 같이 섞여서 들어가게 되겠죠 패킷 여기서 들어가게 될 거고 그 다음에 커스텀 핸들러 부분 중에서 요 부분 핸들 모시기 모시기 상대방 쪽에서 나한테 보내주는 그 패킷을 핸들러 함수로 넘겨주는데 그 부분을 이제 여기서 쭉 늘어야 될 것이고 이 부분도 이제 여기 있는 패킷 개수에 따라가지고 쭉 늘어가면 되겠죠 그 다음에 마찬가지로 이닛하는 부분도 여기 아래 부분부터 이 부분을 자동화하면 될 것이고 마지막에 그냥 샌드 버퍼에다가 이 버전으로 , 이렇게, 오버워딩 해주는 부분은 그냥 하나씩 패킷마다 늘려주면 되겠습니다. , 이렇게, 일단은, 작업을 해보도록 할게요. 그리고 지금은 서버 쪽에 있는 패킷 핸들러를 우리가 서버 패킷 핸들러라고 이름을 지긴 했는데 나중에 생각을 해보면 이제 클라이언트에서 서버로 보내는 패킷도 있겠지만 다른 서버에서 이 서버로 게임 서버로 보내는 패킷도 섞이게 되겠죠 그러다 보면 이 서버 패킷 핸들러 라고 하면은 좀 이름이 너무 광범위하니까 상대방 누가 나한테 보내느냐로 이름을 지어보도록 할게요. 만약에 클라이언트 쪽에서 나한테 보내는 패킷을 처리하는 그런 부분이라고 하면 이 파일을 서버 패킷 핸들러가 아니라 클라이언트 패킷 핸들러라고 짓는 게 조금 더 직관적일 것 같네요. 그래서 이 이름을 일단 뒤집어 볼 거예요. 더미 클라이언트에서는 서버 패킷 핸들러 들고 이쪽에서는 클라이언트 패킷 핸들러로 들고 있도록 하겠습니다. 그래야지 나중에 뭐 DB Packet Handler 이런 식으로 상대방의 이름을 , 이렇게, 건네주는 게 훨씬 더 관리하기가 편하겠죠 , 자, 그건 그렇고 이제 툴을 만들어 볼 건데 이 툴을 어떻게 만들어야 되느냐 제가 C Sharp 강의에서는 이거를 그냥 뭐 언어 통일성을 위해서 C Sharp으로 만들었었죠 근데 이제 뭐 보통 회사를 가면은 툴은 C Sharp으로 만드는 경우도 있고 그냥 C++로 좀 무식하게 만드는 경우도 있지만 가장 많이 활용되는 방법은 Python을 이용해 가지고 툴을 만드는 방법입니다 확실히 파이썬이 툴 만들기에 굉장히 편리하게 되어있어요 그래가지고 저도 이 강의를 뭐 어떻게 만들어 볼까 좀 고민을 하다가 회사에서 굉장히 자주 사용하는 그 진자툴 아닌 라이브러리가 있는데 그거를 이제 한번 사용하는 걸 보여드릴까 합니다 근데 물론 뭐 파이썬을 모르신다고 해도 크게 상관이 없어요 오늘 뭐 엄청 어려운 부분을 작업하는 게 아니라 그냥 간단하게 C++ 코드를 읽을 줄 알면은 파이썬 코드도 그렇게 뭐 분석하는 데는 큰 무리 없는 부분이라고 보시면 되겠습니다 그리고 중간중간에 제가 이제 뭐 부가적인 설명을 드릴 테니까 참고하시면 될 것 같고 어.. , 자, 그래서 여기 오늘 추가 세폴류션 폴더를 만들어가지고 이제 툴스라는 폴더를 만든 다음에 여기다가 할 때 툴을 다 집어넣도록 할거에요. 아 그 다음에 암호 파일이나 우클릭 상위 폴더 열기에 가가지고 파일 구조 상에서 우리가 서버 안에다가 지금 어 여기다가 프로젝트를 만드지 말고 툴은 다 Tools라는 폴더 안에다가 다 몰빵을 해주도록 할게요 그래서 요기 안에다가 , 일단은, 만들어주도록 하겠습니다 , 자, 그래서 일단 Python을 설치를 해야 되는데 혹시 Python 설치를 안 하셨다고 하면은 요기 시작에 가가지고 Visual Studio Installer를 다시 켜신 다음에 그 다음에 요기서 업데이트를 한 다음에 수정에 가면은 이제 Python을 편리하게 다운로드 받게끔 되어 있습니다 요기 Python 개발을 눌러가지고 업데이트를 하시면 돼요 물론 이제 구글에 가서 직접 파이썬을 받아도 되는데 , 이렇게, 다운로드 받는게 조금 더 편리합니다 아 그 다음에 어... 일단 보여드리도록 할게요 , 자, 추가에 가가지고 새 프로젝트에 간 다음에 , 자, 이제 조금 기다리면은 파이썬 어플리케이션으로 만들어 주도록 할게요. 여기 검색해서 파이썬 쳐도 똑같이 나오고요. 이거는 그냥 어떤 식으로든 파이썬을 잘 찾으셔가지고 이 파이썬 어플리케이션으로 만들어 보도록 하겠습니다. 그 다음에 이 위치 같은 경우에 , 자, 이걸 열어가지고 방금 우리가 만들어 준 이 툴 설정 폴더 밑에다가 넣어주게끔 , 이렇게, 선택을 해 주도록 할게요. 그리고 툴 이름은 패키지 제너레이터라고 지어 주도록 하겠습니다. 그래서 만들기를 일단 눌러 보도록 할게요. , 자, 그러면 , 일단은, 요렇게 만들어지고요 저같은 경우에는 지금 Python 3.7 버전으로 , 일단은, 잡혀있는데 이 버전은 , 일단은, 뭐 크게 상관이 없기는 합니다 , 자, 그리고 여기서 Python 3.7을 우클릭한 다음에 여기서 파일 탐색기에서 폴더 열기를 일단 잠시 한번 열어보시도록 할게요. 이게 지금 Python이 설치된 제 경로가 요렇게 표시가 되어 있어요. , 자, 근데 이걸 왜 하고 있냐면은 여러분들이 다시 한번 시작에 간 다음에 cmd를 입력해서 요 명령 프롬트를 잠시 켜주신 다음에 여기 안에서 Python을 쳐보신 다음에 만약에 저처럼 , 이렇게, Python이 뜨면은 괜찮은 건데 이게 만약에 안 뜬다라고 하면은 추가적으로 환경 설정을 하나를 더 해줘야 됩니다. 이거 나갈 때는 Ctrl-Z를 해서 엔터를 누르면 , 이렇게, 나가지고요. , 자, 여기서 이 경로를 잘 기억을 하신 다음에 , 자, 이거를 일단 복붙할게요. Ctrl-C 그 다음에 여기 내 PC를 우클릭해가지고 속성에 가가지고 그냥 환경 설정을 해줘야 됩니다. 그래서 고급 시스템 설정이 간 다음에 여기서 환경 변수라는 게 있는데 여기 경로 중에서 패스라고 되어 있는 걸 눌러보면은 저 같은 경우에는 지금 얘가 이미 잡히는 거 볼 수가 있죠. 아까 말한 경로. 이거를 그대로 새로 만들기에 가거나 아니면 편집을 눌러준다거나 해가지고 똑같이 이 경로를 넣어주고 그 다음에 여기 위에 스크립스까지 백슬래시까지 , 이렇게, 두개를 일단 추가해주시면 되겠습니다. 이거를 넣어주면은 우리가 환경명령을 막 입력을 할 때 아까처럼 파이썬을 입력을 할 때 요 경로에서 찾아보다 보니까 결국에는 , 자, 우리가 결국 명령 프롬프트에서 아까처럼 python 을 입력을 하면은 얘가 아까 입력한 그 환경 변수를 찾다가 요 경례를 찾아 보면서 python.ex 이라는 요 파일을 이제 실행해 주게 될 겁니다 그래가지고 사실상 얘가 실행이 되는 원리라고 보시면 되겠어요 , 일단은, 이렇게, 해가지고 일단 환경 변수를 하나를 추가해 주시면 되겠고요 , 자, 그 다음에 이어가지고 어... 저는 이미 설치가 되어있는데 여러분들 같은 경우는 아마 안되어있을건데 여기다가 오늘 사용할 진자2라는걸 일단 받아주고 진자2랑 파이 인스톨로 , 이렇게, 두가지 애들을 받아줘야 됩니다 근데 여기서 해도 되구요 아니면은 어... 여기서 그냥 파이썬 환경 우클릭을 한 다음에 환경추가에 가가지고 아이고 여기가 아니네요 죄송합니다 여기서 패키지 관리에 가가지고 여기서 직접 입력을 하셔도 돼요 진자 진자2 라고 하면은 여기 pip install 진자2 라고 뜨는데 이거를 그냥 클릭하시면 설치가 될 것이고 요 패키지를 일단 설치를 하고 그 다음에 어 이제 이어가지고 나중에 하나 더 필요한데 파이 인스톨러라고 해가지고 파이 인스톨러 이것도 일단 똑같이 받아주시면 되겠습니다. 명령 실행을 그냥 눌러보시면 돼요. 얘는 뭐하는 이냐면은 나중에 이제 우리가 파이썬을 실행 파일, exe 파일로 만들어줄 때 사용하는 패키지라고 보시면 되겠습니다. 두개를 , 일단은, 다운로드 받고 다시 솔루션 탐색기로 가가지고 작업을 이제 이어서 시작을 해보도록 할게요. , 자, 그래서 패키지 제네레이터 이쪽에 시작을 할건데 여기다가 먼저 import argument path 그 다음에 import jinja2 그리고 일단 , 이렇게, 두 개만 , 일단은, 추가를 하고 시작을 할 것이구요 , 자, 그 다음에 diff 메인함수를 , 일단은, 정리를 해주도록 하겠습니다 여기다가 이제 뭐 이런저런 기능들을 우리가 넣어줄 것이고 그 다음에 if __name이 메인이다 라고 하면은 메인을 실행해라 라고 해가지고 이게 , 일단은, 그냥 파이썬의 기본 메인함수 시작방법이라고 , 일단은, 뭐 그냥 생각하시면 되겠습니다 네 요렇게 뭐 그냥 이건 따라 치시면 되고 네 나중에 이제 뭐 언젠가 파이썬을 공부하시면 알게 될 내용인데 그 다음에 이제 할 거는 요기 아귀먼트 파스라는 거는 뭐 하는 거냐면은 우리가 프로그램을 실행할 때 어 같이 이제 인자들을 넘겨주게 될 텐데 그 인자들을 편하게 파싱하기 위한 어 그런 모듈이라고 보시면 되겠습니다 일종의 라이브러리라고 보시면 되겠어요 즉 게임 서버에서 예를 들면은 우리가 메인에다가도 인자를 받아줄 수 있었죠. 캐릭터 모시기 이런 식으로 배열로 받아줄 수 있었는데 그거랑 유사하게 프로그램이 시작될 때 넘겨받는 뭐 그런 아이들을 편하게 파싱할 수 있는 라이브러리라고 보시면 되겠습니다. 그래서 아귀먼트 파서를 만들어줄건데 아귀먼트 파스 점 아귀먼트 파서를 , 이렇게, 찍어보시면 되구요. , 자, 그 다음에 여기다가 데스크립션을 뭐 패킷 제네레이터라고 입력을 해주도록 할게요. 파이썬 같은 경우는 , 이렇게, 만들어도 되고 , 이렇게, 만들어도 됩니다. 두가지 옵션이 있구요. Python 이랑 C++ 이랑 가장 큰 차이라고 한다면 일단 두 가지를 먼저 생각을 해야 되는데 C++ 같은 경우는 이런 괄호가 굉장히 큰 의미가 있죠 이 괄호에 따라 가지고 코드가 묶여 가지고 한 덩어리로 인식이 되는데 Python 같은 경우는 괄호를 쓰지 않고 , 이렇게, 탭을 이용해 가지고 인덴테이션 이라고 하죠 이 띄어쓰기에 따라 가지고 코드가 의미가 생깁니다 그게 일단 굉장히 중요하고 그 다음에 우리가 이제 뭐 C++에서는 이런 식으로 타입을 항상 , 이렇게, 일일이 지정했는데 Python이나 JavaScript 같은 언어에서는 그거를 알아서 해준다고 생각하시면 돼요. 그냥 타입을 그냥 뭐 문맥상 알맞게 딱 정해줘가지고 그걸로 , 일단은, 뭐 사용이 된다라고 , 일단은, 어렴풋 넘어가시면 되겠습니다. 그래서 이제 이 argumentParser라는 애를 우리가 이제 사용하는 거고요. , 이렇게, 만들어가지고 사용을 하고 있는 거고 여기서 , 일단은, add argument를 이용해가지고 각자 어... 우리가 사용할 그런 인자들을 하나씩 정의해줄건데 요렇게 패스를 만약에 우리가 넘겨줘가지고 사용한다면은 , 자, 타입은 str 그리고 디폴트 값은 뭐 어디어디 이런 식으로 이제 사용을 해줄 겁니다 만약에 어떠한 입력도 안 하면은 요긴 뒤에 넘겨주는 그 경로를 사용할 것이다 라고 , 일단은, 보시면 되겠어요 그 다음에 이게 뭐하는 앤지 만약에 이제 알고 싶다라고 헬프 명령어를 칠 수도 있으니까 헬프도 , 이렇게, 만들어 주도록 할게요 프로토 경로를 입력하라 라는 느낌으로 , 이렇게, 일단은, 만들어 주도록 하겠습니다 그 다음에 엔터 , 자, 이거를 컨트롤 뒤로 복사해가지고 여러개를 만들어 준 다음에 그 다음에 아웃풋 리시브, 샌드 아귀먼트를 각각 넣어줄 것이구요 타입은 다 스트링이고 얘 같은 경우에는 디폴트로는 그냥 테스트 패킷 핸들러 라고 이제 만들어줄 클래스의 이름을 여기다가 우리가 지정할 수 있고 그 다음에 naming convention c__s, s__, c__로 각각 receive랑 send를 이런 식으로 정의를 해줄 겁니다 만약에 이게 기본 값이 아니라 딴 걸로 설정하고 싶다고 하면 이제 인자에다가 얘를 받아주면 되겠죠 나중에 가면 클라스 서버 통신 뿐만 아니라 서버끼리도 통신이 있을 수 있기 때문에 좀 광범위하게 얘를 설정할 수 있게끔 , 이렇게, 인자들로 받아주고 있는 겁니다 그 다음에 얘는 이제 뭐 설명은 얘는 뭐 receive convention 받을 때 받는 쪽에서의 이름, 보내주는 쪽에서의 이름 이런 식으로 receive랑 send와 관련된 convention 이름을 , 이렇게, 정해 주도록 하겠습니다. 그리고 얘는 뭐 그냥 output 파일이라고 , 일단은, 이렇게, 힌트를 주도록 할게요. , 자, 그리고 뭐 패스 같은 경우에는 여러분들이 이제 프로토 파일이 있는 , 자, 일단 이 프로토 파일이 지금 여기 있으니까 우클릭 상위 폴더 여기 가서 그냥 이 주소를 지금 그냥 막바로 여기다가 일단 때려 박아 주도록 할게요 디폴트 값을 , 이렇게, 넣어주고 그 다음에 어 백 슬래시 프로토 프로토 콜 프로토 콜 점 프로토 로 , 이렇게, 입력해 주면 되겠습니다 백 슬래시 대신 그냥 , 이렇게, 슬래시로 하셔도 됩니다 이게 조금 더 직관 어 잘 보이니까 , 이렇게, 일단 바꿔 주도록 할게요 , 자, 요렇게 해가지고 네 일단 , 이렇게, 만들어 놨구요 그 다음에 argumentParser.parseArgument라는 요 함수를 이제 호출해 주면은 얘네들이 다 파싱이 되어가지고 요게 이제 우리가 사용을 할 수 있게 됩니다 , 자, 그 다음에 어 이제 뭐 인자들을 파싱하는 부분은 요렇게 됐구요 그 다음에 이제 우리가 해야 되는 건 뭐냐면은 먼저 진자 툴 하는 걸 활용하기 전에 , 일단은, 요 프로토 파일을 우리가 쫙 분석을 할 거예요 이걸 한 줄 한 줄씩 분석을 하다가 메시지라는 키워드를 찾게 되면은 그 다음 이름을 체크해 가지고 그 다음 이름이 우리가 여기 리시브랑 샌드 컨벤션으로 넘겨준 C 언더바나 S 언더바 둘 중 하나라고 하면은 걔를 패킷이라고 인정을 해가지고 걔를 이제 추적을 해주도록 할 겁니다 그냥 메모리상에 들고 있을 거예요 그래서 이 파일 자체를 파스하는 클래스를 , 일단은, 별도로 하나를 만들어 줄 것인데 여기 우클릭 추가 새 항목에 가가지고 새로운 Python 클래스를 만들어 볼 거예요 이번에는 뭐 , 사실, 빈 파일로 만들어도 딱히 상관이 없습니다 그 다음에 protopasser 라는 이름으로 파일을 , 일단은, 하나를 추가를 해주도록 할게요 , 자, 이렇게, 해서 클래스가 정의가 되었구요 이 오브젝트는 없애줘도 되고 , 자, 그 다음에 이제 파이썬 클래스랑 C++ 클래스랑 가장 다르다고 할 수 있는 점 중 하나는 뭐냐면은 C++ 클래스에서는 우리가 멤버 변수를 뭐 이런 식으로 프라이베트로 뭐 하나 찾아볼까요 프라이베트로 항상 우리가 뭔가를 만들어 놨었죠 여기 어딘가에 뭐 프라이벳 클래스를 많이 찾으려고 하니까 또 안 보이는데 어쨌든 여기 클래스 안에다가 우리가 뭐 이런저런 멤버 변수들을 막 넣고 그렇게 작업을 했었는데 파이썬은 굉장히 신기하게도 생성자에서 뭔가 런타임에 그걸 만든다고 생각하시면 됩니다 이게 무슨 말이냐면 , 자, 예를 들면은 여기 아래다가 다른 클래스를 일단 만들어볼건데 Packet이라는 클래스가 있다고 가정해볼게요 요런 클래스가 있는데 얘 같은 경우에 일단 생성자에서 underbar, underbar, init 이게 생성자라고 보시면 되고 self, name, id , 이렇게, 3개를 받아줄 것이다 이 self라는 것은 C++로 치면 디스포인터 같은 느낌이고요. 그 다음에 우리가 이 패킷 이름, 스트링이랑 인트형 아이디를 받아줄 것인데 그거를 우리가 이런 식으로 name으로 저장하고 self.id로 , 이렇게, 저장을 해주면 됩니다. 즉 C++로 치면은 우리가 뭐 스트링 네임이랑 이런 느낌이죠 스트링 네임이랑 뭐 인트64 아이디를 , 이렇게, 저장했던 거를 지금 이런 식으로 생성자에서 뿅 만들어준다라는 게 굉장히 신기합니다 뭐 이런 느낌으로 만들어 줄 것이고 , 자, 그 다음에 프로토 파서는 이제 무엇을 할 것이냐 얘도 마찬가지로 생성 생성자에서 셀프 어 시작하는 아이디를 일단 받아 주도록 할게요 대역대를 설정할 수 있게끔 시작 아이디를 먼저 받아줄 것이고 그 다음에 Receive Prefix, Send Prefix 라고 해가지고 시작할 때 요 패킷이 붙는 C 언더바, S 언더바 같은 이름들을 먼저 , 이렇게, 인자로 받아주도록 하겠습니다. , 자, 그 다음에 셀프점을 찍어가지고 내가 받는 리시브 패킷들은 다 여기다가 , 일단은, 저장할 것이고요 요 아이는 C++로 치면은 벡터 같은 느낌입니다 그냥 동적 배열을 만들어 주겠다라는 의미로 받아주시면 돼요 그래서 얘가 결국에는 수신 패킷 목록이 될 것이고 그 다음에 샌드 패킷은 이쪽에다가 모아줄 건데 얘 같은 경우에는 내가 보내는 송신 패킷 목록을 여기다가 들고 있을 것이고 , 자, 그 다음에 셀프점 모든 패킷들을 따로 이 목록으로 들고 있도록 할게요 모든 패킷 목록 그리고 이 샵을 붙일 때는 이게 주석의 의미입니다 뭐 이거는 딱 색깔만 봐도 주석같이 생겼죠 , 자, 그리고 이어가지고 셀프점 스타트 아이디도 그냥 들고 있을 거고요 스타트 아이디 참고로 여기 이 땡땡이는 굳이 넣지 않을 것이고 , 자, 그 다음에 self.id는 start id 그리고 self.receive prefix도 저장을 해주도록 할게요 그 다음에 self.send prefix도 각각 다 , 이렇게, 저장을 해주도록 하겠습니다 그래서 말 그대로 우리가 클래스 설계를 지금 여기 , 이렇게, 이닛 안에서 지금 다 만들어 주고 있는 거고요 배열이 일단 3개 있고 동적 배열이 3개 있고 그 다음에 이런 정수로 시작하는 아이디랑 현재 아이디를 각각 , 이렇게, 들고 있을 거고 그 다음에 Receive Prefix랑 Send Prefix, 얘네들은 이제 스트링이죠. 스트링도 , 이렇게, 들고 있겠다라고 보는 거고 그 다음에 이 클래스 내부에서 사용할 함수 중에서 path-underbar-proto라는 함수를 정의를 해줄 건데 , 자, 요렇게 일단 만들어볼거고 얘는 이제 일종의 디스포인터라서 얘는 인자로 받는게 아니고 이 두번째 애를 이제 인자로 받아줄겁니다 경로를 받아줘가지고 먼저 파일을 , 일단은, 오픈을 해주도록 할게요 파일 입출력 오픈 그 다음에 경로를 넣어주고 옵션을 리드로 해가지고 우리 이 프로토콜 프로토파일을 읽어주겠다라는 의미고 , 이렇게, 파일을 열어주면 되구요 그 다음에 f.readlines 라고 해가지고 요 함수를 이제 이용하게 되면은 이 모든 줄, 한 줄 한 줄을 다 , 이렇게, 읽어가지고 그걸 여기다가 저장을 해주게 됩니다. 즉 얘가 일종의 배열이라고 보시면 되는 거죠. , 자, 그래가지고 for line in lines 이게 그 C++로 치면은 그냥 for 문이라고 보시면 되겠습니다. for로면서 이 lines마다 하나씩 하나씩 돌면서 얘가 이제 스트링이 되겠죠. 그러면 요 스트링을 하나씩 하나씩 추출해가지고 한 줄 한 줄씩 보면서 먼저 체크를 해줄 겁니다. 얘가 메시지로 시작을 하는지를 먼저 보면 되겠죠 그러니까 if line이 starts with 이 메시지라는 이 단어로 시작을 한다 를 체크해 가지고 만약에 걔가 false다 라고 하면은 continue를 때려 줄 거에요 , 자, 이 false가 대문자 f 으로 그 다음에 , 이렇게, 만들어 줘야 된다는 걸 조심하시면 되고요 네 , 이렇게, 일단은, 해서 만약에 실패했으면 메시지로 시작하지 않으면은 뭐 이런 줄일 수도 있겠죠 쓸데없는 줄이니까 그냥 넘어가고 메시지가 메시지로 시작하는 줄이라고 하면은 어 그럼 이제 그 다음 단어를 체크해 보면 되겠죠 그러니까 여기서 패킷 네임을 추천할 것인데 line.split split을 하면은 얘가 이제 이 모든 단어들을 다 추출해가지고 이제 배열로 만들어주게 됩니다. 근데 우리 같은 경우는 지금 0번째 단어는 메시지일 거고 그 다음에 1번째 인덱스에 있는 단어가 우리의 실제 패킷 이름이니까 여기서 첫 번째 거를 뽑아 올 것이고 점 어퍼를 찍어가지고 일단 대문자로 변환을 해주도록 할게요. 혹시라도 우리가 소문제로 만들어놨으면 비교가 어려우니까 대문자로 , 일단은, 이렇게, 만들어주도록 하겠습니다. , 이렇게, 해가지고 이제 패킷 네임이라는 변수에다가 얘를 저장해줬고요. C++로 치면 약간 이런 느낌인 거죠. 스택 메모에서 사용하는 그런 건데 Python이다 보니까 타입은 지정하지 않는다는 걸 볼 수 있고 그 다음에 만약에 패킷 네임이 starts with self.receive prefix 우리가 아까 여기서 생성자에서 받아준 요 아이죠? C 언더바 혹은 S 언더바 등등을 우리가 넣어 줄 건데 그거로 만약에 시작하는 게 맞다면은 그러면은 self-receive-packet 에다가 append를 해줘라 이게 벡터의 푸시백이랑 비슷한 겁니다 여기 안에다가 밀어 넣어주세요 라는 의미가 되는 거죠 그래서 여기다가 뭘 넣어줄 거냐면은 아직 우리가 어떤 타입을 넣어줄 거라는 말은 안했죠 근데 이거를 우리가 패킷으로 만들어가지고 , 이렇게, 넣어주도록 합시다 이 클래스, 이 패킷이라는 걸로 만들어가지고 패킷 이름이랑 그 다음에 self.id를 , 이렇게, 넣어주도록 할게요 이 self.id는 이 프로토파스터라는 클래스가 추적하고 있는 이 id죠 얘가 start.id부터 시작을 해가지고 우리가 일식 늘려주는 형태로 만들어주게 될 겁니다 그래서 이 아이디를 발급해가지고 넣어줄 것이고 , 자, 그 다음에 else if packet name이 start with self.send prefix로 이제 시작을 한다 라고 하면은 거꾸로 send packet에다가 얘를 넣어주면 되겠죠 똑같이 packet name 그리고 self.id , 이렇게, 넣어주고 그것도 아니다 else 라고 한다면은 continue를 때려주면 되겠습니다 그리고 여기 유심히 보면은 요거 빼놓으시면 안됩니다 요 땡땡이를 항상 넣어주셔야 돼요 , 이렇게, 자, 이렇게, 해서 만약에 다 아니라고 하면은 뭐 그냥 일반 구조체일 수도 있고 뭔진 모르겠지만 어쨌든 패킷은 아니라고 가정을 하고 컨티뉴 해주면 될 것이고 여기까지 넘었다고 하면은 , 일단은, 뭐 패킷 둘 중 한 케이스 if나 else if 둘 중 하나에 들어왔다는 얘기니까 self.totalpacket 안에다가 append를 해줘서 똑같이 패킷을 다시 한번 등록을 해주도록 할게요 왜 굳이 또 등록을 해주냐 그건 나중에 우리가 전체 코드를 만들 때 여기 서버 패킷 핸들을 다시 한 번 보면은 요 부분 있죠 요 부분 같은 경우에는 우리가 C 언더바건 S 언더바건 상관없이 다 , 일단은, 인원값은 다 등록을 해줘야 되기 때문에 , 이렇게, 토탈 패킷이라는 걸 한 번 더 들고 있는 겁니다 그래야지 나중에 만들기 편하기 때문이에요 그리고 여기까지 했으면은 아이디를 1 증가시켜 주도록 할게요 참고로 파이썬에서는 아이디 ㅃㅃ 같은 문법이 없습니다 그냥 , 이렇게, 증가를 해주시면 돼요 비측관적으로 그리고 여기까지 끝났으면은 뭐 여기 포문은 다 끝난 거니까 여기다가 엔터를 친 다음에 어... 한 칸을 당겨가지고 F10 클로즈를 때려주도록 하겠습니다. 이게 제일 중요한 거에요. 파이썬에서는 어... 우리가 괄호 같은 거를 안 쓰는 대신 이 줄에 따라서 탭키를 몇 번 눌렀는지 이 줄에 따라서 지금 for문이 여기까지 끝난다는 걸 인지를 하는 거죠. 그래서 빠져나오면 f.close를 한다. 그렇게 해서 , 이렇게, 해가지고 , 일단은, 함수가 완료가 될 거예요. , 자, 그러면은 뭐 이걸 이제 그럼 어떻게 사용하느냐 일단 요 클래스를 , 자, 이제 우리가 패킷 제네레이터는 요 안에서 사용을 해볼건데 , 일단은, import protopasser 를 , 이렇게, 임포트 해줘서 이제 이 모듈을 추가를 해줄 것이고 그 다음에 passer는 protopasser.protopasser 이게 생성자처럼 이제 그 기체를 만들어 주는 겁니다 protopasser를 만들어 주는데 뭐 id는 예를 들면은 1000번대에서 시작을 할 것이고 그 다음에 인자로 받아준 argument 리시브랑 샌드를 그대로 넘겨주도록 할게요. 이게 여기서 우리가 팟싱해준 리시브랑 샌드를 , 이렇게, 넘겨줄 수 있게 됩니다. 이 리시브 샌드. 그래서 C 언더바, S 언더바, 혹은 나중에 다른 인자로 넘겨주면 그 인자를 추적해가지고 이제 이 프로토 파일을 체크한다는 거죠. 그래서 여기까지 , 일단은, 완료가 되었으면 팟서점 파스 프로토를 실행해가지고 우리가 만들어준 함수를 실행할 것인데 거기다가 아귀몬트에 패스를 , 이렇게, 넣어주도록 하겠습니다. 그러면은 아까 요 함수를 보면은 얘는 디스포인터처럼 그냥 생략을 하는 거고 얘가 이제 들어오는 거죠 이 해당 경로를 읽어가지고 모든 라인을 읽고 그 다음에 요 코드가 이제 쫙 실행이 될 겁니다 그래서 이제 우리 같은 경우에는 지금 요 프로토 파일의 경로를 지금 디폴트 값으로 , 이렇게, 넣어 놨는데 나중에 이거를 이제 뭐 바꿔치기 해주면 되겠습니다 지금 대발 단계니까 , 이렇게, 그냥 디폴트 값을 하드코딩 해서 넣어 놨구요 네 그 다음에 뭐 여기부터 이제 진짜 과 관련된 코드가 들어갈 겁니다 근데 잠시 여기 리턴 값에다가 브레이크 포인트를 건 다음에 패키지 제네레이터를 우클릭 시작 프로젝터로 설정해가지고 일단 이걸 한번 간단하게 실행을 해보도록 하겠습니다. 문제가 없는지 그래서 F4를 눌러가지고 실행을 빵 때리면은 , 자, 여기서 일단 브레이크 포인트가 잡히는 걸 볼 수 있고 그 다음에 얘가 정상적으로 완료가 되었으면은 , 자, 얘가 파서가 실행이 되었고요. 그 다음에 정상적으로 다 들어가 있죠 Receive Prefix는 C 언더바 S 언더바 Startize는 이거 그리고 Total Packet은 지금 3개가 파싱이 되었고요 각 Packet은 1000번은 C 테스트 1001번은 S 테스트 1002번은 S 로그인 그리고 Receive Packet 또 한 개 Send Packet은 2개로 , 일단은, 각자 들어가 있다는 걸 볼 수가 있습니다 즉, 말 그대로 우리가 처음에 하려고 했던 것처럼 이 프로토 파일에 있는 모든 내용을 긁어가지고 이런 패킷 이름들만 쏙쏙 추출한 셈이 되는 거죠 그걸 약간 분리해가지고 C 언더버가 붙은 애들 S 언더버가 붙은 애들 등등으로 , 일단은, 분류를 해주고 겸사겸사 얘가 시작 아이디로 넘겨준 걸 기준으로 아이디를 하나씩 발급해준 것까지 , 일단은, 완료가 된 겁니다 그 다음에 이제 이거를 이용해가지고 우리가 진자2라는 애를 이용해가지고 뭘 해줄거냐면은 진저2가 이제 템플릿 엔진이라고 이걸 부릅니다 그래가지고 결국에는 요런 패킷 핸들러를 지금 다시 살펴보면은 우리가 요런걸 해주려고 하는거죠 결국에는 자동화를 해주려고 하는데 요 부분만 지금 바꿔치기가 되기를 원하고 있는 겁니다 요럴 때 이제 진자투가 굉장히 편리한데 이걸 어떻게 사용할 거냐면 일단 우클릭 추가 새 폴더를 만들어 준 다음에 템플릿스라는 폴더를 만들어 주고 그 다음에 추가 새 항목을 만들어 준 다음에 어 이건 이제 그냥 헤더 파일을 만들어 줄 거예요 이름하여 그냥 PacketHandler.h 라고 일단 만들어 줄게요 추가 그럼 여기 이제 PacketHandler가 실질적으로 아까 그 경로에다가 여기 안에다가 일단 만들어 줬는데 요 내용 안에다가 서버 PacketHandler로 우리가 테스트로 만들어 준 거를 통으로 Ctrl-C 한 다음에 여기다가 , 일단은, 다 집어넣고 시작을 할 거예요 이게 말 그대로 우리의 샘플이 되는 거죠 여기서 이제 우리의 샘플이 될 겁니다 근데 여기서 이제 요런 부분만 우리가 바꿔치기 하게끔 뭔가 코드를 만들어 줄 겁니다 근데 이게 Jinja2가 이런 부분에서 굉장히 큰 장점이 있는 게 여기다가 Python 코드를 섞어줄 수가 있다는 게 굉장히 놀라운 거예요 , 사실, Python만 있는 건 아니고요 C-SHOP 같은 경우에도 , 사실, 우리가 ASP.NET을 사용할 때 레이저 기술을 사용할 때도 , 사실, 이런 템플릿 엔진 기법을 이용한 건데 레이저 같은 경우에는 그거를 이제 ASP.NET에서 사용하지 않고 꺼내서 사용할 때 조금 불편합니다 이런저런 설정을 해줘야 되는 반면 파이썬은 그냥 굉장히 쉽게 이 진자툴을 이용해가지고 쉽게 할 수 있기 때문에 파이썬으로 지금 진행하고 있다고 보시면 되겠어요 그래서 이걸 한번 사용하는 걸 보면은 나중에 툴을 만들 때 계속 파이썬을 고집하고 싶을 정도로 굉장히 편리하게 되어있다는거지 알 수가 있을 겁니다 , 자, 그런거로 이제 실습을 해볼건데 여기서 이제 그러면은 무엇을 할 것이냐 진자툴.파일시스템 로더라고 , 일단은, 치신 다음에 여기다가 템플릿스라는 폴더를 , 일단은, 서치를 할 것이고 이 애를 , 일단은, 찾아볼 것이고요. 그 다음에 이거를 file-loader라는 객체로 , 일단은, 이렇게, 만들어줄 겁니다. 그 다음에 진자2.environment 한 다음에 로더를 file-loader라고 다시 , 이렇게, 건네주게 될 거예요. 그걸 env라는 걸로 다시 받아줄 겁니다. 그리고 이건 이제 초기화하는 코드라고 생각하시면 되고 그 다음에 env.gettemplate 이라는 함수를 호출할 것인데 여기다가 우리가 샘플로 넣어줄 이 샘플코드 packet-handler를 , 일단은, 건네줄 거예요 packet-handler.h 라는 파일을 template 이라는 이름으로 또 저장을 해준 다음에 그 다음에 output은 template.render 이게 이제 진짜로 작업을 하는 건데 , 자, 여기다가 이제 뭐 우리가 안에서 사용할 그런 코드랑 우리 실제 메모리랑 이제 맵핑을 시켜주면 됩니다 이게 무슨 말이냐면 우선 이 Packet Handler 이 템플릿으로 되어있는 이 코드를 일단 살펴보도록 할게요 , 자, 그러면은 지금 이제 자동화하는 부분을 하나씩 시작을 할 건데 우리가 그냥 이 Parser라는 이 객체를 통으로 넘겨준다고 가정을 해봅시다 이 Parser라는 객체를 통으로 넘겨준다 여기 안에서 사용할 이름은 왼쪽이고 우리가 실제적으로 넘겨준 게 오른쪽에 들어가는 거예요 그냥 똑같은 이름으로 지어줄게요 그럼 , 이렇게, 만들어주면은 이 파서라는 애를 이제 여기 내부에서 사실상 사용할 수 있다고 보시면 됩니다 , 자, 그래가지고 여기서 코드를 만들어 줄 건데 이 자동화하는 코드 첫번째부터 시작을 하면은 얘 같은 경우에는 어... 지금 우리가 메모리 상으로 들고 있는 거 기준으로 생각을 하면은 어떤 애한테 해당하냐면은 여기 있는 토탈패킷 모든 패킷 목록을 여기다가 , 일단은, 만들어주면 되겠죠? 네, 그러기 때문에 , 일단은, 루프를 돌 건데 근데 이 코드가 파일성 코드인지 아니면 그냥 일반 샘플 코드인지 구분을 할 수가 없으니까 이 진자 투만의 문법이 있습니다 그래가지고 여기다가 , 일단은, 요렇게 어... 퍼센테이지를 , 이렇게, 입력을 양옆으로 해주시면 돼요 그 다음에 여기다가 일단 짝대기 하나를 그어주시고요 이거 마이너스 표시는 왜 하는지 일단 나중에 설명을 드릴 거고 , 일단은, 포문을 돌건데 패킷인 파서의 토탈 패킷을 하나씩 하나씩 순회를 할 것이다 라고 일단 하고 있는 거고요. 그 다음에 여기 안에다가 다시 한번 얘를 %로 , 이렇게, 닫아주면 되겠습니다. 그리고 &4 라고 치면은 이게 사실상 여기 내부에 있는 파이썬 코드가 진짜로 실행이 된다고 보시면 돼요. 몰래몰래. 그 다음에 이제 안에 있는 내용을 만들어 줄 건데 안에 있는 내용은 PKT 언더바까지는 고정이니까 얘는 이제 그대로 탭까지 해가지고 만들어주고 그 다음에 이제 패킷 이름이 여기 들어가야 되겠죠 그렇기 때문에 이번에는 , 자, 이렇게, 괄호를 두 개를 만들어 주시고요 패킷.네임을 이제 안에다가 치환을 해달라 이겁니다 지금 요 부분이 실제로 파이썬 코드로 인식이 되어가지고 요 부분이 딱 바꿔치기가 될 거예요 그리고는 다시한번 두개를 만들어준다음에 패킷.id를 , 이렇게, 넣어주도록 하겠습니다. 그리고 심표를 넣어주면 되겠죠. 그래서 결국엔 요코드가 실행이 되면은 요기 토탈패킷에 들어가있는 애들을 하나씩 하나씩 순회하면서 패킷 이름이랑 패킷 아이디를 꺼내가지고 코드가 자동으로 만들어진다라고 일단 볼 수가 있는 거예요 그리고 여기 마이너스를 하는 이유는 이제 만약에 이 끝부분이나 첫 번째 부분에다가 얘를 옵션으로 넣어줄 수가 안 넣어주시는데 이거는 여기 지금 , 이렇게, 한 칸을 우리가 직접 띄웠는데 이 부분을 적용할지 아니면 여기다가 그냥 붙여가지고 얘를 만들어 줄지와 관련이 되어 있어요 그러니까 비주얼적으로 뭔가 , 이렇게, 얘를 이제 만들어주는 부분이랑 연관성이 있다라고 일단 보시면 되는 거고 나중에 실습을 통해 가지고 이걸 없애보고 추가하고 하면서 이게 어떤 식으로 변하는지를 보시는 게 조금 더 이해하기가 빠를 겁니다 네 그래가지고 이건 뭐 크게 중요한 부분은 아닌데 줄 띄는 거랑 관련이 있다라고 , 일단은, 어렴풋 느끼시면 되고 , 이렇게, 해서 코드가 만들어진다는 게 굉장히 신기한 거죠. 우리가 메모리에다가 들고 있는 코드를 , 이렇게, 이용해가지고 동적으로 코드를 만들어준다라고 볼 수가 있는 겁니다. 그럼 나머지 부분들도 이제 해보자면 이 부분도 일단 자동화 대상이었었죠. 그래서 이 부분도 똑같이 만들어줄 건데 , 자, 여기 자동화 대상이었는데 얘 같은 경우에는 우리가 받는 쪽의 패킷만 만들어줘야 되겠죠. 모든 패킷을 대상으로 하는 게 아니라 내가 이제 클라 입장에서라면은 서버 쪽에서 보내주는 패킷만 핸들링을 해주겠죠? 내가 받는 거는 서버 쪽에서 보내주는 패킷을 받을 테니까 그러니까 여기다가 똑같이 , 이렇게, 만들어주는데 복붙을 하면은 이게 , 이렇게, 한 칸 띄고 이게 자동 완성이 막 , 이렇게, 엉망으로 됩니다 이게 .h로 만들어서 그런 것 같은데 이럴 때는 Ctrl-Z를 눌러주면은 다시 , 이렇게, 원복이 돼요 그래서 이걸 항상 유지시켜줘야 됩니다 막 억지로 한 칸 띄고 이러면 안 돼요 그래서 , 이렇게, 한 칸씩 도는데 얘는 토탈 패킷이 아니라 리시브 패킷에 대해서 하나씩 한 회를 순회를 하겠다라고 , 일단은, 만들어주면 되고요 그 다음에 달러 앤드 포 달러 , 이렇게, 일단은, 만들어주고 여기 안에다가 얘를 , 이렇게, 넣어주되 여기서 고정적인 부분은 핸들 여기까지는 고정이지만 요 부분이 , 일단은, 수정이 되면 되겠죠 그래서 요기를 package.name으로 요렇게 바꿔주도록 하겠습니다 그리고 얘를 한 칸 한 칸 붙여주도록 할게요 그 다음에 여기까지는 똑같고 여기 후반부에서도 프로토콜의 모시기 모시기라는 요 부분도 , 이렇게, 바꿔치기를 해가지고 치환이 되게끔 유도를 해주도록 할게요 그럼 이제 요기 괄호 두 개짜리에다가 우리의 실제 메모리가 들고 있던 그 이름으로 이제 얘가 바꿔치기가 될 겁니다. 이건 이제 만들어보면 굉장히 신기하고요. 그 다음에 서버 패킷 핸들러라는 이름이 아니라 이것도 나중에 우리가 아웃풋을 받아가지고 따로 설정을 해주도록 할게요. 그러니까 여기다가 우리가 인자로 받아준 이 아웃풋이 , 사실, 그 용도로 받아준 거기 때문에 여기 파서에다가 아웃풋. 그러니까 아웃풋을 여기다가 아웃풋이라는 이름으로 똑같이 넘겨주도록 하겠습니다. 그럼 이제 얘를 그대로 여기서도 마찬가지로 활용할 수 있는 거고요. 그리고 여기 땡땡이는 삭제를 해주고. , 자, 그 다음에 또 살펴보다 보면은 또 취환할 부분. 이제 두 군데가 남았네요. , 자, 이 부분을 이제 만들어줘야 되는데 얘도 Receive Packet 대성으로만 해주는 애니까 일단 이 코드를 일단 그대로 복붙하도록 하고 Ctrl-Z로 다시 한 번 , 이렇게, 만들어주고 , 자, , 이렇게, 만들어주면 되는데 이 자동화 코드를 일단 복붙 해가지고 여기 안에다가 , 일단은, 이렇게, 넣어주도록 할게요. 그 다음 얘는 한 칸, 두 칸, 탭 두 칸을 띄워야지만 얘가 똑같은 줄로 맞춰져가지고 될 테니까 , 이렇게, 만들어 줬고요. 그 다음에 이제 어느 부분이 똑같는지를 또 장난을 치면 되겠죠. , 자, 여기서 유심히 보면은 여기 패킷 애스트 테스트라는 요 부분이 , 일단은, 바꿔치기가 되어야 될 것 같은데 이건 우리가 패킷 네임이라는 이름으로 관리하고 있었으니까 얘를 요 부분을 요렇게 , 일단은, 바꿔치기를 해주시면 되겠고 그 다음에 뒷부분에서도 쭉 살펴보면은 , 자, 요 부분 핸들 모지기 모지기 요 부분도 컨트롤 V 컨트롤 Z , 자, 이렇게, 해서 패킷 네임으로 바꿔치기가 되게끔 유도를 해주도록 하겠습니다 아 그리고 요 부분도 있네요 패킷 S 테스트 그러니까 이 부분도 Ctrl-V, Ctrl-Z로 해서 , 이렇게, 넣어주도록 할게요. , 자, 그러면 나머지 부분은 건드릴 필요 없을 것 같으니까 , 이렇게, 냅두면 이 부분까지도 일단 완성이 된 겁니다. 그리고 정말 마지막으로 또 한 건 있지 않았나요? 여기 자동화하는 부분이 하나가 더 있었죠? 이 부분 같은 경우는 이제 거꾸로 리시 패킷이 아니라 샌드 패킷을 우리가 여기다가 넣어 놔야 되니까 얘도 일단 복붙을 한 다음에 컨트롤 Z로 자르고 , 이렇게, 당긴 다음에 이 부분을 샌드 패킷으로 바꿔주고 그 다음에 자동화 할 코드를 역시나 복붙 해가지고 만들어주고 얘는 탭을 한 칸만 , 이렇게, 띄워 주도록 할게요 그 다음에 S 테스트랑 여기 뒤에 S 테스트라는 게 등장하는데 그 부분만 바꿔치기를 해주면 되니까 여기 Packet Name 부분을 잘라가지고 여기까지 , 이렇게, 만들어주고 Packet은 냈던 채로 여기까지 일단 또 만들어주도록 하겠습니다. , 자, 이렇게, 하면은 뭐 아직까지 이게 잘 동작할지 굉장히 궁금한데 , 일단은, 코드는 완성이 된 겁니다. 그러면은 여기 다시 돌아와가지고 메인에서 이 부분이 이제 실행이 될 건데 Get Template Packet Header를 파싱해가지고 템플릿 엔진을 이용해서 렌더를 해라 근데 여기서 메모리상의 그 데이터들을 우리가 , 이렇게, 건네준 거라고 보시면 되겠어요 굳이 한 칸 안 띄기도록 하겠습니다 그래서 아웃풋이랑 파설을 건네줘가지고 요 아이를 실행해라 라고 일단 만들어주면 되고 그걸 이제 최종 결과물을 저장해주면 되겠죠 다시 파일 입출력 argument에 output 근데 여기다가는 이제 .h를 추가해서 이 파일 이름을 만들어줄거고 그 다음에 write overwrite w플러스로 만들어줘가지고 파일이 있으면 덮어쓰도록 할 것이고 fwrite를 한 다음에 output을 그대로 출력을 해주도록 할게요 즉 이 템플릿 엔진이 완성한 결과물을 이제 output으로 받아줘서 걔를 파일에다가 쓰고 파일을 닫아 주세요 라고 하는 겁니다 그리고 궁금하니까 로그로 이 아웃풋을 간단하게 찍어 보도록 할게요 , 자, 요렇게 해가지고 , 일단은, 요 패킷 제너레이터 코드가 완료가 될 겁니다 다음 얘는 이제 빌드 하는 게 아니라 그냥 실행을 해 가지고 실시간으로 에러가 나오면 여기서 뭐 크래시가 날 겁니다 그래서 뭐 이걸 리턴에다가 브릭 분들 잡고 다시 한번 실행을 해 보도록 할게요 , 자, 그러면 얘가 실행이 되면은 만약에 우리가 뭐 잘못된 부분이 있다고 하면은 여기서 이런식으로 문제가 지금 뜨고 있는데 아웃풋 아웃풋이 아니라 아웃티가 빠져서 그런거네요 오탈을 내서 그런거고 다시 한번 저장해서 실행을 해보도록 하겠습니다 , 자, 그러면 여기서 정상적으로 실행이 됐고 여기서 로그가 뜬 걸 보면 굉장히 재미있게도 이런 식으로 패킷이 정상적으로 , 이렇게, 만들어진 걸 볼 수가 있습니다. C테스트 만들어 놨고 그리고 이 부분도 정상적으로 생성이 된 걸 볼 수가 있습니다. 그래서 결국에는 우리가 넘겨준 이 프로토 파일을 기반으로 이제 자동화해가지고 파일을 만들어 줬다는 걸 볼 수가 있는 거죠. 그래서 실제로 상위 폴더 여기에 가서 살펴보면은 테스트 패킷 핸들라는 이 파일이 이제 만들어진 겁니다. 이제 이거를 우리가 그대로 복붙을 해서 다시 우리 원복, 원래 C++ 코드에서 사용하면 된다라고 , 일단은, 볼 수가 있는 거예요. , 자, 근데 그렇다고 이거를 매번마다 우리가 빌드해 가지고 실행할 수는 없으니까 이거를 좀 편하게 exe 파일 실행 파일로 만들어 보고 싶은데 파이썬에서는 기본적으로 fuzesio 상에서 뭔가 실행 파일로 만들 수 있는 방법은 없습니다 다만 우리가 이제 따로 별도의 라이브러리에 이용해가지고 좀 간접적으로 뭔가 , 이렇게, 만들어줄 수는 있기는 한데 그게 아까 우리가 다운로드 받은 파이 인스톨러의 개념이라고 보시면 돼요 , 자, 그래서 , 일단은, 뭘 해볼 거냐면은 아까 여기 지금 우리가 만들어준 패킷 제네러이터를 잠시 , 이렇게, 열어본 다음에 여기다가 , 이렇게, makeex.bat 라는 이런 파일을 일단 하나 만들어 주시면 되겠습니다. 저는 미리 해봤는데 뭐 그냥 간단하죠? 이걸 만약에 만든다고 하면은 새로 만들기 텍스트 문서 간 다음에 makeex.bat 라고 , 이렇게, 배치 파일을 만들어 주시고 그 다음에 얘를 드래그 드롭 해가지고 , 일단은, 아무랑 메모장이나 뭐든 , 이렇게, 잠시 켜주면 되겠습니다. , 자, 그 다음에 여기다가 만들어 볼 거는 명령어를 간단하게 그냥 pusht 현재 경로를 일단 저장해주고요 뭐 이건 , 사실, 굳이 안해도 되긴 한데 그냥 일단 요렇게 시작을 해보도록 하고 그 다음에 파이 인스톨러를 실행해서 옵션은 one file 그냥 하나의 파일로 모든 애들을 묶어달라 우리가 , 사실, 패킷 제네레이터랑 프로토파서 두 개의 파일이 지금 개입을 하고 있는데 그걸 하나의 EX 파일로 만들어달라 이겁니다 그리고 파일은 지금 패킷 제네레이터.py라는 파일이 있는데 이 파일을 .exe 파일로 만들어 달라고 요청을 하는 겁니다. 그래가지고 이제 , 이렇게, 만들어 준 다음에 make.exe.batch를 한번 실행을 해보도록 할게요. , 자, 그러면 이제 좀 오래 걸리는데 , 이렇게, 열심히 열심히 막 하려고 할 것이고 이게 만약에 안 돼 있으면은 이 파이 인스털로를 다시 까시면 됩니다 근데 , 일단은, 저 같은 경우에는 뭐 잘 설치가 되어서 , 이렇게, 열심히 하다 보면은 , 자, 요런 식으로 이제 나머지 파일들이 생겨요 빌드 안에 패킷 제너라이트는 뭐 이런 이런 파일도 생기고 실제로 EX 파일은 디스트 안에 요기 패킷 제너라이트는 요렇게 생기게 되었습니다 경우에 따라서 여기서 윈도우 디펜더가 얘를 악성코드로 옵진하는 경우가 은근히 있더라구요. 근데 그런 경우에는 얘를 삭제하지 않도록 그냥 설정을 해주시면 되구요. 그 안티바이러스라는게 굉장히 똑똑하게 잡는게 아니라 어떤 패턴을 봐가지고 잡는건데 하필이면 , 이렇게, 우리가 EX 파일로 만들어줄 때 그 패턴이 어떤 바이러스랑 겹치나 봅니다. 그래가지고 이제 오탐을 하고 있는데 그 부분은 그냥 감안을 하시고 버그가 뭐 딱히 위험한 상황이 아니니까 , 자, 그 다음에 여기 나머지 이런 쓰레기 파일들 빌드나 뭐 요런 파일들을 좀 깔끔하게 지워줬으면 좋겠는데 그걸 여기다가 같이 추가를 해 보도록 할게요 아까 우리의 결과물을 , 일단은, 옮겨 놓도록 하겠습니다. 여기 안에서 dist에 package generator.exe 라는 애가 있었는데 걔를 GenPackets.ex라는 이름으로 그냥 바꿔주면서 dist... 아, 밖으로 , 일단은, 끄집어내도록 하겠습니다. 이동을 하고 그 다음에 나머지 이제 뭐... 리무브 관련된 명령을 실행해가지고 요 빌드와 관련된 폴더들도 지워버리고 그 다음에 dist와 관련된 폴더도 싸그리 지워주세요 라고 하는 겁니다. 그리고 마지막으로 f, q 어... 아까 다시 살펴보면은 찌끄레기가 좀 더 남아있었던 걸로 기억을 하는데 여기서 패킷 제너레이터 스펙이라는 이 애도 지워버리도록 할게요 필요 없으니까 패킷 제너레이터.스펙 그 다음에 포즈를 해가지고 잘 실행이 되는지 한번 살펴보도록 하겠습니다 , 자, , 이렇게, 해서 일단 얘를 다시 실행을 하면 똑같이 잘 실행이 된 다음에 찌끄레기까지 , 일단은, 다 날려주고 최종적으로 결국에는 이 ZenPackage.exe라는 애만 , 이렇게, 딱 동그랗게 남게 된 겁니다. 이제 우리는 얘만 실행을 해가지고 동일한 효과를 낼 수 있는 거죠. 얘를 이제 만들어주는 효과를 낼 수가 있다고 보시면 되겠습니다. 한번 해볼까요? 얘를 삭제하고 신기하게도 GenPackets를 딱 눌러보면 기다리면 얘가 만들어진다는 것도 확인을 할 수가 있어요 , 이렇게, 일단은, 이 EXE 파일을 사용할 준비가 끝났다라고 볼 수 있는 거고 근데 이제 매번마다 이거를 또 눌러주기는 굉장히 또 귀찮으니까 우리가 지금까지 외부에서 관리하고 있던 거로 일단 옮겨주도록 할게요 그래서 일단 얘는 필요 없고 일단 GenPackets.exe랑 Templates라는 이 폴더를 Ctrl-C로 복붙한 다음에 뒤로 가서 Common, Protobuf, Bin 안에 관련된 툴들을 다 모아놓고 있으니까 여기다가 복붙을 해보도록 하겠습니다. 그래서 필요한 기능들은 다 여기다 갖다 놨고 그 다음에 이 Gen Packet을 다시 한번 수정을 해보도록 할 건데 지금 여기까지 작업이 되어 있는데 이제 추가적으로 나머지 부분들도 여기다 넣어주도록 할게요. gen package.exe 를 실행하세요 근데 패스는 현재 위치에 protocol.proto 를 이제 실행해 주시면 되고요 프로토 파일이 요 아이구요 그 다음에 아웃풋 같은 경우에는 client-packet-handler 라는 이름으로 만들어 주시고 receive 컨벤션은 C 언더바 그리고 한 칸 띄고 send 컨벤션은 S 언더바로 부탁을 합니다 라고 , 이렇게, 요청을 해 보도록 하겠습니다 그 다음에 컨트롤 뒤로 하나를 더 실행해 가지고 이번에는 거꾸로 서버 패킷 핸들러라는 걸 만들어 주고 얘는 S 언더바랑 C 언더바를 거꾸로 뒤집어 주도록 할게요 , 이렇게, 일단은, 만들어 주면은 자동화된 코드에 의해 가지고 패킷 핸들러가 두 개가 , 일단은, 만들어질 겁니다 그 다음에 여기서 쭉 실행이 될 거고 마지막으로 복사하는 부분도 추가를 해주도록 할게요 여기다가 컨트롤 D 복사를 한 다음에 프로토콜 모시기가 아니라 얘는 클라이언트 패킷 핸들러 .h라는 파일을 여기 게임 서버에다가 넣어주도록 할 것이고 거꾸로 더미 클라이언트 쪽에서는 서버 패킷 핸들러.h 를 이쪽에다가 넣어 달라고 할게요. 이름을 뒤바꿔 주도록 하겠습니다. 더미 클라이언트에서 앞으로 이제 서버 패킷 핸들러를 들고 있을 거고 게임 서버에서는 클라이언트 패킷 핸들러로 이제 이름을 뒤바꿔 주도록 할게요. 그래야지 좀 더 직관적으로 나중에 서버가 많아지고 할 때 좀 더 이해하기 쉬울 것 같아서 , 이렇게, 바꿔치기를 해주고 그 다음에 나머지 찌끄레기들을 또 지우는 부분을 여기다가 만들어 주도록 하겠습니다. 뭐 s, q, f 요런 명령어들은 그냥 뭐 타키크 그냥 따라 치시면 되고 궁금하시면 구글링을 해보시면 이게 어떤 의미인지 다 나와 있습니다. pb.h 저도 당연히 기억을 잘 안해요. 이거는 한번 필요할 때마다 찾아보고 그냥 작업을 하고 있습니다. q, f pb.cc와 관련된 파일들도 다 날려주도록 하고 불필요한 파일들을 그냥 , 일단은, 다 날려주는 부분을 추가해 주도록 할게요. s, q, .h로 시작하는 모든 파일들로 다 삭제를 해주세요. 그 다음에 잠시 멈춰주세요 라고 , 이렇게, 만들어 보도록 할게요. , 일단은, 이 배치 파일을 실행하기 전에 더미 클라이언트 쪽에 있는 요 파일을 잠시 이름을 바꿔치기 해주도록 할게요. 서버 패킷 핸들러 라는 이름으로 바꿔치기를 해주고 그 다음에 거꾸로 게임 서버 쪽에서는 얘를 클라이언트 패킷 핸들러 라고 , 일단은, 바꿔치기를 해주도록 하겠습니다. 그러면은 나중에 이제 배치 파일을 실행하게 되면은 우리가 작업해준 이 아이로 덮어써지게 될 테니까 이 헤더가 , 일단은, 뿅 바뀌게 된다는 걸 예상을 할 수가 있습니다. 정말로 바뀔지 궁금하니까 , 일단은, 배치 파일을 다시 한번 실행을 해보도록 하겠습니다. 이거를 그냥 빌드해도 되긴 하는데 일단 처음이니까 배치 파일을 실행하는 식으로 한번 작업을 해볼게요. 어디에 썼나? Common Protobuf Bin. 이 배치 파일, 대망의 배치 파일을 두 번 눌러주도록 하겠습니다. 그러면 열심히 열심히 실행이 되면서 문제없이 모든 애들이 다 실행이 됐다는 걸 볼 수가 있고요. 불필요한 내용을 일단 싹을 날려줬고 그 다음에 여기서 이제 다시 보면 패킷 핸들러가 업데이트가 된 걸 볼 수가 있죠. , 이렇게, 새로운 애들이 막 추가가 되어 있다라는 걸 볼 수가 있습니다. 별다른 문제가 없으면 나머지 부분들은 , 이렇게, 처리가 될 것이고 그 다음에 지금 밑줄이 그어져 있는 거는 그냥 Visual Studio 상에서 아직 못 잡아준 것 같고 다만 여기 cpp는 이제 자동화된 코드가 아니니까 이 부분은 우리가 이제 맞춰줘야 되겠죠 클라이언트 패킷 핸들러를 넣어주게끔 , 자, 이렇게, 일단은, 맞춰주고 핸들 c 테스트로 얘를 , 일단은, 바꿔치기를 해주고 나머지 부분은 딱히 문제가 없을 것 같습니다 빌드를 일단 게임 서버 빌드를 해보고 우리가 클라이언트 패킷 핸들러로 바꿔가지고 뭐 문제가 일어나는 부분이 있을 테니까 그 부분을 수정하면 되겠죠 , 자, 일단은, 잡아주고 가서 바꿔치기 이거 클라이언트 패킷 핸들러로 바꿔치기하고 요 부분도 , 이렇게, 바꿔치기를 해주면 되겠습니다. 그리고 이쪽에서도 , 자, 이렇게, 클라이언트 패킷 핸들러로 작동하게끔 해서 다시 한번 게임 서버 빌드를 해보도록 할게요. 그리고 조금 기다리다 보면은 이거 또 문제가 일어나고 있는데 어.. 얘같은 경우에도 클라이언트 패킷 핸들러로 바꿔치기를 해주면 되겠죠. , 자, 이렇게, 해서 또다시 빌드를 해보도록 하겠습니다. 이제 진짜 되는 것 같은데 어... , 자, 그 다음에 여기서 문제가 일어나는 거는 C 테스트와 관련된 부분에서 문제가 일어나고 있는데 아 여기 프로토콜이 C 테스트인데 요 부분을 수정 안 해가지고 구현부가 없다고 지금 불평하는 거네요 네 우리가 선언은 요렇게 해놨는데 구현부가 달랐기 때문이죠 그러니까 다시 한번 진자진자 빌드를 해보도록 할게요 , 자, 요렇게 일단 통과가 되면은 이제 진짜 될 것 같은데 오케이 됐습니다 , 자, 그러면 이제 거꾸로 더미 클라이언트도 마찬가지로 요 부분이 , 일단은, 바뀌었으니까 얘도 이제 빌드를 하면은 이런저런 에러가 나겠죠 기다려보도록 합시다 일단 헤더는 왼쪽에 cpp는 오른쪽에 한 다음에 , 자, 여기서도 , 일단은, 헤더 파일이 서버 패킷 핸들로 바꿔야 되구요 오케이 그 다음에 요 부분도 서버 패킷 핸들로 두개를 만들어주면 되겠죠 아 얘같은 경우는 심지어 이게 필요 없겠네요 핸들 s 테스트랑 에스트 이다 보니까 네 요 부분은 어 잠시 살펴보면은 서버 패킷 핸들 s 테스트 가 여기 있고 핸들 s 로그인이 아직 구현부가 만들어지지 않았는데 임플메니테이션을 추가를 해보도록 할게요 , 이렇게, 자, 그 다음에 핸들 인벨리드가 지금 딱히 없는 것 같은데 얘도 구현부를 만들어주면 되겠죠 좀 정신이 없는데 클라이언트 패킷에서 핸들 인벨리드 쪽을 긁어온 다음에 이쪽에다가 그냥 복붙을 하고 핸들 패킷은 이제 사용 안 할 거니까 얘는 딱 날려도 되고요. 그 다음에 핸들 로그인은 그냥 리턴 투로로 , 이렇게, 만들어주면 되겠습니다. 그 다음에 다시 한번 빌드를 해서 이런 식으로 계속 에러가 나면 그냥 고쳐주시면 되고요. 마지막 에러는 onListPacket에서 나고 있는데 여기 왜 나냐면 우리가 PacketSession이라는 인자를 하나를 추가해줘서 그런 거네요. 여기 부분을 귀찮으니까 게임 세션 쪽에 얘를 긁어와서 그대로 복붙한 다음에 에러 나는 부분으로 돌아와서 얘를 , 이렇게, 넣어주도록 하겠습니다. 그러면 세션을 첫번째 인자로 , 이렇게, 넘겨주면은 , 자, 이제 진짜 문제가 다 해결이 되었습니다 그래서 빌드를 , 일단은, 해보도록 할게요 , 자, 이렇게, 해가지고 처음에 설정을 할 때는 조금 귀찮긴 했는데 어 또 하나가 더 있네요 , 자, 여기는 링크 문제는 그래도 굉장히 다행인게 그냥 요 구현부가 뭔가가 없다는 얘기일 확률이 높습니다 그래서 지금 클라이언트 쪽 s 테스트랑 아 s 테스트가 얘가 바뀌어가지고 그런거죠. 여기 바이트 버퍼가 아니라 요 방식으로 요렇게 , 일단은, 바꿔치기를 해줘야 되겠습니다. 이런 느낌으로 그 다음에 기존에 있던 pass from 아래는 이미 다 해주고 넘어온 거니까 요 부분을 싹 날려주면 되겠죠. 그리고 서버와는 다르게 우리가 더미 클라이언트 쪽에서는 지팩킷 핸들러의 구현부를 만들어 놓지 않아서 얘도 , 일단은, 이렇게, 추가를 해주시면 되겠습니다. 그리고 나머지 부분, 이런 부분은 삭제를 해도 되겠죠. 그래서 , 이렇게, 더미 클라이언트를 다시 빌드해서 이제 진짜 통과가 될 것 같고요. 뭔가 안 되는 부분이 있다고 하면은 좀 비교해서 보시기를 바라겠습니다. 저도 막 좀 정신이 없었는데 아 그리고 제가 작업하다가 하나 실수를 했는데 어 여기 지금 코드가 여기 다 만들어진 다음에 여기 있는 파일들을 다 날리는 것까지는 좋은데 지금 여기 템플릿 안에 있는 우리 원본 파일까지 지금 템플릿까지 다 날려버리고 있네요 그래가지고 이거를 이 S라고 되어있는 이 부분을 , 일단은, 삭제를 해가지고 얘가 Recursive하게 들어가라 재기적으로 안에까지 들어가라는 의미라고 하는데 얘를 없애주면은 이제 안에 있는 폴더 파일까지는 안 지워주고요 그 다음에 뭐 삭제를 하셨다고 하면은 원래 있던 원본을 찾아가지고 다시 한번 넣어 주시면 되겠습니다. server-common-trotmorph-bin 템플릿 안에다가 얘를 다시 , 이렇게, 배치를 시켜 놓도록 할게요. , 자, 그래서 이제 진짜 빌드 하면은 뭐 별다른 문제 없이 다 실행이 될 거구요. 이제 한번 만들어주는거는 굉장히 귀찮긴 했지만 요렇게 만들어주게 되면은 나머지 사람들은 그냥 이 존재에 대해서 잊고 그냥 작업을 해도 됩니다 예를들면 이제 이 상태에서 추가적으로 내가 컨텐츠 프로그래머라고 하고 see on the bar move 라는 패킷을 만약 내가 설계한다고 가정해봅시다 나는 누구누구인데 뭐 어디어디 위치로 이동하고 싶어요 라는 요런 패킷을 만든다고 했을 때 요렇게 프로토 파일을 만들어주고 그 다음에 뭐 , 사실, 더밍클라운트 아니라 이제 게임 서버를 , 이렇게, 한번 빌드를 해주게 되면은 요기 프로토콜이 있는 쪽에서 한쪽에서 이제 작업을 해주게 되겠죠 지금은 그냥 테스트하기 위해서 양쪽에 다 넣어두긴 했지만 그러 보다 보면은 이제 이런식으로 먼저 에러가 한번 나긴 날건데 이거는 딱히 에러라기보다는 이제 경고죠? 여기 핸들러 C무브로 올텐데 얘를 니가 구현을 안했다라고 뜨는거고 이제 이거를 이런식으로 열심히 인플레미테이션을 구현해가지고 여기서 이제 컨텐츠를 작업해주게 될겁니다 그래서 그 다음에 두번째 턴에서 다시 빌드를 하면은 나머지 부분은 다 정상적으로 처리가 될 것이고 그리고 실질적으로 내가 이 부분만 이어가지고 작업을 하면은 나머지 패킷을 조립하고 받는 부분은 다 숨겨져서 정상적으로 동작을 할 것이고 반대로 클라이언트 쪽에서도 이제 만약에 CMove 패킷을 내가 보내고 싶은 일이 생긴다라고 하면은 뭐 굉장히 쉽게 작업을 할 수가 있겠죠? 막 이런데서 CMove를 여기서 직접적으로 만들어가지고 프로토콜에 CMove 뭐 예를 들면 , 이렇게, Move Packet을 만들어주고 그 다음에 얘를 다시 Server Packet Handler에다가 Make Sand Buffer로 호출해가지고 이 Move Packet을 뭔가 , 이렇게, 만들어 준 다음에 여기서 Sand Buffer를 만들어주고 Sand Buffer 그 다음에 얘를 이제 보내는 식으로 굉장히 편하게 작업을 할 수 있게 된 겁니다. 이래서 고생한 보람이 있는 거고 한 번쯤은 맨 처음에 한 명만 이 고생을 하면 그 다음부터는 이거 고치는 건 크게 어렵지 않습니다 이런 자잘한 부분에서 만약에 우리가 고치고 싶은 게 생긴다고 하면 진짜로 그 부분만 찾아가지고 고쳐주면 되겠죠 , 이렇게, 해가지고 환경 설정 처음에 Python 깔아주는 게 좀 귀찮긴 하지만 그럼에도 불구하고 저는 개인적으로 진자2 이 라이브러리를 굉장히 좋아합니다 굉장히 우아하죠 코드가 진짜로 딱 우리가 동적으로 생성되기 원하는 부분만 , 이렇게, 코드로 만들어줄 수 있기 때문에 굉장히 큰 장점이 있다고 일단 보시면 되겠고 제가 이전에 나오기 직전에 이런 자동화하는 코드를 파이썬으로 , 일단은, 작업이 되어 있었길래 저도 이런 부분을 좀 수정하고 나온 기억이 있습니다. 그래서 실질적으로 실무에서도 파이썬으로 진자 툴을 이용해가지고 자동화하는 코드를 굉장히 많이 만들기 때문에 이런 부분도 언제쯤이면 파이썬도 이제 좀 공부를 할 겸 이런 부분을 만들어 보셨으면 좋겠어요. , 자, 이렇게, 해가지고 C샵 수업과는 다르게 툴을 일단 파이썬으로 만들어보는 실습을 끝냈구요. 이제 이어가지고 패킷과 관련된 내용은 여기서 마무리를 짓도록 하고 다음 단원으로 이제 드디어 넘어가도록 하겠습니다. 좀 지루한 작업일 수 있는데 그래도 한번쯤은 할만하니까 어찌됐건 , 이렇게, 작업을 한번 연습을 해보시고 다음 단원으로 넘어오시면 되겠습니다. 아 그리고 이제 혹시 실행 테스트를 하고 싶으신 분들이 계실 수 있으니까 물론 다음 시간에 이어서 하겠지만 지금 약간 버그가 있더라구요 시작 프로젝트 여러 개로 게임 서버 더밍 클라이언트를 킨 상태에서 지금 실행하려고 하면 크래쉬가 날텐데 여기 세션을 추출하는 부분이 getPackinSessionRef라는 함수인데 이걸 get을 제가 뭐 빼먹었는지 오차를 냈는지 이 부분이 없어가지고 일단 널크래쉬가 날 거고요. 더밍 클라이언트에서도 마찬가지로 테스트할 때 얘를 , 이렇게, 바꿔주시게 해주시면 되겠고 그 다음에 우리가 이제 이 서버패킷 핸들러라는 거를 최초 한 번은 이닛을 어딘가에서 호출해가지고 얘를 채우는 부분이 들어가야 되는데 그거를 더밍 클라이언트에서도 해줘야 되겠죠. 여기서 뭐 처음에 한 번쯤은 서버패킷 핸들러에 이닛하는 부분을 , 이렇게, 일단 호출해주면 되겠습니다. 이걸 명시적으로 , 이렇게, 호출하는 게 마음에 안 들면 다른 식으로 만드셔도 되고요. 이건 이제 하나의 예를 보여드린 겁니다. 이런 식으로 자동화를 하면 된다. 꼭 이게 최선의 방법이다라는 의미는 아니에요. 이거보다 분명히 더 좋은 방법도 당연히 있을 겁니다. , 이렇게, 매번마다 함수를 만들기보다 다른 방식도 찾을 수 있을 것이고. 어찌됐건 지금 단계에서는 요렇게 해서 빌드를 해본 다음에 이제 기존에 작업한 코드는 딱히 바뀐 것이 없으니까 똑같이 로그가 뜨는 것만 확인을 해보도록 할게요. , 자, 다시 클라이언트랑 서버를 시작을 해보고 기다려보다 보면은 , 자, 이런 식으로 클라이언트에서 정상적으로 모든 로그가 다 뜨는 것을 볼 수 있습니다. , 자, , 이렇게, 해서 편하게 컨텐츠를 작업할 준비가 되었으니까 진짜 진짜 강의를 마치도록 할게요.