자, 이제 이어서 이번 시간에는 쓰레드를 생성하고 그리고 구동시켜 가지고 정보를 체크하는 그런 실습을 해볼 건데요 드디어 처음으로 멀티스레드 환경으로 들어온다는 얘기가 되는 거죠 , 자, 일단은, 실습은 우리 여기 게임 서버에서 그냥 계속 할 건데 , 사실, 뭐 새로운 프로젝트로 만들어서 해도 상관없습니다 뭔가 이어주는 내용이 아니라 그냥 잠시 실습을 하고 탁재할 내용들이라고 보시면 되겠어요 그래서 게임 서버 프로젝트에서 실행하게끔 여기 까먹지 않고 우클릭 A를 눌러 가지고 시작 프로젝트로 설정을 눌러 주시고요 여기서 작업을 한번 해보도록 할게요 , 자, 그런데 이제 한가지 여러분들이 아셔야 되는 것은 뭐냐면은 우리가 , 이렇게, 예를 들면은 see out을 해가지고 우리가 뭐 hello world를 출력을 한다고 가정해 볼게요 지금까지는 뭐 그냥 아무 생각 없이 이걸 했겠지만 이게 생각보다 의외로 무거운 작업입니다 , 사실, 우리가 유저 레벨에서 컨텐츠 단에서 가볍게 할 수 있는 더샘, 뺄샘 이런 연산이 아니라 모니터에다가 우리가 뭔가를 출력을 요청하고 있죠? 씨아웃이라고 해가지고 요런 애들은 , 사실, 시스템 콜이라고 해가지고 우리가 운영체제 커널쪽에다가 요청을 한 다음에 운영체제가 우리가 요청받은 Hello World를 출력해달라는 것을 사실상 해주고 있는 거예요. 이 얘기를 왜 하냐면 마찬가지로 Thread를 새로 생성해주세요 라는 것도 우리가 유저 레벨에서 멋대로 할 수 있는 게 아니라 이것도 결국에는 우리가 운영체제한테 요청을 해가지고 운영체제가 처리를 해줘야 된다는 얘기가 되겠습니다. 그래서 운영체제한테 요청을 하기 위해서는 결국에는 운영체제마다 제공하는 그런 API 함수들이 있을 것이고 그거를 활용해서 우리가 Thread를 만들어야 되는데요. 이 함수들이 불행하게도 Windows냐 아니면 Linux 진영이냐에 따라 가지고 당연히 다릅니다. 예를 들면 윈도우즈 환경이니까 include-windows-header를 추가한 다음에 예를 들면 여기 보면 create-thread 이런 함수를 이용해 가지고 thread를 만들어서 활용을 할 수가 있어요 그런데 , 이렇게, 만약에 우리가 윈도우의 종속적인 api를 활용하게 되면 혹시라도 혹시라도 나중에 우리가 리눅스 진영으로 넘어간다고 했을 때 굉장히 수정할 내용이 많아지게 되겠죠 그런데 이제 C++11부터 이 Thread를 생성하는 것이 표준에 들어왔습니다. 즉 여기 Include Thread라는 이거입니다. Thread라는 이 헤더를 추가하게 되면 이제 Linux건 Windows건 어떤 환경인건 상관없이 공용적인 코드로 다양한 환경에서 돌아갈 수 있는 코드를 우리가 이제 작성할 수 있기 때문에 어지간해서는 이런 모던한 방법을 이용해 가지고 Thread를 구동하시는 것을 이제 추천을 드립니다. 물론 서버 같은 경우에는 클라이언트와 다르게 안드로이드 아니면 iOS 같이 이 환경 저 환경에서 동시에 실행되는 그런 개념이 아니라 우리가 서버 환경을 하나를 찍고 그냥 거기서 구동이 되게 평생 작업을 하게 되겠지만 그럼에도 불구하고 먼 미래 혹시라도 다른 운영체제에서도 호환이 되는 그런 서버를 만약에 만들고 싶다고 하면 최대한 이런 공용적인 라이브러리를 이용하는 게 좋겠죠 참고로 말씀드리면 서버 같은 경우에 한국에서는 아직도 윈도우즈 서버를 굉장히 많이 사용하는 추세이긴 합니다. 특히나 NC 소프트라고 하는 이런 회사들에서는 리눅스 서버보다는 아직도 C++, IOCP 서버, 윈도우즈 서버를 활용하는데 이제 또 해외 쪽으로 넘어가게 되면 윈도우즈보다는 리눅스를 선호합니다. 그래서 제가 듣기로는 한국에서 윈도우즈 서버로 만들어서 중국에다가 퍼블리싱을 했더니 중국 쪽에서 이걸 리눅스로 포팅 해달라고 굉장히 강하게 요청을 했다는 그런 썰을 들은 적이 있는데 그런 경우를 생각해서라도 최대한 코어 라이브러리를 만들 때 이 환경 저 환경에서 동시에 돌아가는 코드를 만들면 좋겠죠 어쨌든 너무 서론이 길어지는데 그래서 결론은 이 스레드 표준을 이용하겠다가 , 일단은, 결론이 될 것이고 , 일단은, 사용하는 방법은 굉장히 단순합니다 , 자, 여기 std thread 라고 해가지고 일단 thread 라는 클래스로 객체를 하나를 만들어 줄 거에요 이런식으로 얘를 이제 만들자마자 어 얘가 실행될 그 이 thread 에 어떻게 보면 메인 함수를 우리가 지정을 해줄 수가 있어요 엔트리 포인트라고 하는 건데 , 자, 예를 들면은 hello thread 라는 함수를 , 이렇게, 위에다가 만들어 주고 얘가 하는 것은 그냥 hello thread를 출력하고 끝나는 굉장히 단순한 함수를 만들어 볼게요 그럼 여기에다가 그냥 빈 생성자를 만드는 게 아니라 hello thread라는 요 함수를 같이 , 이렇게, 건네 주도록 하겠습니다 그러면 얘가 어떻게 구동이 되는 거냐면 이 코드가 실행이 되자마자 새로운 스레드가 뿅 만들어지게 되면서 그 스레드가 실질적으로 이 코드를 , 일단은, 실행하고 종료가 될 겁니다 우리가 지금까지 이 부분을 많은 사람들이 헷갈려 하시더라구요 이전 C샵 서버 강의 때 보니까 만약에 우리가 이걸 , 이렇게, 고지곳대로 실행했다고 하면은 우리 메인 함수에 와가지고 즉 메인 스레드가 여기 와가지고 여기 있는 헬로 스레드 함수를 호출하고 빠져나와 가지고 아래로 쭉 넘어가는 그런 개념이 되는 건데 그게 아니라 , 이렇게, 새로운 스레드를 만들어 가지고 실행을 하게 되면은 우리 메인 스레드는 계속 이 고지곳대로 이 코드가 실행이 됨과 동시에 다른 스레드가 새로 만들어가지고 병렬로 이 부분이 같이 실행이 되는 그런 개념이라고 보시면 되겠습니다. 동시에 얘랑 얘가 실행이 될 수 있다는 얘기가 되는 거죠. 그래가지고 얘는 이제 진짜로 독립적인 새로운 스레드가 요 부분을 이제 실행하게 될 것이구요 , 자, 그런데 요 부분을 , 일단은, 잠시 테스트를 해볼 건데 얘는 메인 스레드니까 hello main 이라고 , 이렇게, 출력을 해보도록 할게요 그 다음에 이거를 이제 빌드를 해가지고 컨트롤 f5로 실행을 하게 되면은 띵그렁 하면서 뭔가가 , 이렇게, 에러가 나는걸 볼 수가 있습니다 그 이유는 뭐냐면은 우리가 실질적으로 요렇게 쓰레드 어떻게 보면 쓰레드 오브젝트 쓰레드 객체를 하나 만들었는데 그렇다는 것은 우리가 , 사실, 이 t라는 변수로 이 스레드를 우리가 관리를 하고 있는 건데 이 메인 스레드가 먼저 , 이렇게, 끝나버리면 얘가 이런 식으로 에러가 나게 됩니다 그래가지고 이 메인 스레드 쪽에서 내가 호출한 애를 책임지고 끝날 때까지 , 일단은, 이렇게, 기다려주면 되는데 그때 우리가 사용할 함수가 몇 가지가 있는데 그 중에서 대표적으로 이 조인이라는 걸 , 일단은, 기억을 해주시면 되겠습니다 이 조인이라고 하는 건 무엇이냐면 얘가 끝날 때까지 기다려주겠다는 의미가 되는 거에요. 여기서 스레드를 구동하는 것까지 한 번에 실행을 하고 출력하는 것도 한 번에 한 다음에 여기까지 왔으면 얘가 끝날 때까지 대기를 해주는 상태가 되는 거죠. 그러면은 우리가 실행한 요 스레드는 그럼 언제 끝나느냐 뭐 마찬가지로 우리가 이 메인이라는 함수에 들어와가지고 이 메인이 끝날때 우리 프로그램이 종료되는거와 마찬가지로 요 스레드도 우리가 여기 엔트리 포인트로 넣어준 요 함수가 끝날때 요 스레드도 같이 이제 동작을 끝나게 됩니다 반대로 얘기하면 여기서 만약에 우리가 어떤 와일문을 넣어가지고 , 이렇게, 무한 루프를 돌게 하면은 , 사실, 용인은 영영 무한정 무한정 기다리게 된다는 얘기가 되는거죠 , 이렇게, 조인을 넣어주게 되면 다시 이 상태에서 실행을 해보면 Hello Main과 Hello Thread가 , 이렇게, 실행이 되었다는 걸 알 수가 있습니다 그리고 여기서 브레이크 포인트를 하나 잡아 볼 건데 Hello Thread 쪽에서 브레이크 포인트를 잡은 다음에 , 일단은, F4로 실행을 해보면 여기서 브레이크 포인트가 잡히는데 이 상태에서 이 위에 있는 Thread란을 보면 스레드가 여러 개가 있는 걸 볼 수 있습니다 주 스레드라고 해가지고 우리가 맨 처음에 메인함수를 구동한 스레드는 여기서 지금 멈춰있는 상태이고 이런 식으로 얘를 보면은 우리가 새로 구동한 요 스레드가 얘를 같이 실행하고 있는 걸 볼 수 있습니다 그래가지고 이제 우리가 MMO 서버를 만들게 될 때는 이런 식으로 다양한 그런 스레드들이 여기 목록에 뜰 테니까 어 브레이크 포인트를 잡아 가지고 이 시점에서 다른 애는 무엇을 하고 있는지 , 이렇게, 왔다 갔다 살펴볼 수가 있어요 그 다음에 이 Thread 클래스와 관련된 내용들을 , 사실, 그렇게 복잡하진 않은데 여기서 자주 활용하는 기능들이 몇 가지가 있습니다 그걸 이제 하나씩 나열해 볼 건데 여기 hardware concurrency라는 함수랑 그 다음에 getid라는 이 함수랑 그 다음에 detach라는 함수랑 joinable이라는 함수랑 마지막으로 join , 이렇게, 다섯 가지만 알면 , 사실, 그 외에는 뭐 신경 쓸 필요가 없습니다 여기 하드웨어 컨퀴런스 같은 경우는 굉장히 단순한데요 예를 들면 얘가 의미하는 바는 뭐냐면 실질적으로 CPU 코어 개수는 얼마인지 힌트를 줍니다. 즉 논리적으로 실행할 수 있는 프로세스 개수를 말하는 거죠 제가 멀티 스레드 OT 시간에 멀티 코어 환경에서 실질적으로 구동할 수 있는 코어 개수가 어느정도 CPU에 따라서 고정이라고 했었는데 그것을 정보를 추출하는 그런 함수라고 보시면 되겠어요. 근데 이게 100% 확률로 정확하진 않고요. 만약에 정보를 추출할 수 없다고 하면 이게 경우에 따라서 0을 리턴하는 경우도 있기는 합니다. 근데 뭐 제 환경에서는 아마도 잘 출력이 되는 걸로 기억을 하는데 뭐 이거 한번 궁금하니까 , 일단은, 나중에 한번 살펴볼 것이구요 네 요렇게 , 일단은, 살펴볼 것이고 그 다음에 아이디라고 해가지고 실질적으로 각 스레드마다 부여되는 일종의 아이디가 하나가 있습니다 그래서 얘는 이제 순차적으로 1, 2, 3, 4씩 늘어나는 건 아니고 약간 들썩날썩한 값이긴 한데 쓰레드 사이에는 안 겹친다는 게 보장이 되기 때문에 우리가 어떤 쓰레드인지 구분을 하고 싶다고 하면은 요 get 아이디를 이용하면 되겠습니다 그래서 요 부분도 , 일단은, 참고로 하시면 될 것 같고 , 자, 여기서 Get ID도 , 일단은, 출력을 여기서 브레이크 포인트를 잡아가지고 그냥 보도록 합시다 인트 32로 그냥 바꿔주도록 할게요 ID는 얼마이냐? , 자, 요렇게 아 이거 오토로 바꿔주도록 하겠습니다 이게 타입이 SDID여가지고 , 이렇게, 바꿔주도록 하고 , 자, 그건 그렇고 그 다음에 이제 디테치라는 함수도 있는데 얘는 이제 뭘 하는 거냐면은 아까 우리가 조잉 같은 경우에는 이 스레드가 끝날 때까지 메인 스레드에서 영영 기다려 준다고 했었는데 반대로 디테치를 해주면은 얘는 뭐냐면은 이제 우리가 만들어준 이 스레드 객체라는 T라는 애랑 실질적으로 구동된 스레드랑 연결고리를 빵 끊어준다는 의미가 되는 겁니다 그러니까 아예 백그라운드 스레드로 그냥 독립적으로 이제 동작하는 그런 개념이라고 보면 되겠는데 어 그러니까 한마디로 이제 얘는 유학을 해주면 std thread 객체에서 객체에서 실제 쓰레드를 분리한다고 보시면 되는 건데 이게 전통적으로 우리가 리눅스 쪽에서 요렇게 분리를 해가지고 만드는 걸 데몬 프로세스라고 했는데 그럴 때 일단 응용할 수 있긴 합니다 하지만 , 이렇게, 분리를 하게 되면 이제는 우리가 여기서 만들어준 이 T라는 애를 이용해 가지고 만들어준 Thread의 정보를 상태나 정보를 추출할 수가 없어지기 때문에 , 사실, 앤간에서는 이 기능은 활용할 일이 없기는 할 거예요. 그러니까 Detach라는 게 있다는 건 참고서만 알아주시면 되겠지만 , 사실, 딱히 기억은 할 필요 없다는 얘기가 되는 거고요. 그 다음에 Joinable이라고 해 가지고 만약에 아까처럼 디테츠 상태라거나 아니면 실질적으로 연동된 그런 Thread가 없다구나 하는 것을 판별하기 위해서 Joinable 이라는 걸 테스트를 해줄 수가 있어요 이게 어떤 상황이냐면 예를 들면 우리가 위에서 , 이렇게, T라는 객체를 만들자마자 Hello Thread라는 함수를 요렇게 연동을 시켜나가 주고 실질적으로 요 스레드가 생성이 되자마자 요 부분으로 실행이 되게끔 만들어놨는데 , 사실, 이거를 반드시 , 이렇게, 한 스텝에 모든 거를 다 할 필요는 없습니다 무슨 말이냐면 이거를 te는 std 스레드라고 뒤늦게 실질적으로 스레드 구동이 되게끔 만들어주고 이런 식으로 object 자체 객체 자체는 미리 만들어 줄 수도 있다는 얘기가 되는 거죠 이 상태에서는 , 사실, 얘가 아무런 기능도 하지 않는 겁니다 실질적으로 Thread가 실행이 되는 건 아니고 여기서 비로소 실행이 되는 거기 때문에 만약에 우리가 여기서 아이디를 체크를 한다고 하면 여기 있는 아이디 같은 경우에는 0인 상태로 들어오게 될 거예요 이것도 테스트를 해보기 위해서 1번, 2번 상태로 , 이렇게, 각각 배치를 한번 해보도록 하겠습니다 , 이렇게, 한번 놓도록 할게요 그래서 Joinable라는 거는 얘를 타고 가서 살펴보면 , 사실, 이 id가 0인지 아니면 체크하고 있다고 보시면 되겠습니다 실질적으로 이 객체랑 객체가 관리하고 있는 Thread가 살아 있는지 있는지 없는지를 판별하기 위해서 이 Joinable이라는 걸 이제 활용할 수 있다고 보시면 되겠어요 그래서 일반적으로 , 이렇게, t.join을 막바로 하지 않고 진짜로 조인이 될 수 있는지, 실제로 뭔가 연결이 돼 있으면은 기다려라라는 이런 방식으로 사용하는 게 조금 더 일반적이라고 볼 수가 있는 거죠 여기까지 , 일단은, 한번 테스트를 해보도록 하겠습니다 여기다가 브레이크 포인트를 잡아서 한 줄씩 한번 트랭을 해보도록 할게요 , 이렇게, 실행이 된 상태에서 살펴보면 객체가 만들어졌는데 아직까지는 id가 0번인 걸 알 수가 있습니다 , 이렇게, id가 0번이고 이제 실질적으로 이 버전 생성자에 실질적으로 Thread가 호출할 그 함수를 같이 연동해주면 이제 비로소 Thread가 만들어지면서 이 객체를 살펴보면 id가 8924로 배정이 된 걸 볼 수가 있어요 그 다음에 hardware concurrency는 제 환경에서는 , 일단은, 12 코어 개수가 , 일단은, 10이라는 거죠 진짜로 동시에 실행될 수 있는 Thread 개수라고 보시면 되겠습니다 뭐 이런식으로 8924 라고 해가지고 이제 아이디가 추출이 되는걸 볼 수 있습니다 그 다음에 조인이 될 때까지 기다렸다가 우아하게 마치는 요런 부분까지 , 일단은, 확인을 할 수가 있어요 어 그래가지고 뭐 , 사실, 쓰레드를 사용하는 거는 딱히 어려운 개념은 아니고 그냥 요렇게 쓰레드 어 표준 라이브를 이용해가지고 쓰레드를 만들었다가 마칠 때까지 기다려주고 요런 식으로 , 일단은, 활용을 해주시면 되겠습니다 뭐 , 사실, 요기 하드웨어 컨퀴런스 같은거는 참고삼아 알면 되겠지만 , 사실, 이걸 굳이 우리가 사용할 필요까지는 없고요 아이디도 추출해가지고 이걸 이용해가지고 판매를 하고 싶으면 사용하면 되겠지만 이것도 필수적인 건 아니니까 , 사실, 기억할 거는 그냥 이것밖에 없습니다 스레드를 만들고 기다리고 , 자, 그런데 이제 한가지 또 궁금한 점은 이런 식으로 분리해 가지고 스레드 객체를 먼저 만들고 나중에 뭐 이런 식으로 실질적으로 객체를 만들 일이 뭐 굳이 필요할까 싶지만 이게 종종 필요한 경우도 생길 수도 있습니다 뭐 예를 들면 우리가 벡터를 만들어 준다고 가정해 볼게요 이제는 스레드가 하나가 아니라 여러 개를 우리가 이런 식으로 관리한다고 가정해 볼게요 그 다음에 요 상태에서 예를 들면 푸시백을 한다고 하면 다행이지만 이걸 리사이즈를 해가지고 미리 사이즈를 10개짜리로 만들어 놓은 다음에 그 다음에 하나하나씩 구동을 한다거나 하는 식으로 만약에 만든다고 하면 이런 원적 객체를 빈 객체를 만들어 주고 그 다음에 실질적으로 스레드랑 연동시키는 부분이 유용하게 작동을 할 수 있겠죠 뭐 이런 경우를 , 일단은, 고려할 수 있겠습니다 근데 뭐 일반적인 경우라고 하면은 , 사실, 뭐 그냥 , 이렇게, 한 번에 만들어주는 것도 나쁘지 않겠죠 , 자, 그럼 이제 그 다음으로 실습할 거는 뭐냐면은 , 이렇게, 헬로스레드뿐만 아니라 인자가 만약에 추가가 된다고 하면 어떨까요? 이걸 헬로스레드 넘버 2라고 할게요. 여기서 예를 들면 그냥 어떤 숫자를 받아가지고 그 숫자를 출력하는 그런 기능이 있다고 가정을 해봅시다. 그럼 이제 얘를 고지곳대로 넣는 게 아니라 여기다가 뭔가 인자를 여기 있는 인자를 넣고 싶은데 그럴 때는 그냥 여기다가 심표로 해가지고 추가를 , 이렇게, 해주시면 돼요. 굉장히 신기한데 이 문법을 한번 살펴보면 이거 아마 처음 보시면 굉장히 헷갈리는 문법일텐데 잠시만요 어디있더라 여기서 이걸로 보는게 낫겠네요 , 이렇게, 해서 다시 한번 살펴보면은 쓰레드 객체에서 만들어줄 때 이 부분을 이제 function 이라고 해가지고 어떤 함수를 지금 , 이렇게, 받아주고 있습니다 사실상 얘가 템플릿으로 받아주고 있으니까 꼭 함수일 필요는 없고 그냥 어떠한 Callable 타입도 다 될 수 있습니다 즉 뭐 functor 라거나 lambda 타입도 다 받아줄 수 있다는 걸 알 수가 있고요 그 다음에 여기 , 이렇게, 템플릿은 템플릿인데, 점점점이라는 굉장히 묘한 문법이 들어가 있는데, 이게 C++11에 추가된 VeredicTemplate 이라는 문법인데, 한마디로 여기 있는 인자 갯수를 1개 받을 수도 있고, 2개 받을 수도 있고, 3개 받을 수도 있고, 4개 받을 수도 있고, 5개 받을 수도 있고 이 갯수가 자유자재로 변환할 수 있다는 얘기가 되는 거고 그거를 다 요 함수에다가 지금 전달을 해주는 상태라고 보시면 되겠어요 , 자, 이거에 대한 자세한 내용을 일단 생략을 할 것이고 나중에 후반에 잡큐를 다룰 때 요 문법에 대해서 그때 다시 나올 거니까 그때 가서 다시 한번 살펴보시면 될 것 같고 그래가지고 결국에는 여기 인자들을 그냥 , 이렇게, 이 방식으로 일단 넘겨주면 된다라는 것도 , 일단은, 기억을 해주시면 되겠습니다 그래가지고 지금 이제 실험을 해볼거는 무엇을 해볼까 하다가 뭐 이런식으로 스레드를 10개를 만약에 만들어 준다고 가정을 해봅시다 10개를 만들어 준 다음에 여기다가 푸시백을 이용해 가지고 밀어 넣어 줄 것인데 여기다가 스레드를 만들어 주면서 헬로 스레드 2번에다가 , 자, 여기다가 이제 뭐 어떤 숫자를 넣어 주도록 할게요 i 같은 느낌으로 이런 식으로 , 일단은, 활용할 수 있다는 얘기가 되는 거죠 그러면 이제 만약에 , 이렇게, 10개의 스레드를 만들어 가지고 걔네들을 다 구동을 시켜줬으면 거꾸로 걔네들이 모두 완료될 때까지 메인 스레드가 끝나면 안되고 자식들이 끝나기를 기다려줘야 될 테니까 이제는 거꾸로 이런 식으로 만들어주면 되겠습니다 만약에 얘가 조이너블이다 라고 하면은 그러면 조인을 해가지고 걔가 끝날 때까지 기다려줘 라고 조인을 해줘 라고 요런 식으로 만들어주게 되면은 이런 식으로 스레드 자체도 다수를 벡터를 이용해가지고 관리하는 부분도 요렇게 만들어 줄 수가 있을 거예요 , 자, 그래서 이제 얘를 , 이렇게, 실행을 해보면 0, 1, 2, 3, 4, 5, 6, 7, 8, 9까지 , 이렇게, 출력이 되는 걸 볼 수 있습니다 근데 조금 이상한 거는 순서가 우리가 예상한 순서는 아니죠 만들어준 순서가 아닐 뿐더러 실질적으로 출력이 될 때도 0 한 다음에 엔드 라인을 한 다음에 2가 출력이 되는 게 아니라 , 이렇게, 경우에 따라서 같이 붙어가지고 출력이 될 수도 있는데 그건 왜 그러냐면은 스레드가 , 이렇게, 구동이 되는 순간 우리가 10개를 구동했다고 했을 때 걔네들이 병렬로 실행이 되는 것이기 때문에 , 사실, 그 중에서 누가 먼저 얘를 출력을 할지는 예상을 할 수 없을 뿐더러 이 cout이라는 이 표준 입출력 기능을 이용을 할 때 멀티스레드 환경에서 얘가 정확하게 우리가 예상한 대로 하나가 실행되고 그 다음에가 실행되고 하는 순차적인 순서가 보장이 되지 않기 때문에 지금 , 이렇게, 섞여가지고 지금 등장한다고 보시면 되겠어요. 이게 딱히 버그는 아닙니다. 딱히 동기화를 해주지 않았기 때문에 , 이렇게, 지금 뜨고 있다고 보시면 되는 거고 하지만 그임에도 불구하고 , 이렇게, 다수의 스레드를 만들어 가지고 구동시켜 가지고 걔네들이 동작하게끔 기다려주는 요런 부분들까지는 , 일단은, 실습을 해볼 수가 있었습니다 나중에 가면은 , 이렇게, 뭐 단순히 일감 하나를 하고 끝내라 이게 아니라 여기서 얘도 뭐 굉장히 오랫동안 무한 루프를 돌면서 살면서 DB작업도 하고 누구는 게임 일감을 실행하고 누구는 네트워크 IOCP 쪽에 가가지고 해당하는 네트워크 패켓을 처리하고 이런 부분들을 각기 뿌려주게 될겁니다. 그래서 시작은 굉장히 작게 시작을 하지만 요런 기능들이 쌓이고 쌓여가지고 결국에는 우리의 거대한 그런 MMO 서버를 지탱한다는 얘기가 되는 거죠 , 자, 이렇게, 해가지고 첫 시간에는 그냥 스레드를 구동을 시켜가지고 그 스레드를 관리하는 그런 간단한 방법에 대해서 , 일단은, 알아봤고요 하지만 구동하는 것까지는 알았지만 , 사실, 여기서 데이터를 우리가 공용으로 관리하는 실습은 해보지 않았기 때문에 , 사실, 반쪽짜리라고 보시면 되겠습니다 하지만 일단 오늘까지 이 스레드를 사용하는 내용은 여기서 끊어서 마치도록 할게요.