자, 이렇게, 세션에 대한 내용을 쭉 다뤄봤고 오늘도 이어서 세션 3탄을 다뤄볼 건데 이번에는 이제 연결하는 부분 커넥트랑 디스커넥트 쪽을 좀 수정을 해보도록 하겠습니다 어 그나저나 지난번에 봤는데 제가 주석을 다 오버로딩이라고 계속 말하고 있었는데 이게 정확히 오버라이딩을 의미한 겁니다 재정의 쪽을 얘기를 한 건데 저도 오랜만에 얘기를 하다 보니까 좀 용어가 헷갈렸어요 그러니까 이거를 이제 컨텐츠 쪽에서 재정리 해가지고 사용을 해라 라는 의미니까 뭐 딱히 뭐 중요한 부분은 아니지만 주성만 살짝 수정을 하고 넘어가도록 할게요 재정리 재정리를 알아서 해라 , 자, 그리고 이제 오늘 다뤄볼 것은 뭐냐면 여기 디스커넥트 할 때 우리가 그냥 소켓을 그냥 , 이렇게, 닫아주고 있습니다 강제로 근데 물론 , 이렇게, 소켓을 닫아도 실질적으로 연결이 알아서 끊기기는 해요 그러니까 , 이렇게, 해도 문제는 없고 실질적으로 , 이렇게, 그냥 강제로 소켓을 닫아서 처리하는 뭐 그런 경우도 더러 있기는 한데 근데 우리가 소켓 유틸 쪽에서 받아준 함수 삼총사가 요렇게 있죠. 디스코넥트도 요 비동기 버전이 , 이렇게, 하나가 덩그러니 있습니다. 얘네들을 이용하면은 우리가 IOCP에다가 받아가지고 완료된 거를 이제 탐지해가지고 똑같이 우리가 나머지 함수들과 동일하게 사용을 할 수 있는데 그러면은 그냥 , 이렇게, 닫는 것보다 어떠한 장점이 있느냐 이게 묘한 장점이 있어요 그게 뭐냐면은 우리가 뭐 지금 당장은 소켓을 만들고 세션이 날아갈 때 소켓을 그냥 닫아버리고 , 이렇게, 꺼버리고 있긴 한데 사실은 이 소켓을 만드는 작업 자체가 생각보다 좀 부담이 많이 되는 작업입니다 그래가지고 , 이렇게, 매번마다 세션을 새로 만들 때마다 소켓을 불러오고 날리고 하지 않고 이 소켓을 재사용하면 재사용하는 경우가 있어요 우리가 쓰레기도 뭐 버리는 경우도 있지만 플라스틱 같은 경우에는 버리지 않고 재사용을 하는 것과 마찬가지로 요 소켓도 그냥 반대로 강제로 꺼버리는 게 아니라 연결은 끊어 주되 걔를 재사용할 수 있게 만들어 주는 게 유용할 수가 있는데 그거를 이제 이용할 때 특히나 우리가 받아준 이 시리즈, Accept 시리즈 있죠? Accept랑 Disconnect Extended 그리고 Connect Extended 얘네들을 이용하면 재사용한 거를 우리가 계속 사용할 수 있게 됩니다. 뭐 그런 장점이 있어가지고 굳이 IOCP 구조로 하고 있는데 안 할 이유는 없다 보니까 , 일단은, 간단하게 혹시라도 나중에 소켓 재사용이 필요해질 수도 있으니까 그 형태로 , 일단은, 코드를 수정을 해보도록 할게요. , 자, 그래서 , 일단은, 디스커넥트는 좀 이따 만들고 오늘은 일단 커넥트부터 , 일단은, 만들어 보도록 할게요 여기 두 번째로 이쪽에다가 만들어 놓도록 합시다 그리고 커넥트 얘는 이제 연결을 하는 건데 대부분 같은 경우에는 우리가 연결할 일이 뭐 딱히 없긴 할 거예요 서버 역할을 할 때는 클라가 서버에 붙어 가지고 작동을 하는 것이기 때문에 , 사실, 이 커넥트를 할 일이 없는데 제가 지난번에도 살짝 언급을 드렸지만 서버끼리 서로 연결을 할 일이 생길 수도 있다고 했었죠 그럴 때는 이 세션이 상대방 서버를 대표하는 그런 세션의 의미가 되는 거고 그럴 때는 우리가 이 세션을 이용해가지고 상대방 서버로 붙는 작업을 해줘야 됩니다 그렇기 때문에 , 이렇게, 있고요 , 사실, 얘는 딱히 내부적으로 여기서 처리할 일은 없으니까 그냥 레지스터 커넥트로 바로 , 이렇게, 호출을 해주도록 할게요 그 다음에 이 커넥션을 맺을 때 성공했는지가 궁금하니까 얘를 불리언으로 만들어 주도록 하겠습니다 커넥트도 마찬가지로 불리언으로 , 이렇게, 바꿔주도록 할게요 그 다음에 리저스터 커넥트도 불리언으로 , 자, 얘도 일단 , 이렇게, 만들어주고 그 다음에 혹시나 불리언으로 가가지고 요기부터 이제 작업을 시작을 해보도록 하겠습니다 그러면 얘가 먼저 해야되는 건 무엇이냐 체크해가지고 만약에 벌써 연결이 단 상태라고 하면은 두 번 연결할 필요가 없으니까 바로 펄스를 들게 될 것이고 그 다음에 서비스를 체크해가지고 서비스가 반드시 클라이언트 타입이어야 합니다 서버 타입은 상대방이 나한테 붙는 개념이기 때문에 그 경우에는 우리가 리지스터 커넥트를 때리지 않도록 혹시라도 실수하지 않도록 요렇게 유도를 해주도록 하고 어 그 다음에 요기서도 이제 마찬가지로 그냥 iocp 이벤트를 재사용해서 사용을 해도 되겠죠 얘는 그냥 딱 한 번만 하는 애니까 그러니까 요 위에다가 커넥트 이벤트를 그냥 하나 만들어주도록 할게요 커넥트 이벤트 대부분의 경우에는 사용을 안할텐데 너무 아까운거 아닌가 한데 솔직히 서버에서는 메모리가 그정도로 모자라진 않습니다 이정도는 뭐 충분히 사용해도 상관없어요 아주 결국에는 초기화를 해준 다음에 여기서 owner setting을 해가지고 역시나 우리가 늘 하던 shared from this를 해가지고 reference count를 1 늘려준 다음에 그 다음에 여기서 socket.util에서 connectExtended 함수를 호출해줘서 연결을 해주게 될 겁니다. 근데 이걸 하기 전에 몇 가지만 더 챙기자면은 socket.util을 통해 가지고 setReuseAddress를 켜줄 것이고요. 주소 재사용하는 그거라고 했었죠? true. 얘가 만약 실패했다고 하면은 뭔가 문제있는 상황이고. 그 다음에 두 번째로 이거는 우리가 지난번에 만들 때는 누락을 했었는데 bind any address를 해가지고 소켓에다가 어떤 주소랑 포트를 입력을 해줘야 되는데 , 이렇게, 0으로 입력을 하면은 네가 여유있는 포트 중에서 아무거나 알아서 연동을 해라 라는 메시지를 주고 있는 겁니다 그래가지고 , 이렇게, bind any address를 호출해주면은 어떠한 주소도 상관없고, 어떠한 포트도 상관없다. 즉 0번 포트를 , 이렇게, 입력해가지고 지금 연동을 해주면 돼요. 이거를 안하면은 이 커넥트 엑스텐드에서 문제가 일어납니다. 우리가 만든 WSA 소켓으로 만들어가지고 사용할 때는 바인드 애니어스를 통해가지고 아무 포트나 연동을 시켜준 다음에 IP랑 포트를 연동시켜준 다음에 커넥트 엑스텐드를 호출해줘야 됩니다. 요 부분에는 제가 누락해가지고 한참 해냈었는데 뭐 만약에 이걸 누락하면 여기서 이제 에러 메시지를 보고 고치면 됩니다. 에러코드를 보고 그래서 connectExtended를 호출해주면 되고 여기서 필요한 것은 numberOfByte라는 인자를 만들어 줄 것이고 그 다음에 sockAddressIn 내가 어디로 연결할지를 , 이렇게, 받아주도록 하겠습니다. 서비스에서 address의 get socket address 이걸 이용해가지고 받을 수 있는데 서비스 타입이 클라이언트 타입이라고 하면은 여기 있는 의미하는 net address는 상대방 쪽 내가 붙어야 되는 그 서버 쪽 주소를 의미한다고 했었죠 그래가지고 얘를 이제 , 이렇게, 받아가지고 소켓을 넣어주고 그 다음에 reinterpret cast를 해준 다음에 sock address를 socket address를 받아주고 sizeof socket address를 넣어주고 요 아이를 , 이렇게, 넘겨주고 그 다음 인자는 nullptr sandbuffer는 지금 뭐 당장 필요 없고 0 numberofbytes 마지막으로 Connect Event를 넣어주면 되겠습니다. 이게 좀 긴데, 잘라서 보여드리자면 Connect Event를 , 이렇게, 넣어주면 되겠습니다. 이게 이제 Connected 완성형이라고 보시면 돼요. 그래서 저는 일단 한 줄로 표시를 하고, 이게 만약에 실패했다, 이게 false로 떴다라고 하면은 실패가 되었다는 얘기는 아니고, 역시나 늘 그렇지만 에러 코드를 확인해서 살펴봐야 되겠죠? wsa get last error 만약에 에러 코드가 펜딩이 아니다 라고 하면 진짜 문제가 있는 거고 펜딩이라고 하면 그냥 뭐 이런저런 상황으로 진행 중이다 라고 받아주면 된다고 했습니다 그래서 owner를 nullptr로 다시 release reference를 여기서 호출해 줄 것이고 그게 여기까지 왔으면 뭐 실패한 거니까 return false를 때려주고 그게 아니면 성공적이니까 return true로 때려주도록 할게요 요 패턴이 이제 굉장히 자주 나오죠? register 해가지고 어 그게 iocp 쪽에서 이제 관찰을 하다가 dispatch를 빵 때리면서 결국에는 process connect가 실행이 되면서 이거를 인지를 하는 부분으로 만들어 주면 됩니다 역시나 process connect 쪽에서는 우리가 여기까지 만들어 놨는데 여기다가 추가적으로 Connect Event의 Owner를 넓히티어로 밀어주는 작업을 할게요 얘는 이제 대부분의 경우에는 필요 없지만 우리가 사용하는 서비스가 클라이언트 서비스여가지고 우리가 먼저 요청을 해가지고 딴 데에 붙을 때는 이제 얘를 사용하면 되고요 얘가 이제 공용으로 사용하는 거죠 클라이언트가 우리 서버로 붙어가지고 그 세션이 만들어질 때 프로세스 커넥트를 사용할 때도 , 이렇게, 사용하고 그게 아니라 우리가 클라 입장에서 딴 서버로 붙어가지고 그때 커넥션이 완료가 되었을 때도 이 프로세스 커넥트를 그냥 그대로 이용하고 있습니다 , 사실, 왜냐면 어차피 코드가 똑같기 때문이죠 그냥 뭐 onConnected 재정의한 함수를 호출해주고 수신 등록을 어차피 한번 때려줘야 되는 건 동일하기 때문에 얘를 이제 재생할 수 있었던 거고 이 부분만 , 일단은, 그냥 추가적으로 넣어 주도록 하겠습니다 상대방이 이 커넥트 이벤트를 사용 안 한다고 해도 이게 당장 문제되지 않으니까 어차피 노렸을 테니까 , 이렇게, 일단은, 만들어주도록 할게요 그래서 얘가 이제 만들어지면 커넥션을 맺어지는 작업을 그냥 커넥트로 빵 때려주면 이제 될 거다 라고 볼 수가 있는 거고 , 자, 하는 김에 디스커넥트도 같이 수정을 해보도록 하겠습니다 근데 우리가 이 이벤트를 만들 때 디스코넥트는 아마 아직 안 만들어 줬던 걸로 기억을 해요 이건 원래 예정이 없었던 거여가지고 일단 얘도 같이 추가해 주도록 할게요 커넥트 이벤트 바로 아래다가 이제 디스코넥트 이벤트를 만들어 줄 건데 디스코넥트 이벤트 , 이렇게, 일단은, 영역을 잡아주고 디스코넥트 이벤트로 이름을 바꿔치기 한 다음에 이벤트 타입은 디스코 넥트라는 걸 , 이렇게, 만들어 주도록 하겠습니다 타입에 가가지고 뭐 바로 앞에다가 하나를 이제 추가를 해주면 되겠죠 네 , 이렇게, 가지고 디스커넥트 이벤트를 간단하게 추가를 해봤구요 , 자, 그 다음에 어... 까먹지 않고 디스패치하는 부분을 찾아가지고 디스패치를 할 때 사유가 만약에 요 부분을 복붙해가지고 커넥트가 아니라 디스커넥트 였다고 하면은 프로세스 디스커넥트를 호출하도록 수정을 해주도록 할게요 프로세스 디스 디스커넥트 근데 우리가 이 함수도 안 만들어 놓은 것 같으니까 얘도 이제 만들어 줘야 되겠죠 , 자, 그러면은 리지스터 커넥트랑 리지스터 커넥트 쪽에다가 똑같은 느낌으로 얘를 복붙해가지고 리지스터 디스코넥트를 만들어 줄 것이고 프로세스 코넥트 아래다가도 프로세스 디스코넥트란 함수를 만들어 주도록 할게요 굉장히 이제 뭐 패턴이 반복이 되면서 어느정도 익숙해지고 있으니까 딱히 뭐 어려운 부분은 없을 것 같구요 리지스터 디스코넥트는 말 그대로 디스코넥트를 예약을 하겠다라는 의미로 받아줄 수가 있는데 일단 리턴은 까먹지 않고 true로 바꿔주고 얘 같은 경우에도 뭐든 우리가 하듯 디스커넥트 이벤트도 실시간으로 만들어도 되는데 얘도 그냥 들고 있어도 되니까 , 이렇게, 만들어 주도록 할게요 디스커넥트 이벤트로 여기서는 이제 반복되는 패턴인데 초기화를 해주고 owner를 shared from this를 해가지고 나를 여기다가 , 이렇게, 일단은, 넣어주고 그 다음에 여기다가 디스커넥트 X 를 호출해 주게 될 건데 소켓 유틸 쪽에서 디스커넥트 EX 를 호출할 건데 여기서 넣어주는 인자가 소켓이랑 LP 오버랩들을 바로 받아주는 걸 볼 수가 있네요 디스커넥트 이벤트를 , 이렇게, 넣어주고 그 다음에 옵션에다가는 TF on the bar re-user socket 를 넣어주고 마지막 인자는 0으로 , 이렇게, 세팅을 해주도록 할게요 여기 마지막 인자들이 중요한데 Reuse Socket로 하면 우리가 소켓을 다시 재사용하겠다는 의미고요. Disconnect Extended 문서를 보면 여기 Flag가 사실상 굉장히 중요한데 이 부분을 읽어보시면 되겠습니다. 소켓이 다시 재사용이 될 수 있게 준비를 해준다고 나와있죠. 그래서 만약에 Disconnect Extended가 이 옵션을 줘가지고 성공적으로 호출이 돼서 완료가 되면은 그 해당 소켓을 우리가 Accept Extended나 Connect Extended에다가 다시 넘겨줄 수 있다는 굉장히 놀라운 설명을 해주고 있습니다. 그래서 , 사실, 우리가 이런 식으로 이 확장함수를 사용하던 것도 , 이렇게, 재사용할 수 있으니까 요 가능성 때문에 이걸 , 이렇게, 만들어주는 거죠 근데 물론 지금 당장은 안 할 것이고 , 일단은, 에러코드를 똑같이 뱉어가지고 WS의 Get Last Error를 체크해가지고 만약에 에러코드가 , 자, 이제는 좀 지겨워질만 한데 WS의 아 요 펜딩이 아니다 라고 하면은 진짜로 문제가 있는 상황이니까 owner를 다시 null로 , 이렇게, 밀어주고 release reference 그리고 release reference 그 다음에 return false를 때려주도록 하겠습니다. 그래서 register disconnect가 되었고 실질적으로 외부에서 사용할 때는 요 disconnect라는 함수를 이용해주게 될 것이고 그렇게 되면은 우리가 원래는 disconnect할 때 여기다가 close를 때렸었는데 이걸 close를 때리진 않을 것이고 여기다가 register disconnect를 한번 호출해 주도록 할게요. 그 다음에 요게 템프로 넣어놨던 뭐 커즈같은거는 나중에 이제 수정할거니까 , 일단은, 잠시 냅두도록 하고 그렇게 해가지고 디스커넥트 요청을 빵 하면은 한 번만 호출되게 , 일단은, 막아주고 그 다음에 리지스터 디스커넥트를 통해 가지고 요 부분이 호출이 될 것이고 걸어준 다음에 만약에 성공적으로 호출이 됐다고 하면은 IOCB 코어에서 디스패치를 해줄 것이고 그걸 다시 이쪽에서 받아가지고 디스패치 함수에서 프로세스 디스커넥트가 호출이 되면서 요 부분으로 , 일단은, 넘어온다라고 볼 수가 있는 거죠. 근데 프로세스 디스코넥트에서는 뭐 딱히 할게 없습니다. 여기서는 진짜 할게 없고 뭐 그나마 해볼 수 있는거는 온원을 , 일단은, 롤로 밀어줘가지고 릴리스 레퍼런스만 해주면 되겠죠 이거 외에는 딱히 당장은 할게 없으니까 그냥 여기서 싱겁지만 , 이렇게, 끝내도록 할겁니다. 그래서 프로세스 디스커넥트도 , 이렇게, 만들어주면 , 일단은, 완료가 되었고 , 자, 일단 서버콜을 빌드해서 문제가 없는지 체크를 해보도록 할게요 문제가 없는 것 같고 , 자, 그 다음에 이제 이어가지고 클라이언트 서비스를 우리가 만들다가 말았었죠 지난번에 그 부분만 살짝 수정을 해보도록 할게요 서비스 , 자, 이쪽이었던데 서비스는 헤더는 왼쪽에 , 자, 내려보다 보면은 뭐 클라이언트 서비스를 스타트할 때 투두로 우리가 넣어놨는데 이 부분만 간단하게 채워보자면 , 일단은, 복붙 해가지고 CanStart를 체크해가지고 반드시 Factory를 넣어준 상태에서만 실행을 할 것이고 , 자, 그 다음에 SessionCount를 체크해서 GetMaxSessionCount만큼을 , 일단은, 만들어 주도록 합시다 0번 해서 SessionCount 개만큼을 뺑뺑이를 돌면서 SessionRef Create Session을 해서 Session을 만들어준 다음에 Session을 Connect함으로 호출해가지고 상대방 쪽으로 연결을 하는데 만약에 문제가 있다고 하면은 여기서 Return First를 때려주도록 할게요 그럼 이제 클라이언트 서비스는 , 이렇게, 해서 Start를 시키면은 동작을 한다고 볼 수 있는 거죠 , 자, 역시나 한 번 더 서버 코어를 빌드를 하고 그럼 이제 위쪽에 가가지고 우리가 지금까지 게임 서버만 우리가 만든 라이브러리를 이용해서 사용하고 있었는데 이제는 더미 클라이언트도 여기 기존에 정들었던 지저분한 내용들 싹을 지워주고 얘도 지워주고 똑같이 우리가 만든 네트워크 라이브러리를 사용하는 방식으로 수정을 해보도록 하겠습니다 , 일단은, 여기있는 라이브러리는 다 지워도 되구요 서비스 세션 두개만 , 일단은, 들고 있으면 될 것이고 이쪽도 마찬가지죠 , 사실, 이쪽도 여기있는 내용은 뭐 다 필요 없을 것 같으니까 다 날리고 코어 PCH도 날리고 , 자, 이쯤에서 , 이렇게, 다 날려준 다음에 그 다음에 요게는 내용을 복붙해가지고 반대쪽으로 일단 넘겨주도록 하겠습니다 , 자, 얘는 게임 세션이라고 하면은 이름이 헷갈리니까 서버 세션이라고 할게요 서버 쪽을 대표하는 세션이다라는 이름으로 서버 세션을 만들어주도록 하고 그 다음에 지금은 간단하게 테스트를 하기 위해서 공용으로 사용하는 샌드버퍼라는 걸 하나를 , 이렇게, 헬로월드라는 문자를 이제 보내줄 거니까 요렇게 , 일단은, 만들어주고요 그 다음에 얘같은 경우에는 , 일단은, 모든 애들을 다 오버라이드를 해주도록 할게요 onConnected 오버라이드 그래서 앞으로는 컨텐츠에서는 다 이런식으로 재정의를 해가지고 사용을 할거니까 어.. 커넥티드랑 리시브 샌드 그 다음에 버추얼 보이드 온 디스커넥티드 까지도 , 이렇게, 오버레드 해줘가지고 다 받아주도록 합시다 그래서 디스커넥티드가 되었을때는 뭐.. 그냥 디스커넥티드 되었다라고 로그만 간단하게 찍어보도록 할것이고 그 다음에 어.. 리시브가 왔으면은 onReceiveLength를 찍어준 다음에 너무 자주 보내기도 모아니까 지금은 임시적으로 디스스레드 슬립을 넣어가지고 1초동안 자다가 그 다음에 샌드를 해가지고 샌드 버퍼에 있는 내용을 그대로 다시 보내주도록 하겠습니다. Size of Sand Buffer를 , 이렇게, 입력을 해가지고 아 근데 우리가 바이트로 만들어 놓기로 했으니까 , 이렇게, 바이트로 캐스팅해주면 되겠죠 그리고 이 똑같은 코드를 onConnected 할 때도 한 번 더 해주도록 할게요. 그래서 이제는 흐름이 어떻게 되는 거냐면은 처음에 최초로 한 번 연결이 되었을 때 우리가 send를 먼저 호출해 줘 가지고 이쪽에다가 서버 쪽에다가 hello world를 보내주게 될 겁니다. 그러면 게임 서버, 게임 세션이 호출이 되면서 게임 서버 쪽에서는 onReceive에서 echo 서버처럼 동작하기 때문에 receive를 하자마자 똑같은 내용을 다시 send를 해줘가지고 거꾸로 클라이언트한테 얘를 보내준게 되겠죠? 그럼 클라이언트에서는 역시나 이 부분이 호출이 되면서 receive가 되었다라고 이 코드가 실행이 되면서 1초 후에 똑같이 send를 해가지고 다시 한번 이 헬로월드를 또 서버쪽에다가 보내게 될 겁니다. 그래서 이 헬로월드를 계속 핑퐁하는 식으로 이제 동작을 한다 라고 결론을 내릴 수가 있는 거죠. , 자, 이렇게, 일단은, 만들어놨구요. , 자, 그 다음에 메인함수에서는 이제 뭘 해야 되냐면은 , 일단은, 여기서도 디스스레드 슬립을 이용해가지고 서버가 뜰 때까지 그냥 임시로 1초만 기다려 주도록 할 것이고 그 다음에 , 자, 여기서 원래는 우리가 이런 식으로 만들어 놨는데 이걸 일단 복붙 해가지고 살펴보면은 게임 세션이 아니라 이제 서버 세션으로 요 부분을 바꿔 줘야 되는 거고 net address는 똑같고 이제 서버 서비스가 아니라 클라이언트 서비스로 얘를 이제 만들어 주면 되겠죠 요런 느낌으로 , 자, 요렇게 얘가 일단 없으니까 서버 서비스 랩플을 정의한 쪽에 가서 복붙한 다음에 얘도 이런 식으로 뭐 종종 사용해도 될 거니까 편하게 사용할 수 있도록 네이밍을 지어주도록 합시다 , 자, 그러면 서버 코어는 다시 빌드를 하고 통과를 시켜준 다음에 이제 얘를 활용할 수 있으니까 얘도 이제 클라이언트 서비스라는 걸 이제 , 이렇게, 이용할 수 있는 거죠 100개를 만약에 우리가 설정하면은 더미 클라이언트가 이제 100명의 유저를 얘가 묘사해가지고 나중에 서버에 대한 스트레스 테스트를 할 때 이런 식으로 이제 우리가 활용하게 될 겁니다 지금은 뭐 많을 필요 없으니까 딱 한 개만 클라이언트가 연결하도록 , 이렇게, 만들어 줄 것이고 그 다음에 마찬가지로 여기 Assault Crash 서비스 스타트를 그냥 그대로 복붙하면 되겠죠. 하지만 내부적으로 동작하는 방식은 굉장히 다를 겁니다. 얘는 클라이언트 서비스이기 때문에 우리가 여기 넣어준 이 주소로 붙어 가지고 작업을 하게 될 것이고 붙게 되면 우리가 넣어준 이 서버 세션이라는 애를 만들어 줘 가지고 이 함수를 이용해 가지고 우리가 실제적으로 얘가 하는 행동을 지금 조작하고 있는 겁니다. , 자, 그 다음에 이어가지고 요 부분도 그대로 복붙해가지고 넣어주면 될 것 같구요 어... 말 그대로 서비스 스타트를 한 다음에 얘는 한 뭐 한두 개만 넣어주도록 하겠습니다 워커 스레드들을 만들어가지고 체크를 하면서 디스패치를 한다라는 내용이 여기 들어가게 된거죠 아 여기 스레드 매니저는 추가를 해주도록 하겠습니다 요렇게 , 자, 아이오 스트림은 필요 없을 것 같고 , 자, 이렇게, 해가지고 저장하면은 이제 진짜 진짜 끝난 것 같으니까 클라이언트도 빌드해보고 서버도 빌드를 해가지고 별다른 문제가 없는지 체크를 한 다음에 실행을 해보도록 하겠습니다. 네, 된 것 같고요. 그러면 이 상태에서 실행을 해보면 정상적으로 붙어가지고 이런 식으로 양쪽이 잘 뜨고 있는 걸 볼 수 있습니다. 샌드, 리시브, 샌드, 리시브, 샌드, 리시브가 왔다 갔다 하면서 이제 우리가 굉장히 편리하게 만든 작업을 해보게 된 거죠. , 자, 이렇게, 해서 뭐 오늘 할 내용은 거의 끝난 것 같구요 마지막으로 정상적으로 소멸이 되는지만 테스트하고 종료를 하도록 할게요 서버 세션 소멸자 에다가 , 이렇게, 로그를 찍어 주도록 할 것이고 마찬가지로 게임 세션도 요 아이가 소멸이 될다 싶으면은 소멸자가 찍혔다는 이런 로그를 찍어 본 다음에 양옆으로 이제 테스트 해보면 되겠죠 먼저 클라 서버를 키운 다음에 어 그 다음에 이제 서버를 끈다거나 서버를 지금 딱 껐으면 이쪽에서 , 자, 이런식으로 서버 세션 소멸자가 호출이 됐고요. 반대로 이제 둘 다 켠 상태에서 클라우드를 끌 때도 서버 쪽에서 정성적으로 짜잔 하고 요 부분이 뜨면 일단 성공적입니다. , 자, 이렇게, 해서 이번에도 좀 꼼꼼하게 레퍼런스 카운팅이 잘 돼 있는 걸 확인했고요. 그 다음에 뭐 커넥트와 디스커넥트 같은 부분도 이제는 굉장히 편리하게 우리가 세션에다가 만들어준 요 기능 자체로만 이제 활용을 하면 됩니다. 사실상 이 내부적인 네트워크 라이브러리 같은 경우는 외부에서는 신경 쓸 필요 없고 우리가 컨텐츠를 만들 때는 , 이렇게, 퍼블릭으로 열어두어가지고 사용하라고 열어준 이런 아이들만 이용해가지고 기능이 이제 구현된다는 거죠. 샌드, 코넥트, 디스코넥트 등등. 네, 이렇게, 해가지고 , 일단은, 세션 제 3탄에 대한 내용도 마치도록 하겠습니다.