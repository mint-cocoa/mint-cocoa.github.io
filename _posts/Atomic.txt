지난 시간에 우리가 표준 스레드 라이브러리를 이용해 가지고 스레드를 구동하는 방법에 대해서 알아봤고요 이번 시간에는 스레드를 멀티스레드 환경에서 이제 공유 데이터를 사용을 할 때 일어나는 문제점들에 대해서 이제 하나씩 알아보는 시간을 가져보도록 할 겁니다 , 자, 일단은, 음 지난번과 마찬가지로 실습은 여기 게임 서버에서 그냥 그대로 할 거구요 오늘 해볼 거는 이제 공유 데이터 하나를 사용해 가지고 동시에 이제 건드리는 그런 실습을 해볼 겁니다 그냥 간단하게 표현을 해보자면 , 일단은, 요런 식으로 어떤 합이라는, sum 이라는 변수를 전역으로 , 이렇게, 두도록 할게요 , 자, 그 다음에 여기서 두 개의 함수가 있는데 하나는 더하는 함수입니다 얘가 하는 역할은 굉장히 단순한데 , 일단은, 100만 번 동안 , 이렇게, 루프를 돌면서 굉장히 단순하게 sum에다가 ++을 해주게 될 거에요. 100만 번을 더해주고 있는 거죠. 참고로 , 이렇게, 숫자가 많아질 때는 여기 엔터키 바로 옆에 이 땡땡이 표시로 해가지고 , 이렇게, 구분을 해주면 보기가 편해집니다. 그 다음에 마찬가지로 sub는 똑같은데 이제는 minus minus를 해줄 거에요. 그래서 100만 번 값을 더해주는 거고 얘는 100만 번 1을 빼주는 그런 작업을 하고 있는 거죠. , 자, 그 다음에 요 상태에서 만약에 우리가 멀티스레드 환경이 아니라 그냥 add를 하고 그 다음에 서브를 각각 호출하면은 100만 번 1을 더하고 100만 번 1을 뺄 테니까 뭐 결과적으로 이 최종 합을 출력을 해보면 당연한 얘기지만 이제 0이 나오게 될 겁니다 뭐 이거는 실습을 안 해봐도 너무 뻔한 얘기죠 그런데 이제 만약에 멀티스레드 환경에서 이걸 굴린다고 하면 어떻게 될까가 굉장히 궁금한데요 T1을 add라는 엔트리 포인트를 건네줘서 이 함수를 실행하라고 하나한테 건네줄 것이고 Ctrl-D 복붙을 한 다음에 T2라는 이 두 번째 아이는 서브를 실행시킬 겁니다 그러니까 스레드 두 개를 만들어서 하나는 얘를, 하나는 얘를 호출한다는 얘기가 되는 거죠 그 다음에 t1.join을 해가지고 t1을 끝나기를 기다리고 t2도 끝나기를 기다린 다음에 그 다음에 역시나 여기 있는 sum을 다시 한번 출력을 해보고 Ctrl-F으로 한번 실행을 해보도록 할게요 , 자, 그럼 굉장히 놀랍게도 0이 아니라 엉뚱한 숫자가 , 이렇게, 들어가 있는 걸 볼 수가 있는 거고 얘 같은 경우는 심지어 실행할 때마다 계속 값이 왔다 갔다 바뀐다는 것도 알 수가 있어요 , 자, 이렇게, 자, 그래가지고 여기서 이제 이상한 부분이 발생하고 있는 건데 뭐 우리가 더샘을 잘 기억을 하고 있으면 , 사실, 100만 번 1을 더하고 100만 번 1을 뺐으면 당연히 0이 돼야 되는 건데 왜 멀티스레드 환경에서는 내가 알던 더샘이 내가 알던 더샘이 아닌가 이제 여기서 멘붕이 살짝 오기 시작을 하죠 , 자, 그런데 공유 데이터와 관련된 문제가 이제 멀티스레드 환경에서 항상 두고두고 골치 아프게 될 겁니다 참고로 말씀을 드리자면 , 일단은, C++에 좀 익숙하지 않으시다면 애당초 어떤 데이터가 공유하는 데이터인지 자체가 헷갈릴 수가 있어요 쉽게 말해서 멀티세더 환경에서 stack 같은 경우에는 각기 자신의 영역을 따로 갖고 있다고 했습니다 만약에 여기 내부에서 뭔가 썸을 사실상 여기서 뭔가 내가 하고 있다고 하면은 요 아이는 스택 메모리에 올라가는 그런 데이터이기 때문에 다른 애들의 영향을 전혀 받지 않습니다 그런데 이제 힙이나 아니면 데이터 영역 같은 경우에는 쓰레드끼리 서로 공유해서 활용하고 있는 것이기 때문에 , 이렇게, 전역으로 만든 즉 데이터 영역에 올라가 있는 요런 데이터라고 한다면 이 두 쓰레드에서 서로 경합을 해가지고 얘를 건드리고 있는 상황이 된다는 거죠 멀티세더 환경에선 C++ 기본기가 좀 필요한게 이제 어떤 변수를 보자마자 얘가 힙인지 스택인지 아니면 뭐 데이터 영역인지 빠르게 빠르게 구분할 수 있어야 된다는 얘기가 되겠습니다 그게 뭐 거의 필수적이라고 보시면 되겠어요 , 자, 그건 그렇고 그래서 뭐가 문제인지 이제 다시 한번 분석을 해볼 건데 뭐 당연한 얘기지만 무엇인가가 , 이렇게, 뭐 우리가 부두술에 의존을 해가지고 랜덤으로 어쨌든 되고 어쩔 땐 안 되고 이런 건 아니고 당연히 뭔가 문제가 있으니까 지금 , 이렇게, 계속 오답이 뜨고 있는 거겠죠 , 자, 그런데 , 일단은, 여기다 브레이크 포인트를 하나 걸어 본 다음에 그대로 한번 다시 실행을 해보도록 할게요 그 다음에 여기서 지금 썬플플 하는 코드가 , 이렇게, 디버그 상태에서 브레이크 포인트가 잡힌 상태에서 위에 창에 가서 디버그 창에서 디버그 창에 간 다음에 조금 내리다 보면 여기 디스 어셈블리라고 이걸 어셈블리 명령으로 볼 수 있는 창이 있습니다 그러면 코드가 지금 sun++이라고 우리가 c++코드에서 만들었던 코드가 , 사실, 컴파일이 된 다음에 어셈블리 언어로 변환이 될 때 즉 이게 사실상 CPU가 실행하는 인스턱션을 보고 있는 거죠 그 단계가 지금 , 이렇게, 세개로 끊어져서 지금 나온다고 보시면 되겠어요 어셈블리 언어를 모르신다면 간단히 설명을 드리자면 얘가 지금 오른쪽에서 왼쪽으로 읽으면 되는 건데 여기서 어떤 주소에 있는, 이게 뭐 데이터 영역이겠죠 데이터 영역에 있는 어떤 주소에서 값을 가져와 가지고 EAX 레지스터에다가 , 일단은, 이동을 시킨 다음에 그 다음에 그 EAX 레지스터에 있는 값을 1 증가시키고 그 다음에 그 결과물을 다시 원래 있던 그 메모리에다가 다시 , 이렇게, 갖다 놓는다는 걸 볼 수가 있습니다 , 자, 그러면 결국에는 우리가 C++에서는 some++ 이라는 게 마치 한 줄인 것처럼 보였겠지만 실질적으로 얘가 컴파일이 되어 가지고 CPU가 실행을 할 때는 얘가 한 줄이 아니라는 거죠 이걸 의사 코드로 표현을 하면은 대충 이런 느낌입니다 SUM 이라는 메모리에 있는 값을 EAX에 갖다 놓은 다음에 EAX에 있는 값을 1 증가시킨다 잉크 명령어 인크리즈 한다 그 다음에 다시 요렇게 우리가 계산한 결과물을 다시 원래 SUM 메모리에다가 다시 요렇게 갖다 놓는 상황이라고 보시면 되겠습니다 이게 사실상 실제로 일어나는 일이죠 마찬가지로 요 아이 같은 경우는 얘가 이제 거꾸로 1을 줄이는 그런 상태라고 볼 수가 있겠어요 , 자, 그러면 왜 한 방에 이걸 실행하지 않고 굳이 귀찮게 3단계에서 하는 것인가 약간 의아하게 생각하실 수도 있는데 이거는 어쩔 수가 없습니다 CPU가 어떤 메모리에 있는 값을 꺼내 오고 거기다가 연산을 하는 이 두 가지 행동을 동시에 할 수가 없어요 CPU 설계가 그렇게 되어 있기 때문이죠 그러나 결국에는 지금 우리가 한 줄짜리로 표현했던 게 , 이렇게, 세 줄로 지금 , 이렇게, 나눴다고 볼 수가 있는 겁니다 물론 이거를 이제 뭐 실질적으로 스택에다가 갖고 오는 건 아니고 얘가 이제 CPU에 있는 그 어떻게 보면 레지스터라고 부르는 그 메모리에 지금 들어가 있는 거라고 보시면 되겠어요 그래서 이름도 지금 EAX라고 지어 놓은 거죠 근데 의사 코드로만 보면 어쨌든 , 이렇게, 세 단계로 이루어져 있다는 건 변함이 없습니다 지금 이런 상황이 되는 거죠 그러면 이 상황에서 무엇이 문제가 되는지 다시 한번 곰곰히 생각을 해보면 일단 편의상 얘가 100만 번이 아니라 딱 한 번씩만 실행이 된다고 가정해볼게요 하지만 어찌됐건 멀티스레드 환경이다 보니까 add라는 거랑 sub라는 애랑 진짜 동시에 따락하고 동시에 두 개가 같이 실행이 되는 상황이라고 가정해볼게요 그러면 처음에 sum이 지금 0인 상태죠 0인 상태에서 그 값을 일단 가져와 가지고 EAX 레지스터에다가 넣는 요 부분이 , 일단은, 실행이 될 텐데 얘까지 실행이 됐으면 일단 EAX는 0이라는 값이 들어가 있을 겁니다 근데 딱 마침 반대쪽에서 서브를 실행하는 이 스레드도 똑같이 이 sum 이라는 메모리에 접근해 가지고 실행을 할 테니까 아직 얘네가 완전하게 실행이 된 건 아니라 가지고 딱 지금 얘가 add를 실행하는 스레드가 여기까지 밖에 실행이 안 돼 있기 때문에 sum은 여전히 0인 값으로 들어가 있을 겁니다 그러다 보니까 얘도 eax 에다가 , 이렇게, 꺼내올 때 역시나 eax 는 0이라는 값으로 지금 , 이렇게, 추출을 하고 있는 상태가 되는 거죠 그럼 이제 그 다음에 다음 줄을 하나씩 실행을 해볼 건데 여기서 eax를 1 증가시키면 얘가 1이 될 것이고 그 1이라는 값을 다시 sum에다가 , 이렇게, 넣는 작업을 해줄 것이고 그 다음에 sub를 실행하는 스레드 같은 경우에는 eax가 마이너스 1이구나 그러면 얘를 다시 , 이렇게, 넣어주겠구나라는 이제 일련의 명령어들을 실행하게 될 겁니다 그러면 얘네들이 동시에 실행이 될 것이기 때문에 얘가 먼저 실행이 될지 얘가 먼저 실행이 될지는 잘 모르겠지만 뭐 어찌됐건 얘가 만약에 먼저 실행이 됐으면 그 다음에 요 아이가 값을 덮어 써 가지고 최종적으로 sum이 마이너스 1인 상태가 될 것이고 그게 아니라 이 sub를 실행한 애가 간발의 차이로 먼저 실행이 됐다면 그 다음에 add를 실행한 애가 최종 값을 1로 덮어 쓴다는 얘기가 되는 거죠 그러면 결국에 여기서 우리가 사실상 sum++을 한번 해주고 sum++-를 한번 해줬지만 결과적으로 서로 값이 , 이렇게, 충돌이 되어 가지고 최종 값은 0이 아니라 1 혹은 마이너스 1 둘 중 하나의 상황이 되었다는 얘기가 되겠습니다 그리고 이게 뭐 한 번 했을 때 요런 문제가 발생하니까 당연히 100만 번 할 때는 그게 뭐 데이터가 틀어질 확률이 확률이 더 늘어난다고 보시면 되겠어요 그래가지고 사실상 정확하게 0이 떨어지는 게 아니라 엉뚱한 값이 들어가 있는 이유가 결국에는 요런 로직이 3번에 걸쳐가지고 일어나고 서로 상대방이 뭔가 데이터를 건드린다는 걸 인지하지 않고 지금 연산을 하고 있기 때문에 발생하는 문제라고 , 일단은, 볼 수 있겠습니다 그래서 이게 바로 멀티스레드의 문제라는 거죠 데이터를 공용으로 같이 활용할 수 있다는 게 , 사실, 장점이기는 해요 왜냐하면 이런 메모리 상태를 여러 군데에서 관리할 필요 없이 동일하게 힙 영역이나 아니면 데이터 영역에 데이터는 하나만 두고 그 데이터를 서로 읽어 가지고 가져다 쓸 수 있으면 굉장히 아름답게 동작하는 그런 상황이 되겠지만 문제는 뭐냐면 이 데이터를 수정하기 시작을 하면 이제 문제가 발생한다는 거죠 두 군데에서 동시에 수정을 한다거나 아니면은 한 군데에서는 수정을 하고 한 군데에서는 그 데이터를 읽는다거나 하는 상황이 발생을 할 때 요런 식으로 데이터가 상태가 꼬여 가지고 지금 발생하는 문제가 일어난다는 얘기가 되는 겁니다 그럼 결과적으로 지금 문제가 되는 상황은 요약을 해보면 결국에는 요 썸뿔뿔이 , 사실, 완전하게 딱 우리가 이 명령어 자체가 한 번에 일어나야 된다는 얘기가 되는 거죠 , 자, 이제 , 사실, 데이터를 동시에 다루는 이런 문제들 같은 경우는 동기화라는 용어를 표현을 하는데 순서가 이제 보장이 돼야 된다고 보시면 되겠습니다 말을 하자면 여기 애당초 1을 늘리거나 아니면 1을 아직 늘리지 않거나 둘 중 하나의 상황만 존재해야 되는데 그게 아니라 중간에서 , 이렇게, 3단계 거쳐가지고 지금 이 썬뿔뿔 연산을 하고 있기 때문에 발생한 문제라고 보시면 되겠습니다 만약에 지금 우리가 여기서 표현한 이 3단계가 진짜로 한 번에 뿅 일어난다고 하면은 애당초 이런 문제가 지금 발생하지 않는다고 보시면 되겠어요 , 자, 그래가지고 여러가지 동기화 기법 중에서 이거를 아토믹한 버전으로 얘를 만드는 것이 하나가 있습니다 , 자, 아토믹 여기서 아톰이라고 하는거는 원자 물리에서 원자를 얘기를 하는거죠 원자 그래서 물리에서 원자라면 더 작게 쪼개지지 않는 정말로 최소 단위라고 이제 우리가 물리 시간을 배우는데 그러다보니까 아토믹에서 이 아토믹이 표현하고 싶은 의미는 뭐냐면은 다 실행이 되거나 아니면 하나도 실행이 안 되거나 둘 중 하나의 상황만 존재할 수 있는 것을 우리가 아토믹 연산이라고 합니다 그리고 이 아토믹과 관련된 부분들이 우리가 , 이렇게, 멀티스레드에서도 등장하지만 나중에 데이터베이스에서도 , 사실, 이런 상황이 또 발생하게 될 거예요 예를 들면 우리가 db와 관련된 작업을 할 때 예를 들면 뭐 아이템 교환을 한다고 가정해 볼게요 그럼 A라는 유저 인벤에서 뭐 집행검 이라는 아이템을 빼고 그 다음에 B라는 유저 인벤에 집행검을 추가한다 라거나 요런 식으로 이제 이뤄지는게 이제 어떻게 보면 우리가 교환이라고 볼 수가 있겠는데 이제 DB에서 이걸 트랜잭션으로 묶어 줘 가지고 얘네들이 반드시 한번에 아톰윅하게 한번에 일어나야지만 우리가 정상적인 상황이라고 간절할 수 있는데 만약에 얘랑 얘랑 따로따로 진행이 된다고 하면은 여기까지 진행이 되었는데 그 상황에서 갑자기 서버가 크래쉬가 나가지고 얘가 추가가 안 됐다고 하면은 즉 얘만 지금 실행이 됐다고 하면은 정상적인 교환이 이루어진 게 아니죠 말 그대로 A만 아이템을 뺏기고 그 다음에 B는 아이템을 얻지 못한 요런 상황이 발생할 수도 있다는 얘기가 되는 겁니다 그래가지고 DB에서도 , 사실, 이렇게, 아토믹한 연산을 하게끔 유도를 해줘야 되는 경우가 종종 발생하게 될 것이고 그것도 지금과 굉장히 비슷한 상황이라고 볼 수가 있는 거죠 그래가지고 , 이렇게, 한 번에 다 이뤄지거나 아니면 애당초 다 이뤄지지 않을 거면 하나도 이뤄지지 않는다거나 하는 상황을 우리가 이제 아토믹으로 연산으로 처리를 한다고 보시면 되겠어요 그래서 얘 같은 경우는 이제 뭐 이것도 이제 운영체제 마다 조금씩 라이브러리가 다르지만 윈도우즈 같은 경우는 인터럭트 시리즈가 , 이렇게, 쭉 있습니다. 인터럭트 모시기 모시기 해가지고 얘를 뭐 추가할 수 있는 방법이 있는데 근데 얘도 이제 좀 통합이 되어 가지고 C++ 표준에서 이제 아토믹이라는 헤더를 , 일단은, 추가를 하면 이제 리눅스건 아니면 윈도우스건 어떤 환경에서든 다 똑같이 잘 동작을 하는걸 만들 수가 있어요 그래서 이제 모던, 심플플에선 어지간해선 이 아토믹을 사용해주시면 되겠습니다 그 다음에 얘를 활용하는 방법은 굉장히 단순한데 그냥 인트가 아니라 얘를 , 이렇게, 아토믹으로 , 이렇게, 이 클래스를 이용해가지고 얘를 묶어주시면 됩니다 아투미 클래스가 여기 보면은 템플릿으로 , 이렇게, 만들어져 있기 때문에 여기다가 어떤 데이터를 활용할 것인지를 , 이렇게, 안에다가 넣어주면 되겠어요 그럼 요 상태에서 썸뿔뿔 하게 되면은 원래 우리가 생각했던 요렇게 세 단계로 이루어지는 주석처리를 할게요 그런 거로 이루어지는 게 아니라 얘가 진짜로 다 이루어지거나 아니면 하나도 실행이 안 되거나 둘 중 하나의 경우로 이제 종작을 하게 됩니다 요런 느낌으로 만약에 이제 sum++을 하면은 이게 진짜 정수 일반적인 인트인지 아토믹 타입인지 헷갈리니까 경우에 따라서는 , 이렇게, 함수를 이용해가지고 fetch add를 이용해가지고 뭐 이런식으로 하는게 좀 나을 수도 있긴 해요 , 자, 이런식으로 고쳐보도록 할게요 근데 뭐 결과적으로 똑같습니다 마이너스 마이너스를 해도 다 오버로딩이 잘 되어있어요 얘는 마이너스 1을 빼는걸로 , 이렇게, 한번 바꿔보도록 할게요 이 상황에서 다시 한번 똑같이 실행을 해보면 이제는 0과 0이 정상적으로 출력이 된다는 걸 볼 수가 있습니다 그래서 , 이렇게, 공유 데이터를 지금 다루고 있을 때는 이제 이런 문제들이 계속 발생한다는 얘기가 되는 거죠 지금 같은 경우에는 어떤 숫자를 더하고 뺀다는 것 자체가 한 번은 일어나지 않았으니까 이거를 이제 아토믹한 타입으로 바꿔줘 가지고 얘가 이제 딱 실행이 되면은 , 자, 그러면 이게 , 사실, 왜 문제가 해결이 되냐면은 만약에 경합을 해가지고 애들을 실행하는 스레드가 간발의 차이로 얘를 먼저 실행했다고 가정해 볼게요 그러면은 사실상 얘는 실행이 되지 않고 얘가 완료가 될 때까지 살짝 대기를 하게 됩니다 그리고 그 순서를 누가 대기하게끔 만들어주는 주체는 CPU가 된다고 보시면 되겠어요. 이게 이 인스트럭션이 CPU단에 있어가지고 사실상 얘가 실행이 될 때까지는 얘가 그 해당 메모리에 접근해가지고 그 데이터를 갖고 오고 하는 거를 막아버린다고 보시면 되겠습니다. 그래서 , 이렇게, 세 번에 걸쳐서 이루어지는 게 아니라 얘가 딱 한 번에 무조건 이루어진다고 볼 수가 있는 거죠. 그래서 참고로 여기다가 브레이크 포인트를 걸어가지고 여기 Sun Fetch Add를 살펴보면 그 다음에 다시 디버그 창 Disassembly를 가보면 이제 얘가 살짝 달라져 있다는 걸 볼 수가 있습니다 기존과 마찬가지로 세 단계로 이루어지는 뭔가가 아니라 어떤 함수를 이용해 가지고 , 이렇게, 실행한다는 걸 볼 수가 있는 건데 얘가 내부적으로 보면 어떤 다른 CPU 인스트럭션을 이용해 가지고 구현이 되어 있을 거예요 그렇기 때문에 아 그러면 이제 멀티스레드 환경에서는 그냥 일반 이런 정수를 사용하지 않고 무조건 아토믹으로 그냥 범벅을 해보면 되지 않을까 라고 생각할 수도 있겠지만 당연한 얘기지만 이 아토믹 계열로 활용하게 되면 얘가 연산이 생각보다 많이 느립니다 그니까 정말로 꼭 필요할 때만 얘를 사용해야 된다는 얘기가 되는 거지 언제 어디서든 얘를 막 사용하면 안 된다고 보시면 되겠어요 지금 이 상황에서는 얘가 그럴싸한 해결 방법이긴 하지만 그럼에도 불구하고 하나가 실행이 될 때 다른 애는 실행이 되지 못하니까 서로 약간 병목현상이 걸릴 수도 있다는 것도 염두에 둬야 됩니다 하지만 , 일단은, 맛보기로 공유 데이터를 건드리는 실습을 해봤고 이게 첫 번째 동계화 방법이라고 , 일단은, 볼 수가 있겠습니다 물론 이거 말고도 다른 동계화 방법이 계속 나올 거라는 것도 알아주시면 되겠어요.