자, 이렇게, 해서 이번 시간 주제는 결국 메모리 모델인데요. 이거를 알아보기 위해서 , 사실, 캐시랑 CPU 파이플라인에 대한 내용을 쭉 알아봤다고 보시면 되겠습니다. 굉장히 중요한 개념입니다. , 일단은, 지난 시간에 우리가 굉장히 충격적인 사실에 대해서 공부를 했고 지금까지 우리가 알던 프로그래밍이, 프로그램 세계가 사실은 굉장히 어둠의 세계에서 많은 작업을 혼자서 막 하고 있었다는 걸 알게 되었습니다. 이 어쩔 수 없는 게 이제 캐쉬의 개념 때문에 그리고 cpu 파이플라인을 의한 최적화 작업 때문에 결국에는 알게 모르게 , 이렇게, 우리가 작업한 코드와 다르게 동작을 한다는 거에 대해서 알 수 있었고 그게 사실은 싱글스레드 환경에서는 아무런 문제가 되지 않았고 그런 문제가 , 사실, 보이지도 않았습니다 그래서 대부분의 프로그래머들은 뭐 그렇게 멀티스레드를 자주 활용할 일은 없다 보니까 이런 사실이 있었다는 것조차 아마 모르고 그냥 지나갔을 겁니다 그런데 이제 지난번에도 말씀드렸지만 C++11 에서 굉장히 중요한 내용들이 많이 추가가 되었는데 물론 이제 뭐 람다식 이라거나 뭐 하는 그렇게 좀 일상 프로그래밍에서 굉장히 유용한 기능들도 많이 추가되었지만 그보다 더 더 더 중요하고 개념적으로 좀 굉장히 큰 차이가 있었다고 보는 게 저는 이제 메모리 모델에 대한 내용이 확립이 되었다는 게 또 굉장히 중요합니다. C++11 이전에서는 , 사실, C++ 표준 자체가 싱글스레드 환경을 염두에 두고 , 일단은, 구조가 만들어졌었다고 표현할 수 있고 11부터는 이제 어느 정도 이런 메모리 모델이 확립되어 가지고 우리가 지난 시간에 알아본 그런 문제들을 해결할 수 있는 수단이 , 일단은, 만연히 되었다고 볼 수가 있는 거예요. 그래서 우리가 C++11 코드를 잘 작성을 하면은 어떤 환경에서건 상관없이 우리가 의도한 코드들이 동작을 한다고 일단 볼 수가 있는 거죠. 그래서 이것에 대해서 , 일단은, 쭉 알아볼 건데 일단 잠시 복습을 하고 넘어가도록 할 건데요. 우리가 이제 스레드에 대한 내용을 쭉 다루면서 이런 상황에 대해서 쭉 알아보고 있는데 , 일단은, 여러 스레드가 동일한 메모리에 동시에 접근을 하는 이런 상황이 , 사실, 우리가 계속 반복해서 학습하고 있고 또 문제가 되는 상황이라고 볼 수가 있겠습니다 근데 물론 동시에 접근하는 것 자체는 문제가 안 돼요 동시에 접근을 해서 그냥 그 값만 추출해 가지고 리드만 하는 경우라고 한다면 , 사실, 뭐 아무런 문제가 없는데 그 중 하나, 쓰레드 중 하나에서 라이트 연산을 해 가지고 그 내용물을 고치는 순간에 이제 문제가 슬슬 발생하기 시작합니다 그래가지고 동일한 메모리에 동시 접근을 해서 누군가가 라이트를 하기 시작을 할 때 우리는 이런 상황을 레이스 컨디션, 경합 조건이 일어난다고 표현합니다. 뭔가 , 이렇게, 말들이 두구두구 달리는 그런 느낌이죠. 레이스를 한다. 뭔가 경합이 일어나 가지고 이제 그 행동이 코드의 결과물이 어떻게 될지 예측을 할 수 없는 상황이 된다고 볼 수가 있는 거죠 그래서 이거를 이제 보통 영어 문서에서는 Undefined Behavior 이라고 하는데 정의되지 않은 행동이 일어난다고 하는데 이게 정말 무서운 말입니다 정의되지 않았으니까 , 사실, 뭐 컴퓨터가 꺼져도 할 말이 없는 거죠 왜냐면 정의되지 않았기 때문에 그 이후로는 그런 C++이나 언어 차원에서 보증을 할 수 없다는 그런 상황이 발생하고 있는 겁니다 그래서 우리는 결국에는 , 이렇게, 공용 데이터에 동시 접근을 하는 상황이 생기면 지금까지 배운 크가의 두 가지 방식 중 하나를 선택을 했는데 락을 걸어 가지고 뮤택스 표준 뮤택스를 이용해 가지고 상호 베타 적으로 접근을 해서 나 먼저 접근하고 내가 끝나면 너가 접근하고 하는 식으로 순서를 정해 가지고 접근하는 게 있었고 아니면은 아토믹한 연산을 이용해가지고 해결하는 그런 방법이 있었죠. 요 두 가지 방식 중 , 일단은, 하나를 선택을 해야 한다고 , 일단은, 지금까지 얘기를 하고 있었어요. , 자, 근데 오늘 알아볼 거는 이 원자적 연산에 대한 내용을 조금 더 심화해서 알아볼 건데 , 사실, 원자적 연산 자체가 바로 문제를 해결해 주지는 않습니다. 이 부분에 대해서 다시 한번 언급을 해보자면 유일하게 C++에서 보증하는 하나의 절대 법칙이 있는데 그거는 바로 다음과 같습니다. 어떤 원자적 연산, 아토믹 연산이 있다고 가정을 하면은 아토믹 연산에 한해서는 모든 스레드가 동일 객체에 대해서 동일한 수정 순서를 관찰한다는 게 , 일단은, 절대 법칙이에요. , 자, 근데 분명히 제가 한국어로 말한 거 같은데 이게 뭔 소리인지 굉장히 아리달송 하죠 그래서 이 부분이 이제 굉장히 헷갈리고 또 직관적이지 않으니까 다시 이제 좀 설명을 드리자면 여기서 얘기하고 있는 동일 객체 동일 순서가 굉장히 중요한데요 , 자, 동일한 수정 순서에 대한 내용을 , 일단은, 한번 설명을 해보겠습니다 , 일단은, 지금 상황이 아까만은 조금 다르게 이제 여기 있는 아토믹한 방식으로 , 일단은, 변수를 수정을 했고요 그 다음에 원래 우리가 뭐 1 이랑 2 를 , 이렇게, 넣어주는 것도 그냥 뭐 이렇게도 상관 없지만 진짜로 아토믹하게 일어난다는 어 그런 힌트를 주기 위해서 아토믹 여기 클래스에서 제공하는 스토어라는 거로 일단 바꿔치기를 해놨어요 그래서 스토어 스토어를 해가지고 1도 넣고 2도 넣고 요런 상황이 된 겁니다 애당초 요 연산 자체가 이제 아토믹 하다 보니까 아까와는 다르게 그렇게 막 어 예측하지 못하는 그런 상황이 발생하는 게 아니라 1이나 2 둘 중 하나로 , 일단은, 값이 분명히 들어간다는 걸 이제 확신할 수가 있는 거죠 간발의 차이로 얘가 먼저 실행이 됐으면 1이 될 거고 간발의 차이로 얘가 먼저 들어가면 2가 되는 뭐 그런 상황이 될 겁니다 , 자, 그런데 그건 그렇고 여기서 얘기하고 있는 동일한 수정 순서는 뭐냐면 만약에 제3의 스레드 혹은 그 외 다수의 스레드가 관찰자 역할을 해가지고 여기 있는 넘버의 값을 계속 무한 로프를 돌면서 실시간으로 계속 관찰을 하고 있다고 가정을 해보도록 하겠습니다. 근데 우리가 이제 캐쉬에 대한 내용에 대해서 알아봤는데 캐쉬에서 알아본 내용의 토대로 다시 한번 복습을 해보자면 , 이렇게, CPU 안에는 코어가 여러개가 있고 그 코어 안에 , 이렇게, 캐쉬가 붙어있다고 했었죠 L1, L2, L3 같은 캐쉬들이 요렇게 딱 덕지덕지 붙어있고 그 캐쉬들은 각 코어마다 하나씩 하나씩 서로 , 이렇게, 세트로 갖고 있다는 걸 그림에서 확인할 수 있습니다. 그렇기 때문에 , 사실, 우리가 여기서 진짜로 이 넘버의 값을 1이나 2로 , 이렇게, 바로 우리가 수정을 했다고 하더라도 그거를 다른 스레드 입장에서 관찰을 했을 때 그 값을 현재 진짜 이 메모리 들어가 있는 값을 얘가 꺼내 가지고 바로 관찰할 수 있다는 보장이 없습니다 물론 그건 어디까지나 지금 요 설명에 따라서 지금 설명하고 있는 거예요 사실은 나중에 알아보겠지만 이 아토미 클래스는 그거보다 조금 더 기능이 많긴 합니다 네 그래가지고 당장 현재 어떤 값이 있는지는 내가 보증을 할 수 없지만 유일하게 지금 얘가 보증을 하는 거는 뭐냐면은 동일 객체에 대해서 동일한 수정 순서를 관찰한다는 게 굉장히 중요합니다. 동일한 수정 순서 그래가지고 예를 들면은 사실상 존재하지는 않지만 일단 가상의 이런 절대 시간표가 일단 있다고 가정을 해볼게요. 이게 과거부터 현재 미래까지 지금 , 이렇게, 변화하는 걸 나타내고 있는 거고 이 넘버의 값이 처음에는 0으로 시작했다가 어떤 이유에서인지 누군가가 얘를 2로 바꿔치기 했고 그 다음에 1로 바꿔줬고 그 다음에 5로 바꿔준 상태라고 과정해볼게요. 예를 들면 Thread1이나 Thread2가 각각 2나 1로 고쳐놨으니까 중간중간에 , 이렇게, 값이 지금 변화한 상태가 있다고 가정할 수 있는 거죠. 그런데 이 상황에 대해서 다른 애가 관찰을 할 때 얘 같은 경우에는 어차피 얘가 만약에 직접적으로 고친 게 아니라고 하면 지금 이걸 관찰하는 입장에서 , 이렇게, 보고 있는데 진짜로 그 해당 값이 어떤 값이 인지에 따라가지고 그 값을 바로 얘가 관찰하는 게 아닙니다 예를 들면 지금 여기가 0이고 그 다음에 2가 되었으니까 이 시점에서 해당 변수를 관찰하면 얘는 이제 2를 관찰할 것 같지만 그거는 어디까지나 우리의 지금까지 생각하던 프로그래밍에 대한 그런 어떻게 보면 고정관념에 따라서 우리가 그렇게 생각하는 거지 실제로 여기서 유일하게 지금 얘가 보증하는 것은 수정 순서에만 동일하게 수정 순서를 관찰한다는 거예요. 무슨 말이냐면 이 수정 순서라고 한다는 것은 어떤 일정한 흐름이 있어가지고 예를 들면 0, 2, 1, 5 이 순서대로 지금 이 변수가 수정이 돼야 된다는 것 자체를 우리가 수정 순서라고 해요 그래가지고 예를 들면 어떤 스레드가 얘를 관찰하다가 일단 여기까지 관찰할 때는 일단 0이라는 값이 있었는데 그 다음에 한참 후에 관찰을 또 하려고 하는데 여기서는 원래 처음에 관찰한 게 0이었으니까 0 이후에 있는 2로 관찰할 수도 있고 아니면 그냥 그대로 0으로도 관찰할 수 있을 겁니다 즉 이 시점을 이후로 미래에 해당하는 그런 값만 관찰할 수 있다는 얘기가 되는 거죠. 그래서 혹시 0으로 관찰할 수도 있을 거고 1으로도 관찰할 수 있는 거지만 뒤로는 못 간다는 게 , 사실, 핵심입니다. 그래가지고 예를 들면은 지금 여기서 쭉 관찰을 하다가 지금 만약에 2를 내가 여기서 어떻게 하다 보니까 2라는 숫자를 관찰을 했다고 가정해볼게요. 그 상태에서 다시 이 미래로 가가지고 사실상 실질적으로 원래는 1이라는 값으로 일단 메모리가 고정이 되었음에도 불구하고 다른 스레드 입장에서는 이런 캐시나 여러 가지 문제가 얽혀있기 때문에 당장 그 1이라는 값을 보지 못하고 예전에 있던 2라는 값을 똑같이 관찰할 수도 있다는 얘기가 되는 거예요 그래서 동일한 수정 순서라는 게 반드시 0, 2, 1, 5 이 순서로 시간이 흐름이 진행이 된다라는 걸 얘기를 하고 있는 겁니다 반대로 얘기하면 내가 방금 방금 2라는 숫자를 내가 관찰을 했는데 그 다음에 관찰을 했더니만 더 과거의 값인 0이 관찰이 되었다라는 상황은 불가능하다는 얘기가 되는 겁니다 즉 시간의 흐름을 거슬러서 관찰할 수는 없고 이 시간의 흐름에 따라가지고 앞으로 가는 방향으로만 관찰을 할 수 있다는 얘기가 되는 거죠 그렇다고 해가지고 얘가 무조건 0, 2, 1, 5 순서로 가야 된다는 건 아니고 예를 들면 1은 스킵을 하고 0, 2, 5 순서로 관찰 결과가 나올 수도 있다는 얘기가 되는 겁니다 그래서 이 ThreadObserver가 만약에 이 값을 추려고 한다고 하면은 어... 여기서 여기까지 계속 얘가 , 이렇게, 스캔을 한다고 했을 때 뭐 0.0.0.0이 계속 나올 수도 있고 0.2.1.5가 나올 수도 있고 0.1.5가 나올 수도 있고 0.5가 나올 수도 있고 0.2로 나올 수도 있고 뭐 이런 식으로 미래로 계속 미래지향적인 방향으로 , 이렇게, 관찰을 할 수 있겠지만 무조건 뒤로는 갈 수 없다는 법칙이 지금 성립을 한다고 보시면 되겠어요 이게 굉장히 묘하지만 지금까지 우리가 알던 관념에 조금 반하긴 하지만 이제 이걸 받아들여야 됩니다 과거로는 갈 수 없지만 미래로만 갈 수 있다 그래가지고 저는 이거 처음에 공부를 할 때 어떤 생각이 들었냐면은 약간 우주 관찰을 하는 느낌으로 생각이 되더라구요 만약에 우리가 뭐 저녁 9시마다 밖에 나가 가지고 저 멀리 있는 별들을 우리가 관찰을 한다고 가정해 볼게요 하지만 당연히 이건 어디까지나 제 입장에서 보면은 별을 관찰하고 있는 거지만 사실은 우주가 굉장히 넓고 여기 지금 , 이렇게, 하나씩 우리가 보고 있는 별은 현재일 수도 있지만 현재에 존재하지 않는 별일 수도 있겠죠 왜냐면 , 사실, 이 별들은 진짜 저 멀리 어딘가에 있는 거고 이 불빛이 빛이 우리까지 , 이렇게, 지구까지 오는데 어마어마한 시간이 걸리죠 이걸 광년 단위로 몇 천만 광년씩 걸리고 그런 식으로 우리가 사실상 보고 있는 거는 어떻게 보면 지금 당장의 그런 모습이 아니라 과거의 모습을 우리가 보고 있다고 볼 수가 있겠습니다. 하지만 그럼에도 불구하고 제가 만약에 오늘 이런 지금 세상을 보고 있다고 하면 다음 날에 또 동일한 위치에 가가지고 별을 관찰을 하면은 최소한 어제 본 그 시점보다는 더 미래에 있는 값을 본다는 건 우리가 확신을 할 수 있겠죠 물론 역시나 그 값이 정말로 현재에 해당하는 그 별에 대한 상태인지는 , 사실, 우린 알 수는 없지만 어찌 됐건 시계 자체는 미래로 간다는 건 우리가 알 수 있습니다 내가 분명히 어제는 이런 상황을 봤는데 오늘 보니까 그것보다 더 과거 시점으로 돌아간 그 세상을 우리가 바라볼 수 없다는 그런 얘기가 되겠습니다. 그래서 결국에는 이 동일한 수정 순서라는 게 , 이렇게, 미래로 향하는 그 순서대로 우리가 이 값들을 관찰할 수 있다는 게 일단 오늘의 핵심이라고 볼 수가 있겠어요. 굉장히 아르달송하죠. 근데 그 다음에 이제 또 여기서 하나만 더 언급을 드리자면 여기서 원자적인 연산에 한해서 이 법칙이 성립을 한다고 했었는데 여기서 말하는 원자적인 연산은 이 아토믹 클래스를 사용한다는 의미는 아닙니다. 이거에 대해서 좀 혼동을 드릴 수 있을 것 같아 가지고 한 번 더 언급을 드리고 있는 건데 여기서 얘기하는 원자적 연산은 더 이상 쪼개질 수 없는 연산을 얘기하고 있는 거예요. 그러니까 CPU가 한 번에 뿅! 처리할 수 있는 걸 우리가 원자적 연산이라고 하는 거고 그게 아니라 여러 단계 쪼개가지고 실행해야 되는 걸 우리가 원자적이지 않은 연산이라고 표현을 하는데 , 이렇게, 한 번에 일어나는 그런 연산에 한해서는 지금 이 규칙이 지금 성립을 한다고 볼 수가 있는 겁니다. , 자, 그래가지고 예를 들면 아까 우리 처음에 든 예제에서 인트 육서를 가지고 요렇게 지금 장난을 치고 있었는데 어 인트64가 그러면 , 이렇게, 1을 대입하고 2를 대입하는 이 행위 자체가 , 사실, 어지간하면 요즘 CPU에서는 다 원자적으로 이제 일어날 겁니다 1을 대입하는 것 자체가 뭐냐면 CPU 자체가 64비트 연산을 지원하기 때문에 얘가 이제 한 번에 일어난 확률이 굉장히 높겠죠 하지만 만약에 컴퓨터가 뭐 거의 20년 전 컴퓨터라고 하면은 그때는 일반적으로 CPU 자체가 32비트 방식으로 동작을 했기 때문에 그 상태에서 만약에 요런 코드를 실행한다고 하면은 내부적으로는 인트 64를 한 번에 처리할 수 없기 때문에 얘를 인트 32짜리 두 개로 만들어가지고 상위 32비트를 먼저 수정을 하고 하위 32비트를 수정하고 이런 식으로 두 번에 걸쳐가지고 이 넘버를 수정을 했을 겁니다 그런 상황이라고 한다면은 더 이상 요 연산이 원자적이지 않은 상황이 되는 거죠 그러니까 여기서 말하는 원자적인 연산이라고 하는 것은 어디까지나 우리의 CPU에 상대적인 거라고 볼 수 있겠습니다 어떤 환경에서는 원자적이지만 어떤 환경에서는 원자적이지 않을 수도 있다는 얘기가 되는 거죠 그래가지고 여러분들의 환경에서 이게 원자적으로 잘 진행이 되는지 궁금하면은 이 Atomic 클래스를 이용한 다음에 예를 들면 Atomic Int64를 하고 여기다가 멤버함수로 IsLockFree라는 기능이 있는데 이거를 체크를 해보시면 돼요 만약에 LockFree가 true로 떴다고 하면은 여러분들의 컴퓨터에서 이거를 원자적으로 수정을 할 수 있게끔 원래 지원을 해줬다는 얘기가 되는 거고 그게 아니라 여기서 락프리가 만약에 false로 뜬다고 하면은 이거는 CPU 차원에서 원자적으로 이거를 수정할 방법은 없었기 때문에 얘가 어거지로 락을 잡아가지고 이게 원자적으로 수정이 되게끔 유도를 해주는 그런 상황이라고 보면 되겠습니다 그러니까 우리가 , 이렇게, 아토미 클래스를 이용해 가지고 사용을 하게 될 경우에는 어찌 됐건 개를 수정을 할 때 원자적으로 진짜 수정이 일어나야 된다는 걸 보장을 해야 되는데 그게 진짜 원래 애당초 CPU 덕분에 원래 원자적으로 일어났던 거라고 하면 얘가 이제 문제없이 그냥 한 번에 실행을 해줄 것이고 그게 아니라 지금 여기 두 번째 상황에서 든 이런 나이트 같은 경우에는 인트32가 지금 3개 있는 상황인데 이거를 원래 한 번에 뿅 수정하는 그런 CPU는 일단 최소한 제 환경은 아니기 때문에 이거는 원래 원자적으로 처리할 수 없던 애가 된다는 거라고 보시면 되겠어요 그래가지고 사실상 이 아토믹 클래스 내부에서 얘를 원자적으로 처리하기 위해서 우리가 이 나이트라는 이 아토믹 객체를 수정을 한다고 가정을 했을 때 뮤텍스 같이 락을 잡아가지고 다른의 접근을 막은 다음에 값을 수정을 하고 락을 풀어주고 이런식으로 내부적으로 , 일단은, 구현이 되었다고 보시면 되겠습니다 , 자, 그래서 혹시라도 이 아토믹 연산이라는 거에 대한 오해를 하실까봐 진짜 이 아토믹 클래스를 이용해야지만 지금 이 법칙이 성립을 한다고 오해를 하실까봐 이 부분은 조금 길었지만 어찌됐건 , 이렇게, 보충 설명을 드린 거고요 그래가지고 돌고 돌아가지고 결국에는 우리가 지금 유일하게 아는 거는 요런 원자적인 연산에 한해서는 동일 객체에 대해서 동일한 수정 순서를 관찰할 수 있다는 게 , 일단은, 오늘의 결론이라고 보시면 되겠습니다 근데 뭐 아직까지는 이것만 안다고 해서 뭐 딱히 뭔가가 바뀌지는 않겠죠 그리고 또 하나 중요한 거는 동일 객체에 대해서라는 요 부분도 제가 이제 굉장히 중요해가지고 여기다가 , 이렇게, 좀 볼드 처리를 해놨는데 동일 객체에 대해서만 이게 성립을 한다는 게 또 중요합니다 이게 또 뭐가 문제가 되냐면은 그럼 만약에 객체가 , 이렇게, 넘버 하나만 있는 게 아니라 얘가 뭐 넘버 1, 넘버 2, 넘버 3, 넘버 4 같이 여러 개가 막 있다고 가정을 하면은 넘버 하나에 한해서는 동일한 수정 순서가 , 이렇게, 관찰이 되겠지만 그 아이들 사이에 순서에서는 또 아무런 영향을 받지를 않아요 그렇기 때문에 만약에 우리가 No.1이랑 No.2를 같이 수정을 하고 하면은 걔네들끼리의 순서는 또 , 이렇게, 엎치락 뒤치락 뒤바뀔 수 있다는 얘기가 되는 거죠 이게 또 약간 머리가 아파집니다 우리가 이전에 알아본 , 사실, 가장 지금 문제가 됐던 게 가시성 문제랑 그 다음에 코드 재배치에 관한 두 개의 문제가 있었는데 이 아토믹 연산을 한다고 해가지고 가시성과 재배치 문제가 해결이 되지 않는다는 걸 알 수 있는 거죠 순서가 뒤바뀌어가지고 넘버원을 먼저 수정하고 넘버투를 그 다음에 수정했는데 그 순서가 뒤바뀐다는게 우리가 지난번에 문제가 됐던 코드 재배치의 문제랑도 굉장히 비슷하고 그 다음에 이 순서가 동일한 수정 순서를 관찰한다고 해도 가시성 문제는 여전히 해결되지 않죠 만약에 지금 요 상황으로 돌아와서 지금 딱 이 시점에서 우리가 관찰을 한다고 하면 가시성 문제가 해결이 되려면 무조건 2라는 숫자가 딱 보여야 되지만 그게 아니라 이 법칙에 의해서는 얘가 , 사실, 내가 이제까지 관찰한 그 값을 기준으로 그 이후의 숫자 어딘가를 지금 관찰한다는 그런 차이가 있는 겁니다 그러니까 이 법칙만으로는 , 사실, 어떤 문제가 해결이 되는 건 아니지만 이걸 토대로 우리가 이제 생각을 해야 되기 때문에 이 법칙에 대해서 말씀을 드리고 있는 거고요 , 자, 그 다음에 이제 이어가지고 코드로 돌아가지고 이제 좀 여러가지 실습을 해볼건데 그 전에 하나 말씀드려야 될건 뭐냐면은 우리가 , 이렇게, 아토믹 객체를 이용해가지고 지금까지 장난을 치고 있었어요 넘버를 , 이렇게, 1로 바꿔치기를 해주는 작업도 해봤고 사실상 이게 넘버점 스토어 1이랑 똑같은 의미라고 했었는데 또 더 깊이 파고 들어가면은 이 스토어 1이라는 것 자체가 , 사실, 요 의미랑 똑같습니다 스토어 1에다가 뒤에 어떤 메모리 정책으로 우리가 스토어를 할 것인지를 , 이렇게, 추가적으로 기입을 해줄 수가 있어요 이게 오늘의 , 사실, 주인공이라고 보면 되겠어요 마찬가지로 값을 꺼내서 쓸 때도 원래 우리가 그냥 넘버점 로드로 값을 빼내왔지만 이게 정확히 말씀을 드리자면 여기서 이 기본 값으로 메모리 오더를 메모리 오더 이 시퀀시얼 컨시스턴트라는 이 정책으로 우리가 지금 로드를 하고 있었던 겁니다. 하지만 이 메모리 정책이 딱 하나만 있는 건 아니고요. 어떤 메모리 정책에 따라서는 우리가 얘기한 가시성이랑 코드 재배치 문제가 해결이 되고 어떤 정책에 따라서는 해결이 안 되고 하는 차이가 생기기 때문에 이 부분에 대해서 , 일단은, 실습을 해보기 위해서 다시 코드로 돌아가 보도록 할게요. , 자, 다시 코드로 돌아와 가지고 오늘은 뭐 이제 이어서 이런 저런 실습을 해볼 건데요 , 일단은, 어 기본적으로 아토믹에 대한 내용을 다룰 거니까 아토믹에 대한 간단한 복습부터 하고 진행을 해보도록 할게요 그래서 아토믹 헤더부터 , 일단은, 추가를 해주시구요 뭐 간단하게 아토믹 분리언을 이용해 가지고 어 , 일단은, 기본적인 내용에 대해서 알아보도록 하겠습니다 , 일단은, 여기서 Atomic으로 , 이렇게, 만든 Boolean 타입이 , 이렇게, 있다고 가정했을 때 이게 진짜로 원자적으로 원래 동작을 하던 것인지 아니면은 이 Atomic class에 의해 가지고 얘가 원자성을 부여를 받는 것인지 궁금하면은 방금 말씀을 드렸지만 여기서 IsLockFree를 체크하면 된다고 했었죠. 락 프리라는 거에서 영어에서 프리라는 게 무엇 무엇이 없다라는 말을 하는 거죠 네 그래가지고 락이 없다라는 의미가 되는 건데 락이 없는 게 true 라고 하면은 왜 락이 없냐면은 애당초 이 Boolean 자체가 우리 CPU에 의해 가지고 원자적으로 애당초 처리가 될 수 있었기 때문에 락을 걸 필요가 없으니까 얘가 true 로 뜨는 거고 만약에 락 프리가 false 로 한다는 것은 락을 걸어야 된다는 얘기가 되는 거니까 여기서 플래그에서 우리가 뭔가 어떤 값을 집어 넣을 때 만약에 얘가 false였다고 하면은 얘는 원자적으로 실행이 되지 않기 때문에 여기다가 이제 뭐 앞뒤로 락을 , 이렇게, 잡아가지고 얘를 실행해야 되는 상황이라는 얘기가 되는 거죠. 네 그래가지고 뭐 물론 우리가 이거 직접 락을 걸 필요는 없고 여기 Atomic이라는 클래스 내부에서 해주게 되겠지만 이걸 이용해가지고 여기 있는 데이터 안에 넣어준 데이터가 진짜로 락 없이 동작하는 그런 원자적인 연산인지를 체크할 수 있다고 했습니다. , 자, 그러면은 여기다가 이제 뭐 데이터를 넣을 때 우리가 일반적인 불리언 변수를 사용하던 것처럼 이런 식으로 데이터를 집어 넣을 수도 있고 그 다음에 데이터를 꺼내고 싶으면 그냥 , 이렇게, 꺼내 쓸 수가 있었죠 근데 , 이렇게, 쓰면은 이게 진짜로 일반적인 불리언인지 아토믹인지 조금 헷갈리니까 , 이렇게, 쓰기보다는 역시나 스토어를 이용해서 , 이렇게, 데이터를 직접적으로 집어넣는게 조금 더 , 일단은, 가독성이 좋다고 볼 수도 있습니다. 물론 위에 버전으로 한다고 문제가 생기는 건 당연히 아니고요. 얘도 마찬가지로 이런 식으로 value는 flag.load를 해가지고 뭔가를 꺼내 쓰겠다라고 표현을 할 수가 있는 거죠. 그 다음에 여기서 이제 심표를 해가지고 살짝 살펴보면은 , 사실, 여기서 뒤에 두 번째 인자를 , 이렇게, 받아주고 있습니다 , 사실, 우리가 , 이렇게, 그냥 쌩으로 했던 것도 결국에는 얘를 기본 인자를 여기 Sequential Consistent로 , 이렇게, 넣어주는 거랑 , 일단은, 똑같다고 표현을 했어요 이게 오늘의 주제인 겁니다 요런 식으로 , 자, 이게 어떤 의미인지는 뭐 이어서 나올거니까 잠시 스킵을 하고 어 그 다음에 이제 뭐 해보고 싶은건 뭐냐면은 , 자, 만약에 이전 플래그 값을 잠시 뭐 어떤 previous라는 변수에다가 놓고 그 다음에 플래그 값을 뭐 수정하고 싶다고 가정해볼게요 그러면 이거를 쉽게 생각을 하면은 뭐 이런 코드를 작성할 수 있겠죠? previous에다가 flag 값을 넣어주고 그 다음에 flag 값을 true로 설정하겠다라고 요렇게 생각을 할 수가 있는데 어 이건 약간 문제가 있습니다 , 자, 이게 이제 아토믹과 관련된 코드를 작업할 때 요런 부분을 굉장히 조심해야 되는데 플래그를 이전 값을 꺼내와서 프리벳에다 우리가 넣었다고 생각할 수 있겠지만 그 순간에 만약에 이 플래그 값을 다른 쓰레기가 접근해 가지고 걔를 수정하는 상황이 있다고 하면은 여기 프리벳에 있는 값이 더 이상 유효하지 않겠죠 그러니까 뭐 이거를 지금 여기 위에 있다고 가정하는 게 좀 맞겠네요 요런 느낌으로 플래그 펄스는 뭐 요런 상황을 일단 다시 가정하고 진행을 해보면 뭐 그래가지고 결국에는 얘를 꺼내 쓴 다음에 값을 집어 넣는 이 행위도 , 사실, 원자적으로 한 번에 일어나야 된다는 얘기가 되는 거고 그래서 이런 거를 하기 위해서는 , 이렇게, 두 번에 걸쳐 가지고 하는 게 아니라 , 이렇게, 읽고 쓰는 걸 동시에 하는 애들이 있습니다 그게 바로 여기 보면 Exchange라는 기능이 있어요 그래가지고 여기 Exchange 기능을 보면은 우리가 무엇을 넣어줄 것인가 여기에다가 true를 넣어주겠다라고 한 다음에 Exchange에서 뱉어주는 값이 원래 있던 이전 값을 의미를 하기 때문에 만약에 우리가 어떤 값을 넣고 그 넣기 바로 이전의 값을 우리가 추출하고 싶다고 하면은 , 이렇게, 두 번에 걸쳐서 하면 안 되고 반드시 이런 Exchange와 같은 함수를 이용해가지고 얘를 이제 만들어줘야 됩니다 이런 부분도 종종 하는 실수니까 이걸 일단 언급을 드리고 있는 거고요 그 다음에 굉장히 중요한 우리가 뭐 잠시 알아보긴 했지만 compare and swap ces 연산 얘네들도 이제 우리가 프로그래밍 할 때 굉장히 굉장히 중요했었죠 조건부 수정과 같은 느낌으로 일단 동작을 하는 거고 , 자, 여기서도 뭐 간단히 알아보면 compare exchange strong 얘가 일단 기본 방식이라고 볼 수 있는 건데 얘가 인자를 받는 게 , 일단은, expected랑 desired를 받아준다고 했습니다 expected 그 다음에 desired expected는 내가 예상한 값이고 desired는 만약에 예상한 값이 expected라고 하면은 그러면은 나는 이제 이 desired란 값으로 바꿔주겠다라는 의미로 사용한다고 했었죠 그래서 여기다가 expected desired를 차례대로 , 이렇게, 넣어주면 됩니다 물론 이 desired를 따로 빼지 않고 그냥 여기다가 넣어줘도 돼요 저는 일반적으로 의미로 코드가 , 이렇게, 해야지 조금 잘 읽혀가지고 , 이렇게, 하는 거를 조금 더 선호하고요 그래가지고 요 코드의 의미 자체는 일단 이거를 조금 의사 코드로 표현을 해서 보면은 만약에 Flag랑 Expected랑 비교해가지고 얘네들이 같을 수도 있고 안 같을 수도 있겠는데 만약에 같으면은 , 일단은, flag 값을 우리가 원하던 desired로 넣어주고 return true로 한다고 했었죠. 그 다음에 만약에 그게 아니라고 한다면 , 일단은, return false가 뜰 것이고 그리고 그거와는 별개로 원래 있던 flag 값은 expected로 들어간다고 했습니다. 여기 들어갈 것이고 뭐 위쪽에도 이걸 넣어줘도 되고 , 사실, 얘네 둘이 같으면 뭐 , 사실, 굳이 넣어줄 필요가 없으니까 이거 뭐 잠시 조사 처리를 하자면 요런 느낌으로 , 일단은, 코드가 돌아가는 게 이 Compare Exchange Strung이고 얘가 이제 다만 원자적으로 한 번에 뿅 일어나는 그런 작업이라고 했었죠 그래서 이걸 잘 응용해 가지고 우리가 뭐 스피드락도 만들 수 있었고 온갖 코드를 다 만들 수가 , 일단은, 있었습니다 그리고 여기도 보면 역시나 맨 마지막 인자로 메모리 오더라는 걸 받아가지고 여기서 여러가지 정책 중에 하나를 선택을 해줄 수가 있습니다. 그래서 오늘 계속 다룰 이 메모리 오더라는 이 변수 자체가 , 사실, 오늘 알아볼 그 메모리 정책이라고 볼 수가 있는 거예요. 계속 등장하고 있죠. 아 그리고 참고로 Compare Exchange Weak라는 함수가 하나가 더 있어요 이 부분에 대해서도 종종 궁금해하시는 분들이 계시는데 , 일단은, Exchange Strong이랑 Exchange Weak랑 거의 똑같습니다 사용방법은 사실상 거의 똑같다고 보시면 돼요 얘도 마찬가지로 Expected를 넣어줘서 이런 식으로 Expected를 넣어주고 Desired를 넣어주고 이런 식으로 똑같이 넣어주는데 얘가 하나 차이가 있는 건 뭐냐면 스포일러스 페일러 라는 상황이 일어납니다. 가짜 뭐 지적하자면 가짜 실패라는 걸로 일단 분석을 할 수가 있을 것 같은데 어 요 함수 같은 경우에는 일단 동작 방식은 똑같지만 여기서 내부적으로 만약에 이 FLAG랑 EXPECTED가 같았으면 원래 CONFIGURATION STRONG 같은 경우는 얘가 이 로직이 실행이 되면서 무조건 성공해야 정상적인데 이 WEAK 같은 경우에는 여기서 예외적으로 뭐 이런저런 이유로 예를 들면 다른 스레드에 방해를 받아가지고 인터럽션을 받았다거나 하는 온갖 하드웨어적인 이유로 중간에 실패할 수가 있어요 할 수 있음 그래서 여기서 뭐 한마디로 의사코드로 보면은 뭐 이런저런 묘한 상황에 의해 가지고 둘이 같았음에도 불구하고 얘가 이제 false가 뜰 수 있다는 얘기가 되는 거죠 그래가지고 말 그대로 가짜 실패다 원래는 성공해야 되는데 뭔가 묘한 상황에 의해 가지고 얘가 실패했다라는 요런 상황이 일단 추가가 된다고 보시면 되겠어요 근데 원래는 , 사실, 요 컴팩트인지 위크가 정상적인 상황이고 이제 이게 뭐 하드웨어에 따라 가지고 , 이렇게, 중간에 실패를 할 수가 있는 상황이고 Compendie Strong은 이 상황을 이제 없앴다기 보다는 만약에 , 이렇게, 실패를 하게 되면은 얘를 한 바퀴를 더 돌아가지고 , 사실, 우리가 원하던 진짜로 같으면 성공해야 되는 그런 상황이 일어날 때까지 이제 반복을 해준다고 보시면 되겠어요 그래가지고 당연한 얘기지만 얘가 이제 기본적인 형태고 거기서 그거를 이제 보장해주기 위해서 추가 코드가 들어가야 되니까 Strong 버전이 조금 더 부담이 있는 부하가 좀 더 많이 잡아먹는 그런 버전이라고 볼 수가 있겠습니다 그래가지고 일반적으로 이 위크 버전을 사용할 거면은 애당초 이 펄스를 했다고 하더라도 원래는 실패하면 안되는데 가짜로 실패하는 상황이 있을 수 있기 때문에 컴팩트 체인지 위크는 무조건 와일루프랑 같이 사용을 해가지고 여기서 뭐 이런식으로 어떤 상황에 의해 가지고 얘가 될 때까지 , 이렇게, 뺑뺑이를 도는 게 일단 일반적인 코드입니다. 근데 물론 , 사실, 컴폐니션 스트롱도 우리가 스피드 락을 구현할 때도 그랬지만 , 이렇게, 무한 루프를 돌면서 얘가 성공할 때까지 뭐 돌렸으니까 , 사실, 큰 차이는 없다고 보시면 되겠어요. 그래가지고 얘를 사용하나 얘를 사용하나 , 일단은, 기본적으로 큰 차이는 없지만 , 이렇게, 묘한 상황 처리에 대해서 뭔가 좀 달라진다라는 건 일단 참고하시면 되겠습니다 그래서 실제로 테스트를 해보면 둘의 성능 차이도 별로 안 납니다 이게 어떤 머신에서는 성능 차이가 크게 날 수 있다고 하는데 , 일단은, 기본적으로 사용하는 인텔 머신에서는 이게 별 차이가 안 나기 때문에 , 사실, 둘 중 어떤 걸 사용하더라도 크게 , 일단은, 상관이 없다고 보시면 되겠어요 네 이건 지난번에 제가 말씀을 안 드린 것 같아 가지고 컴폐니션 위크에 대한 내용도 , 일단은, 다뤄보고 , 자, 그래가지고 뭐 , 일단은, 잠시 복습을 해봤고요 이게 만약에 불리언이 아니라 내부적으로 이제 인트와 같은 변수라고 한다면은 더샘과 뺄샘 이런 기능들을 추가로 지원을 해 줄 거고 그냥 일반적인 통상적인 관념에서 이런 걸 지원해 주겠다라고 해서 찾아보면 진짜로 있습니다 하지만 기본적인 형태는 스토어랑 로드 그리고 뭐 Exchange, Conference Strong , 이렇게, 4가지 버전을 일단 일반적으로 공통적으로 활용할 수 있는 그런 기능들이라고 볼 수가 있겠습니다 , 자, 그러면은 잠시 이 내용을 , 일단은, 삭제를 하고 그래가지고 아까 계속 등장한 그 마지막에 등장하던 뭔가 메모리 모시기 메모리 모델 일종의 정책 같은 그 아이는 무엇을 하는 것인지 , 일단은, 살펴볼 건데요 , 일단은, 크게 3가지 정책이 있습니다 하나는 Sequentially consistent, 뭔가 일관성이 있다라는게 첫번째고 두번째는 acquire, release 정책이구요 세번째는 relax 상태입니다 그래가지고 얘랑 연관된 애가 요 버전으로 메모리 뭐시기 찾아보면은 이 버전으로 , 이렇게, 끝나는게 1번 정책이고 얘같은 경우에는 consume, acquire, release 그 다음에 요렇게 4개가 얘랑 관련이 있구요 릴렉스드는 역시나 뭐 릴렉스드 얘랑만 관련이 있습니다 그래서 우리가 넣어주는 여러가지 옵션이 , 이렇게, 크게는 3가지로 , 일단은, 정책을 분류할 수 있다고 보시면 되겠어요 , 자, 그러면은 얘는 도대체 어떤 의미이냐 어 , 사실, 여기서도 acquire, release가 가장 핵심이라고 보시면 되겠습니다 acquire, release 이 Consume 같은 경우에는 참고로 이제 C++도 좀 문제가 있어가지고 C++17에서 고치는이 많으니 하는 여러가지 이슈가 있었기 때문에 얘는 , 일단은, 그냥 잊으셔도 되고 기본적으로 이 Acquire, Release랑 얘랑 얘 , 이렇게, 4개를 , 일단은, 기억을 해주시면 되겠어요 얘는 말 그대로 얘랑 얘를 합쳐놓은 것이기 때문에 얘도 뭐 굳이 , 이렇게, 사용할 일은 많이 없고 잊으셔도 되고 , 이렇게, 4가지를 , 일단은, 기억을 해주시면 되구요 요기서 이제 위로 갈수록 1번 같은 경우가 가장 엄격한 거구요 내려갈수록 자유로워집니다. 근데 이게 엄격하다는 게 나쁜 의미가 아니라 엄격하다는 것은 컴파일러 입장에서 최적화 여지가 적다는 얘기가 되는 거고 반대로 우리 입장에서 보면은 코드가 굉장히 직관적으로 동작한다는 얘기가 되는 거고 반대로 자유롭다고 하는 거는 컴파일러 최적화 여지가 많다는 얘기가 되는 거지만 우리 입장에서 보면은 직관적이지 않고 이지 않은 끔찍한 코드가 일어난다고 보시면 되겠어요 그러니까 결국에는 그런 코드 재배치와 같은 경우도 이 윗버전으로 하면은 재배치가 잘 안되고 굉장히 이제 보수적으로 작업을 하게 될 것이고 이 아래로 내려갈수록 최적화 여지가 많으니까 막 지들끼리 코드도 섞고 아주 난리가 난다는 얘기가 되는 거죠 그래서 기본적으로 아무것도 입력을 하지 않으면 아토믹이 항상 이 윗버전인 엄격한 버전으로 동작해가지고 우리가 지금까지는 , 사실, 메모리 모델을 신경 쓸 필요도 없었던 겁니다 그리고 앞으로도 , 사실, 그럴 확률이 높아요 굳이 이런 버전들을 사용해가지고 어렵게 작업할 필요는 없긴 한데 그럼에도 불구하고 이런 내용들이 도대체 무엇인지 궁금하니까 이거에 대해서 , 일단은, 알아보도록 할게요 , 일단은, 코드를 만들어볼건데 , 자, 일단은, 첫번째 버전부터 일단 살펴보도록 할게요 , 자, 일단은, 다시 위로 가가지고 프로듀서 에고 프로듀서 뭔가를 만들어주는 코드가 있고 그 다음에 컨슈머라고 해가지고 뭔가 소모하는 코드가 , 일단은, 있다고 다시 가정을 해보고요 그 다음에 아토믹 불리언을 하나 둬가지고 뭔가 레디 플래그를 하나를 두고 하시고 그 다음에 여기다가 어떤 아토믹이 아닌 그냥 일반 값을 하나를 요렇게 넣어주도록 할게요 그래가지고 사실상 메인 함수에서는 간단하게 얘네들을 호출해줄건데 일단 ready는 false로 밀어주고 value는 0으로 밀어주고 그 다음에 t1을 만들어줄건데 t1은 producer 함수를 실행할 것이고 그 다음에 t2는 consumer를 실행하는 상태이고 t1.join t2.join을 해가지고 양쪽을 기다려줄겁니다 굉장히 단순하죠 그런데 이제 producer에서는 무엇을 해줄거냐면은 value를 , 일단은, 0으로 , 이렇게, 바꿔치기를 해준 다음에 그 다음에 레디 플래그를 2로로 켜 줄 거에요 오케이 난 준비 됐어 라고 켜 줄 건데 여기서 뭐 여러가지 선택권이 있죠 여기서 여러가지 메모리 그걸 바꿔 줄 수가 있는데 우리가 아까 얘기한 이 Sequential Consistent 얘가 일단 기본 버전이라고 했습니다 마찬가지로 컨슈머 코드에서는 무엇을 해줄거냐면은 일단 레디 플래그가 켜져질 때까지 얘는 계속 뺑뺑이를 돌거에요 그래가지고 얘도 이런 식으로 로드를 할 것인데 얘도 마찬가지로 기본적인 상태가 메모리 오더 이거 시퀀셜 컨시스턴트가 기본 상태라고 했었죠 이걸로 , 일단은, 테스트를 해보도록 하겠습니다 얘가 false일 때까지 즉 레디 플래그가 아직 false일 때까지 무한정으로 뺑뺑이를 돌다가 그 다음에 여기까지 넘어와가지고 , 자, 이런 식으로 밸류를 출력을 해보도록 할게요 , 자, 그러면은 sequential consistent 같은 경우에는 얘가 가장 엄격하다고 했었고 이 버전으로 1번 버전으로 하면은 사실상 우리가 지금까지 우리를 괴롭혔던 가시성 문제랑 가시성 문제가 바로 해결이 되고요. 그리고 코드 재배치 문제도 바로 해결이 됩니다. 너무 행복하죠. 사실상 우리가 이거를 지금까지 생각할 필요가 없었던 이유가 에너지 첫번째 버전으로 하면은 이런 문제가 바로 해결이 돼요. 그래가지고 여기서 내가 뭔가 값을 뿅 넣는 순간에 요 정책으로 했으면은 다른 애에서 로드를 해가지고 살펴볼 때도 애당초 이 버전을 이 레딕에 들어가 있는 값을 그대로 본다는 걸 알 수가 있는 거고요. 그 다음에 코드의 재배치 문제도 해결이 됩니다. 재배치 문제가 해결이 되지 않는다고 하면 만약에 얘를 다른 버전으로 했다고 가정해 볼게요. 뭐 , 일단은, 여기서 가장 자유도가 높은 3번부터 , 일단은, 알아보도록 하겠습니다. 3번 같은 경우에는 Relaxed라고 해가지고 영어부터 너무 편안하죠. 너무나도 편안하고 자유롭다. 자율성 100%를 , 일단은, 주고 있는 겁니다. 그러니까 결국 코드 재배치도 멋대로 컴파일러가 할 수 있고 가시성도 딱히 해결해주지 못합니다. 즉 유일하게 얘가 보장하는 것은 원래 우리가 PPT에서 알아본 첫 번째 가장 기본적인 조건 있죠 가장 기본적인 조건 즉 동일 객체에 대한 동일 관전 순서만 보장하는 상태가 되는 거예요 가장 가장 기본적인 애만 결국 보장을 하고 나머지는 하나도 보장을 하지 않기 때문에 만약에 이런 부분들을 만약에 우리가 relaxed로 , 이렇게, 바꿔놨다고 하면은 이제 약간 알이 달성해지는게 요런 코드들에 대해서 재배치가 가능하기 때문에 이 위아래로 여기 있는 부분이 막 요렇게 멋대로 넘어올 수가 있어요 그러면은 요게 이제 또 약간 애매해지는게 우리는 애정초 벨류를 10으로 세팅한 다음에 그 다음에 레디 플래그를 이제 스토어를 2로로 켜줘가지고 이제 고 하세요 라고 한거지만 이런식으로 만약에 뒤바꿔치기가 된다고 하면은 결국에는 의미가 없어지고 요 코드 자체가 좀 이상하게 꼬인다는 얘기가 되는거죠 그래서 사실상 요 릴렉스트 같은 경우에는 거의 거의 사용할 일이 진짜 없습니다 뭐 존재는 나긴 하지만 , 이렇게, 자유로운 코드 자체는 굉장히 직관성이 떨어지고 멀티셋 환경에서 얘가 아주 재앙적으로 일어날 수 있는 문제이기 때문에 얘는 뭐 거의 활용하지 않는다고 , 일단은, 보면 되겠어요 하지만 뭐 이런 코드가 있다는 건 알아야 되겠죠 그 다음에 Acquire Release 같은 경우에는 딱 중간에 해당합니다 너무 엄격하지도 않고 너무 자유롭지도 않고 딱 중간 단계 정도라고 생각할 수가 있어요 그래서 얘 같은 경우에 , 일단은, 어떤 식으로 동작을 하냐면은 , 일단은, 짝을 맞춰줘야 돼요 여기서 acquire, release 짝을 맞춰주게 되는데 일단 프로듀서 쪽에서 얘를 release 버전으로 얘를 맞춰주고 그 다음에 컨실러 쪽에서 얘를 acquire 쪽으로 요렇게 짝을 맞춰주게 됩니다 , 자, 그러면은 얘가 이제 어떤 일이 일어나냐면은 , 일단은, release 명령 이전의 메모리 명령들이 해당 명령 이후로 , 일단은, 재배치되는 것을 금지를 합니다 약간 조건부 금지라고 볼 수 있는 거죠 그래가지고 얘가 , 이렇게, 되면은 여기서 이제 절취선이 딱 만들어지는 거에요 얘를 호출하면서 짝 절취선 그러면서 얘가 주장하는 거는 여기 위에 있는 애들이 이쪽 아래로 넘어갈 수 없다는 걸 일단 얘가 강제로 , 이렇게, 막아줍니다 그래서 , 이렇게, 막아주는 역할을 해 줘 가지고 얘가 어느 정도 재배치가 억제가 되는 현상이 일어나는 거죠 근데 물론 여기에 뭐 이런 식으로 여러 개의 값들이 있었다고 하면은 지들끼리 여기서 뭐 얘네들끼리 바뀌는 건 뭐 그렇게 상관을 하지 않아요 얘는 어디까지나 얘를 기준으로 이 앞뒤로 막아주는 그런 역할을 하게 되는 거고 그 다음에 또 하나의 특징이 있는데 이제 release 만약에 여기서 그 다음에 release 우리가 모드로 먼저 , 이렇게, 걸어준 상태에서 그 다음에 동일한 변수에 대해서 acquire 모드로 같은 변수를 읽는 thread가 있다면 release 이전의 명령들이 acquire 하는 순간에 관찰 가능하다 즉 가시성이 이제 보장이 된다는 얘기가 되는 겁니다 무슨 말이냐면 얘도 마찬가지로 , 이렇게, 절취선을 딱 그어 가지고 얘는 거꾸로 아래에 있는 애들이 위로 올라갈 수 없게 막아 주는 것 뿐만 아니라 얘네들이 짝을 , 이렇게, 맞춰가지고 , 이렇게, 스토어를 릴리스 모드로 한 상태에서 다른 누군가가 로드를 억화하게 되면은 얘네들이 짝꿍이 되가지고 , 이렇게, 짜장 하고 맞아가지고 여기 이전에 있던 모든 내용들이 이 이후에 있는 이후에 다 갱신이 되어 가지고 정확히 가시성이 보장이 됩니다 여기 있는 내용들이 여기에 보이게 된다는 얘기가 되는 거죠 그래가지고 최소한 아까 consistent 뿐만 아니라 release acquire를 이용해 가지고 짝을 맞춰주면은 여기서 여기 value가 100% 확률로 10으로 나온다는 거 , 일단은, 보장을 할 수가 있어요 그리고 뭐 물론 어 아까 처음에 디폴트 상태인 Sequential Consistent로 해도 역시나 100% 확률로 10이 뜨겠지만 가장 자유로운 형태인 Relaxed로 하면은 얘가 엉뚱하게 이게 순서가 뒤바뀌면서 얘가 그냥 초기 값인 0으로 뜰 수 있다는 얘기가 드는 거죠 근데 물론 이걸 여러분이 실제로 실행해 보면 거의 뭐 항상 10이 나오긴 할 겁니다 왜냐하면 이게 정말 극악의 확률로 이게 잘 맞나 가지고 이게 재배치가 일어나고 하는 여러가지 조건들이 일어나야 되는데다가 스레드가 뭔가 만들어지고 하는 것도 부하가 들어가지고 타이밍 이슈도 있기 때문에 이게 , 사실, 제어는 잘 되지 않지만 그럼에도 불구하고 C++ 규칙에 따라서 표준에 의해 가지고 만약에 예를 릴렉스 같은 정책을 사용하게 되면 얘가 코드 재배치가 일어날 수 있다는 사실이 , 사실, 중요한 거죠 그래가지고 , 이렇게, 일단은, 여러가지 모드가 있는데 결국엔 여기서 알 수 있다던 거는 얘는 그나마 가끔 사용할 수 있겠다라는 생각이 들고 근데 가장 일반적으로는 그냥 이 Sequential Consistent 버전으로 하는 게 가장 좋다는 생각이 드는 거죠 만약 우리가 안 그래도 멀티스레드에서 지금 골치가 아픈데 이런 식으로 알게 모르게 코드가 재배치되고 하면 이런 걸 또 언제 신경 써가지고 작업할지가 굉장히 걱정이 되죠 그리고 하나 좋은 소식을 또 말씀을 드리자면 인텔이나 AMD 같은 이런 CPU 애들은 이 경우에 당초 칩 자체가 순차적인 일관성을 보장을 합니다 그래가지고 , 사실, 이 첫번째 가장 엄격한 버전인 sequential consistent 버전을 써도 별다른 차이가 없어요 굉장히 좋은 소식이죠? 그러니까 굳이 정말 위험한 요런 나머지 애들을 쓰기보다 그냥 default 상대로 놔둬도 그냥 똑같다는 얘기가 되는 겁니다 그래서 앞으로도 , 사실, 코드에서 그냥 요렇게 냅둬가지고 원래 처음에 했던 방식으로 해도 아무 차이가 없다는 걸 일단 알 수가 있는 거예요 하지만 암 같은 경우에는 꽤 의미가 있는, 꽤 차이가 있다고 합니다. 저도 테스트는 안해봤지만 뭐 이렇다고 합니다. 그래가지고 결국에는 여기서 이제 알 수 있었던 것은 일반적인 이런 아토믹이 아닌 그런 값들을 막 써가지고 얘네들을 동시에 접근하는 건 문제가 되지만 최소한 , 이렇게, 원자성이 보장이 되는 아토믹 타입을 이용해가지고 그 다음에 여기에다가 정책을 잘 설정을 해주고 하면은 우리가 처음에 문제가 되었던 그런 가시성 문제라거나 아니면 재배치 문제가 절로 해결이 된다는 걸 일단 알 수가 있었던 거죠 굉장히 허무하지만 , 사실, 우리가 이제까지 캐시랑 파이플라인이랑 그리고 요런 메모리 정책에 대해서 알아봤는데 이걸 , 사실, 아나 모르나 그냥 기본 상태로만 사용을 했어도 결국에는 아무 차이 없이 똑같이 잘 동작한다는 걸 일단 알 수가 있었던 겁니다 조금 허무할 수 있는데 뭐 이런 부분들에 대해서 , 일단은, 뭐 알기는 알아야 되겠죠 참고로 저 예전에 NC에 지원을 할 때 이 아토믹의 메모리 모델에 대해서 일단 질문이 나온 적이 있었어요 그래가지고 뭐 이것도 가끔 중요하게 생각하시는 분들이 있기 때문에 이런 것도 , 일단은, 알면 된다는 뭐 그런 얘기가 되겠습니다 그리고 마지막으로 참고삼아 하나만 더 말씀을 드리자면 , 이렇게, 절취선을 긋고 하는 그런 걸 하고 싶을 때 반드시 이 Atomic 클래스를 이용해서 해야 되느냐? 그거는 또 아닙니다. 이런 게 원래 Atomic 클래스에 원래 들어가는 그런 기능이라기보다는 애당초 이게 메모리 베리어라는 기능 자체를 CPU에서 지원을 합니다. 그래가지고 역시나 C++ 표준에서도 이런 거를 똑같이 할 수 있는 방법들이 여러 가지가 있는데 예를 들면은 이런 걸 이제 아토믹 타입으로 만들지 않고 절제선을 쫙 긋고 싶다고 하면은 뭐 이런 식으로 아토믹 스레드 펜스라는 뭐 이런 걸 , 일단은, 여기에 만들어 줄 수가 있어요 얘네들도 , 일단은, 뭐 정책 메모리 정책을 정해주는데 뭐 예를 들면은 여기서 우리가 뭐 릴리스로 하고 싶다고 하면은 뭐 얘를 이런 식으로 골라줄 수가 있다는 얘기가 되는 거죠 그래가지고 여기서도 이제 마찬가지로 똑같은 의미입니다. 우리가 아까 얘기했던 이 스토어랑 로드를 할 때 동작하는 그런 메모리 정책이랑 똑같이 이제 동작을 해가지고 , 자, 예를 들면은 만약에 우리가 여기서 펜스를 두 개를 뾰롱 만들어주는데 하나는 릴리스로 만들어주고 하나는 어퀴어로 만들어주면은 아까랑 마찬가지로 메모리 가시성을 강제로 보장을 해줄 뿐더러 메모리 재배치를 금지하는 그런 효과를 낳게 됩니다. 그래가지고 여기 릴리스 이전에 , 이렇게, 일어났던 모든 행동들이 여기 acquire fence 이후에 다 가시성이 보장이 된다라는 특징이 생기는 거라고 보시면 되겠어요 근데 물론 이것도 이제 뭐 이런 기능이 있다는 건 일단 참고서를 말씀드리는 거지만 이걸 우리가 실전에서 굳이 사용할 일은 없습니다 왜냐면 애당초 , 이렇게, 아토믹 클래스를 이용해가지고 요런 부분을 사용할 때 얘가 간접적으로 같이 포함이 되어 있기 때문에 펜스를 굳이 직접 만들고 나머지 애들을 뭐 아토믹을 제외한 채로 만들 상황은 거의 발생하지 않을 거예요 네 그래서 오늘의 결론은 , 이렇게, 메모리 정책이 여러 개가 있다는 걸 , 일단은, 알 수가 있었고 이제 앞으로는 어차피 제 경우에는 인텔이나 AMD 칩을 이용하고 있기 때문에 CPU를 이용하기 때문에 그냥 첫 번째 버전 가장 일관적으로 코드 재배치도 해결해주고 가시성 문제도 해결해주는 이 엄격한 버전으로 , 일단은, 그냥 냅두고 호출을 해주게 될 겁니다 이게 , 일단은, 오늘의 결론이었어요 , 이렇게, 해가지고 조금 아리덜송하고 머리가 헷갈리는 내용이긴 하지만 메모리 모델, 메모리 정책에 대한 내용을 일단 , 이렇게, 마치도록 하겠습니다.