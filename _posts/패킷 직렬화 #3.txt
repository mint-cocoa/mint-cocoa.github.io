자, 이렇게, 지난 시간까지 버퍼에 있는 내용을 복사해 가지고 꺼내 쓰는 방식이 아니라 그냥 버퍼에 있는 내용을 그대로 다른 관점으로 얘를 , 이렇게, 살펴보는 방식으로 리인터플레이 캐스트를 한 상태에서 그대로 데이터를 사용하는 방식으로 일단 수정을 해봤습니다 그래서 결국에는 불필요한 복사를 한번 아낄 수 있었다 라는 그런 장점에 대해서 알아봤었구요 하지만 반대로 쓰는 쪽에서도 이제 이런 똑같은 방식으로 굳이 중간 단계를 만들지 않고 막바로 버퍼에다가 집어 넣는 그런 실습을 이어가지고 대칭적으로 한번 해보도록 할게요 우리가 서버 패킷 핸들러에서 작업을 하긴 할 건데 지난 시간에 작업했던 요 클라이언트 패킷 핸들러에 있는 일부 기능들을 , 일단은, 복붙을 하고 시작을 하도록 하겠습니다 , 일단은, 요 패킷 이터레이터 요 부분 패킷 이터레이터랑 패킷 리스트까지 얘네들을 , 일단은, 싹 긁어가지고 컨트롤 C 그 다음에 패킷 서버 패킷 핸들러 쪽에다가 , 일단은, 복사를 하고 시작을 하도록 할게요 물론 이제 나중에 가면 요런 코드들은 자동화 처리를 할 거니까 뭐 , 이렇게, 매버마다 복붙을 하진 않겠지만 일단 한 번은 요렇게 위치를 시켜 놓도록 해야 되겠죠 , 자, 그리고 이어가지고 클라이언트 패킷 핸들러 cpp 에다가 우리가 잠시 넣어놨던 요 struct packet-st 테스트라는 요 아이도 마찬가지로 긁어가지고 역시나 마찬가지로 서버 패킹 핸들러 쪽에다가 , 일단은, 복붙을 하고 여기서 일단 작업을 해보도록 할게요. 이것도 역시나 PDL에 있는 이 내용을 토대로 원래는 이제 자동화 처리를 해야 되는 부분이긴 합니다. , 자, 근데 , 일단은, 간단한 간단하게 하기 위해서 , 이렇게, 만들어 볼 거고 참고로 이제 이 Make S 테스트라는 애는 더 이상 사용을 하지 않을 것이기 때문에 그냥 얘를 쿨하게 날려주셔도 되겠습니다. 그래서 여기부터 , 일단은, 작업을 시작을 해보도록 할게요. 지금 요런 상태입니다. 버프 데이터도 , 일단은, 필요 없으니까 삭제를 하고 여기서 , 일단은, 작업을 해보도록 하겠습니다. , 자, 그러면 여기서 뭐 벨리데이트 하는 부분은 딱히 필요가 없구요 벨리데이트는 받는 쪽에서 하는 것이기 때문에 보내는 쪽에서는 딱히 이걸 할 필요가 없고 , 자, 그 다음에 요 부분도 , 일단은, 잠시 삭제를 하고 , 일단은, 이게 우리의 패킷의 정의였었죠 여기까지 , 자, 이걸 토대로 , 일단은, 만들어 볼 것인데 먼저 쓰기 위해서 class packet-stest-write 라는 클래스를 하나를 , 이렇게, 만들어 주도록 하겠습니다 얘는 말 그대로 여기 있는 정보 자체를 나타내는 것이고 여기다가 추가적으로 임시로 들고 있는 정보가 필요할 수 있기 때문에 , 이렇게, 별도의 클래스로 , 일단은, 만들어 주도록 하겠습니다 , 자, 그리고 뭐 여기서 이제 추가적으로 여기 getBufferList도 그냥 필요 없으니까 날리고 그냥 요 정보들만 , 일단은, 사용을 하도록 할게요 struct의 정의라 이거죠 , 자, 그리고 여기 bufferList라는 아이는 패킷 S 테스트 라이트 쪽으로 , 일단은, 긁어서 여기서 , 일단은, 사용을 하도록 하겠습니다. 요런 느낌으로 , 자, 그리고 버프 리스트도 있었지만 버프 리스트 아이템도 유징으로 , 일단은, 정의해서 좀 편하게 사용을 하도록 할게요. 에스트 테스트의 버프 리스트 아이템이라는 걸 우리가 그냥 편하게 버프 리스트 아이템이라고 부르겠다라고 하고 있는 거고요. 여기다가는 , 일단은, 여러가지 정보를 들고 있을 건데 에스트 테스트형 포인터 패킷이라고 할 것이고 샌드 버퍼 래프 샌드 버퍼 그리고 버퍼 라이터를 각각 , 이렇게, 내부적으로 들고 있어서 좀 편하게 사용을 하도록 하겠습니다 어... 그리고 버퍼리더랑 버퍼라이터 헤더를 잠시 긁어가지고 , 자, 이거 우리가 원래 cpp에서는 넣어놨는데 지금 이제 헤더 쪽에서 얘를 잠시 사용해야 되기 때문에 헤더에다가 , 이렇게, 복사를 하도록 할게요 뭐 얘를 왜 굳이 헤더 파일에다가 만드느냐 우리가 지금 서버 쪽에서는 우리 패킷 보내는 걸 사용하는 쪽이 여기 게임 서버 내부에서 여기서 사용을 하고 있었기 때문에 얘를 이제 헤더 쪽에다가 그냥 배치를 한 거고 별다른 이유는 없습니다 그냥 테스트 차원에서 , 이렇게, 간단하게 만들고 있는 거예요 , 자, 그러면은 얘는 도대체 어떤 역할을 하는 것이냐 먼저 그냥 뭐 사용 예제로 한번 살펴보시면 굉장히 간단합니다 , 일단은, 먼저 고정 부분을 하나씩 하나씩 다 받아 줄 거에요 우리 같은 경우에는 유인트 64 아이디 HP 그리고 Attack까지가 , 일단은, 고정적인 크기의 부분이었었죠 그래서 요 부분 , 일단은, 먼저 만들어 줄 것이고 이왕 하는 거 좀 지도를 보면서 하는 게 좋으니까 클라이언트 패킷 핸들러에서 요 부분 , 일단은, 긁어가지고 일종의 지도를 그려보면서 합시다 요거를 , 일단은, 만들어 줘야 된다라는 얘기가 되는 거죠 , 자, 그래서 먼저 해볼 거는 내부에서 샌드버퍼를 여기서 그냥 오픈을 해주도록 하겠습니다. 오픈 대충 뭐 4096으로 할텐데 나중에 가면은 뭐 최대 크기로 한 패킷이 보낼 수 있는 최대 크기로 일단 맞춰주면 될 것이고 그 다음에 버퍼 라이터를 만들어가지고 좀 편하게 쓸 수 있도록 버퍼 라이터로 얘를 랩핑 해주도록 할게요. 버퍼를 꺼내줄 것이고 샌드버퍼에 얼룩사이즈를 꺼내오면 이제 이 버퍼라이터를 통해 가지고 편하게 쓸 수 있는 준비가 되는 거죠 , 자, 그 다음에 먼저 이 PK-ST 테스트를 만들어 줘야 되는데 여기다가 넣어 줘야 되는데 얘 같은 경우에는 뭐 여러가지 방법이 있겠지만 bw.reserve라는 기능을 만들어뒀으니까 얘를 최대한 활용을 해보도록 합시다. s-test 크기만큼을 , 일단은, 예약을 해주겠다, 찝어주겠다라고 하면은 그 다음에 우리가 쓰고 있던 right position이 이만큼 건너뛰어서 이제 여기를 가리키고 있는 상태고 얘는 포인터로 뱉어줄 테니까 이 영역을 우리가 얘가 유지될 때까지는 자유롭게 접근을 해가지고 데이터를 써주면 되겠습니다. 그래서 우리같은 경우에 지금 뭐 예를 들면 패킷 사이즈도 있을 것이고 근데 얘는 아직 최종적으로 개선을 할 수는 없으니까 to fill 나중에 채우자라고 일단 로그를 찍어주고 그 다음에 패킷 id 같은 경우에는 stest1 즉 1번이었었죠 그리고 패킷의 id는 id이고 hp는 hp 패킷의 attack도 attack , 이렇게, 그냥 막바로 , 사실, 이 포인터라는 것 자체가 지금 버퍼에 있는 주소이기 때문에 얘를 그냥 하나씩 하나씩 다 직접적으로 쓸 수 있었죠 그 다음에 또 채워야 될 것 중에서 버퍼의 offset , 일단은, 0으로 해놓을 것이고 그 다음에 버퍼의 개수는 얼마인지는 아직 모르니까 얘네들을 이제 채워줘야 됩니다 두가지를 채워줘야 된다는 얘기가 되는거죠 , 자, 요 버퍼 개수는 이제 어떻게 될지 예상을 할 수 없지만 일단 여기까지 일단 만들어주면은 고정 부분 즉 여기까지 , 일단은, 할당이 되어주고 아직까지 나중에 또 채워야 될 내용은 일부 있기는 하지만 그래도 기본적으로 여기까지 메모리는 이제 할당을 해가지고 우리가 채운 상태가 될거에요 그럼 이제 이어가지고 가변 길이인 이 버프리스트 아이템을 채워줘야 되는데 그거는 하나의 함수를 , 이렇게, 파주도록 합시다 예를 들면은 버프 리스트를 뱉어주는 함수인데 Reserve Buff List 라고 해가지고 버프를 몇 개를 만들어 줄 것인지를 , 이렇게, 예약을 받도록 할게요 우리가 Vector나 List나 다른 STL 컨테이너 같은 경우에는 실시간으로 이런 가변 아이템을 하나씩 하나씩 추가를 할 수 있었죠 근데 요런 방식에서 그렇게 하기가 좀 애매한게 하나씩 하나씩 추가를 해가지고 여기 있는 버퍼 카운트랑 옵셋을 조절하면 되지 않을까라는 생각을 할 수 있기는 하지만 만약에 그렇게 되면은 버퍼리스트 아이템을 추가하다가 또 다른 타입의 가변 길이 아이템을 같이 섞어주게 되면은 이제 문제가 일어날 수가 있습니다 그러니까 요기까지 공간을 우리가 약간 배열 형태로 쭉 이어가지고 , 이렇게, 등장을 하고 그 다음에 뭐 다른 가변 길이 데이터가 , 이렇게, 등장하는 걸 예상하고 있는데 두 개를 섞어주게 되면은 이 중간에 이런 데이터가 껴둘 수 있기 때문에 이게 굉장히 난감해지는 거죠 그래가지고 보통 , 이렇게, 버퍼 안에다가 막바로 쓰는 경우에는 물론 이것도 방식이 여러 가지가 있지만 이런 식으로 내가 사용할 버퍼의 개수를 먼저 지정을 딱 한 상태에서 메모리를 할당하고 그 다음에 채우는 경우가 굉장히 많습니다 그래서 , 일단은, 가장 간단한 형태로 만들어 보기 위해서 , 이렇게, 내가 사용할 버퍼의 개수를 지정하는 형태로 만들어 보도록 할게요 그러면 내가 딱 몇 개를 사용하겠다고 지정을 했으면 여기서 이제 만들어 주면 되겠죠 , 자, 그러기 때문에 여기서 reserve를 해 줘 가지고 버프 리스트 아이템을 이제 리서브를 해줄건데 근데 여기서 문제는 버프 카운트 갯만큼을 내가 예약한다고 했으니까 이거를 한 번, 두 번, 세 번씩 연속해가지고 얘를 세 번 거쳐서 해주면 되긴 하겠죠? 근데 이거를 뭐 루프를 돌면서 하기보다는 여기 리서브 함수에 가가지고 어... 좀 추가적으로 만약에 여러 개를 동시에 예약을 하고 싶다고 하면은 여기다가 카운트 옵션을 둬가지고 이걸 통해가지고 그냥 막바로 한 번에 해줄 수 있게 수정을 해보도록 할게요 그러면은 여기서 사이즈오브 원래 있던 부분을 사이즈오브에다가 카운트를 곱해주는 형태로 바꿔주면 될 것이고 포지션을 증가하는 부분도 여기서 카운트를 곱해주는 형태로만 만들어주면은 나머지 부분은 뭐 별다른 차이가 없겠죠 , 자, 이렇게, 해서 서버코어를 다시 일단 빌드를 해서 얘를 사용할 준비를 끝내도록 하고 닫아주도록 하겠습니다 그러면 다시 돌아와가지고 일리서브를 할 때 버프리스트 아이템을 버프 카운트 개만큼을 예약하겠다라고 하면은 이제 이 뒷부분 여기까지 메모리가 할당이 되면서 이 시작 주소였던 이 주소로 이제 뱉어주게 될 겁니다 그럼 이제 개를 이용해가지고 우리가 사용하면 되는건데 이거를 버프리스트 아이템형 포인터라고 해가지고 First Buff List Item이라고 , 이렇게, 기억을 해주도록 할게요 얘가 첫번째 위치다 이거죠 즉 요 위치를 지금 요 변수로 관리를 하고 있는 겁니다 어 그 다음에 일단 영역을 할당해준 다음에 이제 아까 채워주지 않았던 요런 카운트나 뭐 옵셋 같은 거를 이제 채워주면 되겠죠 버프 카운트 같은 경우에는 말 그대로 버프 카운트 개 라고 했으니까 얘로 채워주면 될 것이고 그 다음에 옵셋도 채워줘야 되는데 옵셋이라는 거는 이 시작 주소를 기준으로 어 요 주소를 지금 의미를 하는 거였으니까 이 주소에서 시작 주소를 뺀 만큼이 이제 옵셋이 될 겁니다. 그러기 때문에 버프... 아이고 PKT... PKT 패킷의 버프 옵셋은 얼마이냐? 이제 계산을 해주면 될텐데 그냥 간단하게 캐스팅을 해줘가지고 FirstBuffListItem의 주소에서 유인트64로 바꿔가지고 PKT의 주소값을 서로 , 이렇게, 빼주면 되겠습니다. , 이렇게, 해서 이 두 주소값의 숫자를 유인트 64로 만들어서 정수끼리 빼줘서 상대적으로 얼마만큼의 차이가 나는지를 봐서 버퍼 옵셋에 , 이렇게, 만들어주면 된다는 얘기가 되는 거죠. 그럼 이제 정보는 다 채워졌으니까 이제 이어가지고 버프 리스트를 뱉어줄 것인데 시작 주소는 버프 리스트 아이템이고 버프 카운트키만큼이 있다라고 요렇게 뱉어주면 되겠습니다 , 자, 그래가지고 뭐 의외로 간단하게 , 일단은, 요렇게 간단 간단하게 만들어 봤는데 이제 나중에 가변 길이 데이터가 여러개가 등장하면 점점점점 어려워지긴 할 거예요 근데 1차적으로 뭐 요렇게 , 일단은, 만들어보면 통과는 될 것 같으니까 이걸 한번 실습을 해보도록 할게요. , 자, 다시 어... 게임 세션 쪽으로 아이고 여기가 아니라 어디였나요? 게임 서버 쪽에 돌아가가지고 , 자, 여기서 원래 우리가 사용하던 부분에서 이제 이거를 살짝 바꿔보자면 요 부분이죠. 이제는 패킷 s 테스트 라이트를 막바로 요렇게 만들어 준 다음에 PacketWriter라고 해서 여기다가 값을, 고정값을 먼저 일단 넣어주도록 할게요. 1001 뭐... 100 그리고 Attack은 10이라고 했었으니까 얘를 이제 그냥 그대로 넣어주면 되고 그 다음에 가변 길이, 즉 배열 같은 애들은 이런 식으로 Reserve Buff List를 해가지고 우리가 3개를 할당하겠다라고 , 이렇게, 선언을 해주면 얘가 선언과 함과 동시에 시작 주소를 이제 뱉어주게 되겠죠? 아니, Buff List를 뱉어주게 되겠죠? PKTS Test Lite의 버프리스트를 이런식으로 받아주면 되겠습니다. 얘가 사실상 시작 주소와 개수를 지금 물고 있는 상태이다 보니까 여기서 이제 데이터를 막바로 넣어주면 되겠습니다. 예를 들면 버프리스트의 0번은 우리가 101.5라고 하긴 했으니까 뭐 이런식으로 넣어주면 될 것이고 두개를 더 복붙해가지고 1번과 2번은 각각 200 300 그리고 2.3 0.7 이라고 하고 있었으니까 요런식으로 , 일단은, 채워주면 된다는 얘기가 되겠습니다 , 자, 여기까지 , 일단은, 채워준 다음에 근데 이제 여기서 끝난게 아니고 다 채웠으면 최종 버퍼 사이즈 계산을 하고 그 다음에 우리가 열어준 샌드 버퍼를 닫아줘야 되겠죠? 그러기 때문에 마지막으로 함수 하나만 더 추가해보자면 샌드 버퍼 래프를 뱉어주는데 Close & Return이라고 이제 닫아주고 버퍼를 리턴하겠다는 의미로 하나를 만들어 주도록 할게요 그럼 먼저 패키지 사이즈를 최종 계산을 해주면 될텐데 패킷의 패키지 사이즈는 얼마얼마이냐? BW야 지금까지 쓴 라이트 사이즈가 패킷 사이즈가 될 것이고 그 다음에 샌드 버퍼를 클로즈를 해줘야 되겠죠? 얘도 마찬가지로 BW.LIGHT 사이즈만큼을 우리가 썼으니까 이만큼을 썼으니까 닫을 때도 우리가 쓴 만큼을 덧내줘서 닫아준 다음에 샌드 버퍼를 , 이렇게, 뱉어주면 되겠습니다. 그러면 이제 사용하는 쪽에서도 마찬가지로 샌드 버퍼를 갖고 올 때 이런 식으로 해주면 되겠죠 샌드 버퍼 랩프를 갖고 올 때 PKT 라이터에서 클롯 앤 리턴을 해가지고 내가 사용한 데이터를 사실상 다 썼다고 하면 여기서 사이즈 계산과 샌드 버퍼를 닫아주고 얘를 끄집어와서 브로드 캐스팅을 해주면 된다고 보면 되겠습니다 그러면 아까와는 가장 달랐던 부분은 임시적으로 벡터를 만들어가지고 임시값을 만들어가지고 그거를 건네준 다음에 채워주는 게 아니라 이제는 우리가 막바로 할당한 이 버퍼 공간에다가 지금 데이터를 바로 막바로 밀어주고 있다는 게 굉장히 크게 달라지는 부분이라고 볼 수가 있겠어요 , 자, 일단은, 서버 빌드를 해가지고 문제가 없는지 테스트를 할 것이고 뭐 여기 이런 부분은 캐스팅 문제인데 유인트 16에다가 넣어주는 주니까 뭐 조심해라 이런 부분인데 이거는 딱히 뭐 지금은 딱히 챙기지 않고 그냥 넘어가도록 하겠습니다 , 자, 이렇게, 해가지고 만약에 정상적으로 뭐 잘 실행이 된다고 치면은 기존과 마찬가지로 클라이언트 로그가 정상적으로 잘 뜨게 되겠죠 이런 식으로 잘 뜨고 있습니다 버퍼 인포 뭐 이런 식으로 100 200 300 , 자, 그러기 때문에 결국에는 리드 할 때도 버퍼에 있는 내용을 바로 쓸 수 있었던 것과 마찬가지로 버퍼를 처음에 만들어서 쓰는 입장에서도 정말 이런 식으로 버퍼를 할당하자마자 바로 쓸 수 있다라는 결론을 얻을 수가 있는 거죠 하지만 역시나 굉장히 좀 찝찝한 부분은 처음부터 , 이렇게, 버퍼의 크기를 먼저 할당해가지고 그 크기만큼만 사용할 수 있는 게 좀 굉장히 아쉬운 부분이기는 해요 그래서 이게 만약에 이런 식으로 버퍼가 하나만 있는 게 아니라 이런 가변 길이가 하나만 있는 거 아니라 이제 다중으로 등장한다고 가정해볼게요 오늘도 이제 이 부분을 같이 한번 처리를 해볼 건데 지금까지 이 부분까지는 잘 처리가 되었는데 이제는 PDL이 만약에 조금 입장을 바꿔가지고 여기에 추가적으로 가변 길이가 하나가 더 있다고 가정해봅시다 리스트 안에 리스트가 있다 예를 들면은 뭐 좀 현실적이지는 않지만 우리가 버퍼리스트를 건네주면서 지금까지 이 버퍼에 의해가지고 뭔가 피해를 입은 유저들의 목록을, 유저 아이디를 뭐 건네주는 그런 컨텐츠가 있다고 가정해볼게요. 딱히 왜그럴진 모르겠지만 유저 아이디를 , 이렇게, 건네준다고 합시다. 타입은 유인트64 뭐 이런 느낌으로 , 자, 그러면 이제는 리스트 안에 또 리스트가 이중으로 들어간 거죠 그럼 이제 머리가 조금 더 골치가 아파지기 시작합니다 , 자, 이걸 이제 과연 어떻게 처리를 해야 될 것인가 그래서 이제 이 부분을 한번 처리를 해보는 실습을 하면서 지금 우리가 사용하고 있는 요 버퍼에다가 바로 밀어 넣는 방식의 단점에 대해서 한번 의논을 해보도록 하겠습니다 그러면 , 일단은, 지금까지와 마찬가지로 , 일단은, 이제 PKS 테스트에서 여기 struct buffer list item 이라는 아이 자체가 원래는 , 이렇게, 고정값 두 개만 들고 있었지만 이제는 사실상 여기서 추가적으로 어떤 가변 길이의 리스트가 생기게 된 셈이 되는 거죠 근데 우리가 지금까지 여기서 사용하던 정책을 보면은 가변 길이의 데이터와 고정 길이의 데이터를 같이 섞어주지 않는다고 했었죠 뭔가 리스트가 등장할 때는 그냥 리스트의 헤더만 여기다가 넣어주고 뒷부분에다가 이어서 붙인다고 했으니까 똑같은 방법으로 버퍼리스트 아이템에다가 여기서도 피해자 목록 빅팀 리스트라고 해가지고 유인트 16으로 빅팀옵셋이라고 하고 그 다음에 빅팀스 카운트라고 해가지고 그 리스트의 개수를 한번 추가를 해보도록 할게요 그래서 실질적으로 여기서 이제 관련 피해자에 대한 정보와 아이디들이 여기서 이제 막 뒤로 막 추가가 되겠죠 각각에 대해서 , 자, 요런 느낌으로 이제 , 이렇게, 쭉 이어지게 될겁니다 그러면은 어... 이제 요 부분이 이제 추가가 됨으로써 조금 작업하는게 조금 더 복잡해질 수 밖에 없는데 , 자, 이거를 이제 어떻게 한번 작업해볼거냐면은 여기서 , 일단은, 새로 하나를 추가를 해주도록 할게요 버프 빅팀스 리스트 패킷 리스트에 얘는 이제 유인트 64만 넣어주면 되니까 그냥 유인트 64로 그냥 바로 처리를 해주도록 할게요 굳이 새로운 스트럭트를 만들어주지 않고 , 자, 이렇게, 해가지고 요 부분까지는 , 일단은, 완료가 됐고 그러면은 이제 요 부분에서 지금까지 우리가 만든 요 부분은 똑같지만 그 다음에 이제 리서브 버프 리스트를 하는 순간에 요기서 이제 데이터가 몇 개가 사실상 더 늘어나게 된 거죠 이 버프 리스트 아이템이 4바이트가 더 늘어났으니까 요 부분이 , 일단은, 더 커지게 될 것이고 그 다음에 추가적으로 버프 빅팀 리스트를 추천할 것인데 얘는 reserve 버프의 빅팀 리스트라고 , 일단은, 이름을 지어보도록 합시다 그래서 버프 리스트 아이템의 포인터를 , 일단은, 받아줄 것이고 그 다음에 여기서도 마찬가지로 빅팀의 카운트 몇 명의 피해자가 있느냐를 인자로 받아준 다음에 , 사실, 여기랑 똑같은 작업을 이제 해보는 거예요 그래서 유인트 64 포인터로 첫번째 빅팀 리스트 아이템은 무엇이냐 bw.reserve를 해줘가지고 얘는 그냥 유인트 64만 있으면 되니까 요렇게 할당을 해줄 것이고 빅팀 카운트 갭만큼을 이어서 할당해주겠다라는게 되는거죠 즉 여기서 추가적으로 빅팀을 몇개 몇개 할당을 하겠다라고 이때 뒤에서 오려붙이는 셈이 되겠습니다 그 부분이 여기 이제 들어가는 거고 그 다음에 버퍼 아이템에 빅팀 카운트는 말 그대로 빅팀 카운트니까 얘를 그대로 넣어주면 될 것이고 그리고 또 하나를 더 채워줘야 되죠 빅팀 옵셋 같은 경우에는 그럼 이제 얼마가 되는 것이냐 얘도 마찬가지로 요 아이가 지금 할당된 첫번째 주소이다 보니까 주소 계산을 여기와 마찬가지로 그대로 해주면 되겠죠 이 코드를 복붙해가지고 요 아이만 , 이렇게, 바꿔치기를 해주면 바꿔치기를 해주면 이 옵셋도 정상적으로 이제 들어가게 될 것이고 그 다음에 최종적으로 버프 빅팀스 리스트를 뱉어줄건데 시작 주소에서 카운트 갭만큼을 뱉어줘서 리스트를 만들어가지고 이제 사용하라고 떠넘겨주면 되겠습니다 그러면 뭐 나머지 부분은 딱히 안 고쳐줘도 , 일단은, 될 것인데 어... 이제 사용하는 쪽에서는 이제 조금 더 복잡해지는게 뭐냐면은 먼저 버퍼리스트를 , 자, 이걸 만드는 순서를 잘 보면은 , 이렇게, 된거죠 지금 요걸 긁어가지고 살펴보면은 원래는 여기서 여기까지만 , 일단은, 만들어 준거구요 그 다음에 버퍼리스트 3개를 여기서 이제 추가적으로 요렇게 할당을 한 상태가 되는 거고 그 다음에 하나 하나 하나씩 순회하면서 뒤에서 자기가 포함하고 있는 그 가변 길이의 데이터를 또 이제 만들어줘야 됩니다 그러기 때문에 여기서 뭐 예를 들면 지금 요 부분까지 채워주는 건 그렇다 치더라도 추가적으로 버퍼리스트 0번에 대해서 아이고 버프리스트라고 했네요 버프리스트 0번에 대해서 이제 데이터를 또 만들어줘야 되니까 뭐 pketwriter.reserveperfvictimlist를 호출한 다음에 요 주소를 여기다가 넣어주면 되겠죠 이런 식으로 0번에 대해서 뭐 데이터를 3개를 만들어주겠다 라고 해가지고 받아줄 때는 pkstestwrite에 perfvictimlist라는 리스트로 받아주게 될 겁니다 이거를 뭐 빅... 빅 제로라 갈게요 0번째 아이의 피해자 목록이다 그래가지고 좀 영역을 집어가지고 정리를 해보자면 여기서 이제 마찬가지로 0번째 데이터는 1000으로 설정하고 이런식으로 하나씩 데이터를 밀어넣어주면 되겠습니다 1000번, 2000번, 3000번 유저가 피해를 입었다 라는 식으로 그 다음에 두개를 더 만들어 줘가지고 1번에 대해서도 똑같이 만들어 줄건데 뭐 1번 버프는 피해자가 한 명밖에 없다라고 , 일단은, 가정할 수가 있겠죠 뭐 예를 들면 이런 식으로 그 다음에 마지막은 2번은 그냥 두 개로 만들어 주도록 할게요 1, 2 숫자를 덮어 쓰지 않게 조심조심 하면서 그리고 얘는 뭐 그냥 아무 값이나 뭐 , 이렇게, 대충 만들어 보도록 하겠습니다 , 자, 그래서 요렇게 , 일단은, 게임 서버를 다시 한번 빌드를 해보면 별다른 문제가 없이 , 일단은, 통과가 된다는 걸 볼 수가 있구요 그래서 데이터를 만약에 중첩해가지고 리스트 안에서 리스트를 활용할 거라고 하면은 뭐 이런 식으로 만들어 줄 수 있다라는 얘기가 되는 거죠 물론 이거를 조금 더 사용하기 편하게 관리하고 싶다고 하면은 요런 식으로 PacketRightHeader 클래스에서 모든 애들을 다 관리하지 않고 요 ReserveBuffVictimList를 어떻게든 잘 만들어서 여기 안에서 관리할 수 있게끔 만들어주는게 조금 편하긴 하겠죠 그렇게 해야지만 인자를 넣어주는 대신 버프리스트 0번에 점 리저브 이런식으로 하는게 좀 더 편할테니까 뭐 이건 , 사실, 여러가지 방식으로 만들 수 있다라는 얘기를 하는거고 그래도 어찌됐건 여기서 이제 봐야될 부분은 뭐냐면 이 코드가 좀 어떤가요? 여러분들은 어떻게 느끼실지 모르겠는데 결국에는 뒤에서 새로운 내용을 동적으로 , 이렇게, 추가를 해야 되다 보니까 , 이렇게, 매번 마다 리스트를 사용하기 전에 그 영역을 한번 찝어주는 리서브가 반드시 들어가게 됩니다 근데 이제 요 부분 같은 게 굉장히 실수의 여지가 일단 높다는 문제가 있어요 그래가지고 만약에 우리가 , 이렇게, 데이터를 사용하기 전에 리서브를 빼먹다거나 빼먹는다거나 하면은 , 사실, 굉장히 엉뚱하게 동작을 할 수도 있고 이 코드 자체가 만드는 것도 심지어 직관적이지 않다는 걸 볼 수 있는 거죠 나중에 가면은 경우에 따라서 , 이렇게, 가변 데이터가 하나만 있는 게 아니라 진짜로 가변 데이터 안에 가변 데이터 안에 가변 데이터가 막 들어갈 수도 있고 한데 이런 식으로 지금 관리를 하다 보면은 작업할 때 패킷을 만들 때 굉장히 고통을 받을 수가 있다는 얘기가 되겠습니다 그래서 전에 일하던 프로젝트에서도 효율성을 많이 따져가지고 버퍼 안에다가 이런식으로 데이터를 바로 밀어넣는 방식으로 , 일단은, 이 serialize 코드를 만들어 놨는데 사람들이 하도 어려워 해가지고 나중에 나중에 가가지고는 그냥 그거를 전체를 다 프로토버프로 다 교체하는 작업을 했었습니다 뭐 그런 기억이 있어요 , 자, 그래가지고 어찌됐건 요 방법의 장점에 대해서는 일단 이해를 해야 되겠죠 확실히 데이터를 바로 밀어넣는 작업이다 라는 건 장점이긴 하지만 사용할 때 굉장히 불편하다라는 단점도 생긴다는 걸 꼭 기억을 해주시면 되겠습니다 결국에는 구글에서 만들어준 굉장히 유명한 라이브러리 중에서 FlatBuffer라는 게 , 사실, 이런 식으로 직접적으로 버퍼에다가 데이터를 밀어넣고 꺼내는 식으로 한다고 했으니까 당연히 성능은 훨씬 더 좋을 수밖에 없지만 복사 비용이 없으니까 한 번 줄어드니까 훨씬 더 성능 좋겠지만 사용하는 게 훨씬 더 지저분하다는 것도 공통적으로 들어갑니다 나중에 언젠가 플랫 버퍼를 사용하실 일이 있으면 이런 느낌을 보게 되실 거예요 반면 프로토버프는 이런 식으로 실시간으로 리접해서 밀어넣는 방식이 아니다 보니까 훨씬 더 작업하는 게 깔끔합니다 하지만 중간에 복사하는 과정이 한 번 더 들어가는 건 어쩔 수 없다는 거죠 중간 그런 객체를 만들어가지고 거기다가 데이터를 채워넣고 그 데이터를 토대로 한 번에 내가 할당해야 될 버퍼 사이즈를 계산해가지고 그 다음에 데이터를 복사해서 밀어넣는 방식이기 때문에 컨텐츠 제작 입장에서 작업하기는 훨씬 편하다라는 결론을 얻을 수가 있는 겁니다 , 자, 그건 그렇고 이제 이거 뭐 이 내용은 오늘 여기서 끝내긴 할 건데 마지막으로 이제 파싱하는 테스트도 해보기 위해서 클라이언트 쪽에서도 똑같이 대칭적으로 요 해당 부분을 이제 긁어올 수 있도록 한번 얘도 똑같이 작업을 해볼게요 , 자, 클라이언트 패킷 핸들러 오랜만에 다시 와 가지고 요 부분을 살펴보면 이제는 얘도 마찬가지로 여기 가변 데이터와 관련된 헤더가 추가가 되어야 되겠죠 그래서 빅팀옵셋 이라는 애랑 그 다음에 빅팀스 카운트라는 애 이 두 아이가 추가가 되어야지만 정상적으로 이제 데이터를 긁어올 수가 있을 거예요 , 자, 그리고 여기서 이제 벨리데이션 코드가 살짝 뭐 바뀌어야 되겠죠 여기서 사이즈가 딱 여기까지만 끝나는 게 아니라 지금 이 그림을 보면 여기다가 추가적으로 주렁주렁 빅팀과 관련된 정보들이 막 뒤에서 추가가 될 테니까 계산하는 부분식이 조금 바뀌어야 됩니다 그래서 여기서 지금 살펴보면 먼저 패킷 사이즈만큼을 확보한 다음에 그 다음에 바로 이 버퍼의 영역까지 지금 확보가 되었으면 최종 계산을 하고 있는데 요 부분을 이제 수정해야 되겠죠 먼저 옵셋 계산을 일단 위로 올려가지고 옵셋만큼을 , 일단은, 안전하게 확보를 한 다음에 그 다음에 버퍼의 가변 데이터 크기를 , 일단은, 추가를 해보도록 할 것이고 그게 이 부분이죠 요렇게 근데 여기서 바로 사이즈 계산을 하지 않고 이거는 최종 크기 비교니까 맨 마지막에 일단 해줄 겁니다 최종 크기 비교 그러면 이제 추가가 돼야 되는 거는 우리가 추가적인 나머지 가변 데이터에 대한 정보들도 넣어줘야 되니까 예를 들면은 우리 같은 경우에는 이 get 버프 리스트를 이제 활용하면 되겠죠 버프 리스트를 , 일단은, 꺼내가지고 , 자, 이런 식으로 버프리스트를 꺼낸 다음에, 에고, get 버프리스트. , 자, 그 다음에 하나씩 스뇌를 하면서 버프리스트의 개수만큼을 하나씩 스뇌를 하면서, 에고 이게 자동 완성이 됐네요. 그 다음에 이제 요 버프리스트에 있는 각 아이템이, 즉 요 아이가 버프리스트에 아이템 자체가 유효한지를 체크해주면 되겠습니다 그래서 여기다가 안에다가 막바로 validate함수를 여기다가 일단 넣어주도록 할게요 얘가 하는 역할은 , 일단은, 패킷 시작주소 패킷 스타트를 받아줄 것이고 즉 요 아이를 받아줄 것이고 그 다음에 패킷 사이즈 최종 패킷 사이즈를 받아줄 것이고 그 다음에 지금까지 작업하고 있는 이 사이즈도 받아가지고 겸사겸사 얘가 내부적으로 밸리데이션 체크를 한 다음에 사이즈도 같이 증가시켜주는 형태로 작업을 해보도록 할게요. 그럼 먼저 얘가 체크해야 될 거는 이제 이 offset이 정상적인지를 먼저 체크해주면 되겠죠 즉 얘가 지금 자기가 주장하고 있는 요 카운트랑 offset이라는 게 있을 텐데 요 offset은 요 시작 주소를 가리킬 거고 시작 주소를 기준으로 빅팀 카운트가 몇 개 몇 개 있다라고 지금 얘가 주장을 하고 있으니까 이런 식으로 만들어주면 되겠습니다 빅팀 offset 기준으로 빅팀 카운트 곱하기 사이즈오브 유인트 64만큼을 더했더니 그게 최종 패킷 사이즈를 넘어간다라고 하면은 뭔가 문제가 있는 상황이니까 return false를 때려줄 것이고 그게 아니라고 하면은 뭐 , 일단은, 정상적인 상황으로 인지를 할 수 있으니까 빅팀 카운트 곱하기 사이즈오브 유인트 64를 더해준 다음에 return true를 , 이렇게, 때려주면은 뭐 대략적으로 요 아이가 유효한지를 이제 뭐 체크할 수 있을 겁니다 물론 나중에 이걸 정밀히 봐가지고 구멍이 없는지는 체크해야 되겠지만 대략적으로 요런 느낌으로 체크하면 된다라는 , 일단은, 뭐 얘기를 하고 있는 거예요 그래서 여기서 이제 버프리스트에 벨리데이트를 한 다음에 자기 자신의 디스포인터를 바이트로 전환해서 넘겨줄 것이고 패키지 사이즈와 그 다음에 사이즈 자체를 요렇게 각각 각각 넘겨줘가지고 얘가 만약에 실패했다 false였다고 하면은 뭐 중간에 validation 체크가 실패한 거니까 false를 때려줄 것이고 그게 아니라고 한다면은 요 사이즈도 이제 같이 늘어나게 되어가지고 요 가변 길이에 대한 사이즈가 이제 계속 개선이 될 겁니다 뭐 요런 느낌으로 , 일단은, 만들어줄 수가 있을 거예요 만약에 이 벨리 데이트 내부에서 사실상 얘가 사용하고 있던 이 가변 길이 데이터에서도 또 가변 길이 데이터가 있었다고 하면은 벨리 데이트 안에서 또 벨리 데이터를 호출하고 이런 식으로 이제 물고 물고 놀아가지고 계속 자기가 담당하는 애의 크기를 계속 확인하는 식으로 뭔가 , 이렇게, 재규적으로 만들어 주면 되겠습니다. , 자, 그래서 뭐 요렇게 , 일단은, 만들어주면은 버퍼 크기 체크까지 정성적으로 완료가 된 다음에 최종 크기를 비교하는 부분이 이제 , 이렇게, 들어가게 될 것이고 얘를 이제 사용할 때는 뭐 요렇게 사용하면 되겠죠 버프 빅팀 리스트를 예를 들면 패킷 리스트에 유인트 64로 소문자 만들어 준 다음에 get 버퍼 리스트는 요 아이였고 이제 추가적으로 버프 빅팀 리스트를 꺼낼 때는 버프 빅팀 리스트에 리스트 아이템의 포인터에서 얘를 넣어주게 되면은 해당하는 그 빅팀을 꺼내주도록 뭔가 만들어주면 되겠습니다 즉 요 코드랑 굉장히 유사하게 만들어주면 되는데 , 자, 요렇게 일단 넣어주도록 할게요 데이터가 시작 주소였고 여기다가 버프 아이템의 빅팀 옵셋만큼을 더해줄 것이고 그 다음에 그거를 리스트로 만들어가지고 버프 빅팀 리스트로 바꿔줄 것인데 re-interpret 캐스트를 한 다음에 유인트64 포인터로 데이터를 바꾸고 그 다음에 버프 아이템의 카운트 갭만큼을 , 이렇게, 만들어주면 요 리스트가 이제 추출이 될 겁니다 물론 꼭 여기도 마찬가지로 P-CAN S 테스트 안에서 모든 접근함수를 다 넣어줄 필요는 없고 이걸 조금 더 편하게 사용할 수 있다고 하면 다른 방식으로 만들어도 상관없지만 대략적으로 이런 식으로 리스트를 추출해서 꺼낼 수 있게 만들어주면 된다고 보시면 되겠습니다. 그래서 이 정보도 접근할 수 있고 그 다음에 이 정보들도 이런 식으로 이 정보의 데이터를 또 참고해서 , 이렇게, 넘어가는 식으로 , 일단은, 만들어주면 되겠어요. , 자, 그럼 최종적으로 얘가 정상적으로 파칭이 되는지 너무 궁금하니까 한번 사용을 해보자면 , 자, 벨리데이션 체크까지는 끝났구요 그 다음에 버프 리스트를 꺼냈는데 , 자, 일단은, 3개로 다 만들 필요는 없으니까 , 일단은, 그냥 하나만 냅두도록 하겠습니다 요런 식으로 그래서 버프 인포를 추출한 다음에 여기서 패킷에 get-buff-victim-list를 이용해가지고 요 버프의 조속값을 넘겨주게 되면 얘가 굉장히 재미있게도 pks-test-buff-victim-list로 튀어나오게 되겠죠 얘가 이제 피해자 목록이다 라고 볼 수 있는 거고 그러면 얘를 로그를 찍어 보도록 할게요 victimCount는 얼마 얼마이다 victims.count 그리고 endline 그 다음에 여기서 역시나 한 번 더 루프를 돌면서 최종적으로 피해자는 누구누구였는지 빅팀은 누구누구이다라고 , 이렇게, 로그를 찍어 보도록 하겠습니다 그래서 정상적으로 우리가 보낸 요 데이터들이 잘 출력이 되는지만 확인을 하면 되겠죠 , 자, 그래서 , 일단은, 뿅 실행을 해 보도록 할게요 그러면 역시나 정상적으로 모든 데이터가 잘 들어오고 있다는 걸 , 일단은, 볼 수가 있습니다 , 자, 이렇게, 해가지고 사실은 앞으로 우리가 실제로 클라스 서버 연동을 할 때 이 방식으로는 , 일단은, 하지 않을 거예요 왜냐하면 제가 이 방식을 별로 좋아하지 않기 때문이죠 하지만 그래도 여러 가지 기술의 장단점에 대해서는 이해를 하는 게 굉장히 중요하니까 오늘 한 실습을 통해 가지고 버퍼에다가 바로 데이터를 밀어넣고 꺼내는 방법도 존재하고 그 방법의 장단점에 대해서도 , 일단은, 숙지를 해주시면 좋을 것 같아요 , 이렇게, 일단은, 바로 밀어넣는다 심지어 이런걸 매번마다 만들진 않을 것이고 역시나 이 pdl을 통해 가지고 자동으로 이런 함수들이나 기능들이 다 만들어지게끔 우리가 유도를 해줘야 되는데 이것도 은근히 좀 까다롭긴 합니다. 그렇게 해가지고 이제 패키지 직렬화 제 3탄은 , 이렇게, 마치도록 할 것이고 이제 다음 시간부터는 무엇을 해볼 것이냐 이런 방식으로 우리가 진짜 수동으로 하나하나 만들어가지고 사용하는 게 아니라 이제 가장 유명한 구글 프로토 버퍼를 우리가 연동해가지고 그걸 이용해가지고 진짜 클라스 서버가 통신을 하는 실습을 , 일단은, 해볼 건데 오늘까지 배운 1탄, 2탄, 3탄에서 배운 이 Serialize 방법들이 가장 기본기가 되는 거고 이런 원리들을 이해하는 게 굉장히 중요하다고 한 번 더 언급을 드리도록 하겠습니다 , 자, 이렇게, 해가지고 시리얼라이즈에 대한 내용을 마치고 다음 시간부터 조금 더 재미있는 작업을 시작해보도록 할게요.