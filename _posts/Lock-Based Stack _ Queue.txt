자, 이제 이어서 이번 시간에는 우리가 지금까지 배운 내용들을 살짝 복습하는 그런 느낌으로 그냥 간단하게 락 기반의 스택이랑 큐를 그러니까 일반적으로 우리가 자주 활용하는 그런 자료 구조를 하나를 만들어 볼 겁니다 그런데 이제 뭐 어떤 실습을 할 거냐면 예를 들면 우리가 어떤 큐가 뭐 이런 식으로 있다고 가정을 해 볼게요 큐도 있을 거고 뭐 스택도 이런 식으로 만약에 있는 상황에서 한쪽 스레드에서는 계속 뭔가 데이터를 밀어 넣는 작업을 할 것이고 한쪽 스레드에서는 데이터를 꺼내 오는 작업을 할 겁니다. 이걸 이제 무한 루프를 돌면서 계속 뺑뺑이를 돌면서 , 이렇게, 해줄 거예요. , 일단은, 쓰레드부터 만들어 줄까요? T1은 푸쉬를 해줄 거고 그 다음에 T2는 팝을 해줄 것이고 T1.join T2.join 물론 이게 뭐 하나씩 두는 것 뿐만 아니라 푸쉬를 여러 명이 하고 팝도 여러 명이 할 수 있고 , 이렇게, 여럿 여럿이 등장할 수도 있습니다 근데 여기서 이제 하고 싶은 건 뭐냐면 결국에는 얘가 , 일단은, 랜덤한 밸류를 아무 랜덤 밸류를 하나를 , 이렇게, 추출해 볼게요 딱히 의미는 없습니다. 그냥 랜덤 밸러가 있다고 가정하고 이 상태에서 큐나 스택 둘 중 하나에다가 그 데이터를 요렇게 밀어 넣어줄 거에요. 그 다음에 대충 뭐 어느 정도 시간만큼 슬리프홀을 해가지고 뭐 대충 한 10ms를 요렇게 잠드는 방식으로 얘는 동작을 할 것이고 반대쪽에서는 이제 큐를 꺼내줄 것인데 우리가 일반적으로 사용하는 stls의 큐에서는 이걸 두 번에 나눠서 뽑아와야 되죠. 이거 큐탑이 아니라 큐니까 얘는 프런트로 해야지고 그 다음에 팝을 하고 뭐 이런식으로 일단 동작을 하게 될겁니다 뭐 이런식으로 데이터가 있겠죠 물론 여기다가 심지어 큐가 비어있는지 안비었는지를 체크해야 되니까 큐가 뭐 엠티라고 하면은 그냥 컨티뉴 때릴거고 큐가 엠티가 아니라고 하면은 데이터를 요렇게 출력을 한 다음에 뭐 간단하게 출력을 뭐 , 이렇게, 해볼겁니다 , 자, 그런데 이게 멀티스레드 환경이라고 하면은 역시나 큐던 스택이던 얘네들을 , 이렇게, 동시 접근을 할 수가 없었죠 만약에 이거를 지금 고지곳대로 , 이렇게, 실행을 해보면 뭐 당연한 얘기지만 크래시가 날겁니다 언젠가 크래시가 어 일어나게 될거에요 어 의외로 안나네요 , 자, 그러면 여기서 팝을 하나를 더 늘려보도록 합시다 t3.join까지 해서 동시에 이제 , 이렇게, 일어나는 코드들이 다시 한 번 똑같이 실행을 해보면 , 자, 이제는 확실히 클래시가 나는 걸 볼 수 있습니다 멀티스레드가 뭐 얘가 지금 슬립을 10ms로 넣어 놔가지고 경합이 좀 자주 안 일어나서 지금 클래시가 안 난 거 같은데 뭐 어쨌든 결국에는 , 이렇게, 공용으로 사용하는 데이터를 , 이렇게, 멋대로 다수의 스레드에서 접근을 하면은 문제가 일어나는 건 우리가 익히 알려봤었죠 그래가지고 뭐 당연한 얘기지만 여기다가 이제 뮤택스를 , 이렇게, 걸어가지고 사용하는 거에 대해서 쭉 알아봤습니다 물론 그렇게 해도 되긴 하지만 일반적으로 큐랑 스택은 굉장히 자주 사용할 예정이니까 이 큐 자체에다가 락을 같이 끼워 넣어서 하나의 클래스로 만들면 어떨까라는 생각이 듭니다. 특히나 게임을 만들 때는 스택보다는 큐 자료 구조를 굉장히 많이 사용하게 됩니다. 예를 들면 클라이언트 쪽에서 이런 네트워크 패킷을 보낸 것을 우리가 순차적으로 처리를 해줘야 되겠죠. 도착한 패킷을 먼저 실행해주는 게 그리 이치에 맞다 보니까 우리가 대부분 패킷이건 아니면 뭐건 거의 다 큐로 , 일단은, 묶어 가지고 처리를 해주게 될 거에요 , 자, 그런 김에 이제 이 큐에다가 뭔가 뮤택스 기능을 1 플러스 1 으로 합친 그런걸 이제 만들어 볼 겁니다 그리고 이걸 이제 클래스로 일단 하나를 만들어 볼 거구요 Concurrent Queue 라고 해가지고 말 그대로 뭔가 멀티스드 환경에서 돌아가는 Queue 다 라고 일단 이름을 지어 보도록 할게요 마찬가지로 하나를 더 만들어 줄 건데 Concurrent Stack 이라고 해가지고 스택도 마찬가지로 멀티스드 환경에서 돌아가는 스택을 만들어 볼 것이고 이제 이거를 다음 시간에 이어 가지고 계속 작업을 하게 될 겁니다 네 , 일단은, 이렇게, 만들어 봤구요 , 자, 이건 이제 뭐 복습 차원입니다 일단 스택부터 작업을 해볼 건데 , 일단은, 오늘 사용할 건 이제 뮤택스를 활용할 것이기 때문에 뮤택스를 , 이렇게, 추가해 주시면 되구요 , 자, 그 다음에 템플릿으로 , 이렇게, 만들어 주도록 하겠습니다 일단 락 기반의 스택을 하나를 만들어 줄 것이기 때문에 락 기반이라는 의미로 이름을 락 스택 이라고 지어 놨습니다 굉장히 뛰어난 작명 센스였죠 , 자, 그래가지고 이제 락을 만들어 락 스택을 만들어 줄 것인데 요게 다 이제 뭐 자료 구조를 처음부터 생으로 처음 만들어도 되고 아니면 그냥 이런 스택과 같은 이미 있는 그런 stl 에서 제공하는 컨테이너를 그냥 랩핑 해가지고 사용하는 것도 나쁘지 않습니다 그래서 스택을 사용할 것이고 락을 걸기 위해서 vtex 도 , 이렇게, 활용을 해볼 거예요 그러면 이제 여기서 락 스택을 구현을 해본다고 하면은 일단 생성자는 아무것도 안 해줄 것이고 음.. 혹시 모르니까 얘를 이제 복사하려고 하는 시도를 한다고 하면은 다 막아버리도록 합시다 딜리트 해주고 그 다음에 락스택 오퍼레이터는 뭔가 , 이렇게, 복사 연산자를 하려고 해도 응 돌아가 라고 막아주도록 할게요 그건 그렇고 이제 핵심 기능은 결국에는 여기다가 뭐 어떤 값을 푸쉬를 해주는 그런 기능이 이제 핵심적인 게겠죠 밸류를 뭔가 , 이렇게, 넣어준다고 가정하고 어 여기서 이제 뭐 우리가 할 수 있는 방법은 여러가지가 있는데 락가드를 잡아가지고 이런식으로 뮤텍스를 이용해가지고 잠금처리를 해준 다음에 그 다음에 원래 사용하던 스택에다가 데이터를 , 이렇게, 넣어줄건데 이왕이면은 std move를 이용해가지고 혹시라도 이동을 해가지고 더 빠른 연산을 할 수 있는 애들은 , 이렇게, 이동을 시켜줄 것이고 그 다음에 끝이죠? 네 이렇게만 일단 해주면 되겠네요 그 다음에 마찬가지로 이제 팝을 해주는 그런 부분도 넣어 줄 것이고 근데 원래는 이제 뭐 우리가 스택을 사용할 때 팝을 하기 전에 일단 mt 상태인지 아닌지를 체크해 가지고 우리가 mt가 아니라고 한다면 걔를 원래 일반적으로 팝을 하는 게 일반적 일 겁니다 그래서 뭐 예를 들면은 이런 식으로 스택점 mt 를 , 이렇게, 랩핑 해 가지고 얘도 , 이렇게, 체크를 할 수가 있겠죠 , 자, 그런데 , 사실, 이런 멀티 세드 환경에서는 요 mt 를 체크를 한 다음에 그 다음에 만약에 우리가 팝을 한다고 가정을 하면은 , 사실, 그게 아무런 의미가 없습니다 왜냐하면은 우리가 mt 를 체크하는 순간에는 아무런 데이터가 없었다고 치더라도 mt 를 체크해 가지고 어 뭔가 데이터가 있네라고 해가지고 팝을 하려는 순간 사실은 다른 스레드가 몰래 낑겨와가지고 먼저 선수를 쳐가지고 데이터를 꺼내올 수도 있다는 얘기되는 거죠 그래서 사실상 , 이렇게, 멀티헤더 환경에서는 이 MT라는 게 뭐 큰 의미가 없습니다 물론 정말 체크를 하고 싶은 경우가 생길 수도 있기 때문에 뭐 제공해줘도 나쁘지 않겠지만 어찌됐건 팝을 할 때 MT를 체크해가지고 비지 않은 상태를 보장해서 팝을 하는 개념이 아니라는 거죠 완전히 이제 좀 개념이 여기서 살짝 달라지기 시작합니다 그래서 팝을 할 때 진짜로 팝을 성공했는지 안했는지를 불리언으로 리턴을 하고 데이터는 요렇게 레퍼런스로 알아서 꺼내가도록 요렇게 유도를 해보도록 하겠습니다. 그럼 하는 김에 이름 자체도 그냥 트라이팝으로 바꿔주도록 할게요. 얘가 뭐 100% 확률로 데이터를 뽑아오는 건 아니니까 트라이팝을 한 다음에 불리언을 체크해가지고 진짜 데이터를 성공적으로 뽑아왔는지를 체크를 해볼 겁니다. , 자, 그럼 얘도 이제 마찬가지로 요렇게 , 일단은, 뭐 뷰텍스를 걸어줄 수가 있을 것이고 지금까지 뭐 이런건 공부하고 있었죠? 만약에 스택이 엠티라고 한다면 어? 데이터가 없네? 라고 바로 false를 리턴해주면 될 것이고 만약에 데이터가 있다고 한다면 여기서 stack.top을 이용해가지고 데이터를 꺼내오면 되겠죠 그리고 얘도 이왕이면은 데이터를 꺼내와가지고 저쪽에다 이동시키기 위해서 std move를 사용하도록 하겠습니다 꺼내왔으면 그 다음에 팝을 해주고 , 이렇게, 리턴을 트롤을 해주도록 할게요 그리고 이거는 이제 뭐 여러분들이 C++ 공부할 때 한번쯤 생각해보셨을 문제긴 하지만 C샵이나 다른 언어에서는 대부분 스택이나 큐 같은게 팝을 해가지고 데이터를 한 번에 뽑아올 수가 있는데 의외로 이상하게 C++은 왜 그렇게 만들었는지 모르겠지만 데이터를 , 이렇게, 탑을 이용해 가지고 살짝 옆 보고 그 데이터를 꺼내 온 다음에 그 다음에 팝을 , 이렇게, 하는 식으로 이루어져 있죠 근데 그 이유는 뭐냐면은 이게 좀 너무 FM 방식이긴 한데 , 이렇게, 데이터를 꺼내 와 가지고 만약에 바로 한 번에 얘를 꺼내 온다고 하면은 요 단계에서 여기다가 외부로 데이터를 꺼내 오는 순간에 혹시라도 크래쉬가 날 수 있다는 문제가 생깁니다 익셉션이 일어나는 거죠 예외가 뭐 그럴리는 거의 드물겠지만 만약에 메모리가 부족해가지고 이 복사 과정에서 익셉션이 일어난다고 하면은 요기 있는 이제 스택이나 큐같은 자료구조가 와장창 구조가 깨지기 때문에 그런 걸 막기 위해서 , 이렇게, 두 단계에 거쳐가지고 얘네들이 애덩추 얘를 꺼내쓰기 만들어 놨어요 근데 뭐 이게 씨뿔뿔이 이제 꼭 게임에서만 사용하는 건 아니니까 , 이렇게, 만들어 놨지만 , 사실, 게임에서는 진짜로 , 이렇게, 데이터를 꺼내다가 만약에 데이터가 고갈돼서 크래쉬 났다고 하면은 그냥 프로그램을 뻗게 냅두는 게 더 좋습니다. 그런 문제가 있다는 건 어차피 다른 부분에서도 결국 문제가 일어나 가지고 언젠가는 프로그램이 뻗을 것이기 때문에 굳이 이런 거를 뭐 트라이캐치로 묶어 가지고 다시 되살리고 하는 걸 할 필요 없다는 얘기가 되는 거죠. 그래가지고 실질적으로 뭐 , 이렇게, 락 스택을 우려 구현을 할 때도 뭐 굳이 이거를 익셉션 처리를 하는 게 아니라 , 이렇게, 바로 트라이팝에서 바로 한번에 꺼낼 수 있도록 , 이렇게, 일단은, 함수의 인터페이스를 구성을 해봤습니다. , 자, 이건 그렇고 그래서 결국 여기서 알 수 있었던 거는 원래 일반적인 싱글스레드 흐름에서는 MT를 체크하고 탑 꺼내고 팝을 하고 이런 식으로 일어났었던 걸 이제 이 트라이팝이라는 걸 한 방에 뿅 해줄 수 있게 유도를 했다는 뭐 그런 얘기가 되겠습니다 뭐 대충 스택은 , 이렇게, 처리를 할 수가 있을 것이고 근데 여기서 이제 이렇게만 처리를 해주면 우리가 실생활에서 나중에 이제 이게 MMO에서 이 스택이 Guns2Q를 사용한다고 했을 때 좀 아쉬운 점은 데이터가 만약에 없을 때라고 하더라도 데이터가 있는지 없는지를 체크할 수 없으니까 무한 루프를 돌면서 트라이팝을 계속 해야 되겠죠 그래서 여기서 false를 계속 리턴해서 데이터가 없구나 없구나 없구나 라는 걸 깨닫다가 얘가 true를 리턴하면 그래서 데이터가 있네라고 그 데이터를 처리하는 식으로 뭔가 동작을 할텐데 만약에 데이터가 없으면 그렇게 매버마다 쓸데없이 루프를 돌면서 체크를 하는 게 아니라 그냥 데이터가 채워질 때까지 얌전히 기다리면 훨씬 더 깔끔하게 돌아갈 수가 있겠죠 그리고 이제 그런 걸 처리하기 위해서 우리가 굉장히 또 우아한 방법으로 컨디션 베리어블에 대해서 알아봤습니다 그래서 뭐 이왕 하는 거 컨디션 베리어블을 제공해 가지고 좀 기다려주는 버전을 하나를 더 만들어 주도록 할 건데 트라이 팝이 아니라 이번에는 웨이트 팝이라고 해가지고 데이터가 진짜로 있어가지고 얘가 꺼냈을 때까지 대기를 하는 뭐 그런 버전의 팝을 하나를 더 만들어 줍시다. 그러면 이제 컨디션 베리어블에서 여기서 Notify 1을 해가지고 대기하고 있는 애를 하나를 딱 깨워줄 것이고요. 물론 여기서 뭐 락을 해제하고 노티파이를 해도 되지만 이렇게도 뭐 일단 큰 차이 없으니까 , 이렇게, 냅두도록 할 것이고 그 다음에 웨이팝을 하는 순간에 이제는 락가드가 아니라 유닛 락으로 만들어 줘야 됐었죠 왜냐면 이제 컨디션 베리업을 웨이트를 할 때는 내부적으로 락을 풀었다가 막 해야 되기 때문에 실질적으로 얘가 인수로 유닛 락을 받아주는 걸 우리가 알 수 있었어요 그래서 뭐 이런 식으로 웨이트를 해주세요 라고 한 다음에 락을 , 이렇게, 넣어 줄 것이고 그 다음에 이제 프레디켓이라고 해 가지고 조건을 넣어 줄 건데 뭐 람단수로 예를 들면은 stack이 mt가 아니다 mt가 false이다 즉 데이터가 뭔가 있을 때까지 대기를 타 주도록 하겠습니다 요렇게 만들어주면은 락을 잡아서 들어갔다가 조건을 체크해가지고 만약에 조건을 만족하지 않으면 락을 풀어주고 잠들어버리고 그 다음에 다시 시그널이 와가지고 , 이렇게, 컨디션 베리어블 노티파이가 빵 때려주면은 다시 일어나가지고 락을 잡고 똑같이 이제 실행을 한다고 했었죠 그래서 , 이렇게, 만들어주면은 이제 무한정으로 루프를 돌면서 트라이팝을 매번 할 필요 없이 만약에 그냥 진짜 데이터가 있을 때까지 대기를 타야 되는 상황이라고 한다면 우아하게 이 웨이트 팝을 이용해가지고 데이터를 꺼내 갈 수가 있을 겁니다 뭐 이런 식으로 이제 응용을 할 수가 있다는 얘기되는 거죠 스택 팝 끝 , 자, 이렇게, 해가지고 뭐 간단하게 스택을 만들어 봤구요 어 큐도 마찬가지로 어떻게 보면 약간 대칭적이긴 한데 이것도 그냥 빠르게 한번 만들어 봅시다 , 자, 여기서 이제 큐도 마찬가지로 어 뮤택 세더를 추가해 줄 것이고 얘도 마찬가지로 템플릿으로 , 이렇게, 만들어 줄 것이고 락 큐로 만들어 볼 것입니다 그리고 이제 다음 시간에 스택이랑 큐를 락 프리 버전으로 이제 또 만들어 볼 건데 그때는 지금처럼 간단하지가 않습니다 굉장히 머리가 아파지기 시작을 해요 그래서 지금이 이제 마지막 행복한 시간이니까 네 조금 쉽더라도 그냥 뭐 너무 방심하지 마시라고 말씀을 드리고 있는 거고 뭐 어찌됐건 , 이렇게, 복사하는 부분은 멀티스도 환경에 조금 취약하다 보니까 , 일단은, 막아 주도록 할게요 Lock Queue도 복사할 수 없습니다. Delete를 해버리고 그 다음에 Push를 할 건데 Value를 Push를 할 것이고 Lock Guard를 똑같이 잡은 다음에 여기서도 Lock을 잡아가지고 다른 Thread이 접근을 못하게 한 다음에 아이고 Queue를 안 만들어 놨네요 , 자, 여기서 이제 Queue 얘도 마찬가지로 Queue를 하나를 만들어 줄 것이고 그 다음에 mutex 도 만들어 줄 것이고 condition variable 도 미리 , 이렇게, 만들어 주도록 합시다 , 자, 그러면은 push 할 때도 마찬가지로 , 이렇게, std move 를 해 줘 가지고 value 를 넣어 준 다음에 condition variable 에다가 notify1 을 빵 때려 가지고 일어나세요 라고 외쳐 주고 마찬가지로 try pop 을 해줄 것인데 누군가가 어 기다리는 애가 있으면은 그냥 요기 복붙을 해보도록 합시다 좀 겹치는 부분이 많으니까 , 자, 요기다가 일단 , 이렇게, 다시 긁어와 가지고 다시 한번 살펴보면은 라까드를 , 이렇게, 잡아온 다음에 엠티면은 펄스를 해줄 것이고 그게 아니라고 한다면 요기서 q의 front를 이용해 가지고 데이터를 꺼내 올 것이고 그 다음에 q의 pop으로 , 이렇게, 데이터를 이제 뽑은 다음에 리턴을 해주면 되겠죠 마찬가지로 여기서도 lock을 잡아 가지고 condition variable을 기다리고 있는데 q가 mt가 false일 때까지 false이면은 이제 빠져나와야 되는 조건이니까 뭔가 데이터가 있을 때까지 기다리겠다라고 하는 거고 그 다음에 여기서 Q에다가 Front를 이용해가지고 Q에 있는 데이터를 뭔가 , 이렇게, 꺼내오도록 합시다 그럼 마지막으로 Q에 팝을 해주면 되겠죠 , 자, 이렇게, 해가지고 간단하게 락 기반의 Q랑 스택을 만들어 봤고요 이제 이런 거를 사용하기 위해서 여기다가 include concurrent Q랑 include concurrent 스택을 양쪽에 추가해준 다음에 여기 있는 버전을 이제 우리가 만든 락 Q 그리고 여기 있는 버전을 락 스택으로 , 이렇게, 바꿔치기를 한 다음에 똑같이 잘 동작을 하면 되겠죠. 큐에다가 푸쉬를 , 이렇게, 해줄 것이고 그 다음에 이쪽에서는 이제 엠티를 여기서 따로 체크하지 않을 것이고 Q에다가 트라이펍을 해준 다음에 여기다가 데이터를 넣어줘야 되겠네요 이런 느낌으로 그리고 if 체크를 해가지고 여기다가 데이터를 , 이렇게, 꺼내 온 다음에 만약에 얘가 true라고 한다면은 데이터가 있다는 얘기니까 그 데이터를 뭐 , 이렇게, 로그를 찍어주면 되겠습니다 , 자, 이렇게, 해가지고 뭐 똑같이 다시 이제 실행을 해보면 에고 뭔가 에러가 나는데 지금은 스택을 찾을 수 없습니다 아 여기 락큐를 아 큐로 바꿔치를 안 해놨네요 네 역시 복붙에 피해였고 다시 빌드를 해보도록 하겠습니다 , 자, 이렇게, 해가지고 뭐 간단하게 한번 구현을 해봤구요 이 상태에서 뭐 실행을 해보면 이제 아까와는 다르게 문제가 없이 잘 실행이 되는 걸 확인할 수가 있습니다 그리고 마찬가지로 만약에 , 이렇게, 트라이팝을 매번만 더 체크를 하는 게 아니라 진짜로 데이터가 있을 때까지 대기를 해야 된다고 하면 아까 얘기한 웨이트팝 버전으로 얘를 바꿔치기 해 줘 가지고 대기를 할 수 있는 그런 기능도 만들어 놨었죠 그래서 실질적으로 , 이렇게, 굉장히 간단하지만 이렇게만 랩핑을 해 놔도 실전에서 활용할 때 굉장히 유용하게 , 일단은, 활용할 수 있는 그런 기능들을 사용할 수가 있습니다 , 이렇게, 만들어 두면 장점이 애당초 푸쉬를 할 때 락을 잡아 주고 팝을 할 때 락을 잡아주고 하는 부분을 잠시 잡아줬다가 놔주고 잠시 잡아줬다가 락을 놔줄 것이기 때문에 , 이렇게, 자치적으로 내부적으로 락을 사용하는 그런 버전의 스택을 만들어주면은 혹시라도 일어날 수 있는 그런 데드락 문제도 좀 예방을 할 수가 있겠죠 만약에 밖에서 어거지로 여기서 뮤택스로 잡아주고 풀어주고 하는 부분을 매번마다 넣어줘야 된다고 하면은 그만큼 실수의 확률도 높아질 수 있기 때문에 뭐 이런 식으로 컨퀴랜드 버전으로 우리가 직접 만들어주는 것도 괜찮다는 얘기가 되겠습니다 , 이렇게, 해서 일단 락 버전은 솔직히 굉장히 쉬웠으니까 여기서 뭐 크게 어려운 점은 없었지만 이제 락프리 버전에서는 문제가 굉장히 많이 달라지게 될 겁니다. 그래서 다음 시간부터 락스택, 락프리 스택에 대해서 , 일단은, 알아볼 것이고 그 다음 시간에는 락프리 큐드에서 알아볼 것인데 이 학문 자체가 락프리 기반으로 뭔가 만드는 것 자체가 굉장히 꾸준히 논문도 많이 나오고 연구가 되고 있는 학문이에요. 그래가지고 일단 좀 마음을 단단히 하시고 , 일단은, 다음 강의로 넘어오시면 되겠습니다. , 자, 이렇게, 해가지고 , 일단은, 간단한 실습을 마쳐보도록 할게요.