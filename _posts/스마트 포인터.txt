이렇게, 지난 시간에 레퍼런스 카운팅에 대한 기초에 대해서 알아봤고 그 다음에 우리가 자작으로 , 이렇게, 만든 쉐어드 포인터에 대한 내용을 알아봤습니다 그리고 실질적으로 제가 예전에 얘기했던 프로젝트 중에서 이런 식으로 자작으로 만든 쉐어드 포인터를 이용하는 그런 프로젝트도 있었어요 이 방식이 딱히 문제가 있다는 건 아닙니다 , 자, 근데 이게 또 어떤 방식을 사용하면 그 방식의 장단점을 확실히 알아야 되겠죠 그래서 오늘 얘기할 부분은 이전에 사용하던 일단 요 방식의 한계에 대해서 , 일단은, 알아보도록 하겠습니다 , 일단은, 크게 두 가지로 생각을 할 수가 있는데요 첫번째로는 지난 시간에도 잠시 언급을 드렸지만 이미 만들어진 클래스 대상으로 사용이 일단 불가능하다는 조금 아쉬운 부분이 있습니다 그러니까 어디까지나 우리가 사용하던 이 레스 카운터블 이라는 애를 상속을 받아야지만 걔를 우리가 이 sharedptr 라는 우리의 자작 방식으로 사용할 수가 있었죠 근데 뭐 경우에 따라 가지고 우리가 뭐 제 외부에 그런 라이브러리를 다운받아서 사용한다고 하면은 그 해당 소스코드를 만약에 고칠 수 없는 상황도 생길텐데 그런 경우라면은 , 사실, 이 레프 카운터블을 상속받아서 사용하는게 조금 아쉽게 느껴질 수가 있습니다. 근데 뭐 물론 우리가 그냥 MMO를 만든다고 가정을 하고 어차피 서버코에서 사용하는걸 우리가 게임 서버에서 꺼내가지고 사용할 것이기 때문에 , 사실, 뭐 이 단점은 아주 크다고 생각할 수는 없어요 근데 이제 두번째 문제는 뭐냐면은 , 자, 이거는 , 사실, 우리가 만든 이 셰어드 피트뿐만 아니라 표준 셰어드 포인터도 똑같이 갖고 있는 문제인데 순환이 일어나는 문제가 생깁니다 순환 문제 , 자, 그래서 이 순환 문제 같은 경우에는 고민을 할 것이 조금 많습니다 제가 예전에 포토플리오를 만들 때 이 순환 문제를 언제 처음 만났냐면 의사 코드를 한번 보여드리자면 일종의 pvp 투기장 게임을 만들고 있었어요 온라인 게임을 만드는 연습을 하다가 대충 이런 느낌으로 , 일단은, 뭐 스마트 포인터를 활용을 했었고 이제 기사끼리 뭔가 pvp 를 하는 게임이었습니다 그래가지고 뭐 서로 서로 주시를 해가지고 공격을 할 수 있는 어떻게 보면 와우 느낌이 나는 그런 방식의 게임이었는데 , 자, 예를 들어서 여기서 우리가 똑같이 지난 시간에 배운 티셔도 포인터를 이용해가지고 요렇게 나이트 타입을 만들어 또 가정해 볼게요 근데 이 나이트끼리는 서로 주시를 할 수 있었기 때문에 이런 식으로 타겟이라는 멤버 변수를 이용해가지고 내가 지금 대상으로 하고 있는 요 아이를 요렇게 지정할 수 있었습니다 그니까 와우 같은 타겟팅 게임에서는 탭을 눌러가지고 우리가 내가 지금 주시하고 있는 몬스터를 요기다가 이제 저장을 할 수 있겠죠 그 다음에 주시라고 있는 몬스터 대상으로 스킬을 쓰는 뭐 그런 방식으로 게임이 이루어졌었는데 어.. 요기서 이제 일어난 문제는 굉장히 단순합니다 , 자, 셋 타겟이라고 해가지고 지난번과 비슷하게 요 나이트 대상으로 하는 타겟을 설정하는 기능이 , 이렇게, 하나가 있었어요 여기까지는 뭐 딱히 어려운 부분 없죠? , 자, 그럼 이제 궁금한거는 요 나이트 생성자랑 나이트 소멸자가 정상적으로 잘 호출이 되는지를 간단하게 로그를 찍어보도록 하겠습니다 얘는 생성자 그 다음에 요 부분이 소멸자가 되겠죠? , 자, 근데 이 순환이 발생하는 문제는 어.. 결국에는 서로 상대방을 주시를 하고 있어 가지고 A라는 나이트는 B라는 나이트를 바라보고 있고 B라는 나이트는 A라는 나이트를 서로 바라보고 주시를 하고 있기 때문에 서로 레퍼런스 카운트가 순환이 되어 가지고 절대로 양쪽이 다 해제가 되지 않는 그런 문제입니다 어떻게 보면 우리가 멀티스레드에서 배운 데드락이랑 약간 유사한 상황이라고 볼 수가 있는 거죠 뭔가 서로 놔주기를 기다리다가 아무도 진행할 수 없는 뭐 그런 상황입니다 그래가지고 이거를 뭐 간단하게 테스트를 해보자면 K1이라는 나이트를 우리가 만들어 줄 것이고 그 다음에 바로 릴리즈 레퍼런스 해가지고 요 아이의 모든 정권을 우리가 나이트 레퍼런스는 이 스마트 포인트 한테 넘기도록 할게요 마찬가지로 K2롤 대상으로도 똑같이 해가지고 이제 이 K1이랑 K2가 완전히 독립적으로 지금 동작을 하면서 얘가 이제 모든 권한을 부여받은 거죠 근데 이 상태에서 우리가 묘하게 새 타겟을 , 이렇게, 한다고 가정해봅시다 K2를 그러면은 만약에 여기까지만 했으면 , 사실, 아무런 문제가 없어요 이 상태에서 만약에 우리가 K1을 다 쓰고 K2도 다 썼다고 하면 그래서 , 이렇게, 날려주게 되면은 실질적으로 이 상태에서 실행을 해보면 소멸자랑 생성자나 소멸자가 정상적으로 다 출력이 되는 걸 알 수가 있습니다 그러면 이 소멸자가 지금 언제 호출이 되냐면 첫번째 나이트가 두번째 애를 바라보고 있는데 우리가 첫번째 애를 널PTR로 밀어주면서 애를 해제시키고 있죠 근데 얘를 널프히터로 밀어주면서 결국에는 레퍼런스 카운팅을 줄이다 보니까 이제 더이상 K1을 기억하는 애가 아무도 없다 보니까 얘가 이제 소멸이 되기 시작합니다 소멸이 되는 것은 여기는 소멸자가 실행이 될 것이고 그 다음에 이 나이트의 소멸자가 호출이 되면서 자연스럽게 얘가 들고 있던 모든 멤버 변수들에 대한 소멸자도 같이 호출이 될 거예요 그래서 이 나이트의 대상으로 이 타겟을 대상으로도 소멸자가 호출이 될 테니까 결국에는 얘가 이 나이트 레프가 소멸자가 호출이 되면서 요 코드에 의해가지고 얘도 릴리즈를 해주게 되니까 내가 들고 있던 상대방에 대한 레퍼런스 카운트도 자연스럽게 포기를 하게 될 겁니다. 그렇기 때문에 지금 요 상황에서는 정상적으로 메모리가 해제되는 그런 상황인데 만약에 거꾸로 K2도 , 자, 요런 느낌으로 서로 바라보고 있는 상황이 되었다고 하면은 이제는 문제가 조금 달라집니다 그래서 요 상황을 지금 이제 보면은 K1이 K2를 주시하고 있고 K2가 K1을 주시하고 있는데 결국에는 상대방이 나를 낮춰야지만 그 상대방 쪽에 요 타겟에 대한 소멸자가 호출이 되면서 나의 레퍼런스 카운트도 줄어들 텐데 지금 굉장히 묘하게도 서로 거꾸로 주시하고 있다 보니까 레퍼런스가 00, 0이 되지 않아 가지고 절대로 요 소멸자가 호출이 될 상황이 나오지 않는다는 거죠 그래서 이제 요 상황에 대해서 우리가 뭐 K2는 Null PTR인 요 상황에 대해서 우리가 한번 디버그를 해보게 되면은 , 자, 여기서 이제 얘가 실행이 되죠 그래서 K2가 우리가 Null로 미뤄지게 되면서 이제 하나씩 하나씩 추적을 해보면 우리가 Null PTR을 대상으로 새로운 객체를 요렇게 만들어 줬구요 오케이 그 다음에 셋을 해가지고 뭐 이걸 실행해 줬고 그 다음에 이거를 K2한테 우리가 지금 복사를 해주면서 기존에 있던 걸 릴리즈를 해주려고 합니다 , 자, 이렇게, 그래서 릴리즈 레퍼런스까지 호출이 되고 있는데 이때 보면 레퍼런스 카운트가 아직도 1이라는 걸 볼 수 있습니다 얘를 더이상 사용하는 애가 없음에도 불구하고 절대로 이 안으로 들어가지 않는 그런 상황이 발생한 거죠 그럼 얘가 절대로 소멸되지 않는 거는 K2를 K1이 계속 이 멤버 변수로 기억하고 있었고 결국에는 서로 , 이렇게, 꼬여가지고 절대로 해제가 되지 않는 그런 암담한 상황이 된 겁니다 그래서 , 이렇게, 사이클이 발생하는 문제가 종종 발생을 하는데 결국에는 우리가 이 쉐도우 포인터만으로 모든 거를 관리하기 시작을 하면은 그게 나쁜 방법은 아니긴 하지만 이 순환 문제를 어떻게든 생각을 하면서 해결을 해줘야 됩니다 그렇기 때문에 얘를 뭐 해결하기 위해서는 결국에는 이런식으로 널피티얼로 밀어가지고 얘를 사용하기 전에 더이상 진짜로 필요 없다 싶으면은 명시적으로 뭐 새 타겟을 요렇게 널로 밀어주는 요런 방법이 일단 있기는 하겠죠 네 그래가지고 요런식으로 깨끗하게 서로 사이클이 일어나서 서로 참조하는 문제를 없애기 위해서 많은 노력을 해야 된다고 보시면 되겠어요. 근데 , 이렇게, 단순하게 나이트끼리 바라보고 있는 상황에서 발생하는 경우는 생각보다 많이 없고요. 이제 일반적으로 이 버그가 발생하는 것은 뭔가 컴포넌트 패턴에서 어떤 클래스가 다른 클래스를 포함하고 있는 관계에서 자주 일어납니다. 그래서 예를 들면은 , 자, 이번에는 좀 다른 예를 다른 케이스를 한번 들어볼건데 뭐 인벤토리라는 클래스가 있다고 가정해볼게요 이거 똑같이 left countable 어 그런데 이 인벤토리를 나이트마다 하나씩 들고있다고 가정해봅시다 그럼 얘를 이제 인벤토리 left로 똑같이 요렇게 만들어 주겠죠 , 일단은, 얘도 인벤토리 를 만들어 준 다음에 나이트가 요 인벤토리를 들고있게끔 우리가 유도를 해줄수가 있을거에요 그래서 말 그대로 모든 플레이어는 자신만의 인벤이 있다 뭐 요런 상황이 되는 거죠 근데 이 내부적으로 인벤토리 코드에서도 나이트에 대한 정보를 접근해야 될 필요성이 의외로 많이 생긴다 이 나이트가 갖고 있는 이 아이의 레벨은 얼마인지 얘가 갖고 있는 최대 아이템 칸은 몇 칸인지 등등을 알고 싶은데 그 정보가 하필이면 나이트에 있다고 하면은 요기 인벤토리 클래스 내에서도 자기의 자기들은 포먹에 있는 주인님에 대한 정보를 알아야 된다는 얘기가 되는 거죠. 그래서 전형적으로 이런 식으로 나이트를 포인터건, 레퍼런스건 이런 방식으로 서로 크로스로 참조하고 있는 상황이 생기는 겁니다. 이런 느낌이죠. 그래서 여기서 만약에 우리가 참조 값을 건네주고 싶으면 스마트 포인터에 접근을 해가지고 여기서 별표를 찍어주면 이제 포인터가 나올텐데 그 포인터를 다시 역참조 해달라고 , 이렇게, 별표를 두 개 찍어주면 일단 되고요. 그래가지고 요런식으로 나이트에서는 인벤토리를 갖고 있는데 인벤토리도 나이트를 서로 존재를 알고 있는 요런 상황이 되는 겁니다 그래가지고 만약에 우리가 요렇게 뭐 사용하는 예를 만약에 들어본다고 했을 때 , 자, 일단은, 이제 k1, k2는 없애고 그리고 k1을 대상으로만 다시 한번 설명을 드리자면 요 상태에서 이제 인벤토리를 만들어보도록 합시다 k1에 인벤토리를 우리가 만들어 줄 것인데 이 인벤토리를 함과 동시에 K1을 넘겨줘가지고 어찌됐건 K1이 인벤토리를 들고 있고 인벤토리도 K1의 존재를 알고 있는 이런 상황을 우리가 만든 거죠 그래서 이런 식으로 만들게 되면은 이 인벤토리의 레퍼런스 그러니까 이 스마트 포인트로 얘를 들고 있다 보니까 레퍼런스 카운트가 지금 1 증가한 상태이지만 거꾸로 인벤토리에서 나이트로 들고 있을 때는 얘는 그냥 참조값으로 들고 있다 보니까 이쪽에서는 레퍼런스 카운트를 우리가 늘리지 않을 거예요 그러다 보니까 이런 상태로 만약에 저장하면 아무런 문제가 없는데 이제 신입들이 와가지고 종종 실수를 하는 게 코드를 보다 보니까 뭔가 다 스마트 포인트로 되어 있네라고 신나게 , 이렇게, 작업을 하는 경우가 생기는 거죠 그럼 , 이렇게, 되면 아까와 마찬가지로 나이트는 분명히 이 인벤토리를 컴포넌트로 들고 있는데 나이트도 인벤토리를 들고 있고 인벤토리도 나이트를 , 자, 이게 없어져야 됩니다 , 자, 요렇게 서로 거꾸로 크로스로 물고 있는 상태가 되기 때문에 레퍼런스를 서로 1 증가시킨 거를 절대로 놔주지 않기 때문에 요런 경우에도 아까와 마찬가지로 이제 절대로 해제가 되지 않고 메모리 릭이 일어나게 됩니다 그래서 요런 크로스로 , 이렇게, 일어나는 상황을 발생시키면 어떤 버그가 일어나냐면은 메모리가 절대로 해제되지 않기 때문에 이게 만약에 몬스터와 같이 굉장히 빈번하게 사용하는 클래스에다가 이런 버그를 만약에 우리가 넣었다고 하면은 메모리가 절대 해제되지 않아가지고 사용량이 그냥 쭉 늘어납니다 그래가지고 대부분 그런 경우에는 이제 퍼블리셔 쪽에서 먼저 연락이 와요. 아 이거 메모리 리익이 있는 것 같은데 대충 지금 추세를 보니까 한 8시간 후에 서버가 크래쉬가 날 것 같다. 미리 준비해달라고 연락이 옵니다. 그럼 그제서야 우리는 코드를 보면서 왜 어떤 코드가 들어갔길래 메모리 리익이 일어났냐를 부랴부랴 찾다 보면은 뭐 이런 코드가 들어갔으면 그런 문제가 일어날 수 있다는 얘기가 되는 거죠. , 자, 그렇게 해서 굉장히 좀 장화했는데 이게 뭐 실무에서 충분히 일어날 수 있는 일이니까 이거에 대해서 좀 중요하게 아셔야 될 것 같아 가지고 이 부분을 좀 강조했고요. 우리가 만든 이 NightRef라는 버전 즉 우리가 자체적으로 만든 이 SharedPtr뿐만 아니라 이거는 당연히 표준에서 사용하는 이 SharedPtr에서도 똑같이 발생하는 문제입니다 이 순환 문제는 그냥 SharedPtr이 들고 있는 특성이라고 보시면 되겠어요 무조건 상대방에 대한 레퍼런스 카운트를 늘리는 방식으로 동작을 하기 때문에 얘를 복사하는 순간 늘리기 때문에 얘는 항상 그런 문제가 발생한다고 생각하시면 되겠습니다 , 자, 그래가지고 오늘 이어가지고 알아볼 내용은 그냥 표준에 세서 사용하는 3종 스마트 포인터에 대해서 일단 알아볼건데 복습을 하는거죠 조금 깊이 있게 더 복습을 해보도록 하겠습니다 우선은 , 이렇게, 3총사가 있어요 , 자, 그런데 어 , 일단은, 이 중에서 유니크 PTR은 솔직히 스마트 포인터로 하기도 좀 민망할 정도로 굉장히 단순한 애니까 뭐 생략을 해도 될 것 같아요 유니크 PTR이 하는 거는 뭐 굉장히 단순한데 예를 들면 얘를 이제 뭐 , 이렇게, K2라고 이름을 지어보면 얘는 사실상 우리가 그냥 생포인터를 사용하는 거랑 거의 차이가 없습니다 이게 부화도 거의 안 걸리고 그냥 완전히 똑같은데 유닉PTR이라는 거에다가 내부적으로 들어가서 살펴보면 얘가 유일하게 다른 건 뭐냐면은 복사하는 부분이 막혀있을 거예요 여기 이런 식으로 막아놨죠 그래서 이 데이터를 복사하는 거는 지금 아예 막아놓고 있기 때문에 그래서 이름이 유니크 PTR인거죠 만약에 우리가 유니크 PTR을 하나를 더 만들려고 하는데 이거를 K3으로 하고 K2를 여기다가 복사하려고 하면 얘가 그냥 알아서 막아주고 있어요 그러니까 생명 주기에 있어가지고 이 K2라는 애는 다른 애한테 그렇게 복사할 수 없다는 얘기가 되는거고 무조건 유니크 해야 되니까 진짜로 이 케이스리한테 얘를 넘기고 싶으면 요런 식으로 그냥 복사를 하는 게 아니라 이동까지 해가지고 너가 들고 있던 소유권을 포기하고 얘한테 넘겨라라는 얘기를 해주고 있는 거죠 그거를 제외하고는 뭐 , 사실, 그렇게 어려운 부분은 없고 물론 얘도 이제 , 이렇게, 유니크 PTR를 만들어주면 결국에는 Shady PTR과 마찬가지로 요 포인터가 더 이상 유효하지 않을 때 즉 요 객체가 사라질 때 알아서 소멸자에서 이제 얘를 삭제해주는 것까지는 뭐 , 일단은, 다를... 그것도 일단 스마트포인트 특성을 갖고 있긴 합니다. 근데 일단 기본적으로 이 유닉 PTR은 어마어마하게 어려운 작업은 하는 건 아니고 그냥 알아서 삭제를 해줄 뿐만 아니라 이런 식으로 이동을 하지 않는다고 하면 얘를 멋대로 다른 애한테 복사하는 걸 막아놨다. 이것만 일단 기억을 하면 돼요. 얘는 , 사실, 뭐 크게 어려운 부분은 없으니까 생략을 할 수 있을 것 같고 오늘 주제는 결국에는 시네디 PTR이랑 위급 PTR 이 두 아이에 대해서 일단 좀 깊이 있게 살펴보도록 할 거예요. 그래서 이 위 끝 포인터를 사용하면 , 일단은, 순환 문제를 해결할 수가 있습니다 근데 물론 이 Weak PTR을 꼭 사용해야 되느냐 그건 또 아니에요 제가 말씀드린 바와 같이 그냥 이전 프로젝트에서는 이 Shared PTR이 유명해가지고 모든 그런 포인터를 관리했던 프로젝트도 있었어요 근데 이제 알아서 사이클이 일어나지 않거나 이런 수납 문제를 일으키지 않도록 이제 프로그래머가 조심해야 되는 얘기가 되는 거고 그러면은 이 Weak PTR은 도대체 무엇이길래 이 Shared PTR을 보충해줘가지고 이제 사이클이 일어나는 문제를 해결할 수 있는지에 대해서만 언급을 하면 될 것 같네요 , 자, 그런데 또 돌고 돌아가지고 한 가지만 더 말씀을 드리자면 그런데 아까 우리가 자체적으로 만든 요 방식 이 레퍼런스 카운터블을 상속 받아가지고 얘를 사용하는 방식이 나쁜건 아니지만 요런 문제가 있었죠 이미 만들어진 클래스 대상으로는 사용이 불가능했습니다 예를 들면 우리가 뭐 어떤 사유의 인을 가지고 , 자, 일단은, 이 인벤토린 삭제를 하도록 하고 나이트를 랩 카운터블이 아니라 그냥 일반 버전으로 만약에 만들었다고 하면은 그러면은 이제 이 나이트 랩이라는 거를 우리가 활용을 할 수가 없을 겁니다 빌드가 아직 안될 거에요 아예 왜냐면은 요기 있는 요 TSharedPtr에서는 내부적으로 add Reference랑 release reference 요 두개를 일단 찾고 있는데 만약에 우리가 만들어 준 요 함수에서 그 기능을 제공하지 않으면 얘는 , 일단은, 실행이 안된다는 얘기니까 여기서 들어가지 않는다는 얘기가 되는거죠 똑같은 인터페이스를 제공해줘야 되는데 그게 아니다 보니까 지금 문제가 되는 거예요 그래가지고 이런 상황에서는 우리가 이 상속을 받는 방식으로 할 수는 없지만 그럼에도 불구하고 이 Shared PTR에서는 똑같이 만들어줄 수가 있습니다 사용 방식은 굉장히 유사한데 딱히 상속에 대한 제한이 없다는 거는 좀 동작 방식이 다르다는 걸 일단 의미를 하는 거겠죠 , 자, 그래가지고 일단 우리가 만든 버전이랑 조금 비교를 해가지고 이 Shared PTR을 알아보면은 얘도 마찬가지로 타고 들어가서 F12를 눌러서 일단 타고 들어간 다음에 살펴보면 이런 식으로 Shared PTR이 PTR Base라는 걸 상속받고 있고 이 PTR Base는 Shared랑 Weak의 모두 공통 조상이라는 걸 알 수가 있습니다. 그 다음에 여기서 또 코드를 쭉 내려보다 보면 여기서 멤버 변수로 들고 있는 걸 살펴보면 지금 이 부분을 , 일단은, 유심히 보시면 돼요. PTR도 들고 있을 뿐만 아니라 또 다른 포인터를 하나를 덜 들고 있죠 지금 여기서 PTR로 들고 있는 이 포인터로 들고 있는 요 부분이 우리가 만든 부분으로 치면은 요 부분이랑 똑같습니다 여기서 내가 들고 있을 포인터를 대신 관리할 포인터를 들고 있는 다가 요 부분이고 그렇다는 것은 요 레퍼런스 카운트 베이스라는 게 어... 말 그대로 레퍼런스 카운트를 관리하는 부분이라는 걸 알 수가 있는 거죠 이런 식으로 우리가 상속 구조로 만약에 만들었다고 하면은 그 객체 자체에 이... 이 부분, left count 부분이 포함되어서 같이 딸려가 있을 텐데 그게 아니다 보니까 지금 , 이렇게, 따로 만들어 줬다는 걸 일단 알 수가 있어요. 이 부분을 일단 유심히 봐야 됩니다. 그래서 결론적으로 만약에 우리가 이런 식으로 Shared PTL을 만들게 되면 사실상 메모리가 두개가 만들어지게 되는데 나이트랑 레프 카운팅 블록 말 그대로 레퍼런스 카운팅과 관련된 정보가 있는 메모리 영역이 하나가 또 잡힙니다 그리고 실질적으로 우리가 아까 살펴본 요 부분에서 요 ptr 하고 해당하는 요 element type 포인터가 하나가 있을 것이고 그 다음에 레프 카운트 블록 레퍼런스 카운팅 블록에 대한 포인터를 , 이렇게, 하나씩 들고 있을 거에요 그래서 요 정보가 , 일단은, 지금 이 Shared PTR 안에 포함이 되어있다고 볼 수가 있는 거죠 그러니까 단순한 포인터가 아니라 , 이렇게, 포인터 두 개짜리로 , 일단은, 얘가 이뤄져 있다는 걸 알 수가 있어요 요 아이 같은 경우에는 이제 나이트 실제 객체를 즉 요 아이를 지금 가리키고 있는 상태라고 볼 수가 있는 거고 요 레퍼카운팅 블록 자체는 이제 여기서 레퍼런스 카운팅과 관련된 숫자를 이제 내부적으로 관리해주게 될 겁니다 그래가지고 이제 앞으로 우리가 다른 Shared PTR을 만들어가지고 만약에 요 데이터를 복사한다 뭐 이런 느낌으로 Shared Pointer 2를 해가지고 얘를 복사한다고 하면은 아까 똑같은 구조로 얘가 이제 한 번 더 만들어지게 될 건데 동일한 나이트 객체와 동일한 레퍼런스 카운트 블록을 서로 가리키고 있는 상태로 만들어진다는 차이가 있어요 그러니까 결국에는 원래는 우리가 아까 상속 구조로 만들어 쓰는 이 레퍼런스 카운트와 관련된 정보 자체가 나이트에 포함이 되어 가지고 얘한테 딸려서 같이 들어갔다고 한다면 그게 아니라 셰어드 포인터가 동작하는 방식 자체는 이런 식으로 두 개의 정보로 따로따로 얘를 만들어 준다라는 걸 알 수가 있는 거죠 왜냐면 애당초 이 나이트라는 애에 레퍼런스 카운팅과 관련된 정보가 들어가지 않으니까 이렇게밖에 만들 수가 없는 겁니다 그리고 사용방법은 , 이렇게, 만들면 되고요 얘는 아까 우리가 했던 거랑 다르게 여기서 릴리스 레퍼런스를 굳이 호출할 필요 없이 그냥 이렇게만 넣어주면 됩니다 이게 우리가 아까 만든 인터페이스랑 조금 다른 부분이고 그 다음에 이 부분에 대해서 , 일단은, 알았으면 또 하나 부분에 대해서도 알아야 되는 게 뭐냐면 포인터를 만들어줄 때 , 이렇게, new로 해가지고 넘겨주는 방법이 있는데 이거보다 좀 더 우아한 방법이 make shared라는 걸 호출하는 방법이 있습니다 그래서 이 둘의 차이에 대해서는 어느 정도 이해를 하셔야 돼요 여기서 Make Shared라는 걸 똑같이 타고 들어가서 코드를 살펴보면 어떻게 되어있냐면 우리가 여기서 넣어준 이 Knight라는 게 지금 언더밧 Ty라는 타입으로 들어가 있고요 그 다음에 그걸 이용해가지고 new를 해 줘 가지고 어떤 객체를 만들어 준다는 걸 볼 수가 있는데 그 객체는 절묘하게도 아까 찰퍼분 레퍼런스 카운트 베이스라는 걸 또 상속 받고 있다는 걸 알 수가 있습니다 사실상 우리가 , 이렇게, 레퍼런스 카운트업 이라는 걸 상속 받아 가지고 나이트를 만들었던 것처럼 얘도 이제 1 플러스 1 으로 정보를 낑겨넣는다는 얘기가 되는거죠 그래서 만약에 우리가 Make Shared를 이용해가지고 , 이렇게, 개체를 만들어주게 되면은 이 Knight랑 Reference Count Block을 , 이렇게, 영역을 잡아가지고 1 플러스 1으로 한 번만 , 이렇게, New를 해줘서 영역을 잡은 다음에 공간을 충분히 할당해서 얘네들을 같이 , 이렇게, 낑겨넣어주게 됩니다 그렇기 때문에 아까와는 다르게 나이트를 할당한 다음에 레퍼런스 카운트 블록을 할당하고 , 이렇게, 두 번에 걸쳐서 할당하는 게 아니라 얘가 일단 한 번에 걸쳐가지고 , 이렇게, 딱 만들어지기 때문에 조금 더 효과적으로 , 일단은, 만들어진다는 걸 알 수가 있는 거죠 그럼 미묘한 차이가 있어요 , 자, 그건 그렇고 그러면 이제 이 그 다음으로 알아볼 문제는 요 레퍼런스 카운팅 블록에는 어떠한 정보가 있는지가 궁금하죠 여기서 내부적으로 관리하고 있는 정수가 무엇일까 어 우리가 만든 요 레퍼런스 카운팅을 곰곰이 생각해보면 얘가 뭐 어떤 정수를 들고 있어 가지고 레퍼런스 카운트를 뭐 들고 있지 않을까라는 생각을 할 수가 있는데 근데 아까 살펴본 대로 요 레퍼런스 카운팅 블록은 셔드PTR이랑 위크포인터 둘 다 공용으로 사용하는 그런 레퍼런스 카운팅 블록입니다 그래서 실질적으로 이것도 코드를 들어가서 살펴보면 알 수 있는 부분인데 여기서 Shared PTR로 들어간 다음에 PTR 베이스로 타고 들어가서 쭉 내려가지고 아까와 마찬가지로 reference count 베이스에 타고 들어가서 이 부분을 살펴보면 어떻게 돼있냐면은 유즈랑 위크라고 두가지의 정수가 일단 있다는걸 알 수가 있어요 우리가 예상한거는 뭔가 그냥 랩카운트 , 이렇게, 정수 하나만 관리할 줄 알았는데 그게 아니라 정수 두개를 관리한다는거죠 유즈라는 정수랑 위크 뭐 , 이렇게, 두가지 아직까지 의미는 모르겠지만 두개의 정보를 관리한다라는걸 알 수가 있습니다 그래가지고 이 방식에 대해서도 어느정도 이해가 필요한데 그나마 좋은건 뭐냐면 이걸 이해하시면 나중에 얼리얼에서도 똑같이 스마트포인터를 사용하는데 얼리얼도 완전 똑같이 되어있어요 그냥 이 표준의 STL을 사용하지 않았을 뿐이지 걔네들도 이제 똑같이 똑같은 원리로 만들었기 때문에 요 부분에서는 이제 1 플러스 1으로 일단 이해하실 수가 있습니다 그래가지고 위크포인터라는걸 만약에 우리가 , 이렇게, 사용하면은 , 일단은, 얘가 어떻게 사용하는지에 대해서 알아보면 되겠죠 위크포인터를 사용하는데 얘는 뭐 그냥 쉐도우 포인터와 마찬가지로 그냥 위급... 어... 섀도우 포인터를 그냥 받아가지고 , 이렇게, 사용할 수가 있습니다. 일단 , 이렇게, 저장을 하고 있는 거예요. 그런데 이 weak 포인터 같은 경우에는 그냥 섀도우 포인터처럼 마치 얘를 그냥 포인터인 것 마냥 사용할 수 없고 , 자, 이런 식으로 얘가 존재하는지 아닌지를 먼저 체크를 해야 됩니다. 그래서 체크하는 방법은 , 이렇게, 엑스파이어드라는걸 체크해가지고 이 불량값을 추출해가지고 아직까지 내가 가리키고 있는 이 나이트가 아직도 존재하는지를 체크를 하는건데 요렇게 하자 만약에 하는게 좀 번거롭다 하면은 이거를 요 락이라는 함수를 이용해가지고 다시 셰어드 포인터로 얘를 다시 캐스팅해가지고 사용하는 방법이 있습니다 뭐 요런 느낌이죠 네 그래가지고 요 두가지 방식중 이제 뭐 둘 다 유용한데 체크를 해가지고 캐스팅을 하거나 어떻게든 얘를 다시 쉐어드 포인터로 변환해가지고 일단 사용하면 되는데 여기서 만약에 어떠한 이유로 이 객체가 이미 날아가가지고 존재하지 않는다고 하면은 이 락을 했을 때 이 쉐어드 포인터가 일단 널 상태가 될 겁니다 널 포인터 그래서 존재하지 않는 상태가 될 수 있다는 거죠 , 자, 그러면은 원래 쉐어드 포인터라는 거 자체가 우리가 만든 이 방식에서 보면은 레퍼런스 카운팅을 해가지고 이 레퍼런스 카운트가 0이 되어야만 그 해당 객체를 삭제하겠다라는 정책이었죠? 그거였는데 이제 이 Shared와 Weak가 동시에 등장하는 이 레퍼런스 카운팅 블록에서는 블록킹이 아니라 블록이죠 이 버전에서는 이제 뭐가 달라지냐면 숫자를 두 개를 둔다는 게 달라집니다 그래서 전형적으로 UseCount라는 이게 사실상 SharedCount를 말하고 있는 거고요 그 다음에 WeakCount , 이렇게, 두 개를 관리할 건데 그냥 쉽게 받아들이자면 요 카운트는 이 쉐도우 포인터로 얘를 참조하고 있는 카운트를 얘기하고 있는 거고 요 두번째 카운트는 위크 포인터로 이 동일한 레퍼런스 카운팅 블록을 참조하고 있는 횟수를 얘기하고 있는 겁니다. 이제 두 개의 버전으로 나눠줄 거예요. 그래가지고 첫번째 거는 마찬가지로 우리가 지금까지 알아보던 일반 쉐어드 포인트랑 마찬가지로 요 유즈 카운트가 만약에 0이 되면은 이제는 더이상 나이트는 유효하지 않기 때문에 걔를 날려도 된다 날려버리겠다 라는 의미로 받아주면 되고 근데 이 위크 포인터가 이 쉐어드 포인터 횟수가 0이 되었다고 해도 이 나이트는 이제 더이상 필요 없다는 게 확실하기 때문에 얘는 사실상 날려도 되고 안 날려도 되고 이건 이제 뭐 구현한 쪽 마음이겠지만 어찌됐건 요 데이터는 더이상 유효하지 않다는 거는 , 일단은, 감수를 해야 됩니다 하지만 그럼에도 불구하고 여기 있는 레퍼런스 카운팅 블록은 아직까지는 날리지 않을 거에요 그럼 얘는 이제 언제 날리느냐 위크 포인터가 있으면은 즉 이 위크 카운트가 0이 아니면은 이 레퍼런스 카운팅 블록은 계속 살려 둘 겁니다 그래가지고 혹시라도 다른 애가 이 위크 포인터를 이용해가지고 이 해당 포인터를 지금 들고 있는 상태라고 하면은 위크 포인터는 촬영 요 부분은 날라갔다고 해도 요 부분은 계속 유효하기 때문에 , 이렇게, 지리를 해줄 수가 있는 거죠 야 근데 내가 지금 사용하려고 하는데 요 나이트 지금 아직도 존재하냐? 엑스파일드냐? 라고 해가지고 이 값을 이용해가지고 알 수도 있고 아니면 그냥 애당초 , 이렇게, 위크 포인터가 다시 섀도 포인터로 얍! 하면서 변신을 하는 요 상황에서도 이제 간접적으로 알 수가 있게 되겠죠 만약에 레파노스 카운트가 이 쉐어드 카운트가 0이 되어가지고 이미 요 부분이 날라갔다 가면은 이 락이 실행되는 순간 얘는 , 일단은, 어차피 널 포인터로 반환이 되기 때문에 그냥 객체가 없을 거예요 얘는 아직 사용할 수도 없다는 얘기가 되는 거죠 그래가지고 결국에는 쉐어드랑 위크는 어떻게 보면 서로 보충하는 그런 존재라고 볼 수 있는 건데 결론적으로 말씀드리자면 이 위크 포인터는 이 레퍼런스 카운팅 블록을 참조해가지고 그 객체가 진짜 사라졌는지 사라지지 않았는지를 알 수 있기는 하지만 하지만 이 나이트 수명 자체에는 영향을 주지 않는 어떻게 보면 반쪽짜리 스마트 포인터라고 볼 수가 있는 겁니다 이게 굉장히 중요하죠 그래서 사실은 요 블록 자체의 구조를 이해하고 요 카운팅이 어떤 원리로 동작하는지만 , 일단은, 이해를 한다면은 , 사실, 내용 자체는 크게 어려운 부분이 없어요 , 자, 근데 그럼에도 불구하고 이제 위크 포인터를 그러면 우리 프로젝트에서 나중에 꼭 사용할 것이냐 이거는 또 약간 애매한 문제긴 합니다 이게 장점은 뭐 어찌됐건 셰어드 포인터만 사용할 때처럼 사이클 문제가 발생하던 문제를 , 일단은, 예방할 수 있겠죠 아까로 예를 들면 나이트가 인벤토리를 들고 있을 때 인벤토리에서 나이트를 참조할 때는 그 나이트를 위크 포인터로 들고 있으면은 뭐 역참조가 사이클이 일어나 가지고 서로 절대 해제 시켜주지 않는 문제는 예방할 수가 있을 거예요 왜냐면은 위크 포인터를 하는 애는 상대방의 그 수명 주기에는 영향을 주지 않기 때문이죠 얘는 객체가 사라지는 것에 영향을 주지 않고 그냥 이 레퍼런스 카운팅 블록만 끝까지 남아가지고 우리가 진짜로 그 객체가 사라졌는지 안 사라졌는지 테스트하기 위한 이 부분만을 유지시켜주는 역할을 하게 됩니다. 하지만 그럼에도 불구하고 막상 위크 포인터를 사용하면 어찌됐건 얘를 사용하기 위해서는 이런 식으로 다시 한번 섀도 포인터로 반환한 다음에 얘가 너린지 아닌지 아직 존재하는지 아닌지를 체크하고 이런 식으로 두 번에 걸쳐 가지고 작업을 해야 되기 때문에 이 부분이 조금 번거롭게 느껴질 수도 있겠죠 그러니까 이건 어디까지나 선택의 영역입니다 제가 이전에 작업했던 프로젝트에서는 , 이렇게, 셰어드 포인터만 자체적으로 만들어서 사용했던 적도 있었고 어떤 프로젝트에서는 그냥 이 표준 셰어드랑 위크를 양쪽을 다 사용하던 프로젝트도 있었습니다 이건 어디까지나 선택의 영역이라고 보시면 되는 건데 하지만 선택을 한다고 하면은 양쪽의 간단한 구조, 원리에 대해서 그리고 장단점에 대해서는 어느정도 숙지를 해야 된다고 볼 수가 있는거죠 , 자, 그래가지고 이 Shared Pointer랑 Weak Pointer는 사실은 대충 여기까지만 , 일단은, 알면은 나머지 부분은 하나씩 실습을 하다보면은 좀 더 익숙해지실 것 같고요 마지막으로 여기서 Weak Pointer와 관련된 코드를 살펴보거나 Shared Pointer와 관련된 코드를 살펴보면서 예를 들면은 Shadow PTR 코드 들어가서 다시 PTR 베이스로 타고 들어가서 레퍼런스 카운트 부분을 찾다 보면은 , 이렇게, Decrease Wrap랑 Increase Weak Wrap 이런 부분을 실행한다는 걸 알 수가 있습니다 이걸 또 다시 타고 들어가서 살펴보면은 딱 봐도 IncreaseRef가 얘를 일단 이 UseCount를 늘려주는 이 버전인 거죠 그러니까 아까 얘기한 이 SharedCount를 늘려주는 이 부분이 지금 , 이렇게, 들어가 있는 거고 WeakPointer를 늘리는 부분은 이 부분이란 걸 알 수가 있는 거고 이제 만약에 우리가 이 UseCount를 줄인다 즉 SharedPointer가 더 이상 사용하지 않아 가지고 이 Count를 줄인다고 하면은 얘를 줄여다가 만약에 0이 되었다고 하면은 , 일단은, 디스트로이를 통해 가지고 결국 이 나이트에 대한 부분은 날릴 수 있다는 얘기가 되는 거고 그 다음에 여기서 Decrease Weak Reference를 해가지고 얘가 Weak Count가 처음에 1에서 시작을 할 겁니다. 둘 다 1에서 , 이렇게, 시작을 하다가 얘가 이제 더 이상 필요 없어서 0이 되는 순간 나이트를 날려도 되고 그 다음에 위크 카운트를 1 줄여 가지고 얘도 같이 날릴 수 있는지를 테스트 할 건데 만약에 요 상황에서 누군가가 위크 포인터로 얘를 일단 물고 있다고 하면 얘가 0이 아닐 테니까 당장은 요 레퍼런스 카운팅 블록은 날리지 않는다는 걸 볼 수 있는 거죠 만약에 위크 포인터까지 0이 되었다고 하면 이제는 진짜 진짜로 요 전체를 더 이상 아무도 신경 쓰지 않을 것이니까 그런 경우라고 한다면 딜리트 디스를 해가지고 지금 이 레퍼런스 카운팅 블록 메모리까지 빵 날리는 부분이 실행될 거라는 걸 예측할 수가 있습니다 , 이렇게, 해가지고 처음에 이제 뭐 이 표준 코드를 보면 생각보다 좀 복잡하게 되어 있습니다 그래서 뭐 템플릿과 관련된 부분도 굉장히 많이 들어가고 해서 굉장히 헷갈리는 부분이 많긴 한데 그래도 조금씩 조금씩 보다 보면 생각보다 그렇게 뭐 엄청나게 어려운 내용은 아닙니다 네 그래가지고 음, 이렇게, 해가지고 Shared Point랑 Weak Point에 대한 내용을 일단 확실히 숙지를 하셨기를 바라고요. 어... 대충 이 정도면은 , 일단은, Smart Pointer에 대한 계로는 일단 맞춰도 될 것 같습니다. 그래서 요런 부분들에 대해서는 방지해 숙지를 하셔도 되는 게 우리가 나중에 설계할 그 서버에 대한 설계를 할 때도 이제 어떤 포인터를 사용할 것인지 정책 정할 뿐만 아니라 요런 부분들이 면접에서도 진짜 자주 나와요. 그... Smart Pointer에 대해서 설명을 해봐라. Shared랑 Weak는 뭐... 어떤 관계인가, 어떤 차이가 있는가 이런 부분에 대해서 면접에서 은근히 자주 나오기 때문에 면접 대비하신다고 해도 이런 부분에 대해서 일단 숙지를 하시면 도움이 될 것 같습니다. , 자, , 이렇게, 해가지고 조금 지루한 내용이었는데 스마트폰에 대한 내용을 마치도록 할게요.