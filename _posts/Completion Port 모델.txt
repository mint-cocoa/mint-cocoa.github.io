자, 이렇게, 해가지고 이제 오늘 드디어 대망의 IOCP 컴플리션 포트 모델에 대해서 이제 학습을 해 볼 건데요 , 일단은, 여기 네트워크 코드를 당장 작업하지는 않을 것이고 그냥 지난 시간과 마찬가지로 우리가 작업하던 이 샘플 게임 서버 쪽에서 그냥 간단하게 컴피션 포트를 실습을 해보고 그 다음 시간부터 이제 이걸 좀 라이브러리화 해가지고 네트워크 쪽에다가 관리를 하는 식으로 이제 작업을 해보도록 하겠습니다 일단 이 내용이 굉장히 중요하기 때문에 좀 간략하게나마 사용 예제를 한번 보고 넘어가는게 나중에 이제 최종적으로 라이브러리를 만드는 데 도움이 될 것 같아 가지고 중간 단계를 한번 더 거칠 건데요 근데 , 일단은, 지난번에 했던 요 오버랩트 모델을 잘 이해했다고 하면은 , 사실, 오늘 하는 IOCP도 크게 어렵진 않습니다 굉장히 이제 비슷한 식으로 동작을 하게 될 거예요 , 자, 그래가지고 음 , 일단은, 요 오버랩트 모델 콜백 기반에 대한 내용을 두 줄로 요약을 해보면 결국에는 우리가 어떤 비동기 입출력 함수가 완료되면 스레드마다 갖고 있는 apcq라는 애의 일감이 쌓였다고 했었죠 완료가 되었다는 사실이 그 다음에 우리가 준비가 되어서 alertableWait라는 상태로 전환을 해주게 되면 들어가서 apcq를 비울 수가 있습니다 이제 콜백 함수를 호출한다는 느낌으로 진행이 된 거죠 , 이렇게, 크게 두 단계로 , 일단은, 구분을 해줄 수가 있을 거예요 우리가 지난 시간에 알아본 오버랩트 모델 특히 콜백 방식에서는 좀 아쉬웠던 점이 APCQ가 Thread마다 고유하게 있다 마다 있다는 게 , 사실, 굉장히 아쉬웠죠 그래서 이거를 나중에 멀티스레드 환경에서 적절히 배분을 하는 것 자체가 조금 애매하게 느껴지는 부분이 Receive나 Send를 호출한 쪽에서 반드시 Alertable Wait 상태까지 들어가서 Q를 비우는 작업까지 이어져서 했어야 했습니다 네 그리고 뭐 물론 이 alertable weight라는거 자체도 조금 부담이 되는 그런 여러가지 문제가 있었죠? 그렇다고 해서 컴플리션 루틴 기반이 아니라 오버랩드 모델 중에서 기존에 알아봤던 이벤트 방식으로 하면 , 사실, 더 끔찍했습니다. 이벤트 방식은 소켓이랑 이벤트를 1대1로 대응하는 것부터가 굉장히 피곤한 일이었습니다. 그리고 애정초 예를 감시하는 함수 자체가 64개밖에 지원을 안하기 때문에 많은 수의 이벤트들을 관찰하는 것도 굉장히 피곤한 작업이라고 했었죠. 오늘 새로 알아볼 IOCP 컴플리션 포트 모델 같은 경우에는 콜백 기반의 오버랩트랑 굉장히 유사한 형태로 , 일단은, 우리가 코드는 만들어집니다 그래서 여기서 보면은 아까 요약한게 2줄이었었죠? 비동기 입출력 함수가 완료되면 스레드마다 들고 있는 APC 큐의 일감이 쌓인다라고 했었는데 APC라는 큐 대신 컴플리션 포트라는 아이가 이제 처리를 해주게 될 겁니다 근데 얘는 스레드마다 있는 건 아니고 그냥 유일하게 하나를 만들어 줄 겁니다 뭐 다수를 만들어도 되지만 딱히 그럴 이유는 없습니다. 그냥 보통 한 개를 만들어 줘서 걔를 사용할 것이고 이게 약간 느낌적인 느낌으로 뭔가 중앙에서 관리하는 그런 APCQ 같은 느낌인 거죠. 그러니까 다수의 스레드가 이 하나의 컴피션 포트를 통해 가지고 이제 일감을 받아 가지고 실행을 하게 될 겁니다. 그래서 약간 중앙에서 관리하는 APCQ APCQ는 어디까지나 스레드마다 있었는데 그게 아니라 일감 자체를 모아놓는 그런 공용 Q를 하나 만든다고 일단 볼 수가 있는 거죠 네 그리고 어쨌든 , 이렇게, 일감이 쌓인 다음에 실질적으로 일감을 뽑아가지고 비워가지고 콜백 함수를 실행했었는데 그거를 위해서 우리가 AlertableWait 단계로 넘어갔었죠 근데 마찬가지로 CompletionPort의 결과 처리를 하기 위해서는 우리가 getCuedCompletionStatus라는 굉장히 이름이 장황하게 긴 요 함수를 이제 호출해주게 될 겁니다 요 두 단계로 , 일단은, 대체가 된다는 거 빼고는 뭐 거의 이제 코드 흐름은 비슷하다고 , 일단은, 생각할 수가 있겠어요 근데 얘 자체가 , 일단은, 굉장히 멀티프렌드래 멀티스레드에 굉장히 친화적이죠 애당초 이 CompletionPort라는 거 자체가 스레드마다 , 이렇게, 배치해 놓는 건 아니기 때문에 그래가지고 보통 컴피션 포트 모델을 사용할 때는 멀티 스레드 환경에서 동작을 하게 하는 경우가 일반적입니다. 궁합이 굉장히 좋다. 오늘도 별도의 스레드를 만들어 가지고 작업을 하는 형태로 실습을 해볼 건데요. , 자, 그리고 이제 오늘 등장할 함수가 두 개가 있습니다 결국에는 이 컴플리션 포트를 만드는 부분과 그 다음에 어떤 소켓을 이 컴플리션 포트에 관찰해 달라고 등록을 하는 부분이 있는데 그 두 개의 행동이 하나의 함수로 만들어지게 됩니다. createIOCompletionPort라는 이 함수가 1번이고, 그 다음에 두 번째, 결과 처리를 감시하는 함수는 getQueuedCompletionStatus라는 이 함수를 이용하게 될 거예요. , 자, 근데 오늘은 뭐 장화학의 인자에 대해서 설명하지 않고 진행을 하면서 설명을 드리도록 할게요 , 일단은, 자, 여기서 , 일단은, 진행을 해볼건데 어.. 먼저 이제 어떻게 해볼거냐면은 먼저 컴피니션 포트를 생성을 해주도록 하겠습니다 그래서 CreateIOCompletionPort라는 이 함수를 이용할 건데 HandleExistingCompletionPortCompletionKeyNumberOfConcurrency라는 , 이렇게, 네 가지 인자를 받는다는 걸 볼 수 있습니다 근데 이제 이 CreateIOCompletionPort가 두 가지 용도로 활용이 되는데 처음에 컴플리션 포트를 생성할 때 최초 한 번 사용하는 경우가 있고 두번째로 나중에 소켓을 여기다가 이 만들어준 컴피니션 포트에 등록하는 용도로도 이제 활용이 됩니다 즉 두가지 용도로 활용이 된다는 거죠 근데 맨 처음 용도 생성하는 용도로 활용할 때는 여기 애당초 파일 핸들을 무조건 invalid handle value 이걸로 넣어주고 나머지들은 다 채워줄 필요가 없어요 0 0 요렇게 , 일단은, 만들어주면 됩니다 즉 모든걸 다 기본 상태로 빡 밀어주게 되면은 어 말그대로 새로운 컴피션 포트를 만드는 방식으로 얘가 동작을 하게 된다는 얘기가 되는 거죠 이것도 MSDN을 살펴보는 것도 좋은 생각이 될 겁니다 이런저런 설명을 하고 있고 두 가지 방식으로 활용이 되는데 처음에 컴피션 포트를 만들 때는 어떻게 해달라고 다 친절하게 설명이 되어 있을 겁니다 , 일단은, 잠시 스킵을 하고 , 이렇게, 만들어주게 되면 핸들을 뱉어주게 되는데 이게 IOCP 핸들이라고 보시면 되겠어요 IOCP 핸들을 이용해서 컨널 객체를 적용할 수 있다고 보시면 되겠습니다. 이 핸들을 일단 만들었고 억셉트 같은 함수도 지난번에도 말씀을 들었지만 비동기 방식이 당연히 있다고 했었습니다 근데 이제 그걸 사용하기 위해서 좀 복잡한 과정을 거쳐야 되기 때문에 오늘은 이제 억셉트까지 즉 여기서 뭔가 새 손님을 받는 단계까지는 그냥 이 메인스레드에서 처리를 해 준 다음에 별도의 스레드에서 샌드랑 리시브를 처리해 주도록 만들어 보도록 할게요 나중에 가면은 , 이렇게, 억셉트를 하는 것도 다 컴피션 포트를 통해 가지고 만들어 주게 될 겁니다 일단 오늘은 , 이렇게, 억셉트 담당은 메인 스레드가 해 주도록 할게요 그리고 참고로 뭐 그렇다 보니까 이걸 꼭 이런 식으로 논블록킹으로 만들 필요도 없어요 그냥 블록킹 소켓으로 만들어 주도록 하겠습니다 좀 쉽게 쉽게 가시죠 그래가지고 , 이렇게, 만들었으면 이 accept를 일단 위로 빼 가지고 루프를 돌 필요도 없이 그냥 , 이렇게, 기다려 가지고 소켓을 , 일단은, 만들어 줄 것이고 누군가가 연결할 때까지 기다려 줄 것이고 그냥 예외 체크만 한번 해 주도록 할게요 invalid socket 이라고 하면은 invalid 하니까 return을 바로 때려 주도록 하겠습니다 , 자, 그럼 그 다음에 요런 식으로 우리가 Session 이라는 걸 , 이렇게, 만들어 줬었습니다 Session을 만들어 줬는데 이제는 그냥 하나만 연결을 한다고 가정을 하는 게 아니기 때문에 , 이렇게, 스택 메모리에다가 만들지 않고 힙에다가 얘를 만들어 주도록 할게요 동적할당을 해보도록 하겠습니다 그냥 , 이렇게, New Session , 이렇게, 그 다음에 이거 대문자죠. new Session 그 다음에 Session의 Socket을 Client Socket으로 , 이렇게, 바꿔치기를 해서 연동을 해주고 , 자, 그 다음에 뭐 나중에 가면은 이 Session을 그냥 어... 아무데서도 잊혀진 상태로 관리하는 게 아니라 이 Session끼리 모아가지고 누군가가 들고 있게 되겠죠. 그러니까 , 일단은, 뭐 그거를 약간 묘사해보기 위해서 뭔가 SessionManager라는 벡터를 하나 , 이렇게, 위에서 만들어 주도록 할게요. Session Manager 얘가 말 그대로 모든 Session들을 다 들고 있는 형태로 나중에 동작하게 될 겁니다 , 자, 그래서 얘를 , 일단은, 여기다가 Push Back을 해가지고 이 Session을 그냥 얘가 포인터 형태로 그냥 들고 있도록 할게요 , 자, 그래서 여기서 이제 들어왔으면 클라이언트 커넥티드까지 뜬거고 클라이언트가 정성적으로 접촉했다 라고 볼 수가 있는 거고 , 자, 그 다음에 해야 될 거는 , 자, 여기는 내용을 , 일단은, 싸그리 지워 줄게요 이제 이거랑 좀 흐름이 바뀌는데 클로우 소켓도 여기서 하는 게 아니고요 어 , 일단은, 소켓을 새로운 소켓이 일단 생성이 되었으니까 얘를 컴플리션 포트에 등록을 해줘야 됩니다 얘는 관찰 대상이다 라는 걸 우리가 알려주는 거죠 근데 굉장히 재미있게도 요 함수랑 똑같이 이 함수를 그대로 다시 사용을 할 건데 이제 인자가 바뀌어야 됩니다 이제 두 번째로는 이 컴플리션 포트를 만드는 용도로 활용하는 게 아니라 기존에 이미 만들어진 건 얘를 통해서 접근할 수 있고 이제는 소켓을 말 그대로 등록을 한다 얘를 관철해줘 라는 걸 이제 부탁을 하고 있는 겁니다 , 자, 그럴 때는 맨 처음에 어떻게 하냐면은 클라이언 소켓을 얘를 요렇게 , 일단은, 넣어주게 되구요 아 근데 이거를 일단 핸들이라는 걸로 캐스팅을 해주면 됩니다 그 다음에 두번째로 우리가 넣어줄 컴피션 포트에 핸들을 또 넣어주게 되는데 요 위에 있는 iocp 핸들이라는 걸 여기다가 , 이렇게, 넣어주면 돼요 , 자, 그 다음에 세번째 인자로 컴피션 키 이라는 거를 받아주는데 이거는 그냥 우리가 나중에 getq-competition-status라는 걸 호출해가지고 일감을 빼올 때 어떤 애인지를 알기 위한 우리만의 키값을 아무거나 넣어줘도 됩니다. 진짜 아무거나 넣어줘도 돼요. 그러니까 우리는 예를 들면은 세션 주소를 그냥 여기다가 넣어주도록 할게요. 이게 이제 소위 키값입니다. 아무거나 넣어줘도 되는데 나중에 좀 구분할 수 있도록 , 자, ulongptr 이라는 걸 받고 있는데 그냥 세션을 이 주소를 그냥 ulongptr 이라고 캐스팅 해가지고 얘를 그냥 그대로 정수를 그냥 넣어주도록 하겠습니다. 그 다음에 number of concurrent thread 는 이제 실제로 이제 iocp 가 어 iocp 한테 이제 활용할 최대 thread 를 우리가 입력을 할 수 있는데 그냥 0 으로 입력을 하면은 최대 코어 개수만큼이 활당이 되니까 그냥 0 으로 이제 입력해도 됩니다 근데 그렇다고 해 가지고 얘가 자동적으로 thread 를 생성해 주는 건 아니고 우리가 thread 를 생성해 가지고 나중에 get queue completion status 로 이제 컴피션 포트를 우리가 체크를 하는 방식으로 동작을 하게 될 거에요. 이건 좀 많이 헷갈리는데 일단 완성된 코드를 보면 굉장히 단순합니다. 그래서 이거는 어디 가냐면 그냥 0으로 입력하면 된다고 일단 볼 수가 있는 거죠. 그 다음에 여기서 맨 처음에 우리가 이제 관찰 대상이다 라는 걸 , 이렇게, 등록을 해놨지만 실질적으로 Receive 자체는 여기서 최초 한 번은 호출을 해줘야 됩니다. WSA 리시브를 호출해줄 것인데 얘는 클라이언트 소켓이랑 WSA 버프는 똑같이 만들어줄 거에요 WSA 버퍼는 Session의 리시브 버퍼로 연결해줄 것이고 WSA 버퍼의 Lens는 버프 사이즈로 똑같이 만들어 주도록 하겠습니다 그 다음에 Deward Receive Length 그 다음에 Deward Flag 얘는 고대로 다시 넣어줘야 되니까 , 이렇게, 만들어줄 것이고 버퍼는 , 일단은, 한 개만 받아줄 것이고 Receive Length를 넣어줄 것이고 그 다음에 Flag를 , 이렇게, 넣어줬습니다 그 다음에 두 개의 인자가 굉장히 중요한데 일단 첫 번째로 Overlapped Pointer를 받아주고 있다는 걸 볼 수가 있습니다 그런데 우리가 이전에서는 여기서는 Overlap 자체를 Session 에다가 넣어 놨지만은 이번에는 얘를 따로 빼 가지고 별도의 Struct를 하나 만들어 줄게요 그 이유는 이제 이어서 설명을 드릴 건데 Overlap Extended 라는 의미로 EX 라고 붙여 가지고 얘를 , 일단은, 이쪽에다가 , 이렇게, 옮겨 주도록 할게요 그 다음에 나중에 가면은 우리가 write, read과 관련된 굉장히 다양한 입출력 함수를 호출하게 되겠죠? read, write, accept, connect 등등 그렇기 때문에 이제 어떤 거를 우리가 실질적으로 호출하고 있는지를 구분하기 위해서 여기다가 뭐 이런 식으로 타입이라는 변수를 두도록 할게요 즉 read, write, accept, connect 등등을 이제 얘가 담게 될 겁니다 요 IOType을 얘가 지금 의미하는 거죠 그래서 요렇게 , 일단은, 만들어 준 다음에 이제 다시 쭉 내려가 가지고 살펴보면은 애당초 우리가 Session 여기다 이제 뭐 이 컴플리션, 그러니까 LP 오버레프트에다가 우리가 사실상 얘가 인자로 받는 것 자체는 이 SS의 오버레프트의 주소를 받는다고 했지만 애당초 얘를 첫번째 변수로 만들어가지고 우리가 원하는 객체를 넘겨줄 수 있다고 했었죠 그래서 지난 시간에는 우리가 Session을 넘겨주긴 했습니다 근데 이번에 그렇게 하지 않는 이유는 Session은 애당초 키값으로 등록이 되어가지고 어차피 여기서 넘겨주고 있어요 그러니까 얘도 넘겨줄 수 있고 여기에 있는 이 LP Overlap을 통해 가지고도 또 데이터를 한 번 더 넘겨줄 수 있다는 얘기가 되는 거죠. , 이렇게, 두 번에 걸쳐서 넘겨줄 수 있는데 이 부분은 , 일단은, 지금은 왠지는 모르겠지만 이 Overlap 구조체를 만들어가지고 넘겨주도록 하겠습니다. Overlap Extended 오벌레프트 EX , 자, 얘도 , 일단은, 동적 칼당을 해가지고 넘겨주도록 할 거구요 왜냐면은 이제 1대1 대응이 아니라 클라가 여러개가 들어올 수 있기 때문에 스택 메모리를 활용하지 않고 , 이렇게, 동적 칼당을 해가지고 걔를 그대로 넘겨주게 될 거에요 , 자, 그 다음에 여기다가 지금은 우리가 이번 테스트는 그냥 간단하게 리드만 할 거지만 나중에 가면은 리드뿐만 아니라 라이트도 있을 수 있고 다양한 상황에 대한 그 오버랩드 객체를 만들어주게 될 겁니다 오늘은 , 일단은, 얘만 , 이렇게, 넘겨주면 되겠죠 여기다가 이 오버랩드 주소를 넘겨주면 되고 그 다음에 마지막 인자 같은 경우에는 원래는 우리가 이전 시간에 이게 컴피션 루틴이라고 해가지고 콜백 함수를 넘겨줬는데 콜백 함수는 딱히 사용 안 할 거니까 그냥 null로 , 이렇게, 채워주면 됩니다 그래서 대충 이제 모습이 요렇게 된다고 보시면 되겠어요 , 자, 요렇게 , 일단은, 될 것이고 그러면은 이 ws의 리시브가 바로 호출이 완료가 될 수도 있고 아니면은 펜딩 상태가 걸려가지고 나중에 완료가 될 수도 있기는 해요 두가지 상황이 있었죠 근데 어찌됐건 우리가 맨 처음에 이 해당 소켓을 관찰해 달라고 어 여기 이제 이 컴플리션 포트랑 , 이렇게, 연동을 시켜놨죠 그러기 때문에 실질적으로 이 컴플리션 포트를 관찰하게 되면은 우리가 등록한 소켓이 소켓에 해당하는 리스이브나 샌드가 완료가 되었다는 통지가 , 일단은, 그 IOCP를 통해 가지고 오게 될 겁니다 근데 물론 그게 자동으로 오는 건 아니고 우리가 관찰해 가지고 완료가 되었는지 여부를 체크를 해야 됩니다 , 자, 그렇기 때문에 지금 , 일단은, 메인 스레드 같은 경우는 딱 여기서 끝낼 건데 얘가 하는 역할은 결국에는 새로운 소켓 입장을 받아 준 다음에 최초로 한번 Receive를 빵 호출하고 얘 역할은 끝나게 되는 겁니다 즉 Receive를 걸어줬지만 그 다음에 완료 여부는 얘가 체크를 하지 않고 그냥 뭐 알아서 다른 클라이언트를 이제 받아주러 간다는 얘기가 되는 거죠 , 자, 요런 식으로 이제 동작을 하게 될 거예요 그러면은 이제 나머지 Receive 처리는 그럼 누가 하느냐 이제 별도의 Thread에서 이거를 처리해주게 될 겁니다 , 자, 그래가지고 여기서 새로운 스레드가 실행할 메인 함수를 만들어 주도록 할건데 워커 스레드 메인이란 함수로 만들어 줄 것이고 어... 그 다음에 여기서 핸들을 일단 하나를 받아주는 형태로 만들어 주도록 할게요 , 자, 요 스레드 같은 경우는 그냥 어... 우리가 실행할 스레드이기 때문에 뭐 함수의 모양 자체는 이 시그니처는 그냥 우리가 멋대로 정해도 상관없습니다 그냥 우리가 실행할 함수를 지금 정의를 하고 있는 거예요 그래서 여기서 이제 얘가 일감을 실행을 할 것인데 결국에는 이쪽에서 처음에 컴플리션 포트를 생성한 다음에 여기서 워커 스레드라는 애들을 만들어 주게 될 겁니다 일을 하는 스레드다 이거죠 그래서 이 스레드들의 역할은 컴피션 포트를 계속 관찰하면서 완료된 입출력 함수가 있는지를 체크해가지고 입출력 함수가 완료가 되었으면은 그거를 이어가지고 완료된 결과물을 받아가지고 호출하는 그런 역할을 해주게 될거에요 , 자, 그래서 얘네들 , 일단은, 한 스레드를 5개만 만들어 보도록 할건데 우리가 원래 사용하던 라이브러리로 G스레드 매니저의 런치를 통해가지고 그냥 런칭을 해 보도록 할게요 , 자, 그 다음에 여기서 람달을 이용해가지고 , 이렇게, 워커 스레드 메인을 호출해줄건데 IOCP 핸들을 그대로 복사를 해줘가지고 요 핸들을 복사해줘가지고 얘를 이용해가지고 워커 스레드 메인이 호출이 되게끔 유도를 해주도록 하겠습니다 , 자, 그 다음에 G스레드 매니저 조인을 여기 아래에다가 넣어줄 것인데 뭐 지금은 어차피 여기서 무한 루프를 돌고 있으니까 딱히 필요 없긴 한데 뭐 항상 세트로 만들어주는게 좋으니까 , 이렇게, 일단 만들어 봤구요 그럼 이제 여기서 컴피니션 포트를 만든 다음에 워커 스레드들을 실행 해결해주고 별도의 스레드들이 이제 열심히 열심히 일을 하게 될 겁니다. 그 다음에 얘네들이 하는 역할은 말 그대로 이 컴피니션 포트 핸들을 받아가지고 get queued completion status라는 함수를 호출해가지고 뭔가 완료된 일감이 있는지를 계속 체크를 하게 될 거예요. 근데 물론 얘네들이 이제 뭐 계속 체크를 한다고 해서 이게 뭐 성능적으로 엄청 부하가 되고 이런 건 아니고 여기다가 옵션에 따라 가지고 대기 시간을 넣어줄 수 있는데 만약에 대기 시간을 무한대로 넣어주면은 그냥 우리가 이벤트를 사용하던 것처럼 얘가 대기 상태가 되어 가지고 일감이 있을 때까지 딱히 일을 하지 않고 가만히 있다가 실질적으로 뭔가 어떤 일감이 떨어져 가지고 완료가 되면은 쓰레드 하나를 이제 운영체제가 깨워 가지고 일을 시키게 될 겁니다 , 자, 그래가지고 여기서 이제 사용하는 걸 보면은 여기다가 처음에 iocp 핸들을 넣어주게 될 거고요 그 다음에 두 번째 인자로 number of bytes transferred 즉 전송되거나 받은 어... 송소신된 그 바이트를 지금 의미한다고 볼 수가 있겠죠 그러니까 이거를 bytes transferred라는 요런 변수로 받아주도록 할 것이고 , 자, 그 다음에 , 일단은, 받아줄 인자들을 다 일단 만들어주도록 할게요 session도 받아줄 것이고 overwrapped ex라는 요 어.. 오버랩트 구조체도 받아줄 것이고 얘네들을 이제 넣어주게 될건데 두번째로는 , 일단은, 바이츠 트랜스퍼드를 요렇게 넣어줄 것이구요 , 자, 인자가 좀 많으니까 엔터를 눌러가지고 다음줄에 하면 할건데 그 다음에는 얘가 받아주는게 컴피션 키에 이제 컴피션 키를 받아준다는 걸 볼 수가 있습니다 근데 이 컴피션 키는 우리가 멋대로 정해줄 수 있었다고 했었죠? 여기서 처음에 크리에이트 컴핀션 포트를 이용해서 소켓을 등록할 때 해당 소켓에 대한 키값을 우리가 , 이렇게, 설정할 수 있었는데 그거를 , 일단은, 세션 주소를 우리가 입력을 했으니까 얘를 고대로 다시 복원을 시켜주도록 하겠습니다 그래가지고 , 이렇게, Session Pointer를 만들어 놓은 다음에 New Long PTR Pointer라고 해가지고 Session 이라고 해가지고 그 해당 숫자를 다시 요기 세션에다가 복원을 시켜달라고 지금 요청을 하고 있는 겁니다. 요 포인터가 하나 빠진 것 같네요. 유롱ptr 네 , 이렇게, 되어있는데 그냥 유롱ptr 포인터로 , 일단은, 받아주시면 되겠습니다. 포인터의 약자죠 이게 앞에 , 자, 그래가지고 여기서 결국에는 요 세션을 우리가 정수로 넣어준 킷값을 다시 복원을 받아가지고 이 주스에다가 , 일단은, 다시 복원을 시켜달라고 한 거고 그렇게 되면은 그 주소값이 다시 이 세션에 들어가게 되니까 얘가 이제 그대로 복구를 할 수가 있게 될 거예요 그런 형태로 이제 킷값을 사용할 수가 있습니다 그 다음에 이어가지고 LP OVERLAPPED라는 것을 받아주고 있는데 얘도 마찬가지로 LP OVERLAPPED 포인터 형태로 요렇게 , 일단은, 다시 받아주도록 할게요 마지막 인자는 무한대기를 하겠다고 INFINITE를 요렇게 입력을 해주면 되겠습니다 즉 어... 유심히 보면 사용하는 게 굉장히 간단해요. 그냥 어떤 컴플리션 포트인지를 먼저 입력을 해주고, 송출신된 바이트 개수는 얼마인지를 반환해주기 위해서 바이트 트랜스퍼드를 넘겨주고, 그 다음에는 키값이랑 우리가 넘겨준 오버랩트 포인터를, 주소를 다시 , 이렇게, 받아올 수 있다는 걸 볼 수가 있습니다. 그러면 결국은 R에서 세팅한 세션이랑 오버랩트를 다시 고대로 , 이렇게, 복원을 시켜줄 수 있다는 얘기가 되는 거죠. 그럼 이어가지고 여기서 원래 이제 쿨쿨 잠자면서 쓰레드가 대기를 하게 될텐데 만약에 이제 진짜로 어떤 일감이 완료되어 가지고 뭐 리시브나 샌드나 뭐 어떤 그런 네트워크 이벤트가 완료가 되어 가지고 실질적으로 일감이 생겼다 싶으면 원래는 우리가 이전 시간에서는 그 APCQ에 들어갔던 내용과 유사하게 그게 이제 실질적으로 이 IOCP에 있는 IOCP에서 지금 관찰하고 있는 쓰레드를 하나를 깨워가지고 걔가 이제 실행이 될 겁니다 다시 이제 이어서 빠져나온다는 얘기가 되는 거죠 그러면 여기서 일단 체크해야 되는 거는 뭐 , 일단은, 진짜 뭐 문제가 없는지 리턴이 false 이거나 아니면은 bytes transferred가 0 인지를 체크해 가지고 만약에 요런 상태라고 하면은 얘가 일단 불리언을 리턴합니다 문제가 일단 없는지 간단하게 체크해 가지고 만약에 뭐 연결이 끊겼다거나 하는 등등의 상황이 있으면 얘를 이제 처리를 해주면 될 것입니다 , 일단은, 뭐 간단하게 그냥 컨트롤 했는데 여기서 이제 나중에 서버 엔진에서는 이거를 좀 정식으로 처리를 해줄 것이고 그 다음에 이제 여기서 얘를 세션이랑 오버랩트를 복원시켜줬으니까 여기서 일단 얘를 살펴볼 수가 있겠죠 이 타입이 무엇인지 지금은 우리가 리드밖에 안 넣어놨으니까 사실은 리드밖에 뭐 안 들어있긴 할 겁니다 진짜 리드인지 한번 체크를 그냥 하고 넘어가도록 합시다. 나중에 가면은 그래서 여기서 if-else나 switch-case를 이용해가지고 여기서 요청한 타입이 뭐인지 따라가지고 리드인지 라이트인지 등등을 따라가지고 처리를 하는 식으로 이제 만들어주면 돼요. , 자, 그래서 여기서는 뭐 지금은 우리는 항상 리드만 할 것이니까 receive-data-iocp 라고 해가지고 얼마의 바이트를 받았는지를 그냥 출력을 하고 마치도록 할게요 , 자, 근데 여기서 그냥 요렇게만 끝내주면은 이제 문제가 되는게 뭐냐면은 우리가 맨 처음에 연결을 받아주면은 요 리시브를 한번 예약을 해줬습니다 즉 리시브를 걸어줬다고 제가 표현을 했죠 걸어준 다음에 당장 완료가 되거나 나중에 완료 되거나 어느 시점에 완료가 되면은 이제 어떤 스레드가 깨어나가지고 일을 계속 처리해주게 될텐데 , 이렇게, 일을 다 처리해준 다음에 반드시 이어가지고 또 리시브를 하고 싶다고 하면은 여기서 했던 것과 마찬가지로 요 부분을 일단 복붙해가지고 다시 위로 가서 요 부분을 한 번 더 똑같이 호출해줘야 됩니다 이런 패턴으로 이제 계속 코드가 만들어지게 될 거예요. 이건 지난 시간에도 제가 살짝 언급을 드린 적이 있었죠. 콜백 함수에서 이 리스브를 다시 한번 호출해준다. 그래야지만 이제 이 리스브가 또 걸려가지고 우리가 예약을 한 게 또 진행이 되어 가지고 또 데이터가 오면은 리스브가 처리가 완료되어 가지고 역시나 대기 타고 있던 쓰레드 하나가 깨어나서 Get Cued Confusion State에서 빠져나와서 또 계속 이런 식으로 반복해서 처리할 수 있다는 얘기가 되는 거죠 그래서 최초로는 여기서 한번 걸어준 애로 인해 가지고 요 부분이 호출이 되겠지만 그 다음에는 얘가 직접적으로 다시 한번 Receive를 , 이렇게, 걸어주는 식으로 왔다 갔다 하면서 동작을 하게 된다고 보시면 되겠습니다 그래서 제가 이전에 만들었던 C샵 서버 강의에서도 , 사실, 이런 패턴으로 우리가 작업을 하게 됐었는데 제가 흔히 그걸 약간 낚싯대의 비유를 했어요 낚싯대를 물에 던져준 다음에 기다렸다가 뭔가 입질이 왔으면 그걸 다시 끌어올려서 물고기를 잡은 다음에 그 다음에 낚싯대를 한 번 더 다시 물속에 던져줘야지만 이어서 낚시를 할 수 있었죠 그러니까 이게 사실상 낚싯대를 던지는 행위랑 굉장히 유사한다고 볼 수 있는 거죠 일단 행동을 걸어준 다음에 완료가 되면은 일처리를 하고 다시 낚싯대를 던지는 요런 느낌으로 이제 이해를 해주시면 되겠습니다 , 자, 그 다음에 여기서 소켓은 여기 세션에 소켓을 통해 가지고 우리가 접근할 수 있었죠 이걸 이용해 가지고 복원을 시켜주고 이 오버랩트 같은 경우에는 뭐 새로 만들어 줄 필요는 없었고 얘는 일단 그대로 사용하지 않을 것이고 애당초 우리가 이 오버랩트 EX에서 여기서 그냥 받아온 거를 그냥 고지 그대로 다시 전달을 해주도록 하겠습니다 만약에 여기서 뭐 리시브가 아니라 샌드라거나 다른걸 하고 싶다고 하면은 이 오버랩트 구조체를 다시 동적할당을 해줘가지고 타입을 바꿔준 다음에 다시 넘겨주는 형태로 동작을 시켜주면 될겁니다 그리고 기존에 사용하던거는 재사용할게 아니라면 메모리 해제를 시켜주는 식으로 만들어주면 되겠죠 , 자, 요렇게 해가지고 간단하게 , 일단은, 컴피션 포트 모델로 만들어봤습니다 이 콜백은 필요 없으니까 삭제를 하도록 하고 , 자, 그래가지고 결국에는 이 Overlapped EX랑 Session을 분리해줘서 이걸 따로 관리한 이유가 나중에 가면은 우리가 네트워크 입출력 함수, read, write 등등을 사용할 때 어떤 사유로 얘를 했는지를 구분을 해주기 위해서 , 이렇게, 분리를 해준 겁니다 지금은 굉장히 단순하게 WS-RECEIVE를 한 번만 뺑! 호출해주고 있지만 경우에 따라가지고 얘를 여러 번 호출한다거나 아니면은 SEND를 한다거나 아니면은 뭐 ACCEPT-EX 같은 비동기 ACCEPT를 한다거나 하는 굉장히 다양한 그런 함수들을 호출할 수 있겠죠 그러니까 그때마다 내가 어떤 사유로 걔를 호출했는지를 알기 위해서 이런 식으로 TYPE을 여기다가 넣어주기 위해서 , 이렇게, 만들어 준 겁니다 반면 SESSION은 처음에 클라우드 소켓을 만들어줄 때 한 번만 , 이렇게, 연결을 해주면 되겠죠 , 자, 그렇게 해가지고 , 이렇게, 완료가 되었으면은 이제 여기 더밀 클라이언트랑 게임 서버를 같이 한번 구동을 시켜 보도록 하겠습니다 뭐 , 사실, 얘가 뭐 어마어마한 일은 하는 건 아니고 그냥 계속 데이터를 받은 다음에 로그를 찍어주고 계속 데이터를 받는 식으로만 이제 동작을 잘 해주면 되겠습니다 , 자, 빌드를 다시 , 이렇게, 해가지고 실행을 해보면 크래넌트가 데이터를 보내고 게임 서버가 정상적으로 데이터를 받는 이런 굉장히 단순한 작업까지 , 일단은, 잘 된다는 걸 확인을 했어요. 그리고 이걸 네트워크 라이브러리를 만들면서 계속 연구를 하게 되겠지만 이 흐름을 잘 이해하는 게 굉장히 중요합니다. 결국에는 다시 유압을 해보면 약간 중앙 관리자 같은 아이의 역할을 해주는 이 컴피션 포트라는 거를 생성을 해준 다음에 그 다음에 소켓을 만들자마자 이 소켓은 관리 대상입니다 라고 컴피션 포트에다가 얘를 다시 등록을 시켜줬고요 그 다음에 최초 한 번으로는 이런 식으로 wsa-receive 비동기 수신을 한번 , 이렇게, 걸어줬습니다 그러면 얘가 이제 당장 완료가 될 수도 있고 안 될 수도 있겠지만 당장 되건 아니면 나중에 완료가 되건 어찌됐건 완료 통지는 여기서 정상적으로 GetQueueCompletionStatus를 통해서 받아줄 수가 있어요 그래가지고 나머지 스레드들은 아까 메인 스레드 제외한 나머지 스레드들은 여기서 계속 루프를 돌면서 이제 일감이 있는지를 계속 대기를 타면서 지금 , 이렇게, 기다리고 있는 거죠 그래가지고 진짜로 완료가 되면은 운영체제가 내부적으로 스레드 하나를 빵 깨워가지고 이제 이를 이어서 나머지 코드들이 실행되게끔 이제 여기서 빠져나와가지고 실행하게끔 유도를 해주게 될 것이고 여기서 우리가 기존에 사용했던 기존에 넘겨줬던 킷값이랑 오버랩트 구조체 이 두가지를 이용해가지고 정보를 복원시켜 준 다음에 그 다음에 이제 나머지 코드를 빵 진행하면 된다라고 불서 있는 거고 여기까지는 이제 굉장히 단순하죠 그리고 실질적으로 이제 여러분들이 뭐 네트워크 책 같은거 tcp 소켓 프로그래밍 뭐 이런 책들을 보면은 대충 코드가 여기까지 밖에 만들어지지 않습니다 물론 여기다가 이제 뭐 에코 방식으로 어 받은 다음에 다시 샌들을 하는 식으로 만들어 지을 수는 있겠지만 기본적으로 그냥 , 이렇게, 만들어 준 다음에 이제 알아서 응용해 보세요 라고 우리한테 던져 주게 돼요 그래서 저도 이제 책을 보고 여기까지 학습을 한 다음에 나중에 이제 게임 서버를 만들기 위해서 이걸 좀 이제 확장해 나가면서 만들어 봤는데 전혀 예상하지 못하던 문제들이 하나 둘씩 발생을 했었습니다 그래서 이건 전 솔직히 진짜 지금도 굉장히 억울해요 이런 걸 왜 책에서 말을 안 해줬는지 모르겠는데 결국에는 여기서 지금 문제 상황이 하나가 있습니다 그러니까 이게 완전히 어... 괜찮은 코드는 아니고 이게 나중에 가면 처리해야 될 문제가 한 가지가 있는데 그게 뭐냐면은 , 일단은, 멀티스레드 문제는 아닙니다 예를 들면 지금 혹시 여기 락을 잡아야 되는 거 아닌가요? 라는 생각은 하실 필요가 없는 게 내부적으로 얘가 멀티스레드에서는 안전하게 동작을 하기 때문에 그런 문제는 아니에요 그냥 하나의 스레드만 깨어나게 될 겁니다 한 번에 한 번씩만 그건 문제가 아닌데 이제 진짜 문제되는 상황은 뭐냐면 이 상황인 거죠 우리가 여기서 넘겨주고 있는 인자들을 유심히 보면은 킷값으로 세션을 넘겨줬죠. 세션의 주소를 넘겨줬고 그 다음에 오버랩트의 주소도 여기다가 넘겨줬습니다. 이 두가지 정보를 우리가 넘겨주고 있어요 지금 그런데 이 세션을 만약에 우리가 여기서 , 이렇게, 연결을 해준 다음에 만약에 이 세션이 날라가면 어떨까요? 그러니까 어떤 유저가 게임에 접속을 했다가 뭐 이런저런 행동을 하다가 게임에 나가가지고 우리가 이 세션을 이제 삭제해야 되는 상황이 있다고 가정해봅시다. , 자, 그거를 간단하게 묘사를 해보기 위해서 지금 그냥 여기서 리시브를 그냥 예약을 해준 다음에 여기서 제거를 해주도록 할게요 다시. 세션 매니저에서 에고 세션 매니저에서 백을 해가지고 마지막 얘를 그냥 다시 꺼내가지고 팝백을 한 다음에 그 다음에 딜리트를 해주도록 할게요 물론 지금 요 S라는 것 자체가 이 세션을 얘기하고 있는 건데 지금 몰랐다고 가정을 하고 그냥 마지막 세션을 꺼내 가지고 삭제하는 식으로만 , 일단은, 동작을 시켜보도록 합시다 여기서 이제 뭐 유저가 유저가 뭐 게임 접속 종료를 했다라는 뭐 이런 등등의 상황이 있을 수 있는 거죠 그렇게 되면은 지금 이제 굉장히 아리달송해진게 사실상 우리가 넘겨준 요 세션은 이미 메모리가 해제가 되었죠 근데 우리가 여기 넘겨준거는 애당초 요 주소를 지금 그냥 고지곳대로 넘겨줬기 때문에 사실은 이 주소가 더이상 유효하지 않은 주소가 되는 겁니다 마찬가지로 요 오버랩도 마찬가지로 뭐 어떤 이유에 인해가지고 얘가 , 이렇게, 우리가 넘겨준 요 주소가 나중이라도 날라가게 된다면 당연히 똑같은 문제가 이제 일어나게 되는 거죠 그래가지고 제가 이제 포트폴리오를 만들면서 여기서 이제 계속 크래시가 났어요 그러니까 게임이 잘 동작하는 것 같았는데 누군가가 나가면은 이상하게 엉뚱하게 여기서 막 계속 크래시가 난다거나 하는 일이 발생했는데 이런 이유 때문에 발생한 겁니다 그래가지고 결국에는 저는 이걸 끝까지 진짜 오랫동안 찾지 못했어요 이 문제라는 걸 상상도 못했던 거죠 지금까지 배웠던 메모리나 멀티셰드와 관련된 걸 이 네트워크 쪽에서는 연결을 해가지고 생각할 생각을 아예 못한 겁니다 그래서 나중에 우리가 다음 시간부터 네트워크 라이브러리를 만들 때는 이런 부분도 같이 처리를 해줘야 되는데 결국에는 이 컴피션 포트 등록을 해줘서 이제 얘를 등록을 해준 다음에 우리가 리시브나 샌드 같은 이런 입출력 함수를 하나라도 걸어주는 순간에 절대로 그 세션은 날리지 못할도록 막아줘야 됩니다 그럼 이제 이것을 어떻게 막아줄 것이냐 가장 간단한 방법은 우리가 이전에 배웠던 레퍼런스 카운팅을 해주는 거죠 스마트 포인터건 어떤 식으로든 레퍼런스 카운팅을 해 줘 가지고 여기서 리시브를 걸어 주게 되면 여기다가 맨 앞에다가 레퍼런스를 무조건 1 증가시키는 형태로 절대로 당장은 메모리에서 날릴 수 없도록 뭔가 보장을 해 줘야지만 이게 정상적으로 돌아간다는 그런 결론을 얻을 수가 있는 겁니다 근데 막상 이 부분을 실행을 해주면 얘가 크래시가 나면 굉장히 다행이겠지만 의외로 얘가 크래시가 나지 않고 그냥 얘가 더 이상 실행이 안 되는 식으로 지금 동작을 합니다 뭔가 좀 이상하죠? 근데 이걸 다시 브레이크 포인트를 잡아보자면 이게 왜 지금 크래시가 안 나는지를 살펴보면 여기서 , 일단은, 일로 왔는데 뭐 별다른 문제가 없어 보이기는 한데 이 세션을 보면 에덩초 굉장히 이상한 값들이 들어가 있는 걸 볼 수가 있습니다 왜냐면 에덩초 그 메모리가 날라간 상태이기 때문에 이제 완전히 쓰레기 값들이 여기다가 들어가 있는 상태가 된다는 거죠 16진수로 볼까요? 뭔지 궁금한데? 디디디디디디디 뭐 이상한 값이 들어가 있다는 걸 볼 수가 있습니다 근데 그게 이제 당장 크래시가 안 나고 이런 식으로 자연스럽게 그냥 넘어갔으니까 , 사실, 이상한 속기 값을 우리가 넘겼으니까 이게 문제가 당장 크래시가 안 난 거지만 경우에 따라서 크래시가 날 수도 있고 안 날 수도 있고 이거는 이제 그때마다 다르겠죠 , 이렇게, 오염된 메모리로 인해 가지고 다른 데서 크래시 나는 게 진짜 더 끔찍한 문제라고 제가 말씀을 드린 적이 있습니다 그래서 이게 지금 대표적으로 그런 상황이라고 볼 수가 있는 겁니다 그래서 오늘 그 결론을 내릴 수 있는 게 킷값이나 오버랩트 같은 걸 넘겨줄 때 얘네들을 반드시 예약을 해줬으면 다시 꺼내 써서 이쪽에서 뭔가 삭제를 했으면 했지 누군가가 멋대로 이미 걸어준 상태에서 삭제를 해주지 못하게 무조건 막아야 된다라는 그런 결론을 얻을 수가 있는 거고 참고로 지금은 여기서 크래시가 안 났지만 우리가 이런 날을 위해서 만들어준 엄청난 기능이 있었죠? , 자, 얘를 이제 xnew로 바꿔가지고 아니 얘 말고 위에 있던 이 session을 session을 new가 아니라 xnew로 만들어 보도록 합시다 , 자, 우리의 이제 그 메모리 체크를 하기 위한 어디 있었나요? 여기 타입 쪽에다가 정리했던 것 같은데 , 자, 스톰프 얼로키터를 켜주도록 합시다 짜잔 하고 , 자, 그래서 스톰프 얼로키터를 켜줘가지고 이제 버그가 일어나는 상황을 받아주게 될건데 , 자, 엑스뉴가 지금 안되는게 메모리 헤더가 추가가 전용으로 안됐나보네요 일단 메모리 헤더를 다시 추가해주고 여기서 스톰프 얼로케이터를 적용시켜서 U를 해준 다음에 삭제를 할 때는 X Delete를 이용해서 삭제를 하는 식으로 , 이렇게, 만들어 주면은 그리고 여기서 실행을 해보면 세션에서 접근을 해서 사용하는 순간에 여기서 바로 크래시가 난다는 걸 볼 수가 있습니다 뭐 , 이렇게, 해가지고 , 이렇게, 라이브러리를 만들 때는 어지간해서는 스톰프 얼로케이터를 켠 상태에서 만들면 이런 버그들을 잘 잡아주니까 굉장히 편리하다는 걸 한 번 더 확인을 할 수가 있었고요 오늘 일단 중요했던 내용은 당장 레퍼런스 카운팅 문제가 있다는 것도 일단 알게 되었고 그 다음에 나머지 이 IOCP를 사용하는 거에 대해서 , 일단은, 알아봤습니다 근데 사실은 뭐 이전에 배웠던 오버랩드 모델이랑 굉장히 사용하는 함수들이 겹치는 게 많죠? 이 WSA-SEND, WSA-RECEIVE 등등은 다 공용으로 활용할 것이니까 결국에는 CREATE-IO-CONFIGURATION-PORT랑 Q-CONFIGURATION-STATUS 이 두 개만 , 일단은, 추가적으로 알면은 , 사실, 사용하는 데는 크게 어려움이 없다는 걸 볼 수가 있습니다 그리고 대부분 한국에서 만드는 특히 윈도우즈 서버 기반으로 만드는 MMO 같은 경우에는 이 IOCP 모델을 이제 활용해 가지고 만드니까 이걸 이제 두고두고 굉장히 유용하게 활용을 하시게 될 거라는 것도 , 일단은, 미리 말씀을 드리면 좋을 것 같네요. 이래가지고 간단하게 IoCP에 대해서 알아봤고 이런 문제는 , 일단은, 잠시 주석 처리를 다시 해놓고 이제 이어서 다음 시간부터 네트워크 관련된 이 내용을 좀 종합해가지고 우리의 네트워크 라이브러리를 다시 한번 처음부터 쌓아 올리는 식으로 진행을 해보도록 하겠습니다.