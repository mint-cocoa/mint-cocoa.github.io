이제 지난 시간에 이어가지고 컴퓨터 구조 특히나 CPU 파이플라인에 대한 내용에 대해서 알아볼 건데요 PPT를 보기 전에 이번 시간에는 거꾸로 실습부터 하고 PPT로 넘어가도록 할게요 그러니까 문제 상황부터 먼저 알아보고 넘어가는 그런 순서로 진행을 해보도록 하겠습니다 사실은 여러분들이 멀티스레드를 공부를 하면서 조금씩 느끼시겠지만 지금까지 여러분들이 알던 프로그래밍 세계랑은 은근히 다르게 동작하는 부분이 많습니다 기존에 내가 알던 고정관념을 다 내려놓지 않으면 , 사실, 멀티스레드와 관련된 부분들이 굉장히 충격적으로 다가올 수가 있다는 얘기가 되는 거죠 , 자, 그건 그렇고 이제 오늘 할 실습은 제가 이전에 C샵 서버 강의에도 똑같은 실습을 해봤는데요 그걸 이제 똑같이 그냥 다시 한번 진행을 해보도록 하겠습니다 일단 변수가 여러가지가 있는 상황이에요 x, y, r1, r2 얘네들은 이제 result의 약자로 r1, r2라고 일단 이름을 지었습니다 , 자, 그 다음에 thread 1번이라고 해가지고 첫번째 thread가 실행할 것은 굉장히 단순한데 y는 1이라고 , 이렇게, 대입을 해줄 것이고요 y를 스토어를 하는 거라고 하고 그 다음에 x의 값을 r1에다가 넣어줄 겁니다 얘는 말 그대로 x의 값을 로드를 한다 꺼내 쓴다라는 상황이 되는 거죠 그리고 마찬가지로 두 번째 스레드도 굉장히 비슷한 작업을 할 건데 얘는 거꾸로 X를 스토어를 해줄 것이고 X에다가 1을 넣어줄 것이고 그 다음에 Y에다가 그러니까 R2에다가 Y의 값을 꺼내가지고 , 이렇게, 일단은, 넣어주도록 할 겁니다 뭐 굉장히 단순하죠 , 자, 그 다음에 메인 함수에서는 , 이렇게, 무한 루프를 돌면서 계속 뺑뺑이를 돌 건데요 내가 몇 번 지금 시도했는지 카운트를 , 이렇게, 세주도록 하겠습니다 그 다음에 얘가 하는 거는 , 일단은, x, y, r1, r2를 다 0으로 , 일단은, 초기화를 해줄 것이고요. 그 다음에 스레드를 각각 만들어 줄 건데 첫 번째는 뭐 스레드 1을 실행할 것이고 그 다음에 두 번째 스레드는 스레드 2번 함수를 실행을 해줄 것입니다. 그리고 얘네들이 끝날 때까지 조인을 해줘 가지고 대기를 할 건데 그 다음에 요 상황에서 우리가 알고 싶은 상황은 R1이 0이 되고 게다가 R2도 0이 되는 상황이 있는지를 지금 알아보고 싶어요 만약에 있다고 하면 브레이크 포인트로 빠져나오게 될 것이고 없다고 하면은 이제 무한 루프를 돌게 되겠죠 만약에 빠져나왔으면 로그를 한번 찍어 보도록 합시다 몇 번만에 빠져나옴 이라고 , 이렇게, 로그를 찍어주고 마치도록 할게요 , 자, 근데, 어, C++에서 요 쓰레드를 이용해가지고 쓰레드를 만드는 작업이 생각보다 무거운 작업이다 보니까 음, 여기다가 추가적으로 불리언 값을 하나를 둬가지고 불 레디라는 값을 하나 둬가지고 어, 얘네들이 이제 시작하면은 동시에 진행이 되게끔 유도를 해주도록 합시다 레디가 펄스 일 동안에는 계속 뺑뺑이를 돌면서 일단 잠시 대기를 요렇게 해주도록 할게요 그래서 혹시라도 컴퓨터가 최적화를 하지 말아 달라고 일단 볼라티를 붙여 줬구요 그리고 아래에서 이제 여기 루프를 돌 때 먼저 레디를 first로 꺼내온 다음에 스레드가 다 만들어졌다고 하면은 여기서 이제 시작하고 레디를 2로로 켜 주도록 하겠습니다 약간 타이밍 이슈를 조금 더 우리가 조절을 직접 한 셈이 되는 거죠. 레디를 둬가지고 조금 기다렸다가 동시에 시작을 하게끔 유도를 해준 겁니다. , 자, 그럼 이 상황에서 , 일단은, 코드를 한번 실행을 해볼게요. 실행을 해보면은 , 자, 여러분들 이제 환경에 따라가지고 이거는 조금씩 달라질 수가 있는데 저같은 경우는 뭐 지금 오른쪽 화면을 보니까 3,000번 정도에 빠져나오고 있습니다. 물론 이게 몇 번만에 빠져나왔는지는 딱히 중요하지 않고요 이게 뭐 5,000번일 수도 있고 아니면 뭐 경우에 따라서 300번일 수도 있고 크게 중요하지 않은데 어쨌든 뭔가가 빠져나온다는 게 지금 중요한 거죠 , 자, 근데 뭐 그건 그렇고 이게 빠져나오는 게 왜 이상한지 다시 한번 위에 올려가지고 코드를 유심히 살펴보면은 결국엔 둘 다 0이 되었다는 상황이 지금 발생하는 게 있는지가 발생할 수가 있는지가 굉장히 궁금한 거죠 그런데 원래 통상적으로 지금까지 우리가 알던 프로그래밍을 생각을 해보고 그 순서에 맞춰서 생각을 해보면 이게 , 사실, 잘 이해가 안 가는 상황입니다 얘가 거의 동시에 지금 1번이랑 2번이 실행이 된다고 가정해볼게요 그럼에도 불구하고 일반적인 관점에서 보면은 얘랑 얘랑 실행이 될 때 둘 중에 간발의 차이로 먼저 실행이 되는 애가 분명히 있겠죠 그럼 만약에 Y는 1이 간발의 차이로 먼저 실행이 됐다고 하면은 설령 얘가 나중에 실행이 됐다고 하더라도 그 상태에서 Y는 1일 테니까 R2가 분명히 1이 될 겁니다 거꾸로 간발의 차이로 X는 1이 먼저 실행이 된 상황이라고 하면 얘는 설령 그렇다 치더라도 이 부분에 대해서 R1이 1이 돼야지 정상적인 상황이 아닐까라는 생각이 들죠 결국에는 우리가 일반적으로 생각하면 , 사실, R1도 0이고 R2도 0인 상황이 발생하면 안 된다는 얘기가 되는 건데 근데 이게 또 멀티스레드에서 이걸 실습을 해보니까 지금 얘가 빠져나오고 있죠 굉장히 묘하게도 그래가지고 이제 이걸 가지고 고민을 하게 되는 겁니다 , 자, 근데 , 일단은, 이거에 대해서 뭐 이유에 대해서 살펴볼 거고 이걸 해결하는 방법은 굉장히 여러가지가 있는데 그거는 뭐 다음 시간에 메모리 모델에 대한 내용을 좀 다뤄보는 게 좋을 것 같아 가지고 그 해결 방법은 다음에 알아보도록 할 건데 일단 지금 문제 자체가 일어나는 이유는 두 가지 이유가 있습니다 가시성 그리고 재배치 코드 재배치 , 이렇게, 두 가지 측면이 있어요 그래서 , 사실, 문제가 하나가 아니라 두 개가 있다는 얘기가 되는 거죠 심지어 , 자, 가시성은 무슨 얘기를 하고 있는 거냐면은 우리가 바로 이전 시간에 캐시에 대한 내용을 공부를 했습니다 그래가지고 cpu가 어 어떤 값을 쓰거나 아니면 읽을 때 굳이 그때로 메모리 즉 램까지 쪼로록 달려가서 거기에 있는 값을 쓰거나 읽을 수도 있겠지만 100% 확률은 항상 그렇지는 않다고 했었죠 왜냐면 캐시라는 게 존재하기 때문에 만약에 내가 긁어놓은 값이 캐시가 있다고 하면 그냥 캐시 있는 값을 이용해서 작업을 한다고 했습니다 근데 여기서 문제는 뭐냐면 우리가 이전 시간에 본 그림에서도 그랬었지만 CPU에서 각 코어마다 자신만의 캐시를 별도로 가지고 있어요 이제 여기서 약간 멘붕이 오는 거죠 그렇다 하면 이게 어떤 얘기가 되는 거냐면 내가 여기서 만약에 y에다가 1이라는 값을 뭔가 , 이렇게, 썼다고 가정을 해봅시다 혹은 반대쪽에서 이 y의 값을 꺼내 가지고 지금 읽는 상황이 또 있다고 가정해 볼게요 근데 역시나 중간에 캐시라는 애가 개입을 하기 때문에 물론 정확한 정책은 우리가 알 수 없지만 이 값이 진짜로 고지곳대로 메모리에 있는 값을 얘가 불러왔다는 보장도 없을 뿐더러 얘도 마찬가지로 진짜로 램에서 램까지 가서 그 데이터를 썼다는 보장도 없다는 이야기가 되는 거죠 , 사실, 이런 문제가 지금까지 우리가 아무런 생각 없이 모르고 지나쳤었던 이유는 , 사실, 멀티스레드 프로그래밍이 아닌 경우라고 한다면 애당초 그게 아무런 상관이 없습니다 단일스레드 기준으로는 내가 어쨌든 이 값을 썼으면은 다음에 읽을 때는 내가 사용하던 캐시의 분명히 1이라는 값으로 얘가 수정이 되어 있을 테니까 뭐 아무런 문제가 없었지만 이제 이런 식으로 다수의 스레드가 개입을 하는 순간 이게 약간 머리가 어지러워지기 시작을 한다는 얘기가 되는 거죠 분명히 나는 1을 대입을 했는데 얘는 딱 읽었더니만 아직은 1을 읽지 못하는 상황이 충분히 발생할 수 있다는 얘기가 되는 거고 그걸 우리가 가시성이라고 표현을 합니다 진짜 보이느냐 안 보이느냐 그 얘기를 하고 있는 거죠 그래가지고 기본 상태로는 얘가 가시성이 뭐 항상 , 이렇게, 보장이 되지 않기 때문에 얘가 설령 1로 얘를 대입했더라도 얘가 무조건 1로 나오지 않을 수도 있다는 게 일단 첫 번째 문제예요 근데 이거는 C샵 기준으로 보면 볼라틸 키워드를 붙일 때 컴파일러 최적화도 막을 뿐더러 가시성도 같이 보장을 해주기 때문에 원래 이런 식으로 볼라틸을 붙이면 C샵에서는 , 사실, 가시성은 해결이 되었습니다 근데 이전에 C샵 서버 시그네도 그랬었지만 가시성이 해결이 되었음에도 이 문제는 없어지지 않고 계속 0으로 00이 빠져나온다는 걸 , 일단은, 실습을 할 수 있었는데 그렇다는 것은 , 사실, 가시성도 문제가 문제지만 두번째 문제도 무시할 수 없다는 얘기가 되는거죠 즉 두번째 문제는 코드 재배치 측면이 하나가 더 문제가 있습니다 굉장히 무서운 말이죠 코드 재배치 근데 이것도 약간 제가 이 말씀을 드리면 여러분들 굉장히 배신감을 느낄 수 있겠지만 사실은 여러분들은 CPU랑 컴파일러한테 지금까지 계속 속고 있었어요 , 자, 우리가 처음에 코드를 배우고 코딩을 배우고 이제 컴파일을 할 때 컴파일러라는 애가 우리가 만들어준 코드를 이제 기계어로 변환을 해주고 그 기계어를 CPU가 실행을 한다고 했었죠 이게 반쯤은 맞기는 한데 이게 항상 우리가 작업한 이 코드를 고지곳대로 컴파일러가 있는 그대로 번역을 해주지 않을 수도 있어요 이게 무슨 말이냐면은 예를 들면은 코드를 보다가 겸사겸사 검수를 하다가 왠지 얘랑 얘 순서를 뒤바꾸면 더 빠르게 동작할 것 같네라고 판단을 하면은 컴파일러가 지 멋대로 요런 식으로 코드 순서를 뒤바꿔 줄 수도 있다는 얘기가 되는 겁니다 아니 이게 무슨 말인가 왜 그딴 짓을 하느냐 싶지만 컴파일러 입장에서 보면은 , 일단은, 컴파일러는 멀티스레드 환경을 생각을 안하고 , 일단은, 단일스레드 대상으로 요 함수를 분석을 할 때 만약에 요렇게 로드를 먼저 하고 그 다음에 스토를 하는게 성능적으로 더 이득이고 그 다음에 실질적으로 요 함수만 봤을 때는 로직도 변하지 않는다고 생각을 하면은 얘가 합법적으로 요렇게 바꿔줄 수가 있어요 왜냐면 , 사실, Y에다가 E를 대입하는 거랑 X를 꺼내가지고 R1을 넣어주는 거랑 , 사실, 이 둘 사이는 아무런 관계가 없죠 그러다보니까 , 이렇게, 멋대로 뒤바꿔줘도 되겠구나라는 판단을 하는 겁니다 근데 물론 이걸 항상 하는 건 아니고 이게 단일 스레드에서 로직이 결과물이 똑같을 때를 가정했을 때 똑같은 보정이 있을 때만 얘를 뒤집어 줄 수 있다는 얘기가 되는 거죠 게다가 심지어 설령 컴파일러가 그런 쓸데없는 짓을 하지 않는다고 하더라도 그렇다고 하더라도 사실은 CPU가 또 멋대로 걔도 , 이렇게, 뒤집어 줄 수가 있어요 멋대로 실질적으로 요 코드를 잠시 지금 뭐 실행을 해가지고 브레이크 포인트를 잡으면은 그 다음에 여기다가 디버그 창 디스 어셈블리를 보면은 지금 뭐 코드 자체가 어... 뒤집혀 있지는 않다는 걸 알 수 있습니다 일단 Y를 먼저 개입을 하고 그 다음에 X값을 꺼내가지고 R1에 넣어주고 하는 식으로 되어 있으니까 컴파일러가 뭔가 최적화를 해주진 않았지만 그렇다는 것은 CPU가 역시나 우리가 Y는 1을 해주고 그 다음에 R1은 X를 해주라고 분명히 우리가 빌드를 해가지고 그걸 기기호로 요청을 했음에도 CPU가 멋대로 순서를 뒤벗겨줄 수 있다는 얘기가 되는거죠 이래서 좀 약간 멘붕이 오기 시작합니다 근데 역시나 우리가 지금까지 했던 싱글스레드 프로그래밍에서는 이런게 아무런 문제가 없었던게 사실은 순서를 뒤바꾸나 냅두나 아무런 차이가 없었기 때문에 이걸 우리가 몰랐던 거예요 근데 이제 멀티스레드 환경으로 오니까 우리가 예상하지 못했던 그런 상황들이 발생하고 있는 거죠 왜냐면 이 Y란 거랑 X라는 애를 나만 건드는 게 아니라 다른 스레드를 또 개입을 해가지고 서로 가지 공유로 하는 데이터를 건드릴 수 있기 때문에 이제 문제가 조금 더 아리락송해지기 시작하는 겁니다. , 자, 그러면 도대체 그럼 애당초 이 코드 재배치를 왜 하느냐 아니 프로그래머도 멍청한 게 아니라 우리도 어느 생각을 가지고 분명히 얘를 만들어 놨을 텐데 그럼에도 불구하고 컴파일러나 CPU가 얘를 뒤집는다는 것은 자기만의 뭔가 합리적인 이유가 있겠어 그래서 그 이유가 무엇인지 , 일단은, PPT로 다시 돌아가서 알아보도록 하겠습니다. , 자, 다시 ppt로 돌아왔고요 이제 이어서 파이플라인 특히나 cpu 파이플라인에 대한 내용을 다뤄볼 건데요 이 내용이 , 사실, 컴퓨터 구조 시간에 배운 내용이긴 한데 일부러 , 이렇게, 재밌는 그런 부분은 아니긴 합니다 제가 예전에 공부하다가 어떤 블로그에서 이거를 빨래에 비유를 하는 그런 블로그를 봤는데 그 비유가 저는 개인적으로 굉장히 마음에 들어 가지고 저도 똑같이 빨래에 이걸 한번 비유를 해보도록 하겠습니다 뜬금없는 빨래가 지금 나오고 있는데 , 일단은, 우리가 뭐 왠지는 모르겠지만 세탁소에 지금 일을 하면서 빨래를 해야 되는 상황이 있다고 가정을 해보겠습니다 빨래가 그냥 하나만 하는 게 아니라 , 이렇게, 뭉뚱그러 , 이렇게, 뭔가 바구니가 여러 개가 지금 우리한테 도착한 상태고 이걸 우리가 빨래를 해야 되는데 근데 지금 여기 보시면 알겠지만 이게 여러 가지 단계로 지금 이루어져 있어요 일단 왼쪽에 있는 애가 세탁기고 오른쪽에 있는 애가 건조기라고 , 일단은, 가정을 해보도록 하겠습니다 그러면 빨래를 할 때 먼저 스텝을 밟아야 되는데 먼저 빨래를 , 이렇게, 한 다음에 그 다음에 건조기에다가 얘를 넣어 가지고 건조를 시키고 그걸 다시 꺼내 가지고 다리미질을 한 다음에 다리미질까지 끝났으면 그걸 이제 열심히 옷을 깔끔히 정리해 가지고 , 이렇게, 위에다가 지금 개는 그런 작업까지 , 일단은, 하고 있는 겁니다 , 자, 그런데 요렇게 4단계를 걸쳐 가지고 지금 해야지만 최종적으로 빨래가 완성이 되는 건데 그렇다고 해 가지고 이거를 고지고대로 , 자, 이런식으로 , 일단은, 첫번째 빨래를 일단 여기 첫번째 기계에다 넣고 그 다음에 건조기에다 넣고 다리미질 하고 개고 하는 방식을 , 일단은, 하기는 해야 되지만 얘가 첫번째 꾸러미가 다 완료될 때까지 다른 애들은 시작도 안하고 얘가 완료되어서야만 그 다음 단계를 시작하고 이런 식으로 동작을 하면 굉장히 낭비가 심하게 되겠죠 왜냐면 사실은 처음에 빨래가 끝난 다음에 건조기에 들어가는 순간 첫번째 기기는 아무도 사용하는 사람이 없기 때문에 얘는 이제 사실상 놀고 있는 상태가 되는 거고 마찬가지로 건조가 끝나 가지고 다리미질을 하는 상태가 되면은 기기가 지금 두 개가 놀고 있는 상황이 되는 거죠 그러니까 우리가 일반적으로 이거를 그냥 현실상에서 생각을 해보면 요런 상황이 있다고 가정을 할 때 건조기를 사용하는 순간 다음 꾸러미를 꺼내 가지고 다음 꾸러미가 시작하게끔 요렇게 유도를 해주면 노는 애가 없이 열심히 일을 하게 될 것이고 그 다음에 얘가 다음 단계로 넘어가면은 이런 식으로 하나를 더 시작을 해 가지고 이런 식으로 모든 애들이 열심히 일을 하게끔 우리가 유도를 하는 게 가장 효율적으로 동작하는 방법이라는 걸 우리가 어렵구나 알 수가 있을 겁니다 뭐 어떻게 보면 굉장히 당연한 얘기죠 그래가지고 , 이렇게, 뭐 병렬로 여러 개의 빨래를 지금 사실상 진행하고 있는 상태라고 볼 수가 있는 건데 근데 여기서 살짝 문제가 뭐냐면은 모든 빨래가 다 동등하지가 않은 상황이라고 가정해볼게요 그러니까 옷에 따라 가지고 어떤 애들은 왠지는 모르겠지만 그냥 빨래를 하는 시간 자체가 오래 걸리고 어떤 애들은 소재가 너무 고급이어가지고 굉장히 신경 써가지고 다리미질을 해야 되기 때문에 다리미질 단계가 오래 걸리고 하는 등 각각의 단계마다 걸리는 시간이 각각 다 다른 상황이 있다고 가정을 하면은 그러면 고지곳대로 우리가 , 이렇게, 받은 순서대로 실행을 하기보다는 이거를 약간 테트리스를 해가지고 계산을 하다 보니까 순서가 왠지 , 이렇게, 뒤바뀌어가지고 얘를 먼저 실행하게 되면 얘가 테트리스상 굉장히 효율적으로 동작할 수 있는 방법이 있다고 하면 , 사실, 이 방법으로 진행하는 게 우리한테는 굉장히 좋을 수 있다는 얘기가 되는 겁니다 왜냐하면 결국에 우리 입장에서는 그냥 이 모든 빨래를 다 해야 되는 입장이지 , 사실, 이 둘 사이의 순서가 만약에 없다고 하면 굳이 주문을 받은 순서대로 꼭 해야 된다는 그런 강압적인 이유는 없기 때문이죠 그래서 이게 , 사실, 우리의 빨래스토리의 끝인데 이게 지금 똑같이 CPU에서도 똑같은 문제가 발생하고 있는 거예요 CPU도 마찬가지로 어떤 명령어를 우리가 실행을 할 때 그냥 실행하세요 뿅 하고 이게 한 번에 실행이 되는 게 아니라 여러 개의 단계를 거치게 됩니다 , 이렇게, 네 단계를 거치게 되는데 Fetch, Decode, Execute 그 다음에 Write back 이라고 해가지고 먼저 명령어를 갖고 온 다음에 그 명령어를 해석을 하고 해석이 끝난 다음에 실행을 하고 그 다음에 그 결과를 다시 갖다 주고 이런 식으로 여러 가지의 단계로 얘가 이루어져 있고 이걸 이제 CPU 파이플라인이라고 하는 겁니다 그렇기 때문에 여기서 지금 우리가 인스트럭션을 명령어를 여러 개를 만약에 우리가 요청한다고 했을 때 예를 들면 첫 번째는 스토어 영역을 어디를 저장해주세요 어떤 애는 어떤 데이터를 꺼내주세요 어디서는 더샘을 해주세요 등 여러 가지 요청사항을 보냈을 때 , 이렇게, 고지곳대로 순서대로 실행을 할 수도 있겠지만 경우에 따라서 순서를 뒤바꿔주고 실행을 하면 더 빨리 동작할 수 있다는 것을 만약에 컴파일러 혹은 CPU가 깨우친다고 하면 그걸 충분히 뒤바꿔주게 된다는 얘기가 되는 거죠 그래야지만 , 사실, 성능이 안 막히고 뭔가 하나가 너무 오래 걸려가지고 다른 애들을 다 막는 상황을 방지하고 최적화된 그런 방법으로 빠르게 동작할 수 있기 때문에 이런 거를 , 사실, 알게 모르게 지금까지 해주고 있던 겁니다 하지만 우리는 어차피 단일 스레드 기준으로만 생각을 했고 단일 스레드 기준으로 아무런 코드 변화가 없을 때에만 뒤바꿔준 작업을 했기 때문에 , 사실, 지금까지 눈치를 채지 못했다는 그런 얘기가 되겠습니다 하지만 역시나 멀티스레드에서는 , 이렇게, 막 뒤벗겨주는거 따라가지고 나비효과에 인해가지고 막 로즈히 꼬이고 이런 상황이 , 일단은, 뭐 충분히 발생할 수 있다는 그런 비극적인 상황이 생기게 된 겁니다 근데 물론 이런 상황이 이제 뭐 당연히 있다고 하면 해결책도 있겠죠 그래서 C++11 기준으로 원래 11 이전에서는 , 사실, 모든 모델이 싱글스레드 기준으로 생각을 했어요 근데 C++11으로 넘어오면서 C++ 표준도 사실상 멀티스레드를 굉장히 잘 고려를 해주기 시작을 했기 때문에 요런 상황에 대해서도 당장 대처법을 마련을 해줘 가지고 우리가 그거를 사용할 수 있게끔 이제 라이브레이션에서 지원을 해주게 되었습니다 그래서 C++에서 제공하는 그런 방법을 우리가 공부해가지고 그거 토대로 코드를 만들게 되면은 어떠한 머신이건 프로세서 이건 상관없이 어떤 환경인건 상관없이 표준에 의해 가지고 그게 다 제어가 되어서 이런 상황을 미연에 방지를 할 수 있다는 그런 결론을 낼 수가 있겠습니다 그렇게 해가지고 , 일단은, 간단하게 캐시랑 그리고 이어서 파이플레인이 무엇인지에 대한 내용에 대해서 쭉 알아봤고 굉장히 무서운 짓거리를 , 사실, 하고 있었다는 어떻게 보면 굉장히 뒤통수를 한번 , 이렇게, 맞은 그런 느낌이 드는데 그래가지고 이어서 다음 시간에는 메모리 모델에 대해서 알아보면서 이런 상황을 이제 우회하는 그런 방법에 대해서 알아보고 요게 이제 또 멀티스레드에서 굉장히 중요하게 중요하게 또 활용이 되는 경우가 있습니다 특히나 우리가 지금까지 아토미 클래스를 그냥 고지곳대로 그냥 기본값 설정으로 다 사용하고 있었는데 세부적인 설정을 통해 가지고 , 이렇게, 메모리를 어떻게 관리를 할지 그러니까 , 이렇게, 뭐 인스트럭션을 뒤바꿔도 되는지 혹은 가시성은 어떻게 할지 등등의 문제를 우리가 해결할 수 있으니까 뭐 그런 부분에 대해서 알아보도록 하겠습니다.