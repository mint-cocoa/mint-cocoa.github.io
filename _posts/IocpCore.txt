자, 이제 이어서 지난 시간에 이어서 이번 시간에 해볼 것은 여기 accept를 하는 이 부분 자체를 이제 우리가 새로 bind를 해서 런타임에 사용할 준비가 끝난 이 accept extended 함수를 이용해서 교체를 해볼 겁니다. 그런데 그러기 위해서 얘를 이제 그냥 막 호출하고 끝내는 게 아니라 iocp 구조를 이용해가지고 얘를 호출해줄 것이기 때문에 오늘 좀 작업할게 이것저것 많습니다. , 자, 그래서 일단 네트워크 쪽에다가 우리가 새로운 클래스를 추가를 해줄 건데 이름하여 Iocp-core라는 이름으로만으로 주도록 할게요. 약간 두 개의 의미가 있는 거죠. Iocp의 진짜 가장 핵심적인 부분이다와 진짜로 그 Iocp의 컴플리션 포트를 담당한다는 뭐 그런 두 가지 의미로 담아가지고 Iocp-core라고 , 일단은, 이름을 지어보도록 할 거고요. , 자, 그 다음에 이제 뭐 저의 부두술을 , 자, 이렇게, 일단은, 실행해가지고 iocp-core라고 , 이렇게, 주석을 친절하게 달아 주도록 할게요 영역을 좀 이쁘게 만들어 주도록 하겠습니다 , 자, 그 다음에 iocp-core가 내부적으로 들고 있는 것은 , 사실, 별게 없어요 그냥 자신의 핸들만 , 이렇게, 들고 있을 겁니다 iocp-handle 우리가 iocp와 관련한 실습을 그래도 비교적 최근에 해봤으니까 iocp를 다룰 때 컴퓨션 포트를 만들고 했었죠 근데 이제 그때 사실은 곰곰히 생각을 해보면 크게 중요한 함수가 , 사실, 두 개밖에 없었습니다. Created IOCompetitionPort랑 GetQueueCompetitionStatus라는 두 개의 함수로 사실상 이 IoCp 모델이 돌아갔었죠. 그거를 여기다가 또 랩핑을 해보도록 할게요. 일단 IoCp4의 행성자를 만들어 줄 것이고 그 다음에 소멸자도 만들어 줄 것이고 그리고 이어가지고 등록하는 함수 우리가 항상 뭐 어떤 세션 이라거나 뭔가 , 이렇게, 소켓을 새로 만들어 주면은 그걸 항상 iocp 쪽에다가 등록을 해놨었죠 등록을 해가지고 이제 얘는 관찰 대상이다 라는 걸 우리가 알려줬었는데 그것을 하기 위한 등록 함수를 , 일단은, 만들어 주도록 하겠습니다 그 다음에 이어가지고 디스패치라고 해가지고 실질적으로 어.. 이제 그 일하는 스레드들이 워커 스레드들이 이 IOCP의 일감이 없나 두리번두리번 거리는 그 짓거리를 하는 디스패치라는 함수를 만들어 줘가지고 여기서 이제 내부적으로 GetQueueCompetitionStatus를 호출하면서 이제 일감을 대기하는 형태로 이제 동작을 하게 될겁니다. , 자, 물론 말로 하니까 좀 어려울 수 있는데 이걸 이제 뭐.. 다 만들어가지고 보면은 크게 어려운 내용은 아니구요. , 자, 그 다음에 얘같은 경우는 , 일단은, 인자를 Timeout MS라고 할게요. 밀리세컨드 단위에 타이머 시간을 , 이렇게, 넣어줄 수 있게 만들어 줄 것이고 이 리지스터는 이제 내부적으로 인자를 하나 더 받아줄 건데 그거는 이제 좀 이따가 설명을 드리도록 하고 , 일단은, 대충 이런 모양으로 만들어 주도록 하겠습니다. , 자, IOCP 코어 쪽에서 일단 생성자 쪽에서 할 거는 뭐냐면은 이 핸들을 이제 만들어 줄 거예요. 그래서 실질적으로 iocp 를 만들 때 우리가 맨 처음 했던 게 create.io.completionPort라는 함수를 호출해 줬는데 처음에 만들어 줄 때는 그냥 모든 걸 다 넓값으로 채워줬죠 invalid handle value랑 000으로 세 개를 채워가지고 , 이렇게, 만들어 주게 되면은 그냥 처음에 컴플리션 포트를 만들어주는 행동을 하게 되었습니다 근데 뭐 혹시 모르니까 여기서 뭔가 이상이 생겼으면 바로 그냥 크래쉬를 내도록 할게요 얘가 인벨릿 핸들이 아닌 거를 우리가 어서트를 해주도록 할 것이고 그 다음에 얘가 끝날 때는 그냥 클로즈 핸들을 통해 가지고 iocp 핸들을 , 이렇게, 닫아주면 되겠습니다 그 다음에 이어가지고 여기서 이제 리제스터를 해가지고 등록을 할 때도 마찬가지로 create-io-confusion-port라는 걸 , 이렇게, 이용을 했었죠. 근데 여기서 원래는 우리가 소켓을 받아가지고 대충 이런 느낌으로 client-socket를 받은 다음에 그 소켓을 요렇게 등록을 했었습니다. 나머지 인자는 뭐 원래 우리가 iocp 헤드를 여기다 건네주고 요 소켓을 우리가 관찰하겠다라고 이제 말을 해줬고요. 그 다음에 여기 다음 인자들을 살펴보면은 컴필션 키 라고 해가지고 말 그대로 그냥 우리가 사용할 키값이었는데 우리가 이전 예제에서는 그 세션의 주소값 자체를 여기다가 넘겨줬었죠. 그래가지고 여기서 뭔가 이제 키값을 여기다가 넣어줘야 되는데 뭔가 넣어주고 마지막 인자는 0으로 넣어주고 이런 식으로 우리가 만들었었던 걸 이제 기억을 할 수가 있습니다. 그래서 오늘도 , 사실, 이런 느낌으로 만들어 볼 것인데 그 다음으로 이제 그럼 궁금한 거는 여기다가 넣어주는 값을 어떻게 관리할까가 굉장히 고민입니다 결국에는 이 Session 이라는 존재를 우리가 만들어 줘 가지고 걔를 등록할 수도 있을 거고 그런데 사실은 이 IOCompetitionPort라는 것 자체가 나중에 가면 꼭 Session만 넣어주는 용도로만 활용을 할 건 아니에요 이게 굉장히 다양한 용도로 사용할 수 있습니다 우리가 그냥 스탠다드 STL-Q를 사용하듯 진짜 원하는 일감도 넣어줄 수 있고 꼭 네트워크가 아니라고 해도 굉장히 다양한 범위로 일단 얘를 활용할 수 있기 때문에 이제 그거를 조금 더 광범위하게 만들어줄 수 있도록 이거를 Iocp Object라는 거로 이제 우리가 관리를 해주게 될 겁니다. 그래서 무조건 여기 Iocp에다가 등록을 할 수 있는 거를 우리가 Iocp Object라는 이름으로 불러줄 거예요. Iocp Object , 자, 그래가지고 Iocp Object라는 걸 일단 만들어줄 건데 이 Iocp Object를 나중에 상속해가지고 어... 다른 애들을 만들어 줄 건데 얘가 , 일단은, 기본적으로 들고 있는 거는 getHandle 이라는 함수를 , 이렇게, 들고 있을 거고요 그 다음에 이어가지고 dispatch를 하는 함수도 , 이렇게, 만들어 주도록 할게요 디스패치 함수도 만들어 줄 것이고 , 자, 여기서도 이제 조금 다른 내용이 들어가야 되는데 , 일단은, iocp-event라는 걸 , 이렇게, 만들어 줄 것이고 iocp-event 그 다음에 number-of-bytes라는 걸 , 이렇게, 받아 줄 겁니다 근데 iocp-event는 아직 만들어 주진 않았는데 이게 여러 개의 그런 기능들이 뭔가 합쳐져 가지고 동작하기 때문에 지금 좀 복잡할 수가 있어요 , 자, 그러면 이제 이 iocp-event는 무엇을 하는 것이냐 다시 한번 곰곰히 생각을 해서 우리가 이 IoCP 를 사용했던 걸 곰곰히 생각해 보면 크게 두 가지의 데이터를 넣어 줄 수 있었습니다. 처음에 등록을 할 때 이 키값으로 넣어주는 게 하나가 있었고 그 다음에 GetQueueCompletionStatus 를 할 때 그 오버랩트 구조체를 상속을 받거나 해가지고 넣어줄 수 있는 두 번째 정보가 있었죠 즉 정보를 두 개를 우리가 건네줄 수 있다고 했었습니다 그 중에서 첫 번째 정보는 이 iocp object가 될 것이에요 얘가 사실상 우리가 이전에 만들던 코드로 치면은 session과 같은 비슷한 느낌이죠 그리고 두 번째로 iocp-event는 이제 실질적으로 우리가 overlap 구조체를 상속을 받아가지고 걔가 뭐 리드를 하는 건지 라이트를 하는 건지 억세트를 하는 건지 등등을 구분을 해줄 수가 있었는데 그 아이를 우리가 이제 좀 더 광범위하게 iocp-event라고 이름을 지어 주도록 하겠습니다 그래서 말이 나온 김에 얘도 , 일단은, 만들어 주도록 할게요 iocp-event 그리고 얘는 그래도 비교적 독립적인 애다 보니까 이 iocp-event부터 일단 만들고 돌아오도록 하겠습니다 그래서 좀 막 정신이 없죠? 왔다갔다 하는데 이건 좀 어쩔 수가 없습니다. , 자, 그래서 여기서 이제 이어서 만들어 보자면 어... , 일단은, 이넘 클래스로 이벤트 타입이라는 걸 , 이렇게, 정의를 해줄 것인데 , 자, 유인트 8로 , 일단은, 만들어 줄 것이고 기본적으로 Connect, Accept, Receive 그리고 Send 한 이정도 4개만 , 일단은, 정의를 해주도록 하겠습니다 경우에 따라서 프리 리시브라고 해가지고 리시브를 하기 이전 단계에서 뭔가 하나를 더 정의하는 경우도 있어요 이건 이제 제로바이트 리시브라는 고오급 기법이랑 관련이 된건데 이거는 뭐 할지 안할지 좀 고민을 해보고 나중에 이제 한번 다루도록 하고 , 일단은, 기본적으로 , 이렇게, 4개만 있으면 됩니다 지금까지 배운 내용은 4개밖에 없죠? 그래서 , 이렇게, 4개를 만들어 줄 것이다 IOCP 이벤트라는 것 자체는 뭐 여기 첫번째 멤버 변수로 이 overlap라는 거를 얘가 , 이렇게, 들고 있어도 되고 아니면 그냥 상속을 받아서 만들어도 되는데 일단 상속구조로 , 이렇게, 만들어 주도록 할게요 상속을 받으면 무조건 첫번째 offset 0번에는 이 오버랩드 메모리가 들어가 있을 테니까 사실상 이 IoCP 이벤트 포인터로 사용을 하나 이 오버랩드 포인터를 사용하나 똑같은 의미가 될 겁니다. 그래서 , 이렇게, 만들어 줄 것이고 , 자, IoCP 이벤트의 생성자에서는 항상 이 이벤트 타입을 받아 줄 겁니다. 그리고 아래서 이벤트 타입을 얘가 , 이렇게, 들고 있을게요. , 자, 그 다음에 초교하는 함수란을 만들어 줄 것이고 이벤트 타입이 무엇인지 너는 누구인가? 라는 걸 , 이렇게, 뱉어주는 함수를 하나를 더 만들어주도록 할게요. 그리고 경우에 따라서 정렬에 굉장히 신경쓰는 분들도 있는데 이건 약간 프로젝트마다 달라가지고 만약에 정렬을 하는게 편하면 정렬을 , 이렇게, 해주시면 되겠고 , 자, 그 다음에 부드술 , 자, 요렇게 영역을 한번 찝어주도록 하겠습니다. 얘가 이제 IOCP 이벤트 영역이 될 것이고 네 그 다음에 두개를 이어가지고 여러개를 더 만들어 줄 것인데 일단 오른쪽에서 얘부터 만들고 넘어가도록 할게요 생성자 만들어주고 이니탐수 만들어주고 생성자에서 하는 거는 그냥 이닛만 때려줄 것이고 그럼 왜 굳이 이닛을 만들어 놨느냐 이걸 이제 독단적으로 외부에서 또 호출하고 싶은 경우가 생길 수도 있기 때문에 얘를 이제 빼놓은 겁니다 초교화를 하는 함수는 뭐 굉장히 간단한데 요 오버랩트에 있는 h 이벤트도 0으로 밀어주고 이런 모든 값들을 다 0으로 밀어 주도록 하겠습니다 internal도 0으로 밀어주고 internal high 얘도 밀어주고 offset 그냥 모든 값들을 다 그냥 싸그리 0으로 밀어주고 넘어가도록 할게요 초기화를 해주는 거죠 이 내부 값들은 운영체제가 사용해서 사용하는 거고 우리가 건들 일은 일단 없다고 했습니다 , 일단은, 초기화를 해주고 , 자, 그 다음에 이어가지고 각각의 타입별로 이벤트를 상속을 받아가지고 하나씩 만들어주도록 할게요 그냥 Connect 이벤트부터 시작을 해가지고 Connect 그 다음에 이제 나중에 가면은 Accept도 만들어줘야 되고 Receive, Send 등등을 다 만들어주면 되겠죠 여기서 얘는 Accept 오늘은 일단 당장은 Accept만 사용할 것이긴 한데 뭐 나중에 필요하게 될 거니까 , 일단은, 미리 , 이렇게, 만들어주도록 하겠습니다 Send 이벤트 , 자, 그래가지고 뭐 Connect 이벤트 같은 경우에는 얘는 뭐 크게 대단한 일은 해주지 않을 거고 그냥 Iocp 이벤트를 상속을 받기는 한데 어... 그냥 기본적으로 요 Iocp 이벤트에서 타입을 Connect 타입으로만 요렇게 넘겨주는 식으로 하고 끝날 거예요 , 자, 그런데 여기서 Accept 이벤트 같은 경우에는 이제 추가적으로 이벤트 타입을 Accept로 바꿔주는 것 뿐만 아니라 여기서 이제 추가적인 정보를 들고 있을 겁니다 우리가 예전에 원래 우리가 했던 , 자, 여기 다시 돌아와 가지고 살펴보면은 이 accept 를 할 때 보면은 accept 를 한 다음에 얘가 빠져나올 때 클라이언트 소켓을 뱉어 줘 가지고 우리가 이 소켓을 사용을 했었죠 근데 실질적으로 우리가 이제 이어서 사용할 이 accept extended 를 살펴보면은 여기 인자 중에서 listen 소켓과 실질적으로 우리가 클라소켓으로 사용할 애도 같이 , 이렇게, 받아주고 있다는 걸 볼 수가 있습니다 그래가지고 인자에서 실질적으로 , 이렇게, 인자가 없는 경우도 있겠지만 이 accept event 같은 경우는 내부적으로 얘랑 관련이 있는 그 정보도 추가적으로 얘가 담아줄 필요가 생길 수 있다는 얘기가 되는 거죠 그래가지고 얘는 이제 좀 이따가 할 거기 때문에 투도로 쓸 것인데 결국 제가 하고 싶은 말은 뭐냐면은 인자가 추가적으로 있을 수도 있고 없을 수도 있다 그래가지고 우리가 , 이렇게, 각각 분류해가지고 관리하는 거다라고 말씀을 드린 거고 뭐 경우에 따라서 어떤 코드에서는 이런 식으로 뭐 이벤트별로 또 클래스를 분류할 필요 없이 그냥 여기서 모든 애들을 다 , 이렇게, 넣어가지고 한 번에 관리하는 경우도 있습니다 뭐 이거는 그냥 편할 대로 하면 되고 그리고 이런식으로 할거면 한가지 조심해야하는게 있는데 여기서 버추얼함수를 사용하면 안됩니다. 괜히 소멸제를 버추얼로 한다거나 하면은 이제 어떤 일이 벌어지냐면은 버추얼함수 때문에 가상함수 테이블이 offset 0번 메모리에 들어가게 되면서 맨 처음 offset에 있던 메모리가 오버랩트와 관련된 메모리가 아니라 다른거로 채워줄 수 있으니까 그 부분만 일단 조심하면 됩니다. 그래가지고 , 일단은, Accept Event도 만들어 줄 것이고 이제 나머지 부분들은 Receive랑 Send 같은 경우는 뭐 딱히 뭐 중요한 그런 정보는 없으니까 얘를 각각 바꿔치기 해준 다음에 Receive Event, Send Event로 바꿔주고 요 부분은 Receive로 요 부분은 , 일단은, 그냥 Send로 , 이렇게, 바꿔치기를 하고 , 일단은, 마무리를 짓도록 할게요 , 자, 그래가지고 뭐 요 아이가 했던 거는 결국 굉장히 단순한데 우리가 이전에 단순하게 공부했을 때 요 Overleft Ext 그 때는 이름을 Overleft Ex라는 요 구조체를 만들어 가지고 사용했었는데 그 역할이라고 볼 수 있는 거죠 말 그대로 우리가 실질적으로 이 IOCP 코어에다가 넘겨줄 때 걔가 어떤 사유로 우리가 지금 걸어주고 있는지를 이제 의미를 한다고 , 일단은, 볼 수가 있겠습니다 그래서 각 함수를 호출할 때 이 이벤트를 만들어 가지고 전달을 해준다 라고 , 일단은, 결론을 내릴 수가 있는 거죠 , 자, 이렇게, 해 가지고 다시 돌고 돌아 가지고 돌아와서 그러면 결국에는 iocp 코어 쪽으로 돌아가 가지고 여기서 결국에는 iocp object 라는 거를 , 이렇게, 받아 가지고 이제 사용을 하고 있는데 거기서 디스패치를 할 때는 얘가 어떤 사유로 지금 디스패치를 하고 있는지, 즉 어떤 일감인지를 얘로 이제 받아주게 될 겁니다. 그럼 여기서 이 ISP 이벤트의 타입을 체크한 다음에 그 타입이 accept였는지, send였는지, receive였는지 등등 사유에 따라가지고 그 이제 일을 요기 디스패치 안에서 처리를 해준다라고 볼 수가 있는 거예요. 이게 구조가 굉장히 좀 처음에 만들 때는 굉장히 헷갈리기 때문에 제가 반복해서 설명을 드리고 있는 건데 결론적으로 모든 걸 다 조립해서 보면은 그래도 좀 볼만하다고 , 일단은, 볼 수가 있겠습니다. 처음엔 뭐 헷갈리긴 할 거예요. 그래서 , 일단은, 여기 다시 돌아와가지고 리지스터 쪽에서 만들다 말았으니까 다시 이제 만들어 보자면 이쪽에서는 결국에는 리지스터를 할 때 여기 Iocp Object라는 거를 , 이렇게, 받아줄 겁니다. 내가 등록해야 되는데 어떤 애를 등록할 것인지 그래가지고 이 애를 , 일단은, 받아줄 것이고 Iocp Object를 받아주면은 그 아이의 핸들을 이제 꺼내줄 겁니다 일반적으로 우리가 사용했을 때는 항상 얘가 소켓을 의미했었죠 소켓을 얘가 내부적으로 물고 있을 거고 그 소켓을 , 이렇게, 이제 얘가 관찰 대상이다 라고 우리가 컴플리션 포트한테 알려준 셈이 된다고 볼 수가 있겠어요 그 다음에 여기 이제 키값 같은 경우에는 이제 iocp object의 그냥 본인의 주소를 다시 여기다가 넘겨주도록 할게요 이건 이전과 마찬가지입니다 우리가 예전에는 session의 주소값 자체를 넘겨줬는데 사실상 지금 iocp object가 하는 역할이 session의 역할이기 때문에 얘는 뭐 마찬가지로 reinterpret, cast해준 다음에 new long ptr로 바꿔가지고 이 IOCP 옵젝트를 여기다가 그대로 넣어주시면 되겠습니다. , 이렇게, 두 줄로 보면 지금 이런 느낌이고 저는 어지간해서는 한 줄로 하는 게 좀 좋은 것 같더라고요. 코드를 읽을 때는 좀 귀찮긴 한데 큰 그림을 볼 때는 이게 좀 더 편한 것 같아서 저는 한 줄로 좀 길더라도 관리하는 걸 선호해서 , 이렇게, 일단은, 만들어 주도록 하겠습니다. , 자, 그래서 리지스터 좀 길고 길었는데 결국엔 리지스터는 뭐 기존에 했던 거 마찬가지로 요기 IOCP 핸들에다가 이제 새로운 아이를 관찰해 달라고 요청을 하는 뭐 그런 등록 함수였고 디스패츠 같은 경우에는 이제 워커 스레드들이 이 디스패츠라는 함수를 계속 실행해 가지고 일감이 있는지 두리번 두리번 하게 될 겁니다 그래서 우리가 항상 사용하던 게 GetQueueCompetitionStatus라는 함수가 있었죠 그거를 사용하기 위해서 , 일단은, 필요한 인자들을 몇 개를 만들어 볼 건데 IOCP iocp object도 , 이렇게, 만들어주고 복원을 하기 위한 준비를 해주도록 하겠습니다. 참고로 말씀드리면 제가 이전에도 말씀을 드린 적이 있지만 이거 등록을 하고 할 때 항상 레퍼런스 카운팅을 해가지고 걔가 절대로 날라가면 안 되기 때문에 추가적인 관리를 해야 된다고 했는데 오늘은 그 부분까지는 하지 않고 그냥 전체적인 구조만 잡아보는 형태로 만들어 보도록 하겠습니다. 완성된 코드를 일단 만들진 않을 거예요. 그래서 getQueueCompletionStatus를 호출할 건데 처음에 iocp 핸들을 넣어주고 그 다음에 두 번째로 numberOfByte를 , 이렇게, 넣어주면 실질적으로 전송된 그 바이트, 그러니까 송신 혹은 수신된 바이트를 여기다가 이제 뱉어줄 것이고 그 다음에 이제 복원하는 부분이었죠. reinterpret, cast를 한 다음에 pulongptr, ulongptr의 포인터다 이거죠. 이걸 이용해가지고 iocp object를 그대로 , 이렇게, 전달해주면 우리가 넣어준 키값을 인해가지고 다시 복원이 될테고 , 자, 그 다음에 그 다음으로 lp-overlapt 쪽에 우리가 넣어준 overlapt 구조체의 포인터를 뱉어주고 있는데 이것도 마찬가지로 reinterpret-cast를 한 다음에 lp-overlapt 포인터로 바꿔줘가지고 iocp-event에다가 넣어주세요 라고 요청을 해주면 되겠죠 그 다음 마지막은 timeout millisecond , 이렇게, 일단은, 만들어주면 되겠습니다 뭐 이건 여러 번 해본 부분이기 때문에 일단 어떤 의미인지는 뭐 예측을 하실 것 같고 이게 원래 우리가 예전에 사용하던 Session 쪽에 Session에 위치하던 거였고 이게 Overlapped Extended 그 구조였죠 그래가지고 두 가지 정보를 넘길 수 있는데 그거를 다시 뾰롱 하고 복원을 시켜주는 부분이 , 이렇게, 들어간다고 보시면 되겠습니다 그래서 , 이렇게, 일단은, 만들어줄 것인데 , 자, 일단은, 뭐 다 만들었으면 이걸 한 줄로 다시 바꿔주도록 하고 그 다음에 얘가 만약에 어 그냥 투로로 리턴했다 얘가 성공하면 그냥 투로로 리턴하고 실패하면은 이제 실패하면은 엘스문으로 들어올텐데 실패했다고 하면은 우리가 에러 코드를 확인을 해가지고 볼거에요 wsn get last error 근데 이제 경우에 따라가지고 이게 진짜 에러가 아닌 경우도 있습니다 무슨 말이냐면 우리가 옵션으로 타임하우스를 설정할 수 있다고 했었죠? 인피니트로 이걸 설정하면은 그냥 무한대기를 타겠지만 그게 아니라 예를 들면 우리가 뭐 100ms만 기다려달라고 요청을 했는데 100ms 동안 일감이 없었다고 하면은 일단 여기서 빠져나오게 될 것이고 그때는 에러코드가 타임하우스로 되어 있게 될 겁니다 , 자, 그래가지고 뭐 여기서 스위치문을 돈 다음에 이제 사유가 무엇인지를 봐가지고 만약에 wait time이라고 했으면은 이거는 , 사실, 우리가 어느정도 예측하고 있는 상황이라고 볼 수가 있는거죠 그래서 그냥 return first를 때려주고 여기까지 왔으면 일단 뭐가 성공한거니까 return true를 , 이렇게, 때려주도록 하겠습니다 뭐 , 사실, 이건 큰 의미가 없어요 그냥 우리가 구분하기 위한거고 그 다음에 여기서 이제 경우에 따라가지고 어떠어떤 사유에 의해가지고 얘가 빠져나오는지 이제 로고를 찍어가지고 살펴본다거나 하는 식으로 이제 공부를 해주면 되겠죠 근데 , 일단은, 기본적으로 그럼 투로로 왔으면은 이제 성공적으로 Iocp Object랑 Iocp Event를 복원한 형태로 빠져나오게 될 거니까 여기서는 그러면은 그 Iocp Event를 디스패치 해달라고 요렇게 요청을 해주게 될 겁니다 넘버 오브 바이트 , 자, 요런 식으로 아이고 요기는 이제 아 넣어주면 되고 Iocp Event를 호출해달라 라고 요렇게 디스패치를 해주면 될 것이고 마찬가지로 만약에 wait time이 아니라고 하면은 , 일단은, 뭔가 문제가 있는 상황인지 모르겠지만 얘도 똑같이 dispatch는 , 일단은, 그대로 다시 해주도록 할게요 여기 지금 빨간 줄이 뜨는 거는 뭐 그냥 비주얼 실료 쪽의 에러 같습니다 뭐 딱히 문제 될 거 없고 이거 빌드해 보면 지금 뭐 딱히 문제는 발견되지 않는 것 같아요 , 자, 그래가지고 뭐 , 이렇게, dispatch를 해주면 된다라고 볼 수 있는 거고 그러면 결국에는 이 IOCP 코어라는 걸 만들어 줘 가지고 나중에 우리가 리센소켓과 관련된 애를 처리할 애를 만들어 가지고 걔를 여기다가 리지스터를 해 가지고 등록을 해 주면 되겠죠 일단 이게 어떻게 사용이 될지는 모르지만 기본적으로 틀은 이제 어느 정도 감을 잡으시길 바라겠습니다 컴플리션 포트를 만들어 주고 등록을 할 때는 이 리지스터를 통해서 등록을 하고 그 다음에 워커 스레드들이 항상 하이네처럼 일감이 없는지 체크하는 그 함수는 이제 말 그대로 디스패치라는 함수를 호출해가지고 여기서 뭔가 일감이 있었다 해서 빠져나오면 걔를 실행하는 부분이 이제 디스패치를 통해가지고 실행이 된다라고 볼 수 있는 거죠. 나중에 가면은 이 IoCp 코어를 우리가 좀 더 어디서 관리할지가 좀 관건인데 , 일단은, 오늘 첫 시간에는 너무 클래스를 늘리진 않을 것이기 때문에 간단하게 IoCp 코어를 그냥 , 이렇게, 전역으로 하나를 만들어 줘가지고 얘를 그대로 사용하도록 할게요. , 자, 그래가지고 이거는 그냥 임시 코드입니다. 나중에 가면은 여기다가 관리하진 않을 거예요. 왜냐면은 어... 코어가 여러개 있을 수도 있기 때문이죠. , 자, 이렇게, 해가지고 뭐 iocp 코드를 넣어놨고 아 여기 include iocp 이벤트가 없어가지고 지금 얘를 인지를 못한 것 같네요. 네 그래가지고 얘가 에러가 났던 것 같고 , 이렇게, 해가지고 , 일단은, iocp 코어까지 그리고 iocp 이벤트까지는 완료가 되었습니다. 근데 일단 이것만으로는 테스트를 할 수 없고요. 억셉트를 하기 위해서는 결국 억셉트를 할 주체가 필요한데 이제 걔를 이어서 만들어 보도록 하겠습니다. 뭐 이거랑 것도 뭔가 , 이렇게, 깔끔하게 줄 정리를 좋아하시면 , 이렇게, 만들어 주시면 될 것 같고 이어가지고 네트워크 쪽에다가 리스너라는 애를 만들어 줄 것인데 이거 만약에 C샷 강의를 보셨으면 요 리스너가 등장했었죠 그때도 그래서 C샷 강의랑 C++ 강의랑 같이 보시면 이게 은근히 유사한 점이 많다는 걸 알 수가 있습니다 전체적인 구조상으로는 의외로 비슷하게 되어 있습니다 , 자, 그래서 이제 리스너라는 애를 만들어 줄 것이고 얘가 사실상 문지기의 역할을 맡게 되는 거죠 그 뭐 제가 그 영.. 뭐 뭐라고 했나요? 처음에 문을 지키면서 우리가 문의를 했을 때 안내원의 역할을 하는 그 아이라고 했었죠? 걔가 이제 리스너가 될 겁니다. , 일단은, iocp-core랑 net-address를 이제 활용할 것이기 때문에 여기다가 인클로드를 해주도록 하고 이 리스너 같은 경우에 우리가 iocp-object로 얘를 인지를 해가지고 실질적으로 iocp-core에다가 얘를 등록을 해줄 거예요. 이 리스너를 만들어 준 다음에 요 아이를 이제 관심 대상으로 살펴봐라 라고 우리가 요청을 해줄 겁니다. 네 그래가지고 그러면은 iocp 옵젝트에서 어... 얘가 얘를 상속받으면 반드시 getHandle이랑 dispatch라는 요 두가지의 함수는 반드시 구현을 해야 된다는 우리가 강제사항을 낳았었죠 그러다보니까 리스너 쪽에서도 똑같이 요 함수들을 이제 요렇게 복붙을 해가지고 얘네들을 이제 구현을 해줄겁니다 이제 abstract가 아니라 override로 뒷부분을 이제 바꿔주면 되겠죠 요런식으로 , 자, 그 다음에 얘가 내부적으로 이거 퍼블릭으로 할 필요는 없으니까 프로텍티드로 바꿔주도록 할게요. 내부적으로 소켓이라는 걸 들고 있을 거고 얘가 이제 리스너 소켓이 되는 거죠. 초기 값은 그냥 인벨리 소켓으로 놓도록 하겠습니다. 그 다음에 뭐 나중에 경우에 따라가지고 여기서 뭐 세션 카운트를 하거나 온갖 정보를 다 관리하고 있을 텐데 지금은 딱히 그거는 필요 없고 이번에 당장 필요한 거는 억셉트 이벤트의 포인터를 여기다가 관리를 해주도록 할게요. , 자, 그 다음에 , 일단은, accept event를 여기서 내용할건데 전방선언을 한번 해줄것이고 이제 영역을 여기서는 이제 인터페이스 구현과 관련된 내용을 넣겠다라고 잠시 주석서리를 , 이렇게, 해주도록 하고 , 자, 그 다음에 외부에서 사용하는 코드와 이어가지고 수신 관련된 코드는 여기서 이제 관리를 해주게 될 겁니다. 수신 관련 코드 그래서 얘 같은 경우는 , 일단은, register accept라는 함수를 만들어 줄 건데 여기다가 마찬가지로 accept event를 받아 가지고 걔를 이제 등록을 해주게 될 겁니다. , 자, 이것도 약간 뭐 지금 말로 하면 설명이 어려운데 완성된 코드를 보면서 작업을 하면 뭐 괜찮은 얘기고요. accept event 그 다음에 마찬가지로 register 한 개 실제로 완료가 되어서 진행할 수 있을 때 그 콜백 함수를 사실상 process accept로 우리가 처리를 해줄 겁니다. 이런 내용들이 이제 등장할 것이고 그 다음에 이어가지고 listener, 생성자 그리고 소멸자도 각각 정의를 해주게 될 것이고 그 다음에 이제 외부에서 사용하는 그런 코드들은 여기다가 넣도록 할게요. 영역을 집어 주도록 하겠습니다. 얘는 startAccept 이제 말 그대로 리스너가 문지기의 역할을 해라 라고 이제 식당 영업 개시를 할 때 요 startAccept라는 함수를 호주게 될 겁니다 그래서 , 일단은, net address를 받아가지고 어떤 주소를 대상으로 내가 이제 영업을 개시할지를 지정을 해줄 것이고 그 다음에 마지막으로 closeSocket 함수도 요렇게 , 일단은, 만들어 주도록 할게요 요고 소문자 , 자, 그래서 뭐 대충 , 이렇게, 하면은 끝날 것 같고 이제 나머지 코드들을 만들러 가겠습니다. 리스너, 소멸자, 스타트 억셉트, 클로즈 억셉트, 겟 핸들 굉장히 간단하니까 바로 해도 되긴 하지만 , 일단은, 이렇게, 다 하나씩 하나씩 만들어가지고 정리를 해보도록 합시다. , 자, 그 다음에 여기 이어가지고 어, 오른쪽에 리스너 쪽에 와가지고 여기서 이제 사용해야 될 게 꽤 많기 때문에 먼저 소켓 유티를 추가를 해줄 것이고 그 다음에 IOCP 이벤트 우리가 전방선언을 해준 걸 사용하기 위해서 IOCP 이벤트도 추가해주고 어, 지금은 일단 두 개만 있으면 될 것 같네요. 그 다음에 아이고, 제가 항상 하던 요, 저만의 행동 집어주기를 일단 하도록 하고 대충 이 정도 영역으로 , 이렇게, 주석을 해가지고 이게 없으면 전 요즘 굉장히 불안하더라구요 영역을 봐야지만 얘가 어떤 역할을 하는지 좀 잘 보여가지고 하다보니까 습관이 되었는데 그래서 리스너가 끝날 때가 됐으면은 소켓 유틸에 클로즈를 해줘가지고 깔끔하게 소켓을 정리하는 작업을 해줄 것이고 그 다음에 여기서 내부적으로 들고 있던 Accept Event들을 이제 얘가 깔끔히 관리를 해주도록 하겠습니다. 얘는 무엇이냐? 이제 이어가지고 살펴보면 될 것 같고 , 사실, 어지간해서는 우리가 리스너를 , 이렇게, 소멸까지 가는 경우가 없기 때문에 , 사실, 얘는 뭐 굳이 안 해도 되기는 하는데 그래도 이왕 C++에서 깔끔하게 코드를 관리하는 게 좋다 보니까 이걸 하고 있는 거고 X Delete를 해가지고 Accept Event를 여기서 삭제를 해주도록 하겠습니다. , 자, 그 다음에 어.. 여기서 이제 좀 연결이 되는 코드가 있는데 여기서도 좀 내용이 추가가 될 것이고 결국에는 , 자, 여기 보면은 굉장히 많은 내용이 들어가 있는데 먼저 코드가 진행되는 순서로 작업을 하도록 할게요 그러니까 결국에는 이 부분에서 우리가 Start Accept라는 것을 호출을 해주게 되겠죠. 얘부터 작업을 해주면 될 것 같네요. 리스너를 만든 다음에 영업을 개시하면 이제 어떤 일이 일어나야 되냐면 먼저 소켓을 하나를 만들어줄 겁니다. 이 소켓이 ListenSocket으로 만들어지게 되겠죠. Socket Utilities에서 CreateSocket을 이용해서 우리가 TCP 소켓을 그대로 만들어주면 되겠고. 그 다음에 혹시 소켓이 InvalidSocket이 아닌지만 체크를 해서 Invalid라면 그냥 Return False를 해주도록 하고 그 다음에 해야 되는 게 이제 이 Listen Socket도 결국에는 우리가 관찰해야 될 대상이다 보니까 Iocp 코어에다가 얘를 등록을 해주도록 하겠습니다 이런 식으로 얘도 만약에 실패했으면 또 Return False를 해주도록 할게요 이 코드는 지금 전역으로 사용했지만 나중에 얘가 다른 식으로 바뀌게 될 겁니다 그 다음에 이제 나머지 설정을 막 신나게 해줄 건데 소켓 유틸에서 set reuse address부터 설정을 해주도록 합시다 이거 안하면은 종종 주소가 겹쳐가지고 서버가 안뜬다거나 하는 문제가 생길 수 있기 때문에 귀찮으니까 이걸 해주고 뭐 그 다음에 뭐 이런저런 것들 소켓 유틸에서 뭐 set linger 같은거 얘는 일단 linger는 그냥 꺼주도록 할게요 00으로 하고 그 다음에 이제 이어가지고 어... 바인드를 해줘가지고 영업을 할 준비를 합시다 net address랑 얘를 바인딩을 해준 다음에 그 다음에 바인드 다음에 listen 차례였죠? listen까지 해줘가지고 말그대로 listen 소켓으로 사용하기 위한 모든 준비를 여기서 해주도록 하겠습니다 return false , 자, 그 다음에 여기서 이제 실질적으로 우리가 accept extended를 호출해가지고 어... 걔를 이제 실질적으로 예약을 해줘야 되는데 이런 식으로 accept event를 만들어 준 다음에 accept event xnew accept event 만들어 준 다음에 그거를 register accept를 해가지고 , 이렇게, 걸어주게 될 겁니다 이게 말 그대로 우리가 register라는 게 예약하다는 의미죠 뭔가 실질적으로 일어나지 않을 수 있지만 우리가 accept extended 함수를 걸어준다 그래가지고 만약에 운 좋게 지금 진짜 클라이언트가 뭔가 접속했으면 바로 완료가 될 수도 있고 아니면은 나중에 누군가가 접속하면 그제서야 완료통지가 뜨게 되겠죠 완료통제는 IOCP를 통해 가지고 워커텍스스레드들이 관찰하다가 이제 꺼내서 쓰게 될 겁니다 그런 느낌으로 자동하게 되는데 이거를 딱 , 이렇게, 한 번만 걸어주게 되면은 많은 동접이 막 몰린다고 가정을 했을 때 몇 명은 이제 입장을 못하는 경우가 생길 수도 있어요 그래서 이것도 어느 정도 여유분을 둬가지고 이제 이벤트를 걸어줘야 됩니다 그래서 나중에 가면은 이것도 뭐 따로 빼서 관리를 할 것이지만 , 일단은, 한계로만 , 이렇게, 루프를 만들어 주도록 할게요 acceptCount 개만큼을 acceptCount 개만큼을 뺑뺑이를 돌면서 요 아이를 요렇게 넣어주겠다라는 얘기가 되는 거죠 그리고 함과 동시에 얘를 푸시백을 해가지고 나중에 삭제를 할 수 있도록 얘를 어딘가에서는 , 이렇게, 물고 있는 게 안전하니까 얘가 , 이렇게, 관리를 하면서 나중에 실제로 소멸이 될 때 같이 메모리 해제도 이제 관리를 해주게 될 겁니다 뭐 요렇게 , 일단은, 만들어줄 수 있다는 얘기가 되는 거죠 그래서 영업 시작하면은 막 소켓을 만들어 준 다음에 얘를 리슨 소켓을 사용하기 위해서 세팅 세팅 해주고 바인드 리슨까지 한 다음에 실질적으로 리지스터 억셉트가 빵 시작이 되면은 여기서 이제 이어져 가지고 억셉트 엑스텐딘 함수를 호출해 준다라는 식으로 이제 동작을 하게 되는 거죠 클러스 소켓은 뭐 얘는 뭐 , 사실, 별건 안하고 그냥 클러스를 해가지고 이 소켓을 그냥 닫아주기만 하도록 하겠습니다 그 다음에 Get Handle 같은 경우에는 뭐 얘는 더 간단한데 사실상 요 소켓을 이제 뱉어주면 되니까 리인터프렛 캐스트를 한 다음에 핸들로 바꿔줘 가지고 요 소켓을 그대로 이 소켓을 뱉어주면 된다고 볼 수가 있고요 그 다음에 이제 이어가지고 쭉 내려 보다 보면은 이제 저 중요한 애들이 몇 개가 있죠 디스패치랑 리지스터 프로세스 억셉트 이런 애들이 이제 등장하는데 먼저 리지스터 억셉트부터 살펴보도록 하겠습니다 이게 그냥 순서로 우리가 작업하고 있으니까 얘는 뭐하는 거냐면 이 억셉트 이벤트를 이제 걸어 줘 가지고 실질적으로 iocp 쪽에서 처리할 수 있도록 우리가 어떤 일감을 이제 호출해줘서 예약을 하는 그런 개념이라고 볼 수가 있는 거죠. 실질적으로는 여기서 해야 되는 역할은 이 리스너가 Accept Extended를 호출하는 게 , 사실, 가장 핵심입니다. 즉, Socket Utils에서 Accept Extended를 이제 드디어 땅! 하고 호출해주면 된다고 볼 수가 있는 거죠. , 자, 그러면 얘가 이제 받아주는 인자가 또 , 이렇게, 여러 가지가 있는데 첫 번째로는 리슨 소켓 즉 요 아이를 우리가 그냥 리슨 소켓을 사용하고 있으니까 얘를 넣어주면 되고 그 다음에 조금 특이한게 미리 소켓을 만들어 가지고 걔를 건네받는다는 걸 알 수가 있습니다 , 자, 그런데 여기서 뭐 그냥 CreateSocket를 해도 되기는 하는데 어 제가 이것도 약간 미리 언급을 드린 적이 있지만 나중에 가면은 클라이언트가 접속을 했을 때 그 클라이어와 관련된 모든 정보들을 Session이라는 클래스에다가 다 몰빵을 해준다고 했었죠 그래서 뭐 클라이언트 소켓 뿐만 아니라 그 아이의 뭐 아이디라거나 하자는 그런 온갖 클라와 관련된 정보들 Session이랑 Class가 다 우리가 몰빵해서 넣어줄 것이기 때문에 걔가 이제 굉장히 중요한 역할을 하게 되는데 그 아이도 , 일단은, 겸사겸사 미리 만들어 두도록 할게요. 이 Session 같은 경우에도 C Sharp 코드에서도 똑같이 등장한 그 Session입니다. 혹시 의심을 하실까봐 Session도 이제 똑같이 , 이렇게, 들어가게 될 거고요. , 자, 요렇게 , 일단은, Session이라는 클래스를 만들어 줄 것이고 얘도 이제 리스너와 마찬가지로 우리가 Iocp 코어한테 등록을 할 대상입니다. 그러기 때문에 얘도 마찬가지로 Iocp 코어랑 그 다음에 Iocp 이벤트도 요렇게 추가를 해줄 것이고 NetAddress도 필요할 것 같으니까 얘도 추가를 해주고 Iocp Object를 요렇게 사용하도록 준비를 할게요. 그 다음에 요 주서 이제 너무 치기가 귀찮아서 복붙을 해서 요렇게 넣어주도록 하겠습니다. 그러면은 세션은 뭐 , 일단은, 오늘은 간단하게 그냥 접속 테스트만 할 것이기 때문에 얘는 뭐 그렇게 복잡하게 만들진 않을 거라서 필요한 애들만 넣어주도록 할게요 세션이랑 어 그 다음에 버추얼 세션 소멸자 그리고 또 뭐가 있을까요? 여기서 이제 나중에 추가될 정보가 특히나 가장 중요한 게 클라이언트 소켓이 있을 것이고 인벨릿 소켓으로 일단 넣어줄 거고 그 다음에 나중에 가면은 얘가 접속했을 때 요 아이의 주소를 얘가 들고 있게 될 겁니다 그래서 요 net address를 , 일단은, 들고 있을 것이고 뭐 그 다음에 뭐 예를 들면은 얘가 진짜 접속 상태가 접속 중인지 아니면 끊겼는지 등등을 뭐 이런 식으로 나중에 들고 있을 겁니다 지금은 얘만 , 이렇게, 간단하게 구현을 해보도록 할게요 그 다음에 마찬가지로 나중에 가면 여기서 샌드나 리시버 관련된 버퍼가 들어가야 되는데 지금 단장 리시버 퍼를 그냥 1000바이트짜리로 임시로 만들어 가지고 사용을 하도록 하겠습니다 이건 나중에 좀 바뀔 겁니다 이걸 왜 벌써 만드느냐 하면 이걸 이제 인자에서 요구를 하기 때문에 얘를 , 일단은, 지금 벌써 만들어 주고 있는 거고요 그 다음에 여기서 이제 뭐 이 세션과 관련된 정보 관련된 함수들을 여기다가 넣어 줄 것이고 얘도 마찬가지로 iocp 오브젝트를 상속을 받고 있다 보니까 이전에 리스너와 마찬가지로 인터페이스 구현과 관련된 정보가 필요하겠죠 그래서 걔는 여기다가 넣어 주도록 하겠습니다 요 부분에서 인터페이스 구현 부분을 그냥 두 아이를 긁어 가지고 이쪽에서도 똑같이 , 이렇게, 넣어 주도록 뭐 하겠습니다. 심지어 인자도 똑같으니까 그냥 얘를 재생하면 되겠네요. , 자, 그리고 뭐 정보와 관련되어서는 뭐 setNetworkAddress 라거나 NetAddress를 받아가지고 얘를 설정하는 주소를 설정해주는 뭐 이런 부분을 만들어 줄 것이고 , 이렇게, 그 다음에 net address를 get 하는 경우도 생길 수 있겠죠. 얘도 똑같이 , 이렇게, return net address도 , 이렇게, 만들어 주도록 하겠습니다. 근데 뭐 이거는 부가적인 거고 일단 오늘 중요한 거는 get socket, 이 return socket을 하는 부분을 , 일단은, 만들어 줄 것이고 뭐 요런 애들을 이제 정보를 사용할 것이다 라는 걸 알 수 있는 거고 그 다음에 이제 이어가지고 이 인터페이슨 구현과 관련된 부분을 만들어줘야 되는데 얘는 cpp 쪽에서 만들도록 합시다 일단 구현부 를 이어서 만들어줄 것이고 생성자 그리고 소멸자도 다 만들어주도록 할게요 주석은 항상 , 이렇게, 옮겨주고 그 다음에 소켓 유틸 소켓 유틸도 이제 나중에 필요하게 될 테니까 요렇게 등록을 해주고 세션이 처음에 만들어지면은 얘는 그냥 간단하게 소켓 유틸스에서 크레이트 소켓을 해줘가지고 tcp 소켓을 이제 따끈따끈하게 하나를 만들어 줄 것이고 어 소멸이 된다 싶으면은 얘를 클로즈 소켓을 통해 가지고 클로즈였죠 그냥 소켓을 , 이렇게, 닫아 주도록 하겠습니다 그 다음에 어 핸들을 뭐 요구할 때는 뭐 아까와 , 사실, 마찬가지죠 얘 같은 경우에도 리인터프렛 캐스트를 해준 다음에 소켓을 , 이렇게, 핸들로 바꿔 가지고 뱉어 주면 되고요 그 다음에 요 디스패치에서는 얘 같은 경우에는 이제 무엇을 디스패치 할 것이냐 나중에 가면은 요 ISP 이벤트가 리시브나 샌드 같은 이벤트를 만들어 가지고 그거를 처리할 때는 이제 이 코드로 들어와 가지고 그 부분을 처리해 주게 될 겁니다 근데 지금은 딱히 거기까지는 맞는지 않을 거고 그냥 접속 테스트만 할 것이기 때문에 요 부분 , 일단은, 비워두도록 할게요 , 자, 요렇게까지 , 일단은, 세션을 만들어 주고 이제 굉장히 좀 헷갈리긴 하는데 그러면은 다시 리스너로 돌아가 가지고 만들던 부분을 계속 만들어 보자면 여기서 Register Accept를 할 때 결국에는 여기서 세션을 만들어 주게 될 겁니다 뭐 이거를 세션을 풀링하거나 해가지고 미리 준비된 애를 뭐 꺼내서 도 되지만 , 일단은, 지금은 얘를 실시간으로 여기서 지금 당장 만들어 주도록 할게요 그러면은 여기 위에 가가지고 Include Session을 여기서 해주면 되겠죠 , 자, 이렇게, 해가지고 , 일단은, Session을 만들어줄 준비가 끝났고 여기서 Register Accept를 하는 순간 Session을 만들어줬구요 그 다음에 우리가 Accept Event라는 이 이벤트에다가 제가 이것도 아까 말씀드렸지만 여기서 약간 연동할 게 남았다고 했었죠 그게 뭐냐면은 이제는 이 Accept Event에다가 우리가 이 Session 정보를 여기다가 , 일단은, 억세프트 이벤트에다가 연동을 시켜줄 겁니다. 그래야지만 나중에 우리가 디스패치를 해가지고 해당 이벤트를 다시 뽑아왔을 때 어떤 세션을 넘겨줬는지를 우리가 알 수 있기 때문에 얘를 지금 이 억세프트 이벤트에다가 임시 저장을 한다는 얘기가 되는 거죠. 그래가지고 이쪽에다가 세션을 잠시 , 이렇게, 연결해 주도록 할게요. 얘가 사실상 클라스 세션이 되는거고 언더바 세션 널 btr 그 다음에 결국에는 set session 이란 함수를 만들어가지고 세션을 요렇게 담고 있도록 그 다음에 세션의 포인터를 다시 뱉어주는 get session도 똑같이 만들어주도록 하겠습니다 요렇게 , 자, 그리고 줄을 맞춰주려면 요렇게 맞춰주면 될 것이고 그 다음에 Session 이라는 아이를 아직 모르니까 위에다가 이쪽에다가 전방 선언을 해주도록 하겠습니다 Class Session을 , 이렇게, 선언을 해줄 것이고 그러면 이제 준비는 다 된거죠 그래가지고 Register Accept을 할 때 Session을 만들어 준 다음에 이 Accept Event에다가 얘를 일단 초기화해가지고 쓰레기값을 다 밀어줘가지고 새로운 상태로 만들어 준 다음에 그 다음에 Set Session을 해가지고 이 Session을 얘가 일단 들고 있도록 해주도록 하겠습니다 그 다음에 이제 비로소 Accept Extended 함수를 빵 해서 이제 비동기 Accept를 걸어준다고 볼 수가 있는 거죠 여기서 두 번째로 받는 애는 , 일단은, Session에 Get Socket을 통해 가지고 얘를 , 일단은, 이렇게, 받아주면 될 것이고 Socket을 받아주고 있으니까 그 다음에 이제 또 뭘 받아주냐 보냐면은 여기서 아웃풋 버퍼라는 걸 , 이렇게, 받아주고 있습니다 굉장히 뭐 뭐 억셉트라는데 얘를 벌써부터 받고 있냐 해서 궁금해서 살펴보면은 이제 문서에서 이 LP 아웃 버퍼가 어떤 용도인지 나와 있습니다 First block of data 처음에 커넥션이 맺어질 때 어찌됐건 그 정보를 받아주기 위한 버퍼가 필요하다라고 지금 설명하고 있는 거죠 그래서 그 버퍼를 그냥 우리가 임시로 만들어 준 리시브 버퍼로 이제 그냥 그대로 건넬 조정할게요 Session에 Receive Buffer 그 다음에 다음 인자는 그냥 0으로 넣어주시면 되겠고 , 자, 그 다음에 이제 좀 묘한 얘기가 나오는데 아까 , 사실, 문서를 살펴보면은 Local Address Length랑 Remote Address Length라는 부분이 나오고요 뭐 좀 이상한 부분이 막 나오기 시작합니다 근데 여기서 쭉 내려가지고 예제를 살펴보면은 여기서 이제 살펴보면은 Bind, Listen , 자, 이게 이제 실질적으로 Accept 함수 주소를 찾아오는 거였고 여기서 지금 , 이렇게, 호출해주고 있는데 size of sock address in에다가 16을 더해줘가지고 , 이렇게, 두 번 넣어줘도 있다는 걸 볼 수가 있습니다. 이걸 그냥 그대로 따라서 만들어주면 돼요. 뭐 큰 의미는 없고 그냥 , 이렇게, 사용하면 되는구나 라는 걸 알 수가 있는 거죠. , 자, 그리고 bytes received라는 걸 겸사겸사 같이 넘겨주게 될 텐데 우선 0 다음에는 size of sock address in에다가 16을 더한 만큼을 이제 두 번 연속해가지고 얘를 , 이렇게, 넣어주면 되고요. 크기와 관련된 애고 그 다음 인자가 ByteReceived의 주소를 넣어줘야 되니까 ByteReceived를 여기다가 이제 넣어주시면 되는 거고 마지막으로 요 이벤트를 넣어줄 수 있는 Overlapped 주소를 받아주는 애가 맨 마지막에 있기 때문에 걔는 여기다가 이제 넣어주면 되겠습니다 얘는 이제 우리가 상속을 하고 있으니까 StaticHast LP Overlapped를 해가지고 요 AcceptEvent를 여기다가 넣어주면 된다고 볼 수가 있는 거죠. 괄호가 3개 땡. , 자, 그래서 이거를 뭐 좀 나눠서 보면은 요런 느낌으로 되어 있습니다. Accept Extended를 호출을 해주고 있는데 아이고 2개네요. 얘를 호출하고 있는데 Listen Socket을 넣어주고 그 다음에 클라이언트 쪽 소켓을 넣어준 다음에 리시이브 버퍼와 0 시작은 0으로 하고 리시이브 버퍼를 넣어주고 그 다음에 왠지는 모르겠지만 아까 뭐 크기 두 개를 넣어주는데 걔는 항상 , 이렇게, 넣어주면 되고 그 다음에 뱉어줄 때 어 억셋바이트 리시이브라는 걸 받아주고 있는데 걔는 여기다 받아주고 마지막으로 , 사실, 중요한 건 이거죠 소켓 , 사실, 3개가 중요한 겁니다. 얘랑 얘랑 얘. 얘가 이제 실질적으로 우리가 넣어준 그 오버래프트 구조체의 주소라고 볼 수가 있는 겁니다. 예를 들면 우리가 ircp 이벤트를 만들 때 얘를 오버래프트를 상속을 받게끔 만든 이유가 바로 이 날을 위한 거였죠. 그래가서 이 accept를 호출해줄 것인데 얘가 만약에 실패했다라면 , 자, 이제 한 줄로 다시 바꿔치기 할게요 저는 한 줄짜리를 좋아하기 때문에 괄호 하나 늘려주고 요렇게 만들어 주도록 하고 너무 인자가 길어지면은 요 false를 앞에다가 당겨서 보는 게 조금 편하기 때문에 요렇게 만들어 놨고 얘가 만약에 실패했으면 그러면은 이제 뭐 에러 코드를 봐야 되겠죠 에러 코드 double get last error를 봐가지고 어떤 사유로 인해가지고 얘가 실패했는지를 보면 되겠습니다. 근데 만약에 에러코드가 wsaio 펜딩이 아니라고 하면은 이제 살짝 뭔가 문제가 있는 상황입니다. 이게 만약에 펜딩이 떴다는 거는 딱히 문제가 되는 상황은 아니에요. 그냥 걸렸는데 뭐 아직까지 접속한 애가 없다 보니까 그냥 뭐 바로 빠져나온 상황입니다. 그렇기 때문에 펜딩이면 아무 문제가 없는데 펜딩이 아니라고 하면 , 사실, 좀 어떤 이런저런 이유로 문제가 일어난 상황이라고 볼 수 있는 거죠 근데 그럴 경우에 그냥 여기서 아무것도 안하고 뿅 끝나면은 펜딩이 아니었는데 끝났다는 얘기는 이제 다시는 register accept를 걸어줄 애가 없다는 얘기니까 여기서 한번 다시 , 이렇게, 걸어줄 필요가 있습니다 일단 다시 accept 걸어준다 그러니까 이 걸어주는 패턴을 잘 봐야 되는데 이게 나중에 accept뿐만 아니라 send랑 receive할 때도 똑같은 패턴이 이제 일어나게 되겠지만 얘가 소위 낚싯대를 던지는 행위라고 있습니다 낚싯대를 뿅! 우리가 던져가지고 입질이 와가지고 실질적으로 고기가 물리면은 나중에 이 dispatch로 들어가가지고 걔를 실행해주게 될 거예요 그러면 dispatch를 한 다음에 이제 걔가 내부적으로 요 프로세스 억셉트로 넘어오게 될 것이고 여기서 다시 낚싯대를 다시 던져야 된다는 얘기가 되는 거죠 고기를 잡은 다음에 다시 낚싯대를 던지고 근데 지금 만약에 여기로 들어왔다는 얘기는 낚싯대를 던지다가 미끄러져가지고 낚싯대를 못 던지고 실패한 상황인 겁니다 그러면 낚싯대를 안 던졌으니까 고기가 낚일 리가 없겠죠 그래가지고 그런 경우에는 다시 이거를 한 번 더 호출해준 셈이라고 보시면 되겠습니다 네 그래서 뭐 요런 느낌으로 , 일단은, 만들어주면 되고 그래서 , 자, 이제 코드가 뭐 당장 이해가 안 갈 거에요 당연히 얘기지만 이게 뭐 이래저래 복잡하게 왔다 갔다 하고 있으니까 이해가 안 가는 건 뭐 감안하셔야 되고 , 자, 그래가지고 여기서 리지스터 억셉트를 빵 던졌으면은 이제 얘가 어찌됐건 당장 실행이 되지 않더라도 펜딩 상태가 됐으면은 IOCP에 우리가 요 리스너 소켓을 관찰하고 있으니까 실질적으로 얘가 완료가 되면은 그 통지가 IOCP를 통해서 이제 오게 될 겁니다. 우리가 IoCP를 관찰할 애들을 냅뒀기 때문에 걔네들이 뿅 인지를 해가지고 아까 보면은 IoCP 코어에 이 GetQueueCompletionState에서 빠져나와가지고 요 디스패치를 호출을 해주게 된다는 얘기가 되는 거죠. 그러면은 IoCP 디스패치를 빵 호출해주게 되면은 다시 요로 들어오게 될 겁니다. 그래서 일로 들어왔으면은 이제 고기가 낚였으니까 일감을 이어서 실행하면 된다라는 뭐 해피한 상황이 되는거죠 지금은 우리가 실질적으로 넣어준 이벤트가 처음에 넣어준 이벤트 타입이 하나밖에 없죠? Get 타입이 이 이벤트 타입이 Accept 있는지를 확인해가지고 아니라고 하면은 뭐 문제가 있는 상황일테니까 Assault Crash를 빵 때려주도록 할게요 그냥 안전빵으로 메고 아 캡슬로 오케이 그 다음에 얘를 다시 accept event로 복원을 시켜주도록 하겠습니다 accept event로 static cast를 통해 가지고 accept event로 다시 뿅 변신을 시켜주고 그 다음에 얘를 이제 실행하기 위해서 process accept로 얘를 다시 , 이렇게, 넘겨주도록 하겠습니다 고기를 잡았으면 이제 뭐 그걸 이제 고기를 낚싯대를 들어 올려가지고 고기를 떼내고 해야 되겠죠 그래서 그 부분이 이제 프로세스로 넘어오게 될 겁니다 요렇게 C샵 서버에서도 굉장히 비슷하게 예약을 해준 다음에 바로 처리를 처리가 되지 않으면은 나중에 콜백 방식으로 스레드풀에 있던 애를 깨워가지고 무엇인가 우리가 콜백으로 넣어준 그 함수를 실행했는데 그게 딱 지금 요 부분이라고 볼 수가 있는 거죠 C++이 어떻게 보면은 우리가 이걸 수동으로 다 관리하니까 훨씬 더 복잡하게 되어 있지만 흐름 자체는 그래도 어느 정도 비슷하다는 걸 알 수 있는 거고 실제로 C샵 서버로 만들어도 그게 윈도우즈 환경에서는 IOCP를 이용해가지고 구현이 된다라는 것도 , 일단은, 알 수가 있습니다 , 자, 그래가지고 process accept로 , 일단은, 우여곡절 끝에 돌아왔다 라고 하면은 이제 여기서 우리가 이런저런 행동을 할 수 있는데 , 일단은, session을 다시 꺼내 쓰도록 할게요 accept event에다가 우리가 이날을 위해서 session을 열심히 보관을 해뒀으니까 걔를 다시 꺼내가지고 아하 너였구나라는 걸 이제 알 수가 있는 겁니다 어... 그 다음에 이제 우리가 만들어준 함수 중에서 socket-util에 set update-accept-socket 이라는 걸 이제 호출을 해줄 것이고요 리스너 소켓이랑 옵션을 똑같이 맞춰주는 부분이라고 했었죠 만약에 여기서 우리가 이런저런 행동을 할 때 실패를 하게 되면 어찌되건 실패를 했더라 하더라도 register accept를 다시 걸어주긴 해야 됩니다 아까랑 마찬가지 이유에요 문제가 일어났다고 해서 얘를 걸어주지 않으면 이제 영영 다시는 손님을 못 받는 상태가 되기 때문에 항상 낚싯대를 끌어올린 다음에 고기를 뽑은 다음에 여기서 어떤 식으로든 리젯트 억셉트가 호출이 돼야 된다는 게 굉장히 중요합니다. , 이렇게, 일단은, 넣어줄 것이고 , 자, 그 다음에 그 다음에 해줄 거는 속 address in을 통해 가지고 이제 요 아이의 정보를 일단 한번 추출해 봅시다. 로고를 찍어 볼 거에요 나중에. sizeof 속 address는 sizeof 속... 뭐 이걸로 할까요? 속 address의 사이즈는 얼마이냐? 라고 한 다음에 여기서 우리가 누구누구가 접속했습니다 라는 로고를 나중에 찍어 보기 위해서 요 부분을 , 일단은, 간단하게 만들어 보도록 할게요. getPeerName 이란 함수를 이용해주고 session에 getSocket을 , 이렇게, 넣어줄 것이고 그 다음에 outReinterpretCastSockAddressPointerSockAddress 그 다음에 마지막으로 sizeofSockAddress의 추수를 , 이렇게, 넘겨주면 됩니다. , 이렇게, 해가지고 여기서 또 실패했으면 register accept를 다시 호출하는 부분을 똑같이 넣어주고 return을 해주면 되겠습니다 여기서 또 유심히 봐야 될 거는 우리가 accept 이벤트를 다 사용한 다음에 걔를 삭제를 하는 게 아니라 그냥 기존에 샀던 거는 어차피 다시 사용한 애가 없기 때문에 걔를 계속 재사용하고 있는 걸 볼 수가 있어요 그래서 처음에 만들어줄 때 생성해준 그 accept 이벤트를 이제 평생 계속 재사용한다는 걸 일단 알 수가 있는 겁니다 이 부분도 굉장히 흥미로운 부분이죠 , 자, 이렇게, 해가지고 뭐 만들어주면 될 것이고 개피어 네임을 통해가지고 방금 저 속 칸에 정보를 , 이렇게, 추출할 수 있었고요 그 다음에 이제 이어가지고 session에다가 그러면 set network address를 호출해가지고 얘를 net address로 변환해가지고 속 address를 , 이렇게, 넣어주도록 하겠습니다 getPeerName을 통해 가지고 이 속 어드레스를 추출한 다음에 걔를 다시 , 이렇게, 세팅하는 거죠. 그럼 , 이렇게, 되면 이제 나중에 이 세션 접속한 애가 누군지 알고 싶다고 하면은 아까 우리가 만들어준 그런 이런저런 기능들, net address 기능들을 통해 가지고 얘를 이제 추출할 수 있다라는 결론을 얻을 수가 있는 겁니다. 그러면 여기까지 왔으면 , 일단은, 성공적으로 client-connected가 뜬다라고 볼 수가 있는 거죠. 물론 여기서 끝나는 게 아니라 여기서도 이제 나중에 뭐.. 세션 매니저의 일 등록한다거나 하는 등등의 행동을 해주면 되는데 여기까지 , 일단은, 어.. 잘 되는지를 확인을 해보도록 하겠습니다. , 자, 그래가지고 뭐 굉장히 내용이 길었는데 여기까지 이제 한 번에 되면 굉장히 감사하겠지만 뭐 보통 조금씩 에러가 나겠죠 , 일단은, 여기서 에러 난 걸 살펴보면은 이 부분은 우리가 지난번에 풀 얼로케이터로 다 교체를 하는데 이 부분을 제가 교체를 안 했네요 x-alloc이랑 x-release가 더 이상 존재를 하지 않아 가지고 지금 얘가 발생한 문제이다 보니까 얘를 그냥 풀 얼로케이터로 대체를 해주도록 할게요 풀 얼로케이터의 얼록으로 우리가 만들어놨으니까 얘를 , 이렇게, 만들어주고 얘는 풀 얼로케이터의 릴리스로 , 이렇게, 교체를 해줬죠 이제는 우리가 이 x-alloc x-release를 해주는 게 아니라 여기 얼로케이터 내부에서 내부에서 우리가 어떤 옵션을 줬는지 따라가지고 스톰프를 쓰거나 아니면은 풀링을 하거나 둘 중 하나를 선택하겠는데 그 부분을 제가 수정을 안 해가지고 발생한 문제였습니다 그런데 왜 아까는 발생 안 하고 이제 발생했느냐 이 stl-allocator를 사용하는 데가 한 번도 없었다고 하면은 애당초 템플릿 자체가 구현이 되지 않아가지고 실체가 만들어지지 않았기 때문에 아무런 문제가 없었지만 지금은 우리가 리스너 쪽이었나요 이 벡터를 사용하다 보니까 얘가 이제서야 발견이 된 겁니다 컴파일러가 잡아준 거죠 그래서 얘를 다시 , 이렇게, 빌드를 해가지고 , 일단은, 통과를 시켜준 다음에 그러면 진짜 진짜로 원래 우리가 , 이렇게, 만들던 걸 이제 그럼 어떻게 바꿔줘야 되느냐 얘를 , 일단은, 삭제를 해보도록 할게요 그 다음에 이제 여기서 이제 어떤 식으로 구현을 하면 되냐면은 , 일단은, 리스너를 하나를 만들어 주도록 하겠습니다 물론 이것도 나중에 가면은 여기서 우리가 직접적으로 모든 애들을 다 구현을 하지 않겠지만 , 일단은, 리스너를 만들어 주고 에고 그 다음에 리스너 헤더도 여기다가 넣어줘야 되겠네요 , 자, 리스너를 만들어준 다음에 리스너에서 스타트 억셉을 여기서 때리게 될 것인데 여기다가 net address를 127.0.0.1로 만들어주고 포트는 777로 그냥 그대로 넘겨주면서 스타트 억셉을 빵 때리면은 뭐 사실상 얘가 내부적으로 리슨 소켓을 만들어 준 다음에 자기 자신을 등록함으로써 자기의 소켓을 여기다가 , 사실, 등록을 해줄 것이고 그 다음에 온갖 옵션을 설정해주고 바인드 리슨을 통한 다음에 이제 드디어 억셉트 예약을 빵 때려주게 될 겁니다 억셉트 예약이 때려줬으면 이제 진짜로 누군가가 접속을 시도해 가지고 커넥트를 만약에 요청했다고 하면은 그게 완료 통지가 IOCP를 통해 가지고 우리가 디스패치를 통해가지고 누군가가 걔를 이제 인지할 수 있게 될 겁니다. 그러니까 뭐 나머지 애들은 이제 무엇을 해야 되느냐 우리가 Thread를 몇 개를 만들어 놔가지고 Ivcp를 관찰하는 애들을 막 만들어줘야 돼요 그래서 그걸 여기다가 만들어주도록 하겠습니다 , 일단은, 이 Client Connected는 여기서 할 건 아니고 , 일단은, 한 5개만 만들어 볼 건데 이 Thread 개수는 무엇이 적당하느냐 보통은 Core 개수 내지 Core 개수의 한 1.5배 정도가 가장 적당하다고 알려져 있습니다 너무 어차피 많이 만들어 봤자 Context Switching 비용만 늘어나기 때문이죠 그래서 여기서 런치를 해가지고 , 자, 이제 쓰레드들을 막 일을 시킬 건데 기본적으로 쓰레드들이 해야 되는 일은 굉장히 단순한데 그냥 iocp 코어의 디스패치를 계속 무한적으로 해주면 될 겁니다 그래가지고 얘네들의 역할은 그냥 노예들처럼 계속 무한정으로 뺑뺑이를 돌면서 여기 IOCP 코어에 뭔가 들어온 일감을 처리하는 식으로만 우리가 구현을 해주면 된다라고 , 일단은, 1차적으로 볼 수가 있는 거죠 , 자, 여기서 밑줄이 그어진 거는 뭐 별다른 문제는 아닌 것 같고요 , 자, 이렇게, 일단 성공이 됐고 이제 그래가지고 여기서 실행을 해봐 뭐 사실은 어마어마하게 복잡한 일은 하진 않을 것이고 그냥 게임 서버에서 누군가가 들어오면 , 일단은, 되겠죠? , 자, 근데 지금 여기서 에러가 났다는 거는 , 자, 이벤트 타입을 제가 뭐 하나를 안 고쳐준 것 같네요 여기 돌아가가지고 살펴보면은 어.. accept는 connect, accept, receive, send로 되어있는데 근데 왜 안 바뀌었을까요? 아 그러면은 여기 이벤트 타입에서 아 이쪽이 빠졌네요 이벤트 타입을 여기서 설정하는 부분을 당연히 넣어줘야 되겠죠 , 이렇게, 그래야지만 요게 설정이 될 테니까 , 자, 그리고 보다 보니까 버그가 하나 더 있었는데 SetObjectSocket이 실패했으면 일로 들어와야 되니까 얘는 false인 경우가 일로 들어오는 거고 성공했으면 그냥 나머지 부분이 실행이 되니까 , 이렇게, 고쳐줘야 될 것 같습니다 , 자, 이렇게, 뭐 굉장히 장대한 코드를 작성해 봤구요 한번 빌드를 해 보도록 할게요 이 빨간 줄은 뭐 그냥 잘못 인식하는 것 같고 어... 이제 이거를 이제 실행을 해볼 건데 브레이크 포인트를 여기 디스패치 쪽에다가 잡아 보도록 할게요 이제 여러분들이 이 IOSP를 공부할 때는 이 흐름을 이해하는 게 진짜 진짜 중요한데 이게 생각보다 처음에는 이해하기가 조금 까다롭습니다 우리가 등록한 그 일꾼들이 디스패치를 막 호출하면서 여기 get queue completion status로 다 들어오게 될 거예요 그래서 여기서 대기를 타게 되겠죠? 무한정기 대기를 탈 텐데 만약에 여기서 일감이 있다 즉 어떤 애가 커넥트 요청을 빵 때렸다고 하면은 이제 한 애가 깨어나가지고 어 엑셉트 엑스텐디드로 우리가 걸어준 애가 완료가 될 테니까 얘가 이제 빠져나올 것이고 그 해당하는 우리가 키값으로 넣어준 애랑 그 다음에 LP 오버랩트로 넣어준 이 두 개가 복원이 될 겁니다 , 이렇게, 복원이 되고 있죠 물론 여기서 레퍼런스 카운팅을 해 줘 가지고 요 아이가 절대로 삭제되면 안 된다는 보장을 해줘야 되는데 일단 그 부분은 누락이 되어 있지만 어 , 이렇게, 일단은, 일단은, 지금 여기서 일단 들어와 가지고 디스패츠로 호출해 주게 되겠죠 디스패츠로 호출해 주게 되면 우리가 넣어준 키값으로 인해 가지고 리스너를 복원시켜 줬고 그 다음에 두 번째 인재로 넣어준 요 IOCP 이벤트를 다시 이거 브레이크본드 잡아 가지고 나와 줬는데 다시 잡아 줘 가지고 결국에는 어떻게 되냐면은 얘를 다시 복원을 시킨 다음에 프로세스 억셉트를 이제 실행해 가지고 얘를 다시 진행해 주게 될 겁니다 얘가 이제 낚싯대를 끌어 올린 다음에 물고기를 막 제거하고 손질하는 그런 부분이겠죠 그러면은 여기서 우리가 연동해 준 그 세션을 다시 끄집어 와 가지고 얘를 뭐 , 이렇게, 설정을 해주고 그 다음에 Get Peer Name을 호출해가지고 이 Socket Address를 추출했는데 지금 정상적으로 들어가 있다는 걸 볼 수가 있습니다 요 포트가 클라이언트 쪽에서 자동으로 할당된 그 포트라는 걸 알 수가 있고요 그 다음에 127.0.0.1이 들어가 있는 것도 이제 확인을 해볼 수가 있습니다 그래서 얘가 , 이렇게, 세션에 연결이 됐고 이제 여기서 뭐 세션이 접속이 되었다라는 뭐 그런 부분들을 호출해주면 될 것이고 클라이언트 커넥티드가 신나게 외쳐주고 그 다음에 모든 일감이 끝났으면 이 부분이 또 굉장히 중요한데 다시 한번 리지스터 억셉트를 똑같이 예약을 해줘야 된다라고 볼 수가 있는 거죠 그래야지만 우리가 낚싯대를 끌어 올려 가지고 물고기를 다 손질한 다음에 물고기를 뗀 다음에는 다시 낚싯대를 물에다가 던져 줘야지만 다음 고기를 낚일 수가 있겠죠 그 부분이 이제 이어가지고 반복적으로 실행이 된다고 보시면 되겠습니다 그때마다 , 이렇게, 세션을 다시 새로 만들어도 되고 풀에 있던 거를 세션 풀을 만들어 가지고 꺼냈어도 되지만 이거는 뭐 어떻게 만들건 이런 식으로 세션을 다시 만들어 가지고 똑같은 부분이 다시 시작이 될 건데 다시 초기화를 해준 다음에 새로운 세션으로 연동을 시켜주고 똑같이 Accept Extended를 다시 걸어준다라는 게 굉장히 핵심적인 내용이 될 겁니다 그럼 이 상태에서 또 다른 애가 들어오면 또 이제 얘가 끝나가지고 똑같은 코드가 계속 반복되게 되겠죠. 이제 여러분들이 굉장히 중요한 거는 이 코드를 굉장히 깊이 이해를 할 필요가 있어요. 이게 C샷 코드도 거의 이런 식으로 동작을 했었죠. 제가 심지어 아마 리지스터 프로세스 이름도 똑같이 아마추어 났을 겁니다. 그렇기 때문에 이 코드를 잘 이해하시게 된다면 앞으로 등장할 샌드랑 리시브도 마찬가지로 이해를 할 수 있겠지만 그게 아니라고 하면 굉장히 헤맬 수가 있어요 그래서 제가 코드를 또 역시나 올려 드릴 테니까 이 코드 흐름을 잘 분석을 해 보시기를 바라겠습니다 컴피션 포트를 만들고 등록하고 디스패치를 하는, 즉 워커스레드들이 감시해가지고 일감을 꺼낸다 그리고 실행해준다라는 이 흐름을 반드시 잘 숙지를 해주셔야 다음 강의도 원활하게 이해를 해줄 수가 있을 겁니다 , 자, 이렇게, 해가지고 뭐 , 사실, 굉장히 너무 허무하죠 구조는 굉장히 어렵지만 결국 얘가 하는 이유는 그냥 이 스타트 억셉트를 빵 때려가지고 iocp를 통해가지고 억셉트 엑스텐디를 받고 있다라는 결론을 우리가 내릴 수가 있겠습니다.