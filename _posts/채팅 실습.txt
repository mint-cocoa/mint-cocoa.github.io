자, 일단 , 이렇게, 해가지고 지난번까지 프로토버프 이식을 정상적으로 끝냈고 그 다음에 자동화 코드도 만들어 가지고 우리가 편리하게 패킷 작업을 할 만한 그런 틀을 마련을 했습니다 그리고 , 사실, 여러분들이 뭐 그냥 간단한 프로젝트를 만들어 가지고 포트폴리오를 만든다고 하면은 , 사실, 여기까지만 해도 충분하고도 넘칩니다 근데 이제 이번 단원에서 배울 잡큐와 관련된 내용은 이제 왜 필요하냐면 그냥 동접 몇십 명이 아니라 몇천명 단위로 진짜 진지한 큰 MMO를 만들 때 그냥 여기까지 우리가 만든 방식으로는 조금 아쉬운 부분이 생기기 시작하는데 이제 그런 부분에 대해서 학습을 해볼까 해요 그래서 만약에 제 C샵 강의를 보셨다면 잡큐라는 게 무엇이고 왜 필요한지 확실히 이해를 하셨겠지만 그게 아니라고 한다면 이게 처음에는 굉장히 직관적이지 않다 보니까 간단한 예제를 들어가서 이제 실습을 해보고자 합니다 그래서 오늘은 이제 간단하게 일종의 채팅 프로그램을 만들어 가지고 몇백 명의 유저들이 하나의 방에 들어온 다음에 그 다음에 뭐 간단하게 헬로 월드 같은 그런 메시지를 서로 뿌리고 채팅을 하는 그런 실습을 해볼 겁니다 근데 왜 굳이 게임을 안 만들고 채팅을 만드느냐 , 사실, 게임이랑 우리가 말하는 MMO랑 채팅이랑은 거의 종이 한 장 차이라고 보시면 돼요 채팅이라는 거 자체가 클라이언트가 메시지를 서버 쪽에 보내고 서버는 그 메시지를 받아가지고 같은 방에 있는 모든 다른 클라이언트한테 쫙 뿌리는 게 결국에는 그냥 채팅이죠 근데 나중에 가면 그 채팅 패킷을 바꿔가지고 그냥 뭐 메시지를 간단하게 채팅 메시지를 보내는 게 아니라 뭐 이동 요청이라거나 아니면은 공격 요청, 스킬을 쓰겠다, 템을 입겠다라는 등등의 행동 자체를 똑같이 받아가지고 주변에 있는 모든 애들, 즉 방에 있는 모든 유저들한테 다 뿌리면은 그게 그냥 MMORPG라고 보시면 되는 겁니다 그래가지고 서버 입장에서 보면은 , 사실, 어떤 패킷을 주고 받느냐는 뭐 크게 중요한 게 아니고 결국에는 그 모든 주변 애들한테 뿌리는 그 행동, 브로드 캐스팅 하는 자체가 중요한 거라고 보시면 되겠어요 , 자, 그건 그렇고 지난번에 제가 몇가지 좀 버그가 있던 것 같더라구요 몇가지만 짚어드리자면 , 일단은, 여기 서버코어에서 환경설정에서 속성에 갈 때 , 자, 이 부분에서 출력 디렉터리를 , 이렇게, LIPS에 서버코어까지 붙여줘 가지고 만들어줘야 되는데 제가 강의코드에서만 그런건지 모르겠는데 이 부분이 빠져 있더라구요 그래가지고 지금 서버코를 빌드하면은 엉뚱한 라이브러리 바로 아래다가 디버그 폴더 안에다가 만들어 주기 때문에 경로가 조금 잘못된 문제가 있었는데 이 부분을 확인해서 , 이렇게, 정상적인 경로로 되어있는지를 , 일단은, 확인하시면 되겠고요 그 다음에 이제 오늘 실습을 해볼 거에서 이제 메시지에서 뭐 이런 식으로 스트링 같은 게 이제 들어가게 될 겁니다 이런 느낌으로 스트링 네 참고로 프로토버프에서 스트링이라는 요 아이는 C++ 기준으로 UTF-8만 지금 우리가 넣어줄 수가 있다고 하더라구요 그래서 만약에 UTF-16으로 갈 거면은 요 스트링을 사용하면 안되고 그냥 일반적인 그런 바이트 배열에다가 우리가 데이터를 넣어 놓은 다음에 스트링으로 W 스트링으로 다시 변환하는 그런 작업을 해줘야 됩니다 뭐 그건 그렇고 지금 요 상태에서 이걸 이제 빌드하면은 에러가 날텐데 그게 이제 프로토버프에서 뭔가 링크 에러라는 에러가 나더라구요 그래가지고 그거에 대해서 좀 찾아봤더니만 딱히 우리 문제라고 하긴 뭐하고 그냥 특정 버전에서 프로토버프에서 일어나는 문제라고 합니다 환경과 관련된 문제는 항상 , 이렇게, 좀 복잡한 상황이 있어요 , 자, 그래가지고 이거에서 잠시 언급을 드리자면 우리가 원래 , 이렇게, C메이크를 이용해서 포토버프 라이브러리를 만들때 원래 이전에 만들때는 여기 Shared Libraries 하는걸 클릭된 상태로 아마 요 두개를 클릭해가지고 제가 만들었던 걸로 기억을 하는데 좀 구글링을 해보니까 이걸 끄고 모든걸 다 , 이렇게, 클릭을 하지 않은 상태에서 제너레이트를 한 다음에 다시 만들라고 , 이렇게, 되어 있더라구요 어떤 블로그에서 이 SharedLib을 키고 만들라고 해가지고 저도 낚였는데 이걸 다 해제하고 다시 만든 다음에 디버그 릴리즈 환경에서 다시 한번 라이브러리를 , 일단은, 빌드를 해서 다시 옮겨주시길 바라겠습니다 물론 이거 빌드 굳이 하지 않더라도 제가 어차피 이 빌드된 결과물을 , 일단은, 올려 드릴 테니까 그거를 그냥 복붙해서 바로 집어 넣으셔도 됩니다 그래서 결과적으로 여기 어 라이브러리즈, 립스, 산하에 프로토퍼프에 요기 디버그 쪽 요 lib 파일이랑 릴리즈에 lib 파일 요 두개를 , 일단은, 복붙을 하시면 되겠고요 그 다음에 아까와 방식으로 빌드를 하게 되면은 굉장히 재미있게도 DLL을 더 이상 요구하지 않더라구요 그래서 실행을 할 때 DLL이 필요 없기 때문에 여기 DLL도 , 일단은, 그냥 같이 삭제를 해주시면 되겠습니다 겸사겸사 , 자, 그건 그렇고 요렇게 해가지고 뭐 짜잘한 그런 환경과 관련된 이슈가 이제 해결이 된다고 치면은 이제 이어가지고 오늘 만들어 볼 패킷을 일단 간단하게 어 설계를 해보고 오도록 할게요 그래서 , 일단은, 요 파일을 열어가지고 내용을 , 일단은, 다 삭제를 하고 새로운 마음으로 시작을 해보자면 이제 일반적인 게임을 기준으로 그리고 , 사실, 채팅도 마찬가지긴 하지만 이제 어떤 식으로 게임이 진행될지를 생각을 해봅시다 처음에 우리가 온라인 게임을 켜 가지고 접속을 하면 먼저 클라 쪽에서 로그인 요청을 하겠죠 이런 식으로 보통은 이제 뭐 비밀번호 내 계정이랑 비밀번호를 입력해가지고 보내주겠지만 우리는 그냥 그 부분을 생략하고 클라한테서 나 로그인할래 라는 요청을 서버쪽에다가 건네주게 될 것이고 그러면 서버쪽에서는 클라가 건네준 정보를 토대로 체크를 한 다음에 성공여부를 뱉어주게 되겠죠 그 다음에 성공여부를 뱉어준 다음에 이제 DB에서 그 해당 플레이어, 해당 유저와 관련된 정보들을 싸그리 긁어가지고 같이 건네주게 될 겁니다 물론 이걸 하나의 패킷에서 같이 처리하기보다는 좀 구분을 해주는 게 좋긴 하겠지만 지금은 편의상 패킷 수를 최대한 줄이기 위해서 여기다가 같이 낑겨 넣도록 할게요 , 자, 그래서 여기다가 이제 이 해당 계정에 들어가 있는 그런 플레이어 정보들을 긁어와가지고 보내주는 작업을 해줄 것인데 플레이어의 정보 자체는 이 struct.proto라는 파일에다가 우리가 만들어 주도록 하겠습니다 이걸 잠시 왼쪽에다가 , 이렇게, 옮겨 놓도록 할게요 그래서 여기다가는 뭐 원래는 버프 데이터라는 것만 있었는데 이걸 이제 플레이어라는 이름으로 수정을 하도록 하고 플레이어 정보는 뭐 뭐가 있을까요? , 일단은, 아이디가 있을 거고 요 아이디는 데이터베이스에서 사용하는 그 아이즈는 아니고 그냥 게임을 실행할 때마다 1부터 쭉 증가하면서 그냥 발급하는 아이디라고 보시면 되겠습니다 항상 다른 플레이어를 지칭할 때 이 아이디 기반으로 우리가 뭔가를 하기 때문에 이제 이 아이디가 굉장히 중요한 역할을 맡게 될 거예요 예를 들면 이 플레이어가 뭐 1005번 몬스터를 공격하겠다라는 식으로 요청을 주게 될 거고 그 1005번에 해당하는 몬스터를 찾아가지고 피를 깎고 이런 식으로 진행한다는 얘기가 되는 거죠 그리고 뭐 이 해당 유저의 이름도 일단 넣어주고 그 다음에 우리가 지난번에 플레어 타입이라는 걸 넣어놨으니까 얘도 , 일단은, 재사용을 해보도록 하겠습니다. 플레어 타입은 딱 마침 우리가 , 이렇게, 만들어놨어요. 나이트, 메이지, 아처. 얘는 그냥 디폴트 0이라는 값이었고 이거를 뭐 , 이렇게, 간단하게 만들어보고 나중에 가면 여기서 뭐 스탯 정보도 있을 거고 온갖 정보를 추가해주면 되겠습니다. 그래서 이 정보를 로그인을 성공한 다음에 같이 보내주도록 할게요. 근데 얘가 생성한 플레이어가 여러개가 있을 수 있으니까 플레이어스라고 리피티드라고 해가지고 여러개를 배열 형태로 묶어가지고 보내주도록 하겠습니다 네 , 이렇게, 일단은, 넣어주도록 하고 그리고 참고로 여기서는 아직은 아이디 발급 전 상태로 , 일단은, 보내줘도 상관이 없긴 합니다 당장은 아이디가 필요 없고 나중에 실제로 인게임에 접속할 때는 반드시 이 아이디가 있어야 돼요 , 자, 그래가지고 그 다음에 그러면 플레이어가 여기 있는 목록을 받아 가지고 로비 창으로 들어오게 되겠죠 그럼 로비 창에서는 이제 무엇을 해줄 것이냐 캐릭터가 있냐 없냐에 따라 가지고 만약에 여기 있는 정보가 하나도 없다 내가 아직 캐릭터를 하나도 안 만들었다고 하면은 캐릭터 생성 창으로 가 가지고 원래 뭐 캐릭터를 만들고 이름도 설정하고 클래스도 고르고 해야 될 겁니다 근데 일단 그 부분을 생략하고 뭐 여기 있는 플레이어가 있다고 가정을 하고 어.. 만약에 있다고 하면은 여기 있는 플레이어 중에 하나를 골라가지고 그거로 접속을 이제 시도를 하겠죠 그래서 이제 게임에다가 나 이 캐릭터로 게임에 들어갈래 라고 요청을 할 거고 그거를 이름하여 엔터 게임이라는 패킷으로 설계를 합시다 그리고 여기서 보내줄 거는 플레이어 인덱스를 같이 보내주도록 할게요 여기서 받은 플레이어 목록 중에 몇 번째 플레이어 인지를 , 이렇게, 보내준다고 가정을 하고 , 자, 그러면은 역시나 서버 쪽에서는 이거를 체크해가지고 얘가 뭐 들어올 수 있는지 없는지를 뭐 이런식으로 불리언으로 다시 체크해가지고 뱉어주면 되겠죠 너 어 이 캐릭터로 들어올래? 오케이 라고 이제 막 다시 전달해주게 될겁니다 그 다음에 보통 이제 게임에 입장을 하면은 뭐 현재 그 필드에 있는 모든 유저들의 정보라거나 등등의 정보를 원래 여기서는 같이 보내줄텐데 지금은 그냥 간단하게 위해서 그런 부분에 스킵을 하도록 할게요 뭐 , 일단은, 게임에 성공적으로 들어왔다라고 가정을 해봅시다 , 자, 그 다음에 이제 오늘 실습할 채팅 메세지 클라이언트 쪽에서 뭐 하고 싶은 말이 있으면 이제 see under my chat라는 메세지 패킷으로 메세지를 이제 전달해주게 될 것인데 서버 쪽에서는 그거를 받으면은 해당하는 플레이어가 누구인지 지금 채팅을 하고 있는 애는 누구인지를 , 이렇게, 메세지랑 같이 전달해주게 될 거예요 물론 나중에 가면은 이걸 플레이어 아이디뿐만 아니라 해당 플레이어의 이름이라거나 하는 정보까지 같이 보내줘 가지고 말풍선을 띄운다거나 뭐 할 수가 있겠죠 뭐 이건 여러가지 옵션이 있겠지만 기본 틀은 약간 이런 흐름으로 일단 동작한다고 일단 예견을 할 수가 있겠습니다 , 자, 그러면 일단 , 이렇게, 패킷 설계까지 끝났으면 일단 빌드를 해가지고 빌드를 하면 지금 워낙 바뀐 게 많다 보니까 여기서 에러가 왕창 나겠죠 그 부분을 , 일단은, 해결하고 넘어가도록 할게요 근데 이런 문제들은 뭐 딱히 심각한 버그라기보다는 그냥 패킷이 바뀌었기 때문에 발생하는 뭐 그런 아이들이구요 여기서 인벨리드 아래 있는 애들을 , 일단은, 싸그리 다 날려준 다음에 , 자, 하나씩 구현부를 임플레멘테이션을 요렇게 만들고자 만들도록 할게요 , 이렇게, 그 다음에 , 일단은, 기본적으로 리턴 2로는 다 , 이렇게, 추가를 해주도록 하겠습니다 , 자, 이렇게, 해가지고 패킷을 다 추가를 해주고 다시 빌드 해서 문제가 또 있는지 한번 찾아보도록 할게요 별다른 문제가 없으면 통과될 것이고 그게 아니라고 한다면 뭐 이런 식으로 에러가 날 테니까 , 자, 지난 시간에 우리가 작업하던 테스트 패킷에서 문제가 나오고 있는데 얘는 그냥 싸그레 날려주면 되겠고요 여기까지 , 일단은, 다 날려주도록 하겠습니다 얘는 뭐 딱히 필요 없을 것 같으니까 여기까지도 날려주고 얘도 필요 없으니까 삭제를 해주고 그 다음에 다시 한번 또 빌드를 해서 진짜 진짜 통과가 되는지 살펴보도록 할게요 , 자, 이렇게, 컴파일러한테 떠넘겨가지고 일단 버그를 다 잡아놨구요 , 자, 그럼 , 일단은, 서버쪽은 해결이 됐으니까 이제는 더미 클라이언트 쪽으로 올라가가지고 여기도 마찬가지로 한번 빌드를 해보도록 하겠습니다 여기도 마찬가지로 뭐 이런저런 문제가 있겠죠 지금 패킷이 바뀌었기 때문에 여기도 마찬가지로 이런저런 문제가 일어나고 있는데 여기서 핸들 테스트랑 로그인 부분도 역시나 삭제를 하고 그 다음에 여기 있는 패킷을 순서대로 하나씩 만들어 주도록 하겠습니다 만약에 여러분들이 비주얼 어시스터가 없다고 하면은 컨트롤 점점 엔터로 , 이렇게, 만들어주시면 돼요 그리고 만약에 비주얼 어시스터로 만들었으면은 리턴 2로까지 같이 , 이렇게, 추가를 해주신 다음에 다시 빌드를 시도를 해보도록 하겠습니다 그럼 한 번 더 에러가 왠지 날 것 같은데 조금 기다리다 보면은 어 성공이 됐네요 , 자, 이렇게, 가지고 , 일단은, 시작을 한 준비가 되었어요 그러면 우리는 아까 설계하고 있던 패킷을 고지곳대로 보면서 순서대로, 흐름대로 작업을 해보도록 하겠습니다. 곰곰이 생각을 해봐가지고 , 일단은, 이 로그인 패킷이 언제 호출이 되어야 되느냐 말그대로 처음에 접속을 했을 때 호출이 되겠죠? 우리는 지금 더미 클라이언트에서 이 클라이언트들이 로그인을 하는 것을 시뮬레이션 하고 있었으니까 이 부분에서 온코넥티드가 떴다고 하면 여기서 뭔가를 해주면 되겠습니다. 네트워크 연결이 되었다고 하면 이런식으로 프로토콜의 CLogin을 통해 연결해주게 되겠죠. 비밀번호라거나 아이디를 입력해가지고 로그인하는 부분까지 원래는 처리가 돼야 되는데 , 사실, 그건 엄밀히 말해서 게임서버 쪽에 바로 붙지는 않고 보통 인증서버는 이제 웹으로 만들어서 붙는 경우가 많습니다 근데 뭐 그거는 C샵 강의에서 웹서버랑 토대로 전체 설계 대선 얘기를 했으니까 지금은 그냥 간단하게 그런 인증은 통과되었고 일단 게임서버로 로그인을 하는 상황이라고 일단 가정을 해볼게요 그래서 여기서 이제 그 다음에 해야 되는 거는 샌드 버퍼를 만들어 가지고 서버 패킷 핸들러 메이크 샌드 버퍼를 , 이렇게, 일단은, 만들어 준 다음에 샌드를 해주면 되겠죠 네 요렇게 , 일단은, 시작을 해 주도록 하겠습니다 요 로그인은 별다른 인자가 없으니까 그냥 고지 곳대로 그 패킷만 만들어 가지고 방금과 마찬가지로 그냥 요렇게 , 일단은, 보내주면 되겠습니다 , 자, 그럼 이제 순서대로 다시 생각하기로 했으니까 C-login을 만약에 보냈다고 하면은 반대쪽에서 S-login을 먼저 받아주게 될 겁니다. 아 이거 C-login을 이제 핸들... C-login을 이제 핸들하게 될 겁니다. 말이 헷갈리네요. 그러면 그 부분은 이제 다시 내려가가지고 여기서 ClientPacketHandler라는 해서 C-login이라는 부분으로 와가지고 이제 그 다음 부분이 실행이 되겠습니다. 그러면은 뭐 요 부분에서 이런저런 체크를 해줘야 되겠죠, 여기서. 지금 같은 경우에는 패킷 세션 랩으로 우리가 받아주기 만들어놨는데 실질적으로 정보 자체는 우리가 게임 세션이라는 걸로 만들어가지고 여기다가 이제 받아주고 있으니까 이걸 , 일단은, 게임 세션으로 바꿔치기를 한번 해보도록 하겠습니다 게임 세션을 일단 바꿔서 시작을 하도록 할게요 스태틱 포인터 캐스트 게임 세션으로 , 이렇게, 바꿔치기를 한 다음에 캐스팅을 해준 다음에 그 다음에 여기서 뭐 이런저런 지금 여기가 에러가 나고 있는 이유는 아 여기 랩프가 없네요 , 자, 이거 PCH 가가지고 오늘 추가할 게임 세션 랩프를 , 이렇게, 추가를 해주도록 하겠습니다 클래스 게임 세션이라고 , 이렇게, 추가해 주도록 하고 지금은 이름을 처음에 지은 대로 게임 세션으로 하고 있지만 나중에 가면 , 사실, 클라이언트 세션으로 하는 게 조금 더 좋습니다 왜냐하면 이게 역시나 서버끼리도 서로 연동을 해가지고 붙을 수 있기 때문에 게임 세션이라고 하면 이게 클라이언트 걸 의미하는지 아니면 다른 서버를 의미하는지가 굉장히 애매하기 때문에 이름을 조금 , 이렇게, 성의 없이 짓는 건 좋지 않지만 , 일단은, 오늘은 그냥 진행하도록 할게요 그래서 게임 세션으로 , 일단은, 이렇게, 캐스팅을 해가지고 뭐 사용할 것이다 라고 볼 수 있는 거구요 그 다음에 여기서 이제 이어가지고 상대방이 로그인을 했으면 뭐 이런저런 밸리데이션 체크를 한 다음에 그 다음에 뭐 입장을 성공했다고 이제 정답 다시 한번 회답을 주면 되겠죠 s-login으로 회답을 줄건데 이거를 괜히 똑같은 이름으로 지으면은 요 패킷이랑 요 패킷이랑 지금 이름이 같다보니까 문제가 일어날 수 있으니까 로그인 패킷이라고 , 이렇게, 만들었습니다 로그인 패킷에서 set success를 해가지고 오케이 너 이제 성공적으로 로그인 했어 라고 설정을 해 준 다음에 그 다음에 원래라면 이 시점에서 대충 db에서 플레이어 정보를 이제 긁어오는 부분을 뭐 해주면 되겠습니다 그리고 그 다음에 긁어온 정보를 게임 세션에다가 플레이어 정보를 저장해야 되겠죠 메모리상에 저장해야 되겠습니다 보통은 이걸 게임 세션 안에다가 바로 때려박지는 않고 계정과 관련된 클래스를 만들어가지고 예를 들면 Account라는 클래스를 만들어가지고 거기다가 , 일단은, 때려박는 게 일반적이긴 하겠지만 지금은 모든 클래스를 다 만들기는 좀 벅차니까 여기다가 , 일단은, 만든다고 가정을 해볼게요 여기서 플레이어를 만들어 줄 것인데 플레이어를 잠시 우리가 게임 서버에서 , 자, 새로 만들기에 가가지고 추가. 새 필터를 일단 만들어 준 다음에 게임 컨텐츠를 여기서 , 일단은, 관리를 해주도록 하겠습니다. 게임 컨텐츠. 그 다음에 이제 여기서 클래스를 만들어 줄 건데 오늘 사용할 플레어라는 클래스 하나랑 그 다음에 룸이라는 클래스 두 개를 , 일단은, 추가를 해주도록 할게요. 룸. 그래서 , 이렇게, 일단은, 두 개를 추가해준 다음에 여기다가 , 일단은, 연결을 시켜주고 요 플레이어는 말 그대로 그냥 플레이어의 정보만 간단하게 들고 있는 형태로 뭐 만들어주도록 할게요 그래서 뭐 별다른 정보는 없을 것이고 심지어 그냥 편하게 사용하라고 다 퍼블릭으로 열어줄 것인데 뭐 일반적으로 뭐가 있을까요 플레이어 아이디를 나중에 발급해가지고 관리할 것이고 요 해당 플레이어의 이름이라거나 그리고 플레이어 타입 내가 어떤 플레이어인지 프로토콜에 플레이어 타입 초기값은 none으로 합시다. 그리고 게임 세션 ref라고 해가지고 내가 소속된 게임 세션을 또 , 이렇게, 물고 있도록 할게요 다만 여기서 만약 , 이렇게, 이거를 Share the Pointer로 만들어주면은 어... 세션에서도 플레이어를 알고 플레이어도 게임 세션을 알면은 사이클 문제가 있긴 할 겁니다 이건 나중에 메모리 누수를 예방하기 위해서는 이 사이클을 언젠가는 끊어주긴 해야 될 거예요 , 자, 그리고 PCH에 가가지고 여기 가가지고 여기 헤더 같은 경우에는 이 인원값 같은 경우는 이제 공용으로 언제 어디서나 편하게 활용할 수 있게끔 얘는 일단 여기다가 , 일단은, 추가를 해주도록 할게요 뭐 , 사실, 나머지들도 여기다가 추가해서 편하게 사용해도 되긴 하는데 어... 이런 팩킷들은 금방 금방 변할 수 있으니까 이걸 PCH에다가 넣어 놓으면은 전체 빌드가 좀 빈번하게 일어날 수 있기는 합니다 뭐 그건 그렇고 그게 뭐 작은 프로젝트에서는 크게 상관이 없으니까 일단 , 이렇게, 놓고 진행을 해보도록 합시다 그래서 이젠 플레이어의 정보는 대충 , 이렇게, 플레이어 아이디랑 이름이랑 타입 그리고 나는 누구한테 소속이 되어 있느냐 오너까지 , 이렇게, 포함을 하도록 만들어 줬습니다 , 자, 그 다음에 또 간단하게 어 아까 만들던 방이라는 개념을 미리 만들어 줄 것인데 요 방은 이제 말 그대로 인게임 세상을 원래 얘기하겠지만 지금은 그냥 채팅에서 사용하는 그 방을 말하고 채팅방을 말을 하고 있는 겁니다 그래서 나중에 보면 방도 여러 개가 있어 가지고 뭐 룸 매니저 같이 방을 관리하는 매니저가 있겠지만 지금은 그냥 간단한 채팅 테스트를 하고 있는 거니까 방을 그냥 하나만 존재한다고 가정을 하고 플레이어들을 , 자, 이런식으로 플레어 랩으로 들고 있도록 할게요 , 자, 플레어 랩도 마찬가지로 P스위치에 가가지고 복붙한 다음에 플레어 랩으로 바꿔주고 요 부분을 플레어 랩으로 , 이렇게, 설정을 해주도록 할게요 얘도 그냥 편하게 사용을 해주도록 하겠습니다 , 자, 그래가지고 플레어들을 , 이렇게, 룸 안에다가 얘가 물고 있을거고 뭐 입장한다 엔터라고 해가지고 플레어가 입장할 때 그리고 leave라고 해가지고 플레어가 떠날 때 함수를 만들어주고 그 다음에 이 방에 있는 애들한테 전체의 대상으로 브로드 캐스팅하는 그런 함수도 하나 만들어주도록 합시다. 샌드 버퍼를 받아가지고 그 모든 애들한테 뿌려주게 될 거예요. , 자, 그래서 요 세 아이를 , 일단은, 다 인플래멘테이션을 만들어 가지고 작업을 해 볼 건데 먼저 엔터가 실행이 됐다라고 하면은 라이트 럭을 잡아 가지고 플레이어스라는 요 맵에다가 플레이어의 아이디를 뭐 추가해주면 되겠죠 요런 느낌으로 간단하게 요렇게 , 일단은, 추가를 해주면 되겠습니다 요렇게 됐고 , 자, 그 다음에 어 여기다가 include 플레이어는 추가를 해줘야 되겠습니다 아이고 여기가 오타가 났네요 , 자, 그리고 이제 이거 얘는 왜 들어갔는지 모르겠는데 프로게스트 삭제를 해주도록 하고 , 자, 그 다음에 리브가 만약에 리브가 실행이 되어야 된다 내가 떠나겠다고 하면 똑같이 락을 잡아준 다음에 플레이어스에다가 예를 들면 이레이스를 해가지고 플레이어의 아이디에 해당하는 걸 탁재해준다거나 하는 식으로 만들어주면 되겠고 그 다음에 브로드 캐스팅을 한다는 의미는 역시나 락을 잡아준 다음에 그 다음에 여기 안에 있는 모든 애들한테 하나씩 하나씩 어.. 스네일을 해주면서 걔네들한테 뿌려주면 되겠죠? p second에 owner session을 찾아가지고 샌드를 해주겠다 뭐 요런식으로 , 일단은, 간단하게 만들어줄수가 있을겁니다 그래가지고 이제 뭐 만약에 어떤 애한테 보내고 싶은 전체 대상으로 쏴주고 싶은 브로드캐스팅 단위가 있다고 하면은 여기다가 이제 쏴주면 된다라고 볼 수가 있는 거죠 , 자, 그 다음에 불완전한 클래스에 대한 모식이라고 하는데 이거는 게임 세션을 게임 세션이 없어서 그런 것 같네요 게임 세션을 추가를 해주도록 하겠습니다 , 자, 요렇게 뭐 , 일단은, 추가를 해봤구요 그래서 뭐 간단하게 사용할 오늘 실습할 플레이어랑 룸이라는 개념에 대해서 , 일단은, 만들어 봤구요 그 다음에 이제 뭐 룸 매니저를 만들기 귀찮으니까 그냥 공용으로 저녁에 룸을 하나를 그냥 , 이렇게, 전체로 들고 있도록 할게요 이건 진짜 오늘 테스트하기 위해서 입니다 그래서 저녁으로 룸 하나를 만들고 모든 애들을 다 이 룸에다가 때려 박아 가지고 접속 시킨 다음에 채팅 실습을 이 룸 단위로 해보도록 하겠습니다 , 자, 이렇게, 일단은, 만들어놨구요 그래가지고 돌고 돌아 가지고 우리가 뭘 하고 있는지 다시 한번 정신을 차려보고 돌아가면은 , 자, 우리가 지금까지 요 부분을 하고 있었죠 s 로그인 2단계를 하고 있었습니다 로그인을 한다고 했을 때 로그인을 할 때 이제 무엇을 처리해야 되느냐 결국에는 요 부분에서 먼저 아이디를 발급을 해보도록 합시다 아이디 발급 얘는 db 아이디가 아니고 인게임 아이디를 의미하는데 뭐 굳이 여기서 당장 발급을 안해도 되긴 하지만 그냥 지금은 여기서 빨리 하도록 할게요 간단하게 하기 위해서 아이디 발급을 여기서 그냥 스태틱 변수를 하나 만들어가지고 아이디 제너레이터라고 한 다음에 이걸 이용해가지고 하나씩 하나씩 뭐 만들어 보도록 합시다 , 자, 그 다음에 이제 이어가지고 여기서 어 먼저 플레어를 만들어 줘야 되니까 로그인에다가 add players를 해가지고 여기다가 이제 하나를 더 추가를 해주도록 합시다. 요 패킷에다가 지금 추가를 해주고 있는 겁니다. 이 플레이어 정보. 뭐 나중에 그러면 DB에서 긁어온 플레이어 개수만큼을 만들어도 되겠지만 지금은 그냥 뭐 두 개가 있다라고 가정을 해보도록 할게요. 그럼 여기서 set name이라고 한 다음에 utf-8로 만들어가지고 뭐 DB에서 나중에 긁어온 이름이라고 그냥 1번이라고 합시다. 뭐 요런 이름 같은 걸 넣어주면 되겠죠. 그 다음에 set 플레어 타입도 설정해가지고 프로토콜에 플레어 타입 모시기 예를 들면 기사 타입으로 , 이렇게, 넣어줄 수가 있겠죠 , 자, 요거는 이제 이 팩킷을 지금 채우고 있는 작업을 하고 있는 거고 그게 아니라 메모리 상으로도 요걸 들고 있어야 된다고 했었죠 물론 이 프로토콜을 우리가 만들어준 요 아이 자체를 이용해가지고 메모리 들고 있어도 되는데 지금 우리는 그냥 플레어 레프라고 따로 클래스를 만들어가지고 이 클래스로 지금 관리하고 있으니까 이걸로 다시 한번 만들어 주도록 하겠습니다 PlayerRef는 makeShared 라고 한 다음에 플레어를 만들어 주세요. 스마트 포인트로 관리할 것이다. 그 다음에 플레어를 이제 아이디도 기입을 해주고 아이디 제너레이터 뿔뿔 해줘 가지고 아이디를 만들어 준 다음에 여기다가 저장을 했고요. 그 다음에 include 플레어 헤더를 추가를 하고 진행을 해보도록 하겠습니다. 그 다음에 하는 김에 룸도 필요할 것 같으니까 여기서 룸도 추가해주도록 할게요 요렇게 그러면은 이제 이어가지고 플레어의 아이디도 할당을 했고 그 다음에 플레어의 이름은 무엇이냐 위에 있는 플레어의 네임을 꺼내와가지고 똑같이 복붙을 해주고 그 다음에 디비에서 꺼내온 뭐 타입 같은 것도 요기다가 뭐 연동을 해주면 되겠죠 위에서 설정한 걸 토대로 다시 한번 메모리 설정도 해보도록 합시다. 이런 느낌으로. 그 다음에 까먹지 않고, On-Off Session, 나는 지금 어떤 Session이 포함되어 있는가도 , 이렇게, 연결을 시켜줘야 되겠죠. 그래서 이 게임 세션에 해당하는 플레이어라고 하는 거고 마찬가지로 이 세션이라는 존재 자체에서도 , 사실, 내가 지금 들고 있는 플레이어들을 메모리상에서 들고 있기는 해야 됩니다. 그렇기 때문에 게임 세션에 돌아가서 게임 세션에서도 똑같이 자기 자신에 대한 플레이어를 여기다가 그냥 간단히 퍼블릭으로 일단 들고 있도록 할게요 너무 함수를 많이 만들기 귀찮으니까 플레이어 랩이라고 해가지고 뭐 이런식으로 플레이어스라고 들고 있도록 하고 그거를 여기서 , 일단은, 또 들고 있도록 할게요 근데 이걸 왜 굳이 메모리에다가 들고 있느냐 그건 이제 이따가 나올 겁니다 게임 세션에 플레이어스라는 벡터에다가 푸쉬백을 해줘가지고 푸쉬백 플레이어랩으로 , 이렇게, 들고 있겠다라고 하면은 이게 일단 하나의 세트가 되는 거죠 플레이어 한 마리가 추가가 되기 위한 굉장히 피나는 노력이 있었던 겁니다 인클루드 게임 세션을 추가하고 , 일단은, 이렇게, 해주면 문제가 없어지고 그 다음에 이걸 한 번 더 해줘가지고 플레이어 하나를 더 만들어줄 건데 DB에서 긁어온 이름 2 그 다음에 이번엔 나이트가 아니라 뭐 메이지 같은 걸로 일단 바꿔주고 나머지 부분은 그냥 냅둬도 되겠죠 똑같으니까 요렇게 , 일단은, 만들어줄 수가 있겠죠 그래서 , 이렇게, 정보를 채워줬다고 하면은 샌드버퍼를 다시 만들어 줘가지고 클라이언 패킷 핸들러에다가 메이크 샌드버퍼를 호출해서 로그인 패킷을 건네주면은 이게 버퍼에다가 기입이 될 거고 그걸 다시 세션에다가 샌드를 뿅 때려주면 되겠죠 요런 느낌으로 , 자, 그래서 , 이렇게, 해서 뭐 건네줄 수가 있을 겁니다 그러면 이제 다음 순서는 뭐냐면은 우리가 어찌됐건 힘들게 힘들게 success true 그 다음에 player 정보를 기입해 가지고 넣어놨으니까 이제 거꾸로 클라이언트 쪽에서 서버 패킷 핸들러 쪽에서 slogin handle 이라는 부분에 들어와 가지고 이거를 이제 데이터를 그대로 받아주게 될 겁니다 그러면은 이 핸들 S 로그인에서는 이제 무엇을 해야 되느냐 거꾸로 체크를 해주면 되겠죠 패킷이 썩색스는 맞았느냐 어 실패했다고? 그러면 뭔가 문제 있으니까 뭐 경고창을 뜨면서 다시 이제 뭐 로비로 튕겨낸다거나 하는 식으로 동작하게 될 것이고 만약에 여기서 플레이어즈를 체크해봤는데 얘가 만약에 하나도 없다 라고 하면은 뭔가 이제 뭐 캐릭터 생성창으로 이동해 가지고 캐릭터를 만드는 부분을 에고 바이트롱이 아니라 사이즈입니다 그 부분을 이제 실행해주면 되겠죠 캐릭터 생성 등등 근데 만약에 우리는 지금은 강제로 캐릭터 두개를 넣어놔가지고 플레이어를 넣어놨으니까 이 부분은 아마 안들어올 아마가 아니라 확실하게 안들어올 것이고 여기다가 넘어온다고 하면은 이제 우리가 입장 UI 버튼을 눌러서 게임을 입장할 수가 있게 됩니다 근데 물론 그 전에 어떤 캐릭터로 입장할 것인지를 뭐 골라가지고 들어가게 되겠죠 그래서 여기서 나 게임 이제 들어갈래 캐릭터 골랐으니까 들어갈래라고 한다면은 엔터 게임 패켓을 만들어가지고 엔터게임 패킷에다가 내가 몇번째 캐릭터로 갈것인지를 요렇게 세팅을 해주게 될겁니다. 지금은 그냥 무조건 첫번째 캐릭터로 입장을 한다고 가정해볼게요. 그 다음에 이제 패킷을 채워놨으면은 서버 패킷 핸들러에서 메이크 샌드 버퍼를 만들어가지고 다시 엔터게임 패킷을 만들어 줄 것이고 세션에 샌드를 이제 호출해주면 되겠죠. , 자, 이렇게, 매번마다 샌드버퍼를 만들어가지고 보내는게 귀찮다면 이런 기능을 패킷세션이나 게임세션 안에다가 잘 넣어주면 되겠습니다 샌드버퍼를 만들어가지고 들고 있는 이유는 나중에 경우에 따라서 하나의 세션한테만 보내주는게 아니라 브로드캐스팅을 하는 상황도 생기기 때문에 , 이렇게, 두단계로 거치고 있는건데 매번마다 타이핑하기가 귀찮고 그냥 이 방식으로 패킷 자체를 바로 밀어넣게끔 하고 싶다고 하면 그런식으로 함수를 만들어 주시면 됩니다 절대 적용이 당연히 없어요 , 자, 그 다음에 여기서 이제 내가 입장하겠다 C 엔터 게임을 내가 이제 클라이언트에서 서버로 보낸 거죠 그러면 이제 어디로 가느냐 다시 계속 왔다 갔다는 겁니다 서버 쪽에서 다시 요 부분으로 오게 되겠죠 핸들 C 엔터 게임이라고 해가지고 클라이언트가 입장 요청을 했습니다 라는 부분으로 , 일단은, 들어오게 될 겁니다 그러면은 엔터 게임에 만약에 왔다고 하면은 이제 입장을 시켜 줘야 되는데 요 부분 , 일단은, 긁어 올게요 게임 세션이 필요해 가지고 다시 얘를 일단 복구를 해준 다음에 그 다음에 뭐 여기서 아이디를 다시 챙겨 가지고 체크를 해봐야 되겠죠 패킷에 플레이어 인덱스를 체크해 본 다음에 여기서 뭐 또 밸리데이션이 들어가야 될 겁니다 그러니까 항상 서버 쪽에서 조심해야 되는 거는 클라 쪽에서 보낸 거를 절대 믿을 수가 없다고 했었죠 만약에 아이디를 말도 안 되는 5000이라는 엉뚱한 값으로 넣었다고 하면은 그거를 걸러내는 것도 당연히 서버의 역할이라고 보시면 되겠어요 그래서 캐릭터 확인을 한 다음에 뭐 어찌됐건 지금은 뭐 딱히 문제가 없다고 가정을 하고 진행을 해보자면 여기서 이제 다시 플레이어를 체크해야 되는데 아까 우리가 굳이 여기 세션에 있는 메모리에다가 넣는 이유가 바로 이 부분 때문이었습니다 즉 DB에 굳이 두 번 접근을 할 필요는 없고 그냥 메모리에다가 들고 있는 다음에 두 번째로 인덱스가 왔으면 해당 캐릭터 정보를 다시 이 게임 세션에 지금 들고 있을 테니까 걔를 이제 참고해 가지고 꺼내주면 되겠죠 바로 DB 접근은 굉장히 오래 걸리는 작업이기 때문에 최소한으로 줄여야 되는 거고 뭐 이런 식으로 만들어주면 되겠습니다 근데 여기서 이제 하나의 질문은 애당초 얘가 멀티셋 환경에서 과연 안전하냐라는 문제가 되는 거죠 지금 단계에서는 딱히 문제가 없기는 해요 플레이어를 세팅하는 걸 유일하게 지금 해주고 있는 부분이 핸들 로그인 패킷이기 때문에 인게임에서 우리가 갑자기 플레이어를 추가한다거나 하는 일은 당연히 존재하지 않을 테니까 기본적으로는 필요 없다고 생각할 수도 있습니다 근데 여기서 한 가지만 더 언급을 드리자면 제가 패킷을 설계하는 걸 보여드리고 있는데 요 부분 로그인 패킷은 맨 처음에 게임이 켜졌을 때 한 번만 오겠다라고 만약에 가정을 하고 있다고 하면은 그거는 굉장히 위험한 생각입니다 제가 말씀을 드렸지만 서버는 정상적인 상황만 생각하면 절대로 안 돼요 클라이언트 쪽에서 온갖 이상한 짓을 다 하려고 하기 때문에 패킷을 조작해가지고 보낸다고 하면은 이 로그인 패킷이 내가 보스를 잡는 중에서도 또 올 수도 있다는 겁니다 즉, 이거는 언제 어디서나 올 수 있다고 가정을 해야 되기 때문에 그런 부분까지도 바로 밸리데이션 체크를 해줘야 돼요 이왕이면은 내가 지금 아직 게임에 입장하기 전에 로비에 있는 상태다라는 것도 관리를 해가지고 그 상태에서만 이 로그인 패키지 진행을 하게끔 뭔가를 만들어 주긴 해야 된다는 얘기가 되는 거죠 그래서 이런 패킷 설계가 진짜 골치 아픈 이유가 그렇게 구멍을 하나라도 내면은 이제 해킹 대상이 되는 거기 때문에 그런 부분이 굉장히 조심해야 된다라고 볼 수 있는 거고 그게 아니라고 한다면 , 사실, 뭐 얘는 리드 올리니까 딱히 락을 아직까지는 잡지 않아도 뭐 , 일단은, 괜찮겠다라는 생각이 듭니다 , 자, 그건 그렇고 그 다음에 여기까지 왔으면 게임이 입장을 한다고 했으니까 룸에다가 엔터를 해줘가지고 이 플레이어를 이제 뿅 집어 넣어주도록 할게요 그러면 아까 만든 함수에 의해가지고 여기서 플레이어가 추가가 되겠죠 그 다음에 성공적으로 C 엔터 게임이 실행이 됐다라고 답장을 줄건데 뭐 여기 내부에서 답장을 줘도 되고 아니면은 여기에서 해줘도 되고 이거는 뭐 상관이 없는데 그냥 코드가 나중에 일관성 있게 맞춰지게끔 동작을 하게끔 만들어주면 됩니다. 그래서 지금은 여기 C 언더바 엔터게임 핸들러 쪽에서 얘를 그냥 답장을 주도록 할게요. 그럼 역시나 샌드버퍼를 다시 만들어가지고 클라이언 패킷 핸들러에 믹 샌드버퍼로 출한 다음에 엔터게임 패킷을 다시 샌드버퍼로 만들어 주고 이거를 오너 세션에다가 샌드를 빵 때려주면 되겠죠 이런 느낌으로 그러면은 너 게임에 입장할래? 라는걸 받아가지고 입장시켜주고 너 입장했어 라고 지금 , 이렇게, 뭐 답변을 주고 있는 겁니다 아 그리고 여기다가 아까 우리가 석세스 값을 만들어 놓은 거 같으니까 얘를 까먹지 않고 set success true로 뭐 이런 식으로 설정해서 보내주면 되겠죠 오케이 입장해도 돼 그러면은 그 다음 순서는 어딜까요 이제 거꾸로 에센터 게임을 받은 클라이언트 쪽에서 이어가지고 요 부분이 이제 호출이 되겠죠 클라이언트에서 답장을 받아가지고 어 나 이제 게임 입장해도 된 된다라는 걸 일단 받아 줄 것이고 그 부분이 일로 들어오게 될 겁니다. 그래서 여기서도 사실은 우리가 게임 룸이라는 거랑 플레이어라는 걸 만들어가지고 서버에서 관리하던 것처럼 클라이언트에서도 대칭적으로 이 룸이랑 플레이어라는 정보를 만들어가지고 똑같이 만들어 주는 게 좋습니다. 완전 대칭적으로 만들어 주는 게 좋아요. 그래야지만 나중에 MMO 게임을 만들 때 그 해당 방에 있는 플레이어들 목록을 추출해가지고 그거를 이제 뭐 유니티나 언리얼로 렌더링을 하고 하는 식으로 이제 호출이 된다는 거죠 근데 뭐 지금은 뭐 이 부분은 그냥 뭐 무시를 할 것이고 그냥 오늘은 채팅하는 게 목적이니까 간단하게 채팅 메시지만 계속 뿌리는 형태로만 작업을 해보도록 하겠습니다 어... 뭐 물론 방에... 그니까 방에 있는 모든 애들이 이제 뭐 예를 들면 1초마다 한 번씩 요 채팅 메시지를 이제 보내주는 작업을 해볼건데 여기서 매니저를 뭐 굳이 만들어가지고 작업하기 너무 귀찮으니까 음... 어떻게 해볼거냐면은 여기 더머의 클라이언트에서 그냥 요기 이쯤 아래 부분에다가 계속 루프를 돌면서 무한적으로 그냥 호출을 해주도록 할게요 , 자, 우리가 어 디스스레드 슬립을 일단 넣어주라고 하고 1초에 한 번씩 뺑뺑이를 돌면서 슬립 for 1 second 여기다가 이제 뭐 브로드캐싱 패켓을 넣어줄 건데 , 자, 우리가 서비스라는 거를 만들어줄 때 여기 타고 타고 들어가면 서비스에서 내가 지금까지 만들어준 이 서비스들을 , 이렇게, 세션들을 다 , 이렇게, 들고 있죠 물론 이거는 내부적으로 서버 코어에서 레퍼런스 카운팅 관리를 하기 위한 용도로 만들긴 했는데 이거를 좀 재사용 해가지고 우리가 좀 편하게 브로드 캐스팅 할 수 있게끔 함수를 하나 파주도록 합시다 그래서 여기 위에다가 이 쯤에 만들어 놓을까요? 크레이트 세션 아래에다가 그냥 임시로 Broadcast라는 함수를 만들어가지고 Sand Buffer를 받아가지고 그거를 현재 만들어준 모든 Session들한테 다 뿌려주는 작업을 그냥 여기서 바로 해주도록 할게요 , 자, 그러면 얘를 , 일단은, Implementation을 만들어 준 다음에 여기다가 뭐 대충 Lock을 잡아가지고 뭐 이런식으로 세션을 하나씩 하나씩 순회하면서 세션에 샌들을 호출해준다 라고 해서 그냥 간단하게 추가적인 테스트 코드 없이 만들어 보도록 하겠습니다 그러면 다시 더미 클라이언트로 돌아와 가지고 요 부분에서 결국에는 여기서 이제 뭔가를 호출해주면 되는데 우리는 오늘 목적은 그냥 채팅 메세지만 보내주는 거니까 여기다가 그냥 공용으로 hello world만 다들 보내주도록 합시다 send message utf-8로 hello world 라는 메시지만 , 이렇게, 보내주도록 할게요 그 다음에 send buffer를 한번 만들어 준 다음에 서버 패킷 핸들러의 make send buffer에서 chat 패키지를 변환해가지고 버퍼로 만들어 준 다음에 그거를 매번 마다 이런 식으로 브로드 캐스팅을 해주도록 하겠습니다 send buffer 되겠죠 , 자, 이렇게, 해가지고 1초마다 모든 애들을 대상으로 우리가 헬로월드를 지금 계속 샌드를 해주고 있는 겁니다 그리고 이제 뭐 한 명이 아니라 이걸 한 100개로 늘려 보도록 할게요 나중에 가면 이걸 뭐 훨씬 늘려줘도 되겠죠 근데 , 사실, 같은 방 안에 몇백 명이 있다는 거는 MMO 기준으로도 굉장히 높은 수치이기는 합니다 MMO라고 해도 동접이 5천 명이라고 해서 그 5천 명이 같은 공간에 다 들어간다는 얘기는 아니에요 대부분 이이저리 맵에서 흩어져 있어야지만 부하가 적게 걸리겠죠 , 자, 그래가지고 여기서 결국에는 우리가 cchat 패키지를 만약에 보내준다고 하면은 맨 마지막으로 그럼 이제 어떻게 되느냐 다시 클라이언트 패킷 핸들로 돌아가지고 최종적으로 여기 핸들 cchat 이라는 요 부분으로 , 일단은, 들어오게 될 겁니다 그러면은 여기서 뭐 우리는 간단하게 예를 들면은 뭐 로그를 찍어 보도록 할까요 이런 식으로 패킷에 어떤 메시지가 왔는지를 로그로 찍어 보고 근데 나중에 가서 뭐 너무 플레이어가 많아진다고 하면은 이 로그를 다 찍을 순 없겠죠 근데 , 일단은, 채팅 메시지가 왔으면 그거를 같은 방에 있는 모든 애들한테 다시 전달을 해주는 게 , 사실, 일반적인 채팅 방이겠죠. 그렇기 때문에 ChatPacket을 다시 만들어 준 다음에 ChatPacket에 SetMessage를 해 줘 가지고 Packet에 메시지를 그대로 , 이렇게, 전달해 준 다음에 SandBuffer를 다시 만들어 주도록 할게요 ClientPacketHandler의 MakeSandBuffer ChatPacket을 넣어 줄 것이고 그 다음에 zRoom에 Broadcast를 이제 최종적으로 출해 가지고 여기서 , 이렇게, 보내줘도록 할 겁니다 그러면 여기서 다시 곰곰이 생각을 해보면 이 부분에 들어오는 것 자체는 상관없는데 여기 내부적으로 보면은 여기서는 지금 우리가 락을 잡아가지고 실행을 하고 있죠 마찬가지로 위에서 엔터하는 경우도 락을 잡고 있습니다 멀티스레드 환경이다 보니까 다수의 스레드가 동시적으로 서로의 핸들 시첸트로 들어와 가지고 호출해 줄 수가 있다는 얘기가 되는 거고 여기까지 건드리는 부분 여기서 만드는 부분은 안전하게 제각각 할 수 있겠지만 여기서 공용적인 룸에서 뭔가 작업을 해줄 때는 락을 걸어줘야 되는데 그 락을 여기 내부에서 일단 잡아주고 있습니다 , 자, 이렇게, 해가지고 락을 잡아가지고 보드캐싱을 해주는 부분까지 실행이 되면은 여기 있는 s-chats 메세지가 다시한번 100명의 유저들한테 다시한번 쫙 뿌려지게 될것이고 그러다보면 최종적으로 이 서버패킷 핸들러의 s-chats로 다시 들어오게 될겁니다 그러면은 요기도 그냥 간단하게 뭐 클라이언트 쪽에서도 see ya 그냥 로그를 찍고 마무리를 짓도록 할게요 요런 느낌으로 , 자, 그래서 일단 흐름이 어떻게 진행되는지 이해가 가셨기를 바라고요 이런 식으로 계속 왔다 갔다 핑퐁을 하는 겁니다 그래가지고 결국 이 패킷만 잘 설계를 했다고 하면은 나머지 부분은 뭐 크게 , 일단은, 어렵진 않다고 보면 되겠어요 아 이거는 서버 코어를 다시 한번 빌드를 해줘야 되는데 그 부분 안에서 그런거고 , 자, 서버 코어 빌드하고 더미 클라이언트도 빌드하고 네 통과가 되면은 그 다음에 서버도 빌드를 해주면 되겠습니다 , 자, 그래가지고 , 이렇게, 왔다갔다 핑퐁을 하는 식으로 지금 동작을 하고 있다라고 볼 수 있는 거고 지금 정상적으로 100명에 대해서 어 다 들어와서 실행을 하면은 , 일단은, 정상적으로 헬로 메세지가 열심히 열심히 출력이 되겠죠 네 물론 아까 우리가 그 어... 세션이랑 플레이어 간에 순환 참조를 끊어주진 않았으니까 지금 이 상태에서 만약에 더미 클라이언트를 강제로 끄면은 어... 메모리 리익이 , 일단은, 일어나긴 하겠지만 그거는 뭐 그냥 나중에 챙기도록 하고 그래서 지금 , 이렇게, 열심히 헬로월드를 막 열심히 보내는 부분까지 , 일단은, 정상적으로 처리가 되었습니다 그리고 하나를 막 끄더라도 크래쉬가 나지 않고 디스커넥트가 되는 것도 확인을 할 수가 있었고요 그리고 하다보니까 여기 이제는 우리가 샌드 버퍼 쪽에서 프리 로그를 찍어주는 부분은 그냥 이제 삭제를 해주도록 할게요 너무 로그가 많으니까 좀 그렇죠 , 자, 그래서 어디 있었나 여기 샌드 버퍼에서 요 부분 이거랑 요 부분 , 일단은, 더 이상 필요 없으니까 삭제를 해주고 , 이렇게, 해가지고 정상적으로 , 일단은, 뭐 채팅 프로그램과 유사하게 동작하는 거에 대해서 , 일단은, 실습을 해봤고 잘 동작한다는 걸 확인을 했으면 이런 식으로 이제는 컨텐츠를 만드시면 되겠습니다 그러니까 강의를 더 이상 보지도 않고 딱 여기까지 끊어 가지고도 여러분들이 만약에 클라이언트를 이미 만든 상태라고 하면 그걸 쪼개 가지고 서버를 붙이는 연습을 이제부터 해도 된다는 얘기가 되는 거죠 제가 예전에 처음에 보여드린 그 와우 포프를 만들 때도 딱 요 상태에서 시작을 했습니다 오히려 이것보다 덜 완성된 상태였어요 이런식으로 패킷 자동화까지는 처리가 되지 않았고 손수 손수 한 땀 한 땀 만들었습니다 근데 , 이렇게, 해서 만들어지는 것 까지는 , 일단은, 오케이고 이제 다음 시간부터 할 얘기를 미리 예고 드리자면 이걸 왜 만들어 봤냐면은 이제 거꾸로 지금 우리가 만드는 방식에서 어떤 문제가 있는지를 잘 생각을 해봐야 됩니다 만약에 어 지금 더미 클라이트가 우리가 100개를 만들어놨는데 이게 나중에 숫자가 더 늘어나다고 가정을 하고 그리고 게임도 점점점점 복잡해져가지고 그냥 , 이렇게, 간단하게 클라이언트가 보낸 것만 다시 , 이렇게, 쏴주는 게 아니라 내부적으로 이 룸이라는 공간 안에 몬스터도 들어가고 인공지능도 이제 막 호출이 돼야 되고 복잡한 일이 같이 일어나는다고 가정을 해봅시다 그러니까 뭐 당연한 얘기지만 나중에 보면 몬스터뿐만 아니라 뭐 프로젝탈이라고 해가지고 미사일같이 원격으로 날아가는 그런 투사체도 있을 것이고 굉장히 많은 개체들이 여기 룸 안에 들어가게 되고 걔네들도 다 실행이 돼야 되는 주체입니다 그런데 우리가 매번마다 지금 브로드캐스팅 하는 부분을 보면은 엔터 리브 브로드캐스트 , 사실, 이게 꼭 브로드캐스트뿐만 아니라 여기서 만약에 어떤 로직이 실행이 돼야 된다고 합시다 즉 여기서 만약에 C챗이 아니라 C 언더바 뭐 무브라는다 이동할래라는 패켓을 보낸다고 해도 지금 우리가 만들고 있는 방식에서는 다 락을 잡아 가지고 지금 작업을 하고 있어요 요런 식으로 락 락 락 굉장히 공평하게 모두를 다 락을 잡고 있죠 그리고 이게 , 사실, 멀티스레드의 함정이기도 한데 굉장히 많은 사람들이 착각하는 것 중에 하나가 멀티스레드어는 뭐 그렇게 어려울 부분이 없고 그냥 락을 걸면 해결이 된다라고 착각을 하는 경우가 굉장히 많아요 제가 얘기를 해봐도 저는 개인적으로 이 학원 저 학원을 굉장히 많이 다녀봤습니다 클라이언트 학원도 굉장히 많이 다녀봤고 서버학원도 많이 다녀봤는데 클라이언트 직원분들이랑 얘기를 해보면 종종 하는 실수 중에 하나가 서버를 굉장히 쉽게 생각하는 경우가 많고 그 중에서 하나 굉장히 크게 오해하는 부분은 멀티스레드 코딩과 관련된 부분을 많이 오해를 하고 있어요 그래가지고 그냥 이런 식으로 어 뭔가 경합이 일어나는 부분에 마다 , 이렇게, 락을 잡아가지고 구현을 하면은 통과가 되지 않을까 라는 생각을 하는데 물론 기능적으로 보면은 , 일단은, 크래쉬는 나지 않는다는 건 맞습니다 근데 그럼에도 불구하고 지금 어떤 치명적인 문제가 있냐면은 이제부터 클라이언트가 몇천명이 보내는 모든 패킷들이 동일한 공간에서 실행이 된다고 하면은 지금 우리가 다시한번 서버가 어떻게 동작하고 있는지를 다시한번 요약을 해보자면 , 자, 여기 이 부분이 굉장히 중요해서 다시 설명드리는건데 , 이렇게, 지금 디스패치를 하고 있는 워커셋들을 우리가 여러개를 만들어 놔가지고 나중에 가면 CPU 코어 개수만큼 만들어주겠죠 몇십개를 만들어가지고 걔네들이 이 IOCP 코어를 계속 두리번두리번 거리면서 일감이 일어날 때까지를 대기하고 있습니다 그래서 일감이 들어오면 디스패치를 빵 때려가지고 우리의 네트워크 라이브러리가 여기서 GetQueueCompletionStatus 들어가가지고 여기서 디스패치를 해서 결국에는 세션에 가상함수를 타고 와가지고 그 부분에 해당 부분들이 실행이 되고 있었던 거죠 , 자, 그런데 여기서 이제 문제는 뭐냐면은 만약에 20개의 스레드가 얘를 거의 동시다발적으로 실행했는데 하필이면 그 요청한 모든 사항들이 결국에는 돌고 돌아가지고 요 부분으로 직결이 된다고 합시다 다시 요기 직결이 된다고 하면 20개의 스레드가 얘를 동시다발적으로 지금 실행하고 싶은데 굉장히 아쉽게도 우리는 다 락을 걸어놨으니까 19개의 스레드들은 이를 제대로 처리하지 못하고 멍때리고 있을 것이고 오직 한 번에 하나의 애만 얘를 처리하고 있다는 게 굉장히 큰 문제입니다 그리고 여기서 심지어 하고 있는 작업도 특히나 이 브로드 캐스팅과 관련된 부분을 보면은 지금 방에 들어가 있는 모든 플레이어를 하나씩 수뇌를 하면서 걔네들한테 다 샌드 작업을 해주고 있는데 요 샌드 작업도 굉장히 무거운 작업이죠 그러다보니까 이 함수 자체가 지금 굉장히 오래 걸리는 건데 20개의 스레드가 경합을 하고 있는데도 불구하고 한명 한명이 굉장히 느리게 일감을 처리하면은 사실상 우리는 20개의 스레드 중 하나만 제대로 일을 하고 19개는 쓸데없이 CPU만 공활시키고 있는 겁니다 설상 가상으로 우리가 락을 만들 때 스피락으로 만들어 놔가지고 얘를 놔주지 않고 계속 뺑뺑이를 돌면서 락을 획득하려고 노력을 하고 있는데 그게 완전히 쓸모없는 짓거리라는 거죠 애당초 여기서 막혀있다고 하면 , 이렇게, 락을 잡아가지고 기다릴 이유가 하나도 없다는 겁니다 그래서 이런 부분을 어떻게 해야 되는지가 제 입장에서는 굉장히 큰 고민이었어요. 그리고 저는 이거를 다시 말씀드리지만 회사를 갈 때까지도 몰랐습니다. 그래서 이번 단원에 대한 잡큐라는 것 자체가 이런 부분을 어떻게 개선해야 될지에 관한 일단 뭐 그런 학문이라고 보시면 되겠습니다. 학문이라고 하기엔 너무 거창한데 어쨌든 그런 부분을 해결하기 위한 그런 방법을 원한다고 이해를 해주시면 되겠어요. 그래서 다음 시간부터 잡이라는 방식 일감을 만들어 가지고 관리하면 이런 문제를 어떻게 해결할 수 있는지에 대해서 , 일단은, 논해 보도록 하겠습니다 , 자, 이렇게, 해가지고 뭐 여기까지 간단하게 채팅 프로그램을 만들어 봤는데 여기 지금 만들어지는 이 프로토콜을 만들어 본 다음에 하나씩 작업하는 흐름 자체는 굉장히 중요하니까 그 부분에 대해서는 반드시 이해를 하셨으면 좋겠습니다 , 자, 이렇게, 해서 그냥 간단한 채팅 프로그램을 만들어 보고 다음 시간으로 , 일단은, 넘어가도록 할게요.