자, 이렇게, 몇 개의 강의를 통해서 락을 간단하게 사용을 해보고 그리고 데드락 같이 락을 사용할 때 일어날 수 있는 문제점에 대해서도 알아봤는데요 이번 시간에 해볼 것은 락을 그냥 표준에서 제공하는 뮤택스만을 그냥 사용하는 게 아니라 실질적으로 우리만의 방법으로 락을 구현해보는 그런 연습을 해볼 겁니다 그리고 이걸 왜 하냐면은 , 사실, 락이 워낙 중요해가지고 우리가 실제 서버 개발을 할 때 평생 달고 산 일 정도로 굉장히 중요하기 때문이기도 하지만 이게 또 면접에서도 굉장히 자주 나오는 개념들이 많이 들어가게 됩니다. 여러가지 테크닉들을 이용해가지고 우리가 락을 구현을 할 수가 있는데 그런 부분들이 결국에는 멀티스레드 프로그래밍을 할 때 있어서 뼈와 되고 살이 되는 그런 부분들이라고 일단 보시면 되겠어요. , 자, 좀 서론이 길었는데 그래가지고 결국에는 돌고 돌아가지고 우리가 하고 싶은 거는 요렇게 자물쇠를 만들어가지고 안에 누군가가 들어가 있으면은 어... 이제 대기를 해야 된다라는 상황이 되는 겁니다 그리고 이게 상호 배터적으로 한 번에 한 명만 들어갈 수 있는 상황을 우리가 만들어줘야 되겠죠 , 자, 그런데 여기서 이제 또 여러가지 생각할 점이 있는데 , 일단은, 밖에 있는 애 기준으로 누군가가 이미 안에 있다고 가정을 할 때 그럼 이제 어떤 정책을 취할 것이냐가 또 두 번째 문제가 되는 겁니다 여러분들은 어떠실지 모르겠는데 저는 개인적으로 기다리는 거를 굉장히 싫어합니다 그래서 약속도 30분 이상 늦으면은 저는 그냥 집에 가버릴 정도로 시간에 민감한데 비행기를 탈 때 만약에 화장실을 가려고 딱 가봤더니만 누군가가 이미 있다고 가정을 하면은 이제 그럼 어떻게 할 것인지 살짝 머리가 좀 돌아가야 되겠죠 그냥 곧이곧대로 계속 대기를 하는 방법도 있겠지만 안에 있는 사람이 너무 안 나온다 싶으면은 에라 모르겠다 하고 , 일단은, 자리에 돌아온 다음에 대충 한 3분에서 4분 정도 기다렸다가 랜덤하게 기다렸다가 다시 한번 화장실에 가보는 뭐 요런 정책도 괜찮을 것이고 뭐 여러가지 , 일단은, 방법이 있을 겁니다 근데 이게 왜 중요하냐면은 이거에 따라가지고 , 사실, 성능이 조금 미세하게 갈린게 돼요 그래서 , 일단은, 세가지 상황으로 일단 크게 구분을 할 수가 있을 건데 그냥 무작정 앞에서 대기를 하는 방법이 일단 가장 무식하면서도 어느정도 효과적인 방법입니다 안에 들어가 있는 사람이 뭔가 이미 들어간지 꽤 오래되었고 그리고 뭐 아니면은 손 씻는 소리가 들린다거나 라는 상황이 있다고 하면은 굳이 귀찮게 또 자리에 왔다갔다 하기보다는 그냥 그 앞에서 계속 대기를 타는게 조금 더 효율적 일 수도 있겠죠 그래서 그 안에 있는 사람이 나오면 바로 사용할 수 있다는 장점은 있긴 하지만 단점은 굉장히 지루하죠. 내가 앞에서 기다려야 되고 그냥 자리에 갔으면 영화라도 볼 텐데 그 앞에서 기다리고 있으면 , 사실, 그냥 멀뚱멀뚱 기다려야 될 뿐만 아니라 혹시라도 안에 있는 사람이 또 왠지는 모르겠지만 또 오랫동안 안 나온다고 하면은 앞에서 대기하는 사람 또한 쓸데없이 이제 시간을 낭비해버린다는 굉장히 끔찍한 문제가 발생하게 될 겁니다. 이게 이제 일반적으로 락을 구현할 때 스핀 락에 해당하는 그런 방법이라고 보시면 되겠어요. 계속 앞에서 뺑뺑이를 돌면서 야 나 들어가도 돼? 들어가도 돼? 들어가도 돼? 를 계속 이제 외치면서 물어보는 그런 방법이 될 겁니다. 그래서 나중에 실습을 할 때도 맨 먼저 구현을 해볼게 요 스핀 락 방법인데 스핀 락은 참고로 면접에서 굉장히 자주 나오는 질문입니다. 이거는 이제 꼭 수집을 하셔야 되는 거고 그 다음 방법으로는 , 일단은, 자리로 되돌아가고 그 다음에 나중에 다시 오겠다라는 방법입니다. 그런데 이 방법은 어떻게 보면 효율적이긴 하겠죠. 왜냐하면 어지간해서는 3분 후에 다시 돌아오면 자리가 비어있을 확률이 높으니까 나름 괜찮은 방법이긴 하지만 이 방법은 확실성이 없고 어떻게 보면 운빨에 맡긴다는 그런 단점이 있습니다. 내가 만약에 자리에 딱 돌아가는, 돌아가려고 하는데 그때 딱 10초만 더 기다렸으면 사실상 내가 차지할 수 있던 거를 10초를 못 기다려가지고 내 자리에 다시 돌아갔더니만 그새 다른 사람이 또 그러니까 안에 있던 사람이 나오고 다른 사람이 또 화장실에 들어갈 수 있는 상황이 또 발생할 수도 있겠죠. 내가 앞에서도 계속 대기를 타고 있는 게 아니다 보니까 뭐 그런 식으로 굉장히 미묘하게 엇갈릴 수도 있는 거고 그래서 이 방법은 나의 입장에서 보면 어찌됐건 기다리는 시간은 없고 어... , 이렇게, 왔다갔다 하면서 최대한 시간을 효율적으로 활용하는 것 같지만 그럼에도 불구하고 운 나쁘게 누군가가 또 화장실을 찾으러 가면은 이 방법은 이제 뭐 좋은 방법이 아니라의 수도 있게 됩니다. 그니까 이거는 이제 뭐 정해진 그런 결론은 없어요. 그냥 상황에 따라서 다 다른 거죠. 그 다음에 맨 마지막 방법은 이거는 완전히 이제 갑질을 하는건데 아 이거 위에 내가 그냥 계속 화장실 앞에서 기다리기도 뭐하고 그렇다고 그냥 무작정 자리로 가기도 뭐하니까 그냥 직원을 불러가지고 이거 좀 신뢰가 되는거지만 뭐 승무원분께 부탁을 해가지고 혹시라도 화장실이 비면은 나한테 와서 이제 알려주세요 라고 일단 부탁을 하는 겁니다 그래가지고 요렇게 하면은 제 입장에서 보면은 만약에 이제 다시 자리 돌아가가지고 진짜 화장실이 비면은 누군가가 직원이 찾아와가지고 나한테 말해줄 테니까 제 입장에서 보면은 굉장히 아름다운 방법이겠지만 요 방법의 단점은 뭐냐면은 다른 사람의 리소스를 그만큼 쓰는 거죠 그 직원한테 내가 사실상 부담을 짊어지게 하는 거니까 굉장히 이제 갑질에 해당하는 그런 부분이라고 , 일단은, 볼 수가 있겠습니다 뭐 그래가지고 요렇게 세가지 방법이 있는데 결국엔 첫번째 방법은 스피락에 해당하는 거고 얘는 그냥 잠시 슬립을 해가지고 운영체제한테 다시 소유권을 넘긴 다음에 돌아오는 방법이고 요 방법은 이벤트를 사용하는 그런 방법이라고 볼 수 있겠습니다 , 자, 요렇게 일단 세가지 방법이 있구요 그런데 여기서 또 하나 고려를 해야 될 부분은 뭐냐면 아까 얘기한 대로 화장실 문 앞에서 계속 대기를 타는 방법은 또 하나의 장점이 있는데 왔다 갔다 하는 그 비용이 , 일단은, 없어진다는 장점이 생기겠죠 예를 들면 우리가 여기 화장실에 , 이렇게, 대기를 해서 이 앞에 있으면 이동할 필요 없이 계속 대기를 할 수 있겠지만 만약에 자리로 왔다가 다시 가야 된다고 하면 어찌됐건 , 이렇게, 이동하는 거리가 있게 될 겁니다 그러면 이제 이 이동하는 거리 때문에 발생하는 그런 추가적인 부하가 어찌됐건 일어날 수 밖에 없는데 아까 얘기한 요 방법 첫번째 방법을 제외한 두번째 세번째 방법은 다 , 이렇게, 왔다갔다 화장실에 갔다가 자리로 되돌아갔다 하는 그런 이제 이동 거리가 등장하게 될 겁니다 그리고 이게 실질적으로 컴퓨터에서 어떤 거에 해당하냐면 컨텍스트 스위칭에 해당한다고 보시면 되겠어요. 그래서 이것도 이제 맞물려가지고 동작을 하는 거기 때문에 컨텍스트 스위칭에 대한 내용도 간략하게 알아볼 건데요. , 자, 요렇게 , 일단은, 식당 예제로 다시 한번 돌아와가지고 우리가 지금까지 하고 있던 멀티스레드를 다시 한번 복습을 해보면 결국 이런식으로 식당이 여러개가 있고 즉 프로그램이 여러개가 켜져있는 상태에서 스레드라는 직원을 배치해가지고 cpu 코어가 영혼이 되어가지고 그 직원을 빙해서 움직이는 그런 상황이라고 했었죠 , 자, 그리고 사실상 어... 요 직원이 지금 요렇게 식당에만 있는 게 아니라 사실상 요기 안에 있는 식당 관리자에 해당하는 요 아래 있는 부분도 누군가가 직원이 있다고 일단 생각을 하시면 되겠어요 그러니까 이게 , 사실, 사람들이 좀 간과하는 그런 부분이긴 한데 만약에 프로그램이 음... 뭐 예를 들어서 3개가 떠 있다고 해가지고 진짜로 실행해야 되는 주체가 3개밖에 없는 건 아니고요 여러분들이 지금 백그라운드에서 실행되는 운영체제, 즉 윈도우즈도 결국에는 프로그램이다 보니까 누군가가는 CPU가 개도 빙의해서 실행을 해줘야 됩니다. 그래서 실질적으로 나중에 운영체제와 관련된 책을 보시면 알겠지만 프로그램이 실행이 될 때는 커널 모드와 유저 모드라는 게 있어요. 여기서 보면 이 위에 있는 부분이 일단 유저 모드이고 아래 있는 부분이 커널 모드입니다. 이 커널 모드는 우리가 건드리는 건 아니고 이제 마이크로소프트나 운영체제 회사에서 만들어준 코드가 실행이 되는 운영체제를 관리하고 있는 관리자의 영역이라고 보시면 되겠습니다. , 자, 그럼 그건 그렇고 결국에는 그래서 여기서 어떤 직원이 막 실행이 되다가 어... 다른 직원한테 이제 빙의를 해야 되는데 그때 항상 얘가 이제 유저 레벨에서 멋대로 여기서 여기로 옮겨 타는게 아니라 항상 , 이렇게, 관리자 모드로 , 일단은, 돌아가가지고 관리자 모드에서 다음에 실행이 될 애가 누구인지를 계산을 해가지고 그 애가 이제 실행이 되게끔 유도를 해주게 될 겁니다 그래서 결국에는 요 단계에서 요 단계로 요렇게 유저 레벨에서 커널 레벨로 즉 위에서 실행하던 일반 직원에서 실제로 관리자 모드로 , 이렇게, 돌아가는 부분이 요 부분을 사실상 우리가 컨텍스트 스위칭이라고 하는데요 근데 이 부분이 결국에는 아까 요 예제에서 보면은 , 이렇게, 화장실 앞에 있다가 다시 한번 자리로 돌아갔다가 다시 오는 그런 이런 부분들을 일단 해당하다고 보시면 되겠습니다 근데 유저 레벨에서 커널 레벨로 왔다 갔다는게 생각보다 부하를 많이 잡아먹습니다 그 왜 그러냐면은 어 그냥 고지 곧대로 요렇게 영어만 뿅 빙일 하고 끝이 아니라 실질적으로 이 지금 요 아이를 실행하기 위한 부가적인 정보가 이리저리 또 많이 들어가 있어요 무슨 얘기냐면 결국에는 요 아이가 무슨 생각을 하고 있었고 그 다음에 어떤 위치에 있었고 다음에 해야 되는 그런 일은 무엇이었는지 등등과 관련된 모든 정보들이 이제 레지스터에 들어가게 되는데 이 레지스터는 만약에 다른 직원으로 이제 다시 이제 갈아타게 된다면 기존에 있던 내용을 싸그리 다 램에다가 다시 저장을 하고 다른의 레지스터의 값들을 다 불러 읽어 가지고 복원을 똑같이 시켜 줘야 됩니다 즉 완벽하게 어떤 직원으로 빙의하기 위해서는 그 직원이 생각하던 모든 그런 생각들과 그 상황 자체를 완전히 복원시키고 그 기억을 다시 저장하고 막 이런 식으로 왔다 갔다 해야 된다는 얘기가 되는 거죠 그렇기 때문에 진짜로 요렇게 뭐 이 유저 레벨에서 커널 모드로 왔다가 다시 커널에서 유저 모드로 왔다 갔다 하는게 정말로 꽤 부담을 많이 잡아먹는 그런 부분이라고 , 일단은, 볼 수가 있는 겁니다 근데 뭐 그렇다고 해가지고 이게 뭐 그냥 정말 최악의 경우 그래가지고 절대로 해선 안된다 이런 개념은 아니고 결국엔 이 컨텍스트 스위칭은 항상 일어날 수 밖에 없어요 , 이렇게, 왔다 갔다 하면서 유저 레벨과 커널 모드로 왔다 갔다 하는거는 결국은 우리가 지금 실행하고 있는 모든 프로그램들이 다 그렇게 동작을 하는거니까 최소한으로 줄여야 되기는 하는 건 맞지만 이게 뭐 죄악이라는 건 아닙니다 예를 들면 이것도 한번 언급을 드린 적이 있지만 예를 들면 이 유저 레벨에서 우리가 지금까지 사용하던 그런 Cout을 이용해 가지고 콘솔 출력을 하는 것도 콘솔 출력이라는 것 자체는 이제 하드웨어와 관련된 문제이기 때문에 위에서 유저 레벨에서 곧이곧대로 자기가 멋대로 하드웨어를 조작하고 하는 게 불가능합니다 그리고 실질적으로 cout을 이용해가지고 우리가 뭔가 요청을 하면은 내부적으로 어떻게 동작을 하냐면은 여기 위에 있는 유저 레벨에서 다시 kernel 레벨로 , 이렇게, 돌아가가지고 즉 이 상태로 돌아와가지고 kernel 레벨에서 이 관리자가 실질적으로 그 해당 부분을 우리 대신 실행을 해준다고 보시면 되겠습니다 즉 우리는 위에서 아래로 뭔가 요청을 보내가지고 어떤 함수를 이용해가지고 요청을 보내는 것이지 위 단계에서 실행을 한다는 얘기가 아니라는 거죠 좀 얘기가 새고 있는데 그래서 결국에는 이 컨텍스 스위칭이라는 게 , 이렇게, 정보들을 왔다 갔다 하면서 얘가 들고 있던 정보들을 저장했다가 다시 복원을 하고 이런 일련의 과정들이 , 일단은, 다 들어간다는 것만 이제 어렴풋이 이해를 해주시면 되겠습니다 그래서 컨텍스 스위칭은 느리다 하지만 이게 스레드끼리 뭔가 변화는 일어날 때 일어나는 그런 일들이다라는 걸 , 일단은, 기억을 해주시면 되겠어요 , 자, 이제 이거를 어느정도 이해했으면은 결국 돌고 돌아가지고 아까 우리가 처음에 얘기했던 요 방법 결국 화장실에 이미 사람이 있다면 무엇을 해야된가 되는가에서 이 첫번째 방법에서 소위 존버메타라고 표현한 이 방법에서는 유저 레벨과 커널 레벨을 왔다갔다 하는게 아니라 그냥 계속 유저 레벨에서 무한 루프를 돌면서 계속 체크를 하게 될겁니다 그래서 얘는 컨텍스트 스위칭 비용이 없다는 장점이 있는거고 만약에 우리 MMO 같은 경우에 만약에 다른 스레드가 여기 잠그고 있는 이 자물쇠를 금방 풀어줄 것이라는 어느정도 기대와 혹은 확신이 있다고 하면은 이 스피락을 활용하는 것도 굉장히 빠르게 동작하는 것이고 하지만 그게 아니라 얘가 조금 오래 걸릴 것 같다. 그렇다는 것은 얘가 무작정 기절해도 아무런 쓸모가 없으니까 그럴 때는 다른 방법을 채택하는 게 괜찮을 수도 있겠죠. , 이렇게, 일단 자리로 돌아간다. 일단 컨텍스 쉬징이 일어나게 될 것이고 코너레벨로 돌아가게 되는 부분들이 일어날 것이고 얘도 마찬가지로 코너레벨로 돌아가면서 이제 이벤트라는 커널 옵젝트를 만들어가지고 실질적으로 상황이 딱 맞아떨어질 때 그 이벤트를 호출해가지고 다시 돌아오는 뭐 그런 개념이 될 거예요. , 자, 근데 물론 이 세 가지 방법이 있다고 해가지고 진짜 이 세 개 중에 하나를 골라야 된다는 얘기가 아니고 뭐 적절하게 섞어서 써도 됩니다. 어느 정도는 , 이렇게, 기다리다가 에라 너무 시간이 오래 걸리네 라고 하면은 이런 식으로 잠시 커널 모드로 돌아갔다가 다시 돌아오고 하는 식으로 뭐 나중에 작업을 하게 될 겁니다. 그래서 지금 뭐 아직 정확히 얘네들이 어떤 역할을 하는 것이고 어떻게 구현을 해야 되는지 뭐 와닿지 않으시겠지만 이거는 그냥 우리가 실질적으로 다음 시간부터 코드를 하나씩 구현을 해보면서 이제 공부를 해나갈 거니까 지금은 다 이해가 안가도 , 일단은, 상관이 없습니다 그냥 어렴풋이 뭐 요런 방법들이 있구나라는 거면 , 일단은, 알아주시면 되겠어요 , 자, 그래가지고 이제 다음 시간부터 한번 코드로 요런 부분들을 한번 구현을 해보도록 하겠습니다.