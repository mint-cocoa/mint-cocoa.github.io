이렇게, 해서 길고 길었던 멀티스레드와 관련된 내용을 마쳤구요 지난 시간에 했던 연소 문제는 필요 없으니까 일단 싸그리 다 날려 주도록 하고 오늘부터는 새로운 챕터로 넘어와서 메모리 관리 쪽에 대한 내용을 쭉 다뤄보게 될 겁니다 근데 이제 C-Sharp 서버 강의에서는 멀티스레드 다음에 바로 네트워크 쪽으로 넘어갔었는데 C++ 같은 경우는 이제 우리가 메모리를 직접적으로 알아서 관리를 해야 되기 때문에 여기서 또 생각할 게 굉장히 많아집니다 스마트포인터는 활용할 것인지 한다면 우리가 커스텀으로 만들어서 사용할 것인지 표준 스마트 포인터를 사용할 것인지 그리고 메모리 관리는 어떻게 할 것인지 기본 할당기를 사용할 것인지 아니면 메모리를 풀링해서 사용할 것인지 등등 여러가지 정책 중에서 우리가 하나를 정해줘야 된다는 얘기가 되는 거죠 그런데 뭐 그런 여러가지 옵션들 중에서 뭔가 하나를 고르기 위해서는 대충 어떤 내용이 있는지는 당연히 알고 넘어가야 되겠죠 , 자, 그래가지고 , 일단은, 가장 첫 시간 메모리 관리 첫 시간에는 일단 스마트 포인터에 대한 내용을 쭉 다뤄보도록 하겠습니다 뭐 스마트 포인터에 대한 내용은 어렴풋 아마도 알고 계실 거라고 생각을 하지만 이게 또 멀티스레드로 오면서 조금 내용이 살짝 또 애매해지는 부분이 있습니다 , 자, 그래가지고 , 일단은, 기본기부터 다시 한번 복습을 해보자면 우리가 스마트포인터에 대한 필요성을 보통 사람들이 언제 느끼냐면 게임 학원 같은 데서 C++ 기초를 배운 다음에 STL을 공부하고 그 다음에 첫 포트폴리오를 만들 때 사람들이 이런 저런 게임 모작을 많이 합니다. 뭐 RPG 게임을 모작하는 학생도 있을 거고 스타크래프트 같은 전략 시뮬레이션을 모작하는 학생도 있을 거고 다양한 게임을 모작할 때 그때 , 일단은, 항상 뭔가 아리덜송한 상황이 꼭 생겨요 예를 들면은 , 자, 우리가 스타크래프트에서 뭔가 레이스라는 비행기 종이비행기 유닛이 있다고 하고 그 레이스가 뭔가 미사일을 쏜다고 가정해봅시다 미사일 , 자, 그래가지고 레이스가 다른 레이스를 뭐 피격하기 위해서 미사일을 빵! 쏜 상태여가지고 그 미사일이 어... 해당... 다른 대상을 뭐 쫓아가는 그런 상황이라고 가정해봅시다 그러면 , 일단은, 요 레이스라는 것 자체가 뭐 요런 느낌으로 자신만의 체력을 뭐 갖고 있을 것이고 그 다음에 스타크래프트는 뭐 2D 게임이었으니까 이런 식으로 Y 좌표 X 좌표와 같은 2D 좌표를 뭔가 갖고 있다고 생각할 수가 있겠죠? 그러면 이제 미사일이라는 요 아이는 아이고 어.. 어떤 대상을 지정해가지고 쭉 그 대상을 향해서 계속 추적을 해서 나가는 거니까 어.. , 일단은, 뭐 대리석 요런 느낌으로 어떤 타겟이 지정되어가지고 걔를 따라간다고 가정해봅시다 물론 이걸 나중에 좀 복잡하게 만들면 레이스만 얘가 쏠 수 있는 건 아니니까 어.. 공용으로 부모 클래스로 묶어가지고 걔를 뭐 관리해야 되겠지만 일단 지금 당장은 그런 내용을 신경쓰지 않을 것이고 뭔가 요렇게 처음에 셋 타겟을 통해가지고 내가 목표를 하고 있는 목표 대상을 지정을 하게 될 것이고 그 다음에 이 타겟을 여기다가 저장한 다음에 내 프레임마다 업데이트 틱이 돌 때마다 결국에는 이 레이스를 쫓아가게끔 우리가 뭔가 코드를 만들어줘야 되겠죠 뭐 예를 들면은 여기서 x 값을 추출하고 그 다음에 y 값도 추출하고 이런 식으로 뭔가를 작성해가지고 여기서 뭐 쫓아가기 쫓아간다. , 이렇게, 그 해당 유닛을 대상으로 쫓아가게끔 뭔가 코드를 이제 만들겁니다. , 자, 여기까지는 뭐 그냥 그런가보다 할 수 있는데 이제 코드를 사용하려고 그냥 간단하게 테스트를 하기 위해서 뭔가 레이스를 요렇게 만들어놨어요. 이거 포인트로 , 이렇게, 뉴 레이스를 통해서 만들어놨고 테스트하기 위해서 역시나 미사일도 하나를 만들어 보도록 합시다 미사일은 뉴미사일 , 자, 그래가지고 이 다음에 어 우리가 레이스를 쫓아가게 만들기 위해서 미사일의 타깃을 요렇게 해당 레이스로 우리가 지정을 했다고 가정을 하고 그 다음에 , 이렇게, 무한 루프를 돌면서 , 자, 만약에 이제 미사일이 있다고 하면은 그냥 널 체크를 한번 한 다음에 어... 미사일의 업데이트를 뭔가 요렇게 실향을 해줄 수가 있겠죠? 그래서 이제 이 미사일이 얘를 쫓아가게끔 뭔가 유도를 해주는 코드가 뭐 대략 이런 느낌으로 만들어진다고 가정을 해봅시다 근데 이제 뭐 스타크래프트 한 유닛이 어... 이 미사일만 있는 것도 아니고 이 레이스가 뭐 스컬즈나 다른 유닛에 의해가지고 피격을 당해가지고 터질 수가 있겠죠 그래가지고 그 미사일이 지금 , 이렇게, 나가기 이전에 어쩌다보니까 레이스가 피격을 당해가지고 레이스의 체력이 0이 된 다음에 0이 되었으니까 필요 없으니까 , 이렇게, 메모리를 뿅 날려주려고 할겁니다 우리가 항상 뉴를 했으면 메모리 리그를 예방하기 위해서라도 항상 , 이렇게, 딜리트를 하는 습관이 들여져 있다고 항상 , 이렇게, 뭔가 강박관념처럼 이걸 익히다 보니까 당연히 메모리 누수를 예방하기 위해서 , 이렇게, 딜리트를 언젠간 해주긴 해야 되겠죠 근데 결국에는 메모리를 , 이렇게, 직접 관리하다 보니까 요런 상황이 굉장히 애매한 상황이 되는 거죠 왜냐면은 지금 요 상황에서 문제가 되는 건 뭐냐면은 이 레이스라는 것 자체를 우리가 미사일한테도 넘겨줘가지고 요 포인터가 해당 객체를 가리키고 있지만 걔뿐만 아니라 실질적으로 요 코드가 실행이 되면서 이 미사일 내부에서도 해당 레이스에 대한 포인터를 지금 , 이렇게, 들고 있는 겁니다 양쪽에서 동일한 레이스 객체의 주소를 지금 양쪽에서 들고 있는데 우리가 한쪽에서 , 이렇게, 삭제를 해버리는 순간 이제 문제가 발생하는 거는 이제 얘가 들고 있는 그 포인터 주소는 더 이상 유효한 메모리가 아니게 된다는 얘기가 되는 거죠 그러면은 요 상황에 대해서 만약에 이걸 실행하면은 어떤 일이 발생할지 일단 예측을 하실 수가 있을지가 궁금한데 의외로 굉장히 케바키로 다를 수가 있습니다 예를 들면 제 상황에서 지금 , 이렇게, 실행을 하면은 크래시가 날 수도 있고 안 날 수도 있는데 어 , 일단은, 딱히 크래시가 저는 안 나고 있는 것 같네요 그래가지고 요 상황에서 아이고 얘를 , 일단은, 디스워스 홈링 꺼보고 브레이크 포인트를 한번 잡아보자면은 업데이트가 정상적으로 실행이 되고 있는 걸 볼 수가 있어요 분명히 타겟은 날렸는데 메모리는 실질적으로 날라가긴 했지만 그 주소 자체에 있는 내용물 자체가 아직 어... 완전히 그 메모리 접근을 할 수 없는 건 아니기 때문에 사실은 접근하면 안 될 이미 날라간 메모리에 접근해가지고 엉뚱한 값을 지금 , 이렇게, 쓰레기 값을 뽑아오고 있다고 보시면 되겠습니다. 이게 아마로 16Ghz로 CCCC로 해당하는 그 값일거에요 그러다보니까 지금 , 이렇게, 엉뚱한 값을 추출해가지고 지금 코드가 자연스럽게 계속 실행이 되고 있는건데 이게 , 사실, 크래시 나는 상황보다 더 안좋은겁니다 오염된 메모리를 건드려가지고 코드가 실행이 되고 있는데 여기 지금 보면은 X랑 Y가 0,0이 아니라 굉장히 엉뚱한 값이 들어가있었죠? 만약에 요 코드가 하필이면 우리 MMORPG에서 골드를 건드리는 코드여가지고 갑자기 골드가 막 무한으로 증식한다고 하는 버그가 지금 이런 상황에서 일어날 수 있다는 얘기가 되는겁니다 벌써 이제 이런 상황이 발생하는 이유는 결국에는 우리가 생명 주기를 관리함에 있어서 정책이 딱히 없기 때문에 그냥 멋대로 이 레이스 포인터를 지금 누군가가 참조하고 있음에도 불구하고 걔를 우리가 멋대로 삭제를 했기 때문에 지금 발생한 문제라고 볼 수가 있는 거죠. 그렇다고 뭐 영영 딜리트를 안 해가지고 삭제를 안 하면 안 되느냐 당연히 그렇진 않겠죠. 왜냐면은 객체가 생성이 되면 언젠가 소멸시켜 줘야지 그 메모리를 회수해가지고 다시 재생할 수 있을 텐데 이런 식으로 무한정으로 객체를 만드는 것도 당연히 올바른 방법은 아닐 겁니다. , 자, 그래가지고 결국에는 이거를 관리할 필요가 생긴다는 얘기가 되는 거고 누군가가 요 포인터를 참조할 때까지는 걔를 날리지 않겠다라는 뭔가 일종의 수단이 필요합니다 그래가지고 이거를 , 일단은, 가장 쉽게 해결할 수 있는 방법은 이제 레퍼런스 카운팅을 하는 겁니다 숫자를 세가지고 나를 참조하는 내가 몇 명인지를 이제 기억을 하는 거죠 그래서 오늘 실습해볼 거는 서버 코어에다가 메모리와 관련된 부분을 실습하기 위해서 이쪽에 메모리 라는 필터를 만들어 준 다음에 오늘 첫 손님은 레프 카운팅 이라는 이름으로 , 이렇게, 만들어 보도록 하겠습니다 그리고 이 둘을 메모리 쪽에다가 , 일단은, 옮기고 시작을 하도록 할게요 , 자, 이제 랩카운팅 코드를 만들어 볼 건데요 일단 클래스 이름은 랩카운팅이 아니라 랩카운터블 이라고 이름을 지어보도록 하겠습니다 여기에 이제 뭐 이런저런 기능들이 다 추가가 될 거예요 랩카운팅과 관련된 애들 그 다음에 역시나 이건 제 의식 같은 건데 뭔가 , 이렇게, 영역을 집어줘 가지고 주석을 한번 달아보도록 할게요 보기 좋으라고 대충 , 이렇게, 잡아 보도록 하겠습니다 , 자, 그건 그렇고 결국에는 이제 이어가지고 해야되는 부분은 뭐냐면은 어... 카운팅을 해가지고 요 객체가 사라지지 않게끔 우리가 유도를 해줘야 되는데 결국에는 이 랩프 카운팅을 할 때 여러 가지 방법이 있는데 그 중 하나는 최상위 객체를 하나를 만들어 준 다음에 거기다가 랩프 카운팅 기능을 넣어주고 우리가 사용하는 이런 레이스나 미사일 같은 컨텐츠에서 사용할 클래스들을 이 상위 클래스를 상속받아 가지고 만드는 방법이 있어요 그러니까 이게 무슨 말이냐면 대충 이런 식으로 , 자, Protected를 만들어 줄 것인데 여기서 이제 LeftCount를 시작해 주게 될 겁니다. 말 그대로 나를 참조하고 있는 애들이 몇 명이냐를 이제 추적을 하는 거죠. 처음에는 뭐 기본값으로는 정책에 따라 갈리긴 하지만 , 일단은, 하나로 만들어 놓을 것이고 그 다음에 소멸자는 , 이렇게, Virtual로 LeftCountable 소멸자를 , 이렇게, 만들어 주도록 하겠습니다. 메모리 릭을 예방하기 위해서 항상 최상위 클래스의 소멸자에는 버추얼을 붙여야 된다고 했었죠 그 다음에 여러가지 기능을 만들어 놓을 건데 , 일단은, 랩카운트가 무엇인지 궁금하니까 , 이렇게, 랩카운트를 리턴하는 걸 만들어주고 그 다음에 여기다가 addReferenceCount라는 기능 addRef를 이용해가지고 얘는 이런식으로 렙카운트를 1 증가시키도록 하겠습니다. 그 다음에 혹시 그 증가된 렙카운트가 뭔지 로그를 찍어보고 싶을 수도 있으니까 여기다가 리턴을 해줘가지고 그 현재 수정된 값을 바로 리턴을 해주도록 할게요. 마지막으로 거꾸로 이제 다 사용했다고 하면은 릴리즈 레퍼런스 카운트를 해주기 위한 함수를 하나를 만들어 줄 것인데 얘는 거꾸로 요런 느낌으로 마이너스 마이너스를 해가지고 랩프 카운트를 1 줄여준 다음에 걔를 뱉어 줄 것이고 , 자, 근데 이전에 만약에 랩프 카운트가 0이다 나를 기억하는 애가 더 이상 아무도 없다고 하면은 그제서야 그 해당 개체를 딜리트를 해 줄 겁니다 요렇게 이제 생명 주기를 관리하고 있는 거죠 , 자, 그래가지고 이게 가장 기본적인 레퍼런스 카운팅 방법이라고 볼 수 있는거고 이제 레이스랑 미사일과 같은 우리의 인게임 컨텐츠는 다 요 public wrap countable 이라는거를 상속을 받아가지고 사용을 하게 될겁니다 그러면 역시나 마찬가지로 여기서 include refcounting을 추가해 줘 가지고 얘를 이제 사용할 수 있는 거고 그러면 이제 요 객체는 항상 자기를 참조하고 있는 아이의 개수를 계속 추적하는 형태로 이제 동작을 하게 될 거예요 그럼 이제부터 조금 달라지는 게 우리가 생성한 다음에 실질적으로 더 이상 그 해당 요 객체가 필요 없다고 해 가지고 무조건 딜리트를 하는 게 아니라 그냥 reference count를 1 줄이는 형태로만 동작을 해주게 될 겁니다 그래서 맨 마지막에 맨 마지막에 릴리스 래프를 호출해 가지고 래프 카운트를 0이 되게끔 만들어 준 애가 실제로 그 객체의 삭제를 이제 담당하게 된다는 차이가 생기게 되는 거죠 , 자, 요렇게 , 일단은, 만들어 보도록 할 거구요 그럼 이제 사용할 때는 여기서 그냥 레이스를 , 이렇게, 바로 만드는 게 아니라 요 래프 카운터블 형태로 우리가 만들어 놨으니까 아 여기까지 똑같습니다 참고로 이거 딴 거랑 헷갈렸는데 여기서 만드는 것까지 똑같죠 어차피 얘가 랩 카운터를 상속받아서 만들고 있으니까 네 그래가지고 여기서 여기까지는 각각 이제 랩 카운터가 1인 상태고 그 다음에 이제 랩 카운터를 우리가 수동으로 이제 관리를 해주기 시작을 할 거예요 그래서 예를 들면은 지금 셋 타겟에서 우리가 이 레이스를 딱 넘겨 놨었죠 그럼 셋 타겟을 보면은 이 타겟을 저장하는 순간에 이제 이 이 레퍼카운트를 추적하는 이 포인터를 딴 데서 우리가 지금 저장하고 있으니까 여기다가 , 이렇게, Add Reference를 하나를 늘려줘야 된다는 얘기가 드는 거죠. 내가 기억하는 애가 늘어났기 때문에 얘가 이제 하나가 늘어나게 된 겁니다. 그 다음에 이제 조금 일반적인 상황에 대해서 만약에 이 업데이트 문이 실행이 된다고 가정을 했을 때 어 이제 레이스가 만약에 죽어가지고 더 이상 충격할 필요가 없다고 하면은 얘를 뭐 굳이 계속 쫓아갈 필요는 없겠죠 그러다 보니까 뭐 예를 들면 여기서 타겟의 HP를 체크를 해가지고 만약에 얘가 0이다라고 하면은 이제 얘는 더 이상 요 타겟을 추적하지 않게 될 텐데 그 경우에는 거꾸로 Release Reference를 호출해 줘 가지고 아까 1 늘려줬던 요 Reference Count를 1 줄여주게 될 겁니다 여기서 만약에 릴리즈를 했는데 얘가 딱 마침 레퍼런스 카운트가 0으로 떨어졌다고 하면은 내가 마지막으로 이 해당 유닛을 기억하고 있었던 거니까 내가 이 메모리를 날리는 것까지 책임을 진다는 얘기가 되는 거죠 그 다음에 여기서 릴리즈 레퍼런스를 해줬으면은 이제 더 이상 사용 안 하겠다는 얘기니까 여기다가 널 포인터로 , 이렇게, 바꿔치기를 해주면 되겠습니다 , 자, 그럼 다음 턴이 오게 되면은 널 포인터 크래쉬가 날 테니까 여기서도 타겟이 널포인터라고 하면은 아무것도 실행을 안하게 그냥 리턴을 , 이렇게, 안전하게 때려주도록 할게요 뭐 요런 식으로 , 일단은, 수정을 해볼 수가 있을 거예요 그래가지고 어 결국에는 이제 여기서 , 이렇게, 딜리트를 했던 부분들이 다 삭제가 되어야 되는 거고 , 이렇게, 명시적으로 우리가 직접적으로 딜리트를 하는 게 아니라 항상 요 레퍼런스 카운팅에 의해 가지고 얘가 릴리스 레퍼런스를 통해 가지고 최종적으로 기억하는 애가 없을 때 알아서 딜리트가 되기 유도를 해야 된다는 얘기가 되는 거죠 , 사실, 이렇게, 딜리트를 했던 부분을 결국에는 다 이런 식으로 릴리스 레퍼런스로 다 바꿔줘야 된다는 그런 얘기가 되겠습니다 그래서 이쪽도 마찬가지로 레이스를 더 이상 사용 안 할 거면 여기다가 릴리스 레퍼런스를 해주고 그 다음에 하는 김에 더 이상 사용 안 할 거니까 , 이렇게, 널 포인터로 밀어주는 게 좀 안전하겠죠 그래서 이런 식으로 만들어줘야 된다는 결론을 일단 얻을 수가 있습니다 , 자, 그래가지고 뭐 요렇게 , 일단은, 실행을 하면은 뭐 어느정도 아까 발생했던 그 오염된 메모리 문제는 일단 해결할 수가 있을 거예요 실질적으로 얘를 이제 실행해 보게 되면요 , 자, 여기서 지금 똑같이 레이스가 피규어 땅에서 삭제된 상태죠 , 자, 요때 이 레퍼런스 카운팅이 변화하는 것을 유심히 한번 추적을 해보시기 바랍니다. 여기부터 일단 시작을 해볼게요. 위에부터. 그래서 레이스가 먼저 만들어지고 미사일도 만들어진 상태인데 각각 레퍼런스 카운트가 지금 1인 상태로 초기화가 되어 있습니다. 유일하게 이 L을 기억하는 것은 지금 이 변수이기 때문이죠. 그 다음에 setTarget을 우리가 빵 호출하는 순간 여기 내부적으로 여기서 기억을 해주면서 레퍼런스를 1 늘려줬기 때문에 얘를 실행한 다음에 우리가 레이스의 레퍼런스 카운트를 보면 이제 2로 늘어난 걸 볼 수가 있어요 두 명이 이 객체를 지금 참조하고 있다는 얘기가 되는 거죠 그 다음에 더 이상 이 레이스가 필요 없어 가지고 0으로 하고 릴리즈 레퍼런스를 딱 했다고 해도 여기서 당장 삭제가 되지는 않을 것이고 누군가가 얘를 기억하고 있기 때문에 레퍼런스 카운트가 아직 1로 유지가 되고 있다는 걸 볼 수가 있어요 그러면 그 다음 턴에 미사일의 자기 로직을 실행하게 될 텐데 이 업데이트를 함과 동시에 얘도 똑같이 HP를 체크할 텐데 어 뭐야 이 레이스 이미 죽어있네 라고 한다면 더 이상 추적할 필요가 없으니까 자기 자신을 소멸시키거나 하면서 릴리즈 레퍼런스를 해주게 되면 이 릴리즈 레퍼런스에서 결국에는 레퍼런스 카운트가 0이 되니까 실질적으로 그 레이스 객체의 메모리를 날려준다는 식으로 동작하게 될 겁니다 , 자, 요런 느낌을 일단 작업을 하는 거구요 물론 여기서도 이제 더 이상 내가 추적하는 애가 없다고 하면은 어 얘도 또 이제 소멸시켜 줘야 될텐데 어 자기 자신을 스스로 메모리를 날리기가 조금 지저분하다 보니까 뭐 예를 들면 얘는 불련을 리턴해가지고 요 해당 미사일이 더 이상 업데이트할 필요가 있는지 없는지 등등을 뱉어주면 되겠죠 예를 들면 트롤을 리턴하면은 더 이상 필요없는 상황이라고 가정을 하면은 뭐 이런 식으로 리턴 값을 이용해가지고 우리가 뭐 추적을 해줄 수가 있을 겁니다 요런 느낌으로 그러면은 이쪽에서 만약에 미사일 업데이트를 했는데 업데이트를 했더니만 갑자기 트롤을 이턴했다는 거는 얘도 마찬가지로 더 이상 필요 없다는 얘기가 되는 거니까 여기서 뭐 릴리즈 레퍼런스를 한 다음에 그 다음에 여기 있는 미사일을 널로 밀어준다거나 하는 식으로 우리가 작업을 할 수가 있을 거예요 , 자, 그래가지고 , 이렇게, 해가지고 일단 간단하게 레퍼런스 카운팅의 개념에 대해서 알아봤는데 이게 이제 굉장히 중요한 개념입니다 그런데 지금까지 작성한 코드가 어디까지나 싱글스레드에서는 문제가 없는데 이제 또 멀티스레드 환경으로 넘어오기 시작하면 또 여러가지 문제가 발생을 하기 시작합니다 , 자, 그래가지고 여기서 지금 우리가 작업하고 있는 코드를 유심히 보면은 뭐 , 일단은, 가장 끔찍한 문제 중에 하나는 애드 레퍼런스를 우리가 , 이렇게, 수동으로 관리하고 있다는 점이죠 그래가지고 만약에 아까처럼 셋 타겟을 할 때 뭔가 실수를 해가지고 얘가 복사되는 걸 우리가 간과해가지고 요 부분을 만약에 추가 안했다고 하면은 , 사실, 기껏 레퍼런스 카운팅을 했지만 일단 숫자가 맞지 않아가지고 우리가 1을 증가시키지 않았기 때문에 어 결국에는 얘를 쓰나 마나 누군가가 다른 애가 참조하고 있음에도 불구하고 이 랩 카운트가 잘못 계산이 되는 바람에 그 메모리를 날릴 수 있는 문제가 똑같이 발생할 수 있게 됩니다. 그래가지고 , 이렇게, 수동으로 뭔가 레퍼런 카운팅을 늘려주는 것 자체가 , 일단은, 마음에 안 들기도 하는데 근데 문제가 이것뿐만은 아닙니다. 이제 멀티스레드 환경으로 넘어간다고 가정을 하면은 , 자, 일단은, 우리가 지금까지 배운 멀티스레드 지식을 잘 사용을 해보면 요게 지금 얘가 인트32인데 요기다가 숫자를 1 더하고 빼는 것 자체가 원자적으로 아토믹하게 일어나지 않는다고 했었죠. 그렇기 때문에 이 코드 자체가 일단 문제가 있는 겁니다 그래서 이제 랩프 카운팅을 하더라도 싱글 스레드에서만 동작하게 할 거면 그냥 , 이렇게, 인트32가 같은 일반 정수로도 상관없지만 그게 아니라 만약에 멀티 스레드 환경에서도 똑같이 돌아가야 되는 그런 랩프 카운팅 기능이라고 하면 역시나 얘를 아토믹한 타입으로 바꿔치기를 해주셔야 됩니다 아니면 여기 있는 기능들을 인턴 락 엑스체인지 같은 그런 원자적인 연선으로 바꿔주던가 뭐 여러가지 선택을 해야 된다는 거죠 , 자, 이렇게, 해가지고 그럼 이제 어 끝인가 멀티셋에서 이제 안전해졌나라고 생각할 수도 있지만 여기서 또 끝이 아니에요 , 자, 요 코드를 이제 유심히 보도록 하겠습니다 우리가 셋 타겟을 하는 코드가 , 자, 이제는 뭔가 멀티셋 환경에서 다시 한번 생각을 해볼게요 그러면 지금 여기서 타겟을 갖고 온 다음에 여기서 타겟에 레퍼런스 카운팅을 증가시켜 가지고 우리가 어 여기다가 이제 얘를 1 증가시켜 가지고 내가 얘를 기억하고 있다는 걸 우리가 알리고 있어요 , 자, 근데 여기서 문제는 뭐냐면은 지금 요 타겟을 우리가 갖고 와 가지고 저장하는 요 행동이랑 애드 레퍼런스를 1 늘리는 요 행동이랑은 , 사실, 어... 별개로 지금 동작을 하고 있는 거죠 그러니까 이게 무슨 말이냐면은 여기까지 실행을 한 다음에 요기 중간 단계에서 우리가 늘 그랬지만 멀틸세드 환경상 중간에 누군가가 개입을 할 수 있다는 얘기가 되는 겁니다 그래서 이걸 동지가발적으로 생각해보면 우리 코드가 지금 이런 루직이었죠 지금은 비록 이걸 싱글스레드로 그냥 쭉 , 이렇게, 실행하고 있으니까 이런 일이 발생하지 않겠지만 만약에 우리가 여기 있는 레이스 피격당하는 코드랑 미사일이 움직이고 있는 이 코드를 병렬로 실행한다고 가정해봅시다 그래서 미사일을 움직이는 코드가 여기까지 실행이 되어 가지고 업데이트를 실행하는 이런 상황인데 아 셋 타겟부터 일단 들어볼게요 이게 좀 나을 것 같네요 한에는 셋 타겟을 하고 있고 한에는 릴리스 레퍼런스 요걸 하고 있는 상황이라고 가정하면은 여기서 셋 타겟을 받아가지고 요 레이스를 받아주는 순간 , 자, 여기까지 , 일단은, 실행이 된 상태에서 이제 이어가지고 레퍼런스를 1 증가시키려고 하고 있다고 가정해봅시다 근데 절묘하게도 그 딱 그 정확하게 요 순간에 누군가가 중간에 개입을 해가지고 릴리스 애플을 빵 호출해줬다고 가정을 하면 요 릴리스 애플을 하는 시점에서는 아직까지 레퍼런스 카운티가 1 증가하지 않은 상태이기 때문에 결론적으로 요 코드가 실행이 되다보면은 요기서 1 빼줬더니만 어 뭐야 나 얘 삭제도 되네 0이네라고 해서 메모리를 날려버릴 수가 있다는 얘기가 되는 거죠 얘는 메모리를 자기만 있다고 생각하고 메모리를 날렸지만 그 거의 동시에 비슷한 시점에서는 이 레이스를 받아가지고 이 셋 타겟을 이외해 가지고 결국에는 얘를 누군가가 , 이렇게, 사용하려고 했던 이만 , 사실, 이 중간에서 이미 얘가 사용하려고 했던 이 포인터는 이미 날라간 상태가 될 수도 있다는 그런 끔찍한 상황이 발생하고 있는 겁니다 , 자, 그래가지고 요 코드에서 결국 문제가 있었던거는 우리가 요 타깃을 사용해도 되는것처럼 넘겨받았지만 , 사실, 얘가 우리가 넘겨받은 요 순간부터 이미 누군가가 얘를 릴릿 해버릴 수가 있다는 얘기가 되는거죠 그러면 이제 돌고 돌아가지고 그러면은 어 요기다가 셋 타깃을 하기 전에 요기다가 레퍼런스 카운트를 1 증가시켜가지고 뭔가 넘겨주면 되지 않을까라고 생각할 수도 있지만 이건 약간 돌고 도는 문제입니다 그러면 이 애드랍을 하기 전에 또 여기서 내가 이걸 하려는 순간에 누군가가 또 얘를 날려버렸다고 하면 결국 얘도 댕글링 포인터가 되는 건 똑같죠 이상한 메모리 로이어 건드리고 있는 겁니다 그래서 , 이렇게, 수동으로 관리하는 거는 이제 멀티스도 환경에서 올바른 해결 방법이 아니고 이거를 좀 자동적으로 안전하게 처리를 해줄 수 있는 장치가 필요한데 그게 이제 기반적으로 기본적으로 이제 스마트 포인터의 개념이라고 생각하시면 됩니다 , 자, 그래가지고 여기 이어가지고 우리가 얘를 이제 스마트 포인터라는 걸 이제 사용해 볼 건데 기본적으로 우리가 가장 기본으로 이제 사용할 수 있는 생각할 수 있는 그 Shared Pointer를 얘로 들어 보도록 할게요 공유해서 내가 사용하는 포인터입니다 , 자, 우리가 표준에서 사용하는 스마트 포인터가 뭐 크게 3가지가 있죠 유니크, 쉐어드 그리고 위급 PTR 그 중에서 Shared Pointer가 거의 활용도가 제일 높은 그런 대표 아이이기 때문에 얘를 기준으로 일단 설명을 해보도록 할게요. Shared Pointer라는 거는 뭘 하는 거냐면은 , 사실, 랩 카운팅을 하고 있는 그 객체 자체를 얘가 랩핑 해가지고 그냥 들고 있을 거예요. 그래서 뭐 이런 느낌으로 T-Shared PTR이라고 이름을 지어보도록 할게요. 이게 템플릿을 받아준다는 의미로 , 이렇게, T-Shared PTR을 만들어 줄 것인데 어 결국에는 얘가 하고 싶은 일은 뭐냐면은 내부적으로 요렇게 포인터를 하나 요렇게 들고 있을 거에요 근데 얘가 이제 그냥 아무런 그냥 굴러다니는 PTR은 아니고 우리가 위에서 사용한 것 같이 레퍼런스 카운팅이 지원이 되고 있는 그런 포인터를 얘기하는 걸 겁니다 , 자, 그래가지고 여기서 이제 함수를 두 개를 만들어 줄 것인데 inline void set 어떤 포인터를 우리가 세팅 하려고 하면은 그 ptr 를 우리가 멤버 변수에다가 저장을 해 준 다음에 만약에 ptr 이 null이 아니라고 하면은 reference count를 , 일단은, 1 증가 시켜서 사용을 할 것이고 그 다음에 거꾸로 릴리스를 만약에 해야된다는 상황이 온다고 하면은 우선은 얘가 널이 아니라고 하면은 PTR에 릴리스 레퍼런스를 해주고 그리고 얘를 더이상 사용하지 않게 널로 밀어버릴 겁니다. 그래서 말 그대로 얘를 랩핑 해가지고 , 이렇게, 잠시 간접적으로 얘가 대신 이 레퍼런스를 늘리고 줄이고 하는 부분을 얘가 대신해주고 있는 거죠 그래서 우리가 직접적으로 나중에 가면 , 이렇게, 릴리스랑 애드 레퍼런스를 , 이렇게, 코드상에서 직접 할 일은 없을 것이고 다 이 Shared PTR 이라는 요 객체가 감춰져 감춰 가지고 그걸 다 대신 해주게 되는 게 일단 컨셉입니다 그래서 일단 , 이렇게, 두 개를 만들어 놓고 나머지 부분이 조금 긴데 이제 하나씩 한번 해보도록 할게요 어떤 포인터가 있는데 TSharedPtr을 만들어 줄 것인데 뭐 기본 생성자는 딱히 아무것도 안 해줄 것이고 얘가 그냥 null인 상태이니까 그런가보다 할 수 있고 그 다음에 여기서 어떤 데이터를 이 PTR을 넘겨 받았다고 하면은 이제 내부적으로 , 이렇게, 셋을 해주게 될 겁니다 셋을 해 줘 가지고 저장한 다음에 레퍼런스 1 늘리는 걸 해주고 있는 거죠 그래 가지고 이 Shared PTR이 여기 레퍼런스 카운팅이 되던 이 포인터에 이제 처리를 위임을 받았다라는 느낌으로 얘가 이제 자기가 저장을 한 것 동시에 , 이렇게, 레퍼런스를 1 늘려준 상태가 된다고 보시면 되겠습니다. , 자, 그 다음에 나머지 부분들도 이제 하나씩 , 예를 들어, 보자면 먼저 복사하는 걸 생각할 수 있겠죠. 이 shared-ptr 이라는 것을 딴 애가 넘겨주는 상황을 우리가 예측할 수 있을 겁니다. RHS, Right Handed Side 라고 해가지고 그냥 다른 인자 이름을 , 이렇게, 지어보도록 할게요. 다른 애가 복사를 해가지고 넘겨줬으면 얘도 마찬가지로 , 이렇게, RHS의 PTR을 받아가지고 똑같이 상대방이 넘겨준 포인터도 나도 이제 관리를 할 거니까 여기다가 이제 애드랩을 복사해가지고 걔를 뭐 , 이렇게, 사용을 해주게 될 겁니다. 그 다음에 이어가지고 나머지 부분들도 뭐 이런 느낌으로 예를 들면 티셔츠 PTR을 사용하는데 이제 뭐 이동이 돼야 된다 이동 같은 경우에는 상대방의 소유권을 완전히 뺏어오는 거니까 그냥 내 포인터에다가 상대방의 포인터를 , 이렇게, 넣어주고 상대방 것에 대해서는 이 PTR을 그냥 널로 밀어주면 되겠죠? 레퍼런스 카운팅은 그대로 내가 걔 거를 받아올 거니까 건드려주지 않아도 됩니다 뭐 그래서 그냥 , 이렇게, 코드를 만들어 줄 수가 있을 것이고 그 외에 뭐 잡다한 그런 나머지 부분들 예를 들면 상속관계에서 있는 그런 개체들을 또 , 이렇게, 받아준다고 한다면 뭐 이런 느낌으로 다른 템플릿으로 받아준 다음에 t-shared ptr에서 뭐 이런 느낌으로 t-shared ptr rhs 그 다음에 셋 스태틱 캐스트를 해가지고 캐스팅을 해가지고 내가 원하는 타입으로 요렇게 바꿔치기 해주면 되겠죠 그래서 다른 이제 부모 클래스나 자식관의 변환도 , 이렇게, 만들어 줄 수 있다는 얘기가 되는 겁니다 다양한 관계에서 이제 이거를 랩핑 해줘 가지고 우리가 일반적으로 포인터를 사용하던 그런 모든 기능들을 다 지원을 해줄게 만들어주면 되겠죠. 그리고 거꾸로 Shard PTR이 소멸된다고 하면은 얘는 이제 릴리즈를 해줘 가지고 레퍼런스 카운팅을 이제 경우에 따라서 얘가 들고 있던 포인터가 있다고 하면은 걔를 1 줄여주는 역할을 만들어 주게 될 겁니다. 마치 우리가 락에서 락가드라는 애가 락을 잠그고 해제하는 부분을 알아서 처리했던 것과 비슷한 느낌이죠 그래가지고 이 T-Shield 비트캔을 결국에는 레퍼런스 카운팅이 되는 포인터에 레퍼런스 카운팅을 알아서 관리를 해준다라는 핵심 컨셉이 들어간다고 보시면 되겠어요 그 다음에 또 중요한 게 뭐가 있냐면 복사 연산자 이것도 굉장히 자주 사용하는 거죠 어 복사현상자 같은 것도 요렇게 만들어주면 됩니다. operator는 그래가지고 t-shared ptr을 요렇게 받았다고 하면은 어 만약에 이미 내가 들고 있는 포인터랑 상대방이 나한테 넘겨주려는 포인터랑 같은 애면은 뭐 굳이 해줄 필요가 없으니까 요렇게 예외체크를 해주셔서 뭐 요런 느낌으로 같은 애가 아닐 경우에만 실행을 한 다음에 같은 애가 아니라고 하면은 내가 들고 있던 애를 날려준 다음에 상대방 아이의 것을 뭐 요렇게 받아주는 방식으로 뭔가 만들어 줄 수가 있겠죠? 요런 느낌 그 다음에 또 뭐 있을까요? 이동 연산자도 똑같이 만들어 줄 수가 있을 겁니다 , 자, 얘는 operator는을 할 건데 tshardptr에서 &&을 해가지고 상대방이 소유권을 완전히 넘겨주는 상황이라고 한다면 일단 내가 혹시라도 들고 있던 애가 있다고 하면은 그 아이를 날려준 다음에 그 다음에 상대방의 소유권을 뺏어오기 위해서 포인터를 내가 저장한 다음에 상대방은 너의 포인터를 가리키게끔 상대방의 거를 , 이렇게, 뺏어오면 되겠어 이런 느낌으로 만들어줄 수 있을 거고요 물론 이런 코드들이 코드 재사용하려고 우리가 동일한 함수를 사용하고 있지만 더 최적화해서 하고 싶다면 이런 코드를 잘 낑겨 넣어가지고 만들어주면 되겠습니다 나중에 언젠가 언리얼 엔진도 살펴보게 되면 이런 코드들이 일단 똑같이 들어가 있어가지고 자신들만의 스마트 포인터를 다 구현을 했어요 그 다음에 여기서 뭐 또 필요한 게 뭐가 있을까요? isNull이라고 해서 널포인트 체크하는 기름들도 충분히 만들어 줄 수가 있겠죠? isNull 그리고 이제 나머지 뭐 이 SharedPtr을 사용할 때 또 편리한 기능들을 이제 막 여러 개를 만들어 보자면 비교할 때 tSharedPtr rhs를 받아가지고 return ptr이 상대방이 들고 있는 ptr이랑 같느냐 즉 shared ptr끼리 비교를 한다는 건 결국에는 걔가 들고 있는 ptr끼리 비교하는 거랑 마찬가지겠으니까 뭐 요런 식으로 만들어 줄 수가 있을 거고요 마찬가지로 우리가 들고 있는 이 shared ptr이랑 어떤 포인터랑 비교를 만약에 요청한다고 하면은 결국에는 내가 들고 있는 이 ptr이랑 상대방에서 체크하고 싶은 그 포인터랑 체크하는 거랑 똑같을 테니까 요렇게 일단 만들어 줄 수가 있을 겁니다 마찬가지로 경우에 따라서 같지 않느냐 뭐 요런 것도 체크할 수 있겠죠 우리가 사실은 널 체크... 아이고 널 체크 같은 거 널 포인터 체크 같은 것도 결국에는 요런 식으로 우리가 불리언으로 뱉어줘야 되기 때문에 얘도 마찬가지로 요런 식으로 같냐 포인터가 같냐 아니냐 등등으로 체크할 수 있을 것이고 그 다음에 경우에 따라 가지고 대소관계 같은 것도 결국에는 지원을 하게끔 만들어 줄 수가 있을 겁니다 얘는 요 ptr 이 해당 주소보다 작습니까 를 반환해 주면 될 것이고 그 다음에 몇 가지만 더 해볼 건데 어 이제 이 티샤드 포인터를 사용하다가 진짜로 이 생 포인터 요 아이가 만약에 필요해가지고 뱉어줄 필요가 생긴다고 하면은 요 별표도 똑같이 오버러딩을 요렇게 해줄 수가 있습니다 그래가지고 얘도 이제 연산자를 요렇게 재정의를 해줘가지고 얘도 지원을 해주게 만들 수가 있구요 콘스트 타입도 똑같이 , 자, 요렇게 만들어줄 수가 있을 거구요 return ptr , 자, 그 다음에 어... 아예 그... 나머지 애들도 그냥 간단하게 맞춰보도록 할게요 나머지 애들 예를 들면 , 이렇게, 캐스팅을 해줘가지고 반환하고 싶을 때 그리고 화살표 이 화살표를 통해 가지고 우리가 접근을 하는 경우도 많이 생길 텐데 그런 것도 , 이렇게, 만들어주고 콘셉트 버전도 만들어주고 이런 식으로 이제 좀 반복적인 내용이 들어가는데 이거를 , 이렇게, 하나씩 하나씩 만들어주다 보면 결국엔 우리가 일반적인 포인터랑 사용하는 거랑 별다른 불편함 없이 동일하게 사용할 수 있는 준비가 끝난다고 보시면 되겠습니다 이게 좀 이쁘게 보기 위해서 , 이렇게, 줄을 맞춰주는 것도 좋을 것 같으니까 , 이렇게, 일단 줄을 맞춰 보도록 할게요 뭐 이런 다양한 상황에 대해서 다 랩핑을 해주게 되면 이제 준비는 끝난다고 보시면 되겠어요 그럼 이제 이 T-sheared PTR로 우리가 무조건 우리의 레퍼런스 카운팅 포인터를 무조건 관리해야 된다는 얘기가 되는 거고 처음에 얘가 만들어지자마자 이런 식으로 생 포인터로 관리하는 게 아니라 우리가 만들어준 이 랩핑하는 버전으로 , 일단은, 무조건 얘만 사용하게 될 겁니다 그게 핵심이에요 , 이렇게, 굴러다니는 포인터가 있으면 절대 안되고 무조건 랩핑한 버전으로만 우리가 서로 건네주게 받게 됩니다 그럼 이제 어떤 차이가 있냐면은 , 자, 예를 들면은 여기 있는 레이스 랩프를 T-Shared PTR 우리가 만들어준 T-Shared PTR에 레이스 타입을 넣어준 거를 레이스 랩이라고 일단 이름을 지어보도록 할게요 마찬가지로 미사일 같은 경우에도 얘를 랩핑 해가지고 사용한 버전을 우리가 좀 편리하게 사용할 수 있도록 요 타입이라고 , 일단은, 가정을 해봅시다 그러면은 이제는 이 포인터를 받는 버전은 절대 사용하면 안 되고 얘가 만들어지자마자 그 해당 내용물을 바로 요렇게 전달해 줘 가지고 이 T-Shield PT라는 우리의 스마트 포인터 버전으로 관리하게끔 이제 유도를 해주게 될 겁니다 요런 느낌으로 , 자, 근데 여기서 유심히 보면은 우리가 뉴 레이스를 만들어 줄 때 우리 정책상 초반에 레퍼런스 카운팅이 1로 시작을 한다고 했었고 1로 세팅된 상태에서 이제 이 T-Shield PTL한테 자기를 넘겨줄 때 이 부분에서 세팅이 되어 가지고 세트를 하면서 자기의 레퍼런스 카운팅이 1 증가시켰으니까 얘까지 끝나면 일단 레퍼런스 카운트가 2가 될 겁니다. 그렇기 때문에 우리 정책상 여기서, 여기서만 릴리즈 F를 초반에만 , 이렇게, 한 번 빼줘가지고 얘를 이제 1로 만들어줘야 됩니다 그러면 이제 나에 대한 모든 소멸권은 이제 이 레이스 F라는 이 스마트 포인터가 담당하게 된다라는 얘기가 되는 거죠 이건 경우에 따라서 , 이렇게, 있을 수도 있고 만약에 초기 세팅해서 넘겨받을 때 레퍼런스 카운팅을 늘리지 않게끔 만들어줬으면 이 부분이 필요 없고 이거는 이제 그때마다 다릅니다 근데 우리가 지금 만들어준 버전에서는 이게 필요해요 그래가지고 얘까지 , 이렇게, 했으면 이제 무조건 이 레이스랑 미사일은 이 스마트 포인터 버전으로 관리가 된다라는 차이가 생기게 된 겁니다 그러면 이제 여기부터는 그 이후로는 절대로 명시적으로 특별한 이유 없이 , 이렇게, 막 releasef를 알아서 호출해주면 이제 안되게 된다는 얘기가 되는거죠 이제부터는 만약에 요 얘가 더이상 필요 없다고 하면은 얘를 호출하면 안되고 그냥 고지곳대로 얘만 , 이렇게, nullpointer만 , 이렇게, 넣어주면 됩니다 얘가 왜 실행이 되냐면은 nullpointer를 넘겨주는 부분이 , 자, 요 코드를 유심히 보면은 이 tsh-ptr라는게 이 포인터를 받아줘서 생성되는 버전이 있기 때문에 얘가 내부적으로는 요런 느낌으로 일단 만들어지게 될 거예요 널로 만들어주는 버전을 만들어준 다음에 걔를 레이스에다가 복사를 해주게 될 거니까 우리가 복사도 지원하게끔 다 요렇게 만들어놨었죠 네, 그렇기 때문에 내가 더 이상 필요 없다고 하면은 , 이렇게, 널로 밀어주게끔만 , 이렇게, 만들어주면은 알아서 요 코드들이 다 실행이 되면서 내부적으로 내가 더 이상 필요 없겠다 싶으면은 릴리즈를 하는 부분이 들어가게 됩니다 그리고 상대방이 만약에 널로 처음에 받아줬다고 하면은 그 PTR은 이제 널로 세팅이 되겠고 이런식으로 일단 날려주게 됩니다 그래가지고 결국에는 이 릴리스 앱을 더이상 다 사용할 필요 없고 필요 없으면 무조건 얘를 그냥 , 이렇게, 널 포인터로 밀어주거나 아니면 다른 함수를 만들어가지고 얘를 더이상 사용 안하게끔 그냥 밀어주는 방식으로만 만들어주면 된다는 얘기가 되는 거죠 , 자, 그래가지고 이 내용이 , 사실, 처음에 공부하면 이게 좀 굉장히 헷갈릴 수가 있어요 이게 도대체 아까에 비해서 도대체 왜 아까 발생한 요 중간에 개입하는 문제를 이제 해결해줄 수 있을까가 좀 아리달성 하실 수 있습니다 근데 이제 요 부분만 예를 들어보면은 원래는 우리가 , 이렇게, 명시적으로 애들 애플을 손수 한 땀 한 땀 관리를 했지만 이제는 그게 아니라 어.. 여기서 얘도 이제 이 생 포인트를 받는 게 아니라 요 버전으로 일단 당연히 받아주게 되겠죠? 그럼 얘를 이제 받아줘가지고 새 타겟에 우리가 여기서 넘겨주는 요 순간에 애당초 이 스마트 포인터 특성상 얘가 이제 복사가 될 것이죠 여기 넘겨줄 때 복사가 될 것이고 복사가 된다고 하면 알아서 레퍼런스 카운팅이 1 증가된 상태에서 이제 넘어가게 될 겁니다 그러니까 내가 무조건 얘를 사용하는 동안에는 얘가 절대 삭제되지 않을 거라는 걸 확신할 수 있는 거죠 최소한 레퍼런스 카운팅이 1 이상은 될 것이라는 걸 확신할 수 있기 때문에 설령 내가 얘를 호출 여기서 복사하는 순간에 누군가가 중간에 개입해서 릴리즈를 한다고 해도 최소한 1 미만으로 떨어지진 않기 때문에 얘가 삭제가 되지 않는다는 거 일단 보증을 받게 됩니다 요런 느낌입니다 그래가지고 이제 멀티셰더 환경에서는 랩카운팅을 한다고 하더라도 그냥 고지곳대로 걔만 호출하기보다는 요렇게 스마트포인터 형태로 묶어서 호출하는게 중요하다는 얘기가 되는거죠 그래가지고 우리가 , 이렇게, 만들어준 여러가지 부분에 의해가지고 사실상 사용할때는 그냥 일반 포인터랑 똑같이 사용할 수 있습니다 예를 들면 레이스에다가 화살표를 땡겨보면은 진짜로 HB 포지션 Y도 다 사용할 수 있는 걸 볼 수가 있는 거죠 다 요렇게 우리가 요런 오퍼레이터 오버로딩을 통해 가지고 지원을 하게끔 만들어놨으니까 이런 게 가능한 거예요 , 자, 그래서 마지막으로 이제 뭐 한 가지만 테스트 해볼 건데 이제 레퍼런스 카운트가 변하는 모습만 한번 살펴보도록 합시다 아 지금 에러가 나는건 별게 아니고 여기 레이스 레퍼런스를 여기 아래다 놔서 그런거네요 얘가 지금 사용하기 위쪽에다 놔야되는데 우리가 지금은 , 이렇게, 한 파일에 모든걸 낑겨넣어가지고 관리하고 있으니까 이게 좀 꼬인건데 나중에 이제 뭐 파일을 별도로 분리해가지고 사용하면 이런 문제는 없어질테니까 그냥 간단하게 일단 해결하고 넘어가보도록 할게요 , 자, 요렇게 해서 , 자, 빌드가 통과됐죠 얘 위에 있으니까 , 자, 그러면은 이제 이어서 테스트 할 것은 여기다 브레이크 포인트를 잡아가지고 레이스의 스마트 포인터가 레퍼런스 카운팅을 관리하는 것을 이제 한번 추적을 해볼 건데요 여기다 일단 잡아가지고 실행을 해보도록 하겠습니다 그러면은 맨 처음에 뉴 레이스를 통해서 레이스가 만들어진과 동시에 F10을 눌러가지고 보면은 레이스가 지금 레퍼런스 카운팅이 2로 되는 걸 볼 수 있습니다 생성될 때 1개, 그 다음에 우리가 레이스라는 스마트포인터 객체한테 넘겨주는 요 부분이 실행이 되면서 얘가 세팅을 해주기 때문에 요 부분에 의해가지고 지금 1이 늘어난 상태라고 볼 수가 있는 거죠. 그 다음에 이제 얘 생성할 때 이제 2가 되었으니까 한번 레퍼런스를 줄여줘가지고 영원히 나의 소유권을 이제 요 스마트포인터한테 넘겨준 게 됩니다. 이제 이 아이가 정말로 사라지면은 이 객체도 같이 사라지게 되는 거예요. 즉 모든 권한을 얘한테 이제 위임을 한 상태가 되는 거죠. 이 상태에서 setTarget 이라는 함수한테 우리가 사용하고 있던 이 스마트 포인터를 복사해가지고 넘겨줄 것인데 이 부분에서 F11로 이제 진짜 정밀하게 살펴보면은 복사가 먼저 일어나는 걸 볼 수가 있습니다. setTarget에 넘겨주기 위해서 복사를 해주고 있죠. 그래가지고 복사를 해주기 위해서 여기다가 결국에는 referenceCount1이 증가가 되어가지고 최종적으로 레퍼런스 카운트가 1에서 다시 2로 증가한 상태에서 이제 넘어가게 될 겁니다 , 자, 그래서 다시 살펴보면은 요 부분 이제 미사일 쪽에 우리가 당기는 요 화살표 때문에 얘가 호출이 됐고 그 다음에 다시 한번 타고 들어가면은 요기서 딱 들어오는 순간에 레퍼런스 카운팅이 이제 2로 바뀌는 걸 볼 수가 있어요 그니까 요 상황에서 내가 지금 물고 있기 때문에 얘가 레퍼런스 카운팅이 1 증가한 것이기 때문에 누군가가 아무리 중간에 개입을 해가지고 다른 스레드가 레퍼런스 카운트 자기껄 소멸해가지고 줄인다고 하더라도 최소 1은 보장을 받기 때문에 여기서는 안전하게 접근할 수 있다는 얘기 되는 거죠 , 자, 요렇게 해가지고 이제 복사할 때마다 결국에는 알아서 레퍼런스 카운트를 1 증가시켜 준다라는게 핵심이고 여기서 2인 상태에서 원래는 이제 타겟에 넘겨줄 때 3이 돼야 되는데 지금은 안 늘어난 이유는 우리가 이 아이를 안 바꿔줬기 때문입니다 그러니까 이제는 생포인터는 절대 사용하면 안 되고 무조건 이 스마트포인터 버전으로만 우리가 계속 서로 관리를 하기 시작한다는 게 이제 우리의 통일된 규칙이라고 보시면 되겠어요 그래서 스마트포인터를 사용하는데 , 이렇게, 생포인터를 병해서 사용하면 안 되고 무조건 이런 느낌으로 이제 진짜로 이 스마트포인터만 서로 건네죽은 식으로 하면 아까 얘기한 그 중간에 개입하는 문제가 완전히 , 일단은, 사라지게 됩니다 이게 , 일단은, 가장 중요한 부분이에요 근데 물론 내부적으로 아주 잠시만 사용할 것이라는 경우가 있다고 하면 예를 들면 우리가 어떤 테스트를 통해 가지고 여기서 잠시 얘를 , 이렇게, 사용한다고 가정해 볼게요 왠지는 모르겠지만 그래서 이 테스트를 만약에 , 이렇게, 내부적으로 우리가 사용한다고 가정했을 때 , 이렇게, 복사를 해서 사용하는 거 당연히 문제가 없는데 이런 경우에 조금 아쉬운 게 뭐냐면 애당초 여기서 복사를 하는 이 비용이 아예 없는 건 또 아닙니다 우리가 멀티스레드 환경까지 고려해 가지고 여기 레퍼런스 카운팅을 아톰이크 하게 만들어 놨는데 이런 아토믹에 대한 더샘과 뺄샘은 그냥 일반 정수 더샘, 뺄샘보다 훨씬 더 무겁습니다. 그렇기 때문에 이런 경우에 굳이 그냥 내부적으로 잠시만 사용했다가 뱉어줄 것인데 이런 식으로 레퍼런스를 1 늘리고 줄이는 게 너무 아깝다고 하면 이런 경우에는 그냥 이 스마트포인터에 참조를 그냥 받아주면 됩니다. 그러면 이 참조를 받아주게 되면은 얘는 복사가 일어나는 게 아니라 요 아이의 주저소 자체를 넘겨주는 것이기 때문에 아까와는 다르게 얘로 넘어갈 때는 레퍼런스가 늘어나지 않는 걸 일단 확인할 수가 있을 거에요 , 자, 여기까지 , 일단은, 다시 한번 넘기고 넘겨가지고 확인해 보면 , 자, 지금은 , 일단은, 레퍼런스 카운터가 3인 된 상태인데 여기서 우리가 테스트를 호출하기 위해서 fcb로 타고 들어가는 순간에 타고 들어갔는데도 불구하고 레퍼런스 커트가 증가하지 않았죠 그래서 이런 식으로 경우에 따라서 만약에 진짜 진짜 내부적으로만 사용할 게 확실한다고 하면 그리고 얘를 이제 뭐 따로 빼가지고 뭐 하는 게 아니라 잠시만 사용했다가 뱉어줄 거라고 하면 이런 식으로 레퍼런스, 스마트 포인터에 레퍼런스를 넣는 것도 일단 방법이긴 합니다 이것도 참고해서 한번 알아주시면 되는 거고 지금까지 지금 하고 있는 모든 얘기들이 표준 스마트 포인터에도 똑같이 적용이 됩니다 셰어드 PTL을 사용할 때도 똑같은 문제가 다 있어요 Share the PTR도 결국은 내부적으로 , 이렇게, 아토믹한 변수를 이용해가지고 레퍼런스 카운팅을 관리하고 있는 것이기 때문에 , 이렇게, 마찬가지로 복사를 해가지고 넘겨줄 때 약간의 비용이 들긴 합니다. 그래가지고 경우에 따라서 , 이렇게, 스마트 포인터에 레퍼런스를 넘겨준 것도 고려를 해볼만 합니다. , 자, 이렇게, 해가지고 이 내용들에 대해서 이제 반드시 잘 숙지를 하셔도 되는 거고 이게 참고로 면접 문제로도 이 스마트포인터와 관련된 부분들이 굉장히 자주 나오는 편이에요 이건 워낙 중요한 거니까 당연히 알아야 되겠죠 이제 만약에 우리가 서버 신입을 뽑았는데 이제 클라이비에서 서버가 훨씬 더 보수적으로 뽑는 이유가 이런 이유입니다 이게 되게 애매한 문제가 많죠 멀티셋이다보니까 근데 만약에 이런 스마트포인터에 대한 개념 없이 투입이 되었더니만 자기가 지금까지 하던 방법으로 개인 포포를 작업할 땐 만약에 포인터만 작업했다거나 하는 이유로 인해가지고 얘를 갑자기 포인터로 꺼내가지고 저장을 한다거나 하는 식으로 작업을 하면 난리가 난다는 얘기가 되는 거죠 그래서 이런 부분들을 잘 숙지를 하셔야 되는 거고 이 레퍼런스 카운팅에 대한 개념은 반드시 숙지를 해주셔야 되겠습니다 , 자, 그런데 뭐 물론 , 이렇게, 직접 만들어서 사용하는 버전도 있구요 뭐 Unreal Engine도 직접 만들어서 사용을 하죠 아니면은 표준에서 사용하는 Shadow PTR을 사용하는 방법도 있는데 이제 이어가지고 그렇다면 우리가 , 이렇게, 사용하는 이 Shadow PTR을 만들어가지고 상속을 받는 버전과 다른 버전과는 또 어떤 차이가 있는지 알아보도록 하겠습니다 당연한 얘기지만 이런 식으로 우리가 직접적으로 만들어 가지고 사용할 수 있는 객체라고 하면은 우리가 뭐 완벽히 이 코드를 수정할 수 있으니까 내부적으로 , 이렇게, 레퍼런스 카운터블이라는 최상의 객체를 만들어 가지고 사용하는 것도 나쁘진 않은데 경우에 따라 가지고 우리가 외부 라이브러리를 사용한다고 하면은 그 외부 라이브러리를 우리가 막 이런식으로 퍼블릭 랩 카운터블을 막 붙일 수가 없겠죠 코드가 많이 없는 경우도 있을 테니까 라이브러리만 받아서 사용하는 경우도 있을 텐데 그런 경우는 이런 경우를 사용할 수가 없을 겁니다 그래서 실질적으로 셰어드피탈 같은 경우에는 , 이렇게, 랩 카운터블과 같이 최상위 객체를 상속을 받아가지고 만드는 방법으로 돼 있지는 않아요 그래서 그 부분은 , 일단은, 너무 길어지니까 다음 시간에 일단 알아보도록 하고 오늘 다룬 내용을 일단 올려드릴 테니까 코드를 잠시 보면서 이 레퍼런스 카운팅이 어떻게 증가하는지를 멋진 장난을 쳐보시기를 일단 바랍니다.