자, 이제 이어서 지난 시간에 이어서 잡큐에 대한 내용을 계속 다뤄볼 건데 지난 시간까지 했던 부분을 다시 유약을 해보자면 우리가 이제 잡큐에다가 일감을 , 이렇게, 밀어넣음과 동시에 만약에 내가 첫 번째로 이 잡을 밀어넣은 애라고 하면은 즉 프리프 카운트가 0이었다고 하면은 걔를 실행까지 담당하게 요렇게 수정을 해봤고 그러다 보니까 이제 누군가가 따로 이 잡큐를 실행하는 식으로 따로 빼가지고 권리하는 게 아니라 밀어넣음과 동시에 실행하니까 조금 권리 차원에서 유리한 부분이 있다고 말씀을 드렸습니다 하지만 뭐 잠시 언급을 드린 바와 같이 그럼에도 불구하고 아쉬운 부분이 몇 가지가 있는데 이제 일감이 너무 많이 몰려가지고 즉 내가 얘를 실행하는 것보다 일감이 쌓이는 속도가 더 빠르다고 하면은 이제 해당 스레드는 요 잡큐의 노예가 되어가지고 더이상 빠져나오지 못하는 뭐 어떻게 보면 어... 균등하게 일을 배분하지 못하는 문제가 하나 생길 뿐더러 그 다음에 두번째가 , 사실, 더 큰 문제인데 내가 얘를 호출하다 말고 여기서 엑세큐트를 해가지고 이 잡을 호출함으로 인해서 만약에 얘가 이런저런 사유로 인해가지고 또 다시 내부적으로 다른 잡큐에다가 일감을 밀어넣는 현상이 있었다고 하면은 이제 운이 나쁘면은 하나의 잡큐를 실행하려고 하다 보니까 여기서 있는 내용을 타고 타고 가 가지고 여러 개의 잡큐를 동시에 선점해 가지고 하나의 스레드가 다 실행을 해야 되는 상황이 발생할 수 있다는 거죠 만약에 걔가 맨 먼저 실행을 쫙 해 가지고 100개의 잡규를 먼저 선점해가지고 다른 애들은 실행을 못하고 , 이렇게, 잡만 푸쉬하고 빠져나오고 그 해당 스레드가 100개를 동시에 선점해가지고 다 실행해야 된다고 하면 어떻게 보면 굉장히 낭비가 아닐 수가 없습니다 우리가 원하는 거는 결국에는 모든 스레드들이 다 균등하게 일감을 배분을 받아가지고 다들 열심히 농땡부리지 않고 일하는 상황을 원하고 있는 건데 한 명한테 그렇게 일감을 몰빵하는 건 당연히 우리가 바라는 상황이 아니겠죠 그래가지고 뭐 이런 방법을 그럼 이제 어떻게 해결할지에 대해서 뭐 얘기를 해볼 건데 뭐 , 사실, 이것도 여러가지 방법이 있지만 가장 간단한 방법은 내가 지금 잡큐를 , 일단은, 호출하고 있는지 아닌지를 추적을 해가지고 내가 이미 어떤 애를 호출하고 있다고 하면은 설령 내가 처음으로 잡을 넣은 상태라고 해도 당장 걔는 실행하지 않고 딴 애한테 , 일단은, 떠넘기게 될 겁니다 근데 딴 애한테 떠넘기기 위해서는 지금 요 방식대로는 할 수 없고 이제 좀 다른 방식을 이용해야 됩니다 , 자, 이렇게, 해가지고 오늘 이제 새로운 애를 일단 등장시킬 건데 어 이름하여 글로벌 큐라고 이름을 지어 보도록 할게요 전역으로 뭔가 관리하는 그런 큐다라고 일단 이름을 좀 성의없게 지어놓고 얘가 이제 사실은 전역으로 이제 일을 배분하는 그런 도움을 주게 되는 클래스라고 보시면 되겠습니다 , 자, 일단은, 이거 글로벌 큐부터 한번 켜보도록 할게요 요런 느낌으로 근데 뭐 , 사실, 여기서 만들 내용은 많이는 없어요 그냥 기존과 마찬가지로 , 자, 이런식으로 몇가지만 만들어 보자면 일단 생성자 소멸자는 필요할 것 같으니까 일단 만들어주고 그 다음에 푸쉬랑 팝을 만들어 줄 건데 얘는 또 특이하게도 잡큐의 스마트 포인터를 들고 있도록 하겠습니다 잡큐를 받아주고 그 다음에 잡큐 레퍼런스를 또 팝을 해줄 것이고 그 다음에 내부적으로는 lock q 를 들고 있을 것인데 잡 q ref 타입의 q 를 , 이렇게, 들고 있도록 할게요 , 자, 근데 우리가 뭐 아직 잡 q ref 는 안 만들었으니까 여기 어 타이프스에 가 가지고 얘를 추가를 해보도록 할게요 요 부분에다가 뭐 참고로 요런식으로 Shared Pointer를 그냥 뭐 계속 늘려도 되지만 이게 이것도 타이핑하는게 너무너무 귀찮다 싶으면은 요런것도 이제 매크로를 만들어가지고 당연히 처리를 할 수 있습니다 뭐 예를 들면은 이런식으로 Define Using Shared PTR 이라고 해가지고 어떤 이름을 주어주면은 Using Name 에다가 , 자, 여기다가 샵샵을 두개를 , 이렇게, 붙이게 되면은 여기에 실질적으로 우리가 넣어준 이름에다가 이 ref라는게 , 이렇게, 붙어가지고 하나의 단어로 이제 인식이 될겁니다. 즉 샵샵은 말그대로 얘를 이제 갖다 붙여라라는 의미로 이제 사용이 됩니다. 그래서 뭐 이런식으로 일단 만들어줄 수가 있어요. 전방선언 그 다음에 클래스 네임 요런식으로 만들어줄 수가 있다는거죠. 그래서 만약에 이것도 이제 활용을 하자면 IOCP 코어도 이런식으로 한방에 뿅! 호출을 해줄수가 있습니다. 나머지 애들도 그냥 쭉 해볼까요? , 이렇게, 바꾼김에. 이런식으로 다 바꿔준 다음에 하나씩 하나씩 복붙을 해주도록 합시다. 세션도 넣어주고 패킷 세션도 넣어주고 리스너도 넣어주고 서버 서비스 플랜트 서비스 샌드 버퍼 그 다음에 샌드 버퍼 청크 잡 그리고 마지막으로 잡큐까지 , 자, 이제 완성이 되었습니다 , 이렇게, 하니까 좀 더 타이핑이 쉽긴 하죠 , 자, 이렇게, 일단은, 만들고 넘어가도록 하겠습니다 닫아주고 , 자, 이렇게, 잡큐 자체가 아니라 잡이 아니라 잡큐 자체를 , 일단은, 받아줘가지고 걔를 저장하고 있다가 다른 애가 잡큐를 이어받아가지고 걔를 실행할 수 있게 유도를 해준다는게 일단 오늘의 핵심 컨셉이라고 보시면 되겠어요 뭐 별로 어려운 내용은 아니죠 , 자, 그래서 , 이렇게, cpp를 오른쪽에 만들어 줄 것이고 하나씩 구현물을 , 일단은, 만들어 주도록 합시다 요즘 손이 아파가지고 키보드를 최대한 안치고 마우스로 일단 작업을 해봤어요 Push, Pop, 잡큐까지 , 이렇게, 돼있고 근데 , 사실, 뭐 여기서 나중에 가면은 이 Lock Q를 사용하지 않고 이걸 다른 방식으로 만들어도 되겠지만 , 일단은, 뭐 간단하게 최대한 간단 간단하게 하기 위해서 그냥 뭐 잡 Q에 푸쉬만 그대로 다시 전달을 해주고 그 다음에 팝을 할 때는 그냥 잡 Q를 팝 해가지고 뱉어주도록 할게요 그냥 이미 있던 기능을 그냥 재사용하도록 하겠습니다 그 다음에 글로벌 큐는 결국에는 이 Q를 들고 있는 아이가 될텐데 이름부터가 글로벌 큐라고 이름을 지은 이유는 얘를 전역으로 들고 있을 겁니다 그리고 이게 전역으로 들고 있는 이유는 이제 나중에 나올 건데 , 일단은, 여기다가 extern class global q pointer를 만들어 주도록 할게요 g global q 클래스는 빼고 글로벌큐를 이쪽에다가 만들어 주도록 하겠습니다. 널포인터 , 이렇게, 한 칸을 띄워주도록 할게요. 그 다음에 구현부 글로벌큐를 실제로 만들어주고 글로벌큐 삭제도 해주도록 합시다. delete global q , 자, 요런 느낌으로 여기서 에러가 되는거는 include global q를 안해줘서 그런거겠죠. global q 헤더를 추가를 해주도록 할게요. 이거 delete g global q를 삭제를 해야되죠. , 자, 요렇게 해서 , 일단은, global q를 만들어 놨구요. 그 다음에 이제 하나가 더 필요한데 그 다음에는 이제 tls 영역으로 달려가가지고 내가 내부적으로 현재 스레드가 지금 실행하고 있는 잡큐가 있는지를 관리하기 위한 변수를 하나를 파주도록 하겠습니다 그래서 여기 아래쯤에다가 스레드 로컬 클래스 잡큐 포인터로 일단 만들어 줄게요 , 사실, 얘는 그냥 내가 뭘 실행하는지 알기 위한 용도이기 때문에 굳이 스마트 포인터까지 갈 필요는 없습니다. 그냥 간단하게 어떤 주소감만 들고 있으면 돼요. Current.jobQueue라고 해서 내가 지금 실행하고 있는 jobQueue는 누구이냐라고 들고 있도록 하겠습니다. 그 다음에 오른쪽 TLS 영역에서 ThreadLocal로 jobQueue 포인터로 current.jobQueue를 , 이렇게, 만들어 주도록 하겠습니다. 그리고 뭐 경우에 따라서 줄 맞춤이 편하면 줄도 맞춰주면 되겠죠 , 자, 이렇게, 일단 준비물은 완성이 되었고 다시 잡큐로 돌아가 가지고 이제 어떻게 해줄 거냐면은 먼저 프리입 카운트가 0인 상태에서 우리가 항상 실행을 해줬지만 이제 항상 실행하진 않을 거고 먼저 조건을 체크할 겁니다 엘커널 잡규가 널포인터 인지를 체크해가지고 만약에 널이라고 하면은 널일경우에만 엑세큐트를 호출해줄거에요. 즉 이미 실행중인 잡큐가 없으면 실행한다는 차이가 생기는 거죠 그리고 만약에 누군가 실행하는 애가 이미 있다고 하면은 얘는 지금 당장 내가 또 실행하기에는 뭐하니까 나는 이미 담당하는 애가 있으니까 원래는 내가 실행해야 되는 게 맞긴 하지만 딴 애한테 , 일단은, 떠넘길 겁니다 그래서 아까 얘기한 그 글로벌 큐에다가 , 일단은, 얘를 등록해줄거에요 여유있는 다른 Thread가 실행하도록 Global Queue에 넘긴다 라고 볼수가 있는거죠 , 자, 그래서 위에서 Include Global Queue를 추가해준 다음에 이 아래쪽에 가가지고 gGlobalQueue에 Push를 해줘가지고 SharedFromThis를 해줄겁니다 요 아이는 이제 너가 실행을 해줘라 나는 지금 바쁘다 라고 하는거죠 그러면 이제 Execute 쪽으로 돌아가면은 Execute 안에 들어가면 이제 내가 어찌됐건 얘를 담당해서 실행한다는 얘기니까 여기다가 디스포인터를 잠시 넣어가지고 내가 얘를 지금 실행하고 있다는 걸 인지를 해줄 겁니다. 그러면 이제 다음에 여기 내부적으로 Execute를 통해 가지고 타고 타고 가가지고 다른 잡규를 만약 내가 호출하는 상황이 왔다고 해도 내가 이미 엘커런 잡큐가 널이 아닌 상태가 될테니까 얘를 실행하지 않고 그냥 잡큐에다가 글로벌 큐에다가 , 이렇게, 밀어넣고만 나온다는 얘기가 되는거죠 요렇게 , 일단은, 수정이 될거에요 , 자, 그리고 남은 일감이 종료하면은 엘커런 잡큐는 다시 널 포인터로 밀어주면 되겠죠 이제 나는 호출을 끝났다 라고 요렇게 , 일단은, 만들어 줄 수가 있을겁니다 어 그러면은 뭐 여기까지는 오케이인데 그러면 내가 여기서 지금 , 사실, 글로벌 큐에다가 우리가 밀어 놓은 요 잡큐 같은거는 그럼 누군가는 또 꺼내 가지고 실행은 하긴 해야 되겠죠 , 자, 여기부터 이제 조금 상황이 아리랄송이 치기 시작을 합니다 이걸 과연 어떻게 배분을 해야 될까 그리고 이것도 , 사실, 뭐 당연히 여러가지 방법이 있겠지만 굉장히 좀 효과적이고 간단한 방법을 하나 보여드리고자 합니다 , 자, 일단은, 어떻게 해볼거냐면은 여기 TLS 영역에 가가지고 아니 Thread Manager 쪽에 가가지고 함수를 하나를 만들어줄건데 static void do global q work라는 이름으로 글로벌 큐에 일을 하겠다 뭐 약간 콩글리쉬 같은데 그냥 이런 이름으로 함수를 만들어 보도록 할게요 그래서 임플레멘티션을 만든 다음에 얘는 , 이렇게, 무한 루프를 돌면서 현재 어 이걸 , 사실, 무한으로 다 실행할 수는 없겠죠 일감이 몇 개인지 모르니까 그러니까 일정 시간 동안 만 얘를 실행을 할 겁니다 나오는 getTickCount 64를 이용해 가지고 현재 Tick을 체크를 한 다음에 언제까지 내가 해야 되는지를 봐 가지고 해당 기간이 지났으면 , 일단은, 빠져나올 거에요 근데 물론 이 시간도 이제 뭐 어떻게 관리할지는 뭐 선택의 여지가 있긴 하겠지만 뭐 오늘은 얘도 TLS에 가 가지고 , 일단은, 여기다가 ThreadId 바로 아래에다가 하나를 만들어 주도록 할게요. extern ThreadLocal uint64 그 다음에 얘는 lendTickCount 즉 요번 Tick이 완료되는 시간을 일단 의미하는 건데 이건 이제 당장 좀 이해가 안 가시더라도 일단 조립을 하고 살펴보도록 하겠습니다. 그래서 요렇게 만들어주고 오른쪽에서도 thread local uint64 l end tick count는 0 이라고 , 일단은, 만들어 주도록 할게요 , 자, 그래서 다시 돌아와 가지고 어 어디까지 하고 있었죠? 아 thread manager 쪽을 하고 있었는데 thread manager에서 요 end tick count를 체크해 가지고 만약에 현재 시간이 엘드티 카운트보다 더 크다 이미 시간이 지났다 라고 하면 빠져나올 것이지만 그게 아니라고 하면은 계속 이어가지고 잡큐를 호출해 줄 겁니다 잡큐를 꺼내 가지고 gglobalqueue에서 pop을 해가지고 그 잡큐를 꺼내준 다음에 얘가 null인지 일단 체크해주고 null이라고 하면은 뭐 더이상 실행할 애가 없다는 얘기가 되겠지만 그게 아니라고 하면은 얘를 이제 실행시켜준다는 얘기가 되는 거죠 이런식으로 그 다음에 위에 가가지고 include globalqueue를 , 이렇게, 헤더를 추가해주면 되겠습니다 아 그리고 글로벌 큐뿐만 아니라 지금 얘가 프라이벗으로 되어있어 가지고 실행을 못하고 있으니까 얘는 잠시 퍼블릭으로 열어주도록 합시다 요런 느낌으로 , 자, 일단 , 이렇게, 코드가 바뀔 거예요 그래가지고 결국에는 다시 이제 요약을 해보자면 원래는 내가 푸쉬를 해가지고 일감을 실행했던 애를 , 일단은, 잠시 글로벌 큐에다가만 밀어 놓고 나올 것이고 그거를 누군가가 챙겨 가지고 다시 호출해 준다라는 개념이 일단 생기게 되는 겁니다 그러면 여기서 아까 우리가 ThreadManager에서 만들어준 이 일감을 누군가가 실행을 해가지고 뭔가 호출해주면 되지 않을까라는 생각이 드는데 이제 이거는 또 어떻게 할 것이냐 다시 서버 쪽으로 돌아가가지고 한번 살펴보도록 합시다 여기 위에 가가지고 게임 서버 쪽을 어디있나요 여기 위에 있죠 게임 서버 쪽을 여기 살펴보도록 할게요 그냥 우리가 뭐 처음에 할 때는 처음에 만들 때는 간단하게 하기 위해서 뭐 이쪽에다가 두... 뭐 뺑뺑이를 돌면서 뭔가를 , 이렇게, 호출했었죠? 두 워커 잡 이런 거를 만약에 여기서 일단 해줄 수가 있을 겁니다 예를 들면은 그래가지고 이 메인 스레드가 담당해가지고 일을 꺼내도 되는데 그렇게 하면은 좀 균등하게 일감을 분배하는 거랑 좀 위배된다고도 또 볼 수가 있을 거예요 살짝 고민이 되는 거죠 , 자, 그래서 뭐 , 일단은, doWorkerJob 이라는 함수를 만들어 줄 건데 얘는 서버 서비스 레퍼런스를 잠시 , 이렇게, 받아 줄 것이고 그 다음에 와일문을 돌면서 , 일단은, 엘 엔드틱 카운트를 설정을 해줄겁니다. 아까 얘기한 그 엘드틱 카운트입니다. 이번 틱이 언제까지 끝나는지를 , 이렇게, 만들어줄 것이고 64로 그 다음에 여기에다가 이미의 값을 하나를 정해줄건데 , 일단은, 이넘으로 빼주도록 할게요. 그래가지고 워커틱이라고 해가지고 일단 64로 , 일단은, 설정을 해주도록 하겠습니다. 그 다음에 이 부분이 굉장히 중요한데 원래 지금까지 우리가 일감을 뭘 처리하고 있었는지 보면은 이런 애들이 워커스레드들이 계속 뺑뺑이를 돌면서 IoCP 코어를 계속 두리번거리면서 디스패치를 호출하고 있었습니다. , 이렇게, 하고 있었던 거죠. 그리고 이 디스패치 내부에서는 결국 무엇을 하고 있느냐 결국에는 IoCP를 GetQueueCompletionStatus를 호출하면서 얘를 대기를 타면서 IoCP에 있는 일감이 뭔가 튀어나올 때까지 기다렸다가 여기서 만약에 리시브나 샌드 등의 그런 네트워크 입출력 통지가 완료가 되었으면 여기 빠져나와 가지고 디스패치를 호출해주고 있었죠 그래가지고 이 디스패치를 호출함으로써 인해가지고 우리의 다시 타고 타고 가가지고 Session 특히나 패킷 Session 쪽에 onReceive로 타고 온 다음에 거기서 패킷을 조립을 해가지고 넘어와서 컨텐츠 코드로 넘어오는 식으로 지금 호출이 되고 있었습니다 그래서 타고 여기까지 일단 오는 거였죠 굉장히 먼 작업을 하고 있었는데 결국 애초에 시작은 요 아이였습니다 그리고 얘가 지금은 우리가 네트워크 입출력 처리를 받기 위해서 얘를 호출하고 있었고 그게 겸사겸사 인게임 로직까지 같이 호출해주고 있는 상황인거죠 패킷 핸들러에 의해 근데 , 사실, 요 부분은 여러가지 방법이 있어요 어떤 프로젝트에서는 네트워크 입출력 천리를 , 이렇게, 디스패치를 한 다음에 그 다음에 실질적으로 패킷을 파싱해가지고 룸에다가 우리 이런식으로 잡을 넣어주고 그냥 빠져나오는 식으로 구현하는 경우도 있습니다 즉 네트워크 전달만 담당하는 쓰레드를 배치를 하고 인게임 로직을 배치하는 애들은 따로 채용을 해가지고 인게임 로직만 담당하게 굴릴 수도 있다는 얘기가 되는 거죠. 그러니까 이제 스레드가 만약에 우리가 한두 개가 아니라 지금은 우리가 다섯 개만 사용하고 있어. 메인 스레드 한 개랑. 나중에 가면 거의 뭐 열 개, 스무 개 단위로 굉장히 스레드가 많아지게 될 겁니다. CPU에 따라가지고. 그러면 이제 진짜 중요한 부분은 걔네들을 어떻게 배치를 해가지고 일감을 적절하게 잘 분배를 할 것인가가 굉장히 큰 일이 되는 겁니다. , 이렇게, 네트워크한테만 전문적으로 뭐 담당스네들을 배치를 하는 것도 가능하지만 우리처럼 약간 만능형 직원을 뽑아가지고 네트워크 입출력 처리가 된과 동시에 걔네들이 타고 타고 가가지고 간접적으로 인게임 로직까지 호출을 하게끔 유도를 해줄 수도 있겠죠 여러가지 방법이 있는 겁니다 근데 지금 요 방식에서 한가지 문제점이 있는데 일단 첫번째로는 디스패치를 지금 우리가 기본값으로 무한대로 넣어놓고 있는데 무한대로 넣어놨다는거는 네트워크 입출력 함수가 완료가 되지 않으면 여기서 빠져나가지 않고 그냥 쿨쿨 잠들게 됩니다 그래가지고 요런 부분 같은 경우에 , 이렇게, 타임아웃을 넣게 되면은 무한으로 대기를 하지 않고 우리가 지정한 밀리 세컨드만큼 대기를 하다가 만약에 실패한다고 치면은 여기로 빠져나와 가지고 라스트 에러가 wait time out로 뜨고 바로 완료가 되게 된다 바로 빠져 나오게 돼요 그래서 , 이렇게, 바로 빠져나오게 유도를 할 수도 있습니다 즉 일감이 없으면 조금만 기다리다 빠져나와라 라는 식으로 , 이렇게, 인재를 넣어 가지고 , 일단은, 그 부분은 해결할 수 있어요 근데 이걸 왜 바로 빠져 나오냐면은 사실은 , 자, 우리가 룸을 유심히 살펴보면은 지금까지는 우리가 뭐 그냥 간단한 채팅 프로그램을 만들고 있었으니까 여기 네트워크 입출력 처리에 의해 가지고 패킷이 만들어지고 그 다음에 여기 있는 엔터 리브, 브로드캐스트 같은 사실상 우리가 인게임 로직으로 만들려는 부분이 실행되게 유도를 했겠지만 나중에 가면은 이게 만약에 진짜 MMO 게임의 그런 룸이라고 가정을 하면은 패킷을 받아가지고 처리하는 애들 뿐만 아니라 그냥 얘 자체적으로 뭔가 계속 로직을 돌려야 되는 애들도 같이 생기게 됩니다 예를 들면은 요 룸 안에 뭐 몬스터가 있다거나 아니면은 뭐 화살이라거나 뭐 화염구 같은 그런 투사체들이 막 날아다닌다거나 뭐 그런 경우라고 한다면 우리가 딱히 클라이언트 쪽에서 패킷을 받아서 뭔가를 처리하는 게 아니라 진짜로 누군가가 이 룸을 계속 뺑뺑이를 돌면서 체크를 하면서 그 로직을 실행시켜야 된다는 얘기가 되는 거죠. 그렇기 때문에 , 이렇게, 모든 애들을 다 네트워크 딴에서 뭔가 받은 입출력 처리가 호출하게끔 만들 수는 없다는 얘기가 되는 겁니다. 즉 누군가가 이 아이도 자체도 감시해가지고 뭐 계속 호출해 줄 필요가 있다는 거죠 요 잡규도 , 자, 그래가지고 좀 말이 길었는데 지금 요 방식에서는 그래서 뭘 하고 있는 거냐면은 , 이렇게, 같이 1 플러스 1으로 ThreadManager에다가 doGlobalWork를 , 이렇게, 같이 호출을 해줄 거예요 , 자, 이걸 만약에 여기다가 하지 않고 만약에 우리가 여기에다가 배치를 했다고 가정해봅시다 그러면 이제 어떤 의미가 되는 거냐면은 네트워크와 관련된 Thread들은 이제 이쪽에서 네트워크와 관련된 일감은 얘가 처리를 해주고 메인 Thread가 나머지 그 전역에다가 이제 예약된 그런 글로벌 큐를 호출해주겠다 얘를 처리해주겠다는 의미가 되는 거지만 만약에 이거를 다 같이 여기 안에다가 요렇게 넣어주게 되면은 , 자, 이렇게, 만약에 함께 넣어주게 되면은 이제 우리가 Thread를 이용할 때 그냥 직원을 채용을 하는데 진짜 만능형 직원을 채용을 하는 겁니다 , 자, 그래서 이게 왜 진짜 중요하냐면은 식당의 비유 해볼게요 여러분들이 직원을 20명을 고용했어요 그럼 이제 여러분들 직원을 20명을 고용했으면 여러가지 상황이 있겠죠 주방에 5명을 배치하고 서빙에 10명을 배치하고 그 다음에 결제하는 직원을 1명 배치하고 이런 식으로 식당에 맞게끔 딱딱 배치를 해야 될 겁니다 근데 항상 이제 좀 문제가 되는 상황은 정말 요리사를 다섯명 배치하는게 맞을것인가 요리사가 더 늘러나야 되는건 아니고 아닐것인지 혹은 어 서빙하는 직원을 좀 줄여야 되는게 아닌지 항상 , 이렇게, 애매한 상황이 오겠죠 모두 다 , 이렇게, 알뜰히 일을 해야되는데 만약에 네트워크 퐁신 부하보다 그냥 일반적인 게임 로직 실행하는 부하가 훨씬 크다고 하면은 이쪽에다가 더 쓰레드를 많이 배치해가지고 일감을 실행해야 될 거고 거꾸로 이쪽에다가 다 몰빵을 했더니만 이제는 네트워크 처리가 즉 여기 IOCP 코어에서 디스펙트 하는 부분이 너무 느리게 처리가 되어가지고 이 부분이 좀 밀린다고 하면은 그것도 그거대로 문제가 아닐 수가 없습니다 그래가지고 굉장히 무식하면서도 효율적이고 제가 이제 본 코드 중에서 제가 가장 좋아하는 방법은 뭐냐면은 그냥 모든 스레드들이 만능형으로 변신을 하는 겁니다 그래서 , 이렇게, 네트워크 입출력 처리를 해보다가 디스패츠 10ms를 넣어가지고 여기서 만약에 일감이 없으면 바로 빠져나와가지고 그 다음에 글로벌 큐에 있는 즉 얘가 뭔가 이제 게임 로직과 관련한 애들을 이어서 실행을 하게끔 유도를 해준다는 얘기가 되는 거죠 그럼 여기 두 글로벌 큐 내부에서는 우리가 만들어준 요 코드에 의해 가지고 , 자, 일단은, 현재 시간을 , 일단은, 체크를 한 다음에 내가 이제 요 때까지는 실행을 해도 된다고 허락을 받았으니까 이때까지 계속 뺑뺑이를 돌면서 잡큐를 계속 비우려고 노력하는 겁니다 전역에 있는 일감을 내가 조금씩 조금씩 빼가지고 걔를 실행을 하는데 도움을 준다는 얘기가 되는 거죠 이 할당받은 시간 동안 물론 이거를 뭐 이런 식으로 TLS에다가 놓지 않고 인자로 받아도 되고 그건 이제 뭐 여러분이 설계하기 나름이겠지만 여기서 중요한 거는 바로 이런 부분들입니다 이제 쓰레드 배치를 어떻게 할 것이냐에 굉장히 중요한 부분들이 있는데 이거는 , 사실, 여러 가지 프로젝트들이 다양하게 하고 있지만 어떤 프로젝트들은 그냥 모든 애들을 다 IOCP 코어를 이용해가지고 하는 경우도 있어요 그러니까 여기 IOCP에서 디스패치를 할 때 GetQueueCompetitionStatus가 지금은 우리가 기본적으로 그냥 네트워크 입출력 함수들의 완료 통지를 이걸로 받고 있지만 꼭 그렇게 사용해야 되는 것만은 아닙니다 우리가 원하면 나중에 MSN을 찾아보시면 여기다가 우리가 그냥 일반 Queue를 사용하듯 강제로 어떤 완료 통지가 뜨게끔 뭔가를 , 이렇게, 강제로 넣어줄 수도 있어요 그러니까 , 사실, 이런 그냥 게임 컨텐츠와 관련된 일감 자체도 그냥 일반 큐를 사용하듯 이 IOSP 코에다가 빵 때려가지고 디스패치를 통해 가지고 걔가 실행이 되게끔 유도를 해줄 수도 있다는 얘기가 되는 거죠 근데 저는 그렇게까지는 하기 않고요 그냥 좀 역할을 구분해가지고 요 아이는 기본적으로 네트워크 입출력 처리를 하고 그 다음에 요 아이는 이제 일반적인 그런 게임 일감들을 처리를 한다라는 식으로 구분하는 거를 조금 더 선호합니다 근데 물론 지금 제가 하고 있는 얘기가 잘 와닿지 않고 약간 외계어처럼 들릴 수도 있어요 이건 나중에 이제 실질적으로 얼리얼 엔진이랑 연동을 해보고 컨텐츠를 만들어 봐야 좀 감이 올 겁니다 근데 이제 기본적으로 제가 하고 싶은 얘기는 뭐냐면은 결국 스레드를 엄청 많이 배치를 해가지고 이런저런 일감을 지켜야 되는데 어 지금 여기서 하고 싶은 방법은 뭐냐면은 그냥 2번 , 이렇게, 루프를 계속 돌면서 어느 정도 시간을 할당을 해준 다음에 예를 들면 64ms 만큼 이번에 실행을 하겠다고 하면 현재 시간에서 64ms 후까지를 딱 지정을 해준 다음에 이때까지 얘네들이 실행을 하게끔 유도를 해주는 거죠 그러면 디스패치를 해 줘 가지고 Q 컨디션 스테이터스에 의해가지고 , 일단은, 만약에 여기서 뭔가 어떤 입출력 완료 통지가 있다고 하면은 걔가 호출이 되어가지고 겸사겸사 인게임 로직을 한 바퀴 돈 다음에 그 다음에 시간이 그래도 남으면은 글로벌 큐를 실행하게끔 요렇게 유도를 해주겠다라는 컨셉으로 지금 가고 있는 겁니다 그러면 이제 좀 설명이 길었는데 그래서 여기서 뭐 이런 식으로 루프를 도는 게 아니라 이제는 do worker job이라는 걸 해가지고 여기다가 이제 서비스를 , 이렇게, 연동을 해주면 되겠죠 요런 식으로 전달해주면 되겠습니다 그러면 우리의 갓 일꾼들이 정말로 만능형 일꾼들이 되어가지고 이런저런 시도를 지금 해주려는 그런 부분으로 작동을 하게 된다고 보시면 되겠습니다 , 자, 그 다음에 아이고 여기 하나가 빠져서 그런거고 그 다음에 메인스레드 같은 경우에는 그럼 무엇을 하는 것이냐 뭐 지금은 딱히 따로 철리를 할 일이 없으니까 얘도 그냥 마찬가지로 마찬가지로 만능형 일꾼이 되도록 합시다 그래서 지금은 모든 일꾼들이 굉장히 공평하게 네트워크 이벤트 감지를 했다가 인게임 로직도 잠시 실행했다가 글로벌 큐를 비우려고 시도하는 식으로 동작을 하게 될 겁니다 그래서 코드를 이제 , 이렇게, 만들면 굉장히 많은 차이가 생기게 된다는 거죠 , 일단은, 서버 코어랑 그 다음에 게임 서버를 , 일단은, 빌드 해가지고 문제가 없는지 일단 체크를 해보도록 할 거고 그럼 이제 코드는 어마어마하게 많이 바뀌진 않았는데 , 사실, 우리가 하려는 컨셉 자체는 굉장히 많은 것들이 바뀌었다는 걸 알 수가 있어요 즉 여기 다시 잡큐를 타고 가면은 이제 만약에 내가 Execute를 한번 실행해가지고 이미 어떤 잡큐를 내가 실행하고 있는 상태라고 하면 얘가 채워짐으로 인해가지고 그 다음에 다시 뭐 이런저런 상황에 의해가지고 다른 잡큐를 내가 호출할 일이 생겼을 때 첫 번째가 아직 완료가 되지 않았으면 얘가 넣을 포인터가 아닐 테니까 그냥 여기 글로벌 큐에다가 밀어놓고 나올 것이다 그러면 누군가가 글로벌 큐에 있는 내용을 열심히 열심히 가져가가지고 대신 실행을 해줄 것이다 라는 컨셉으로 가고 있다고 볼 수가 있는 거죠 네 그래서 뭐 , 이렇게, 일단은, 만들어 봤습니다 굉장히 무식하면서도 뭐 은근히 효과적인 방법이라고 볼 수 있는 거죠 그래서 두 async를 타고 타고 가서 절대 끝나지 않는 상황도 일단 어느 정도 예방을 할 수가 있고 왜냐면은 내가 뭐 다른 애를 타고 갔다고 해가지고 걔를 이어서 실행하는 게 아니라 걔는 그냥 글로벌 QDA가 놓고 빠져나올 테니까 그 부분을 , 일단은, 이번은 일단 해결할 수 있다는 얘기가 되는 거죠 , 자, 그런데 첫 번째 문제는 아직 해결이 되지 않았는데 일감이 너무너무 많이 몰리면은 이쪽에서 계속 처리를 하다가 뭐 그냥 제 풀에 지칠 수도 있겠죠 어느 정도 호출을 하다가 도저히 답이 없다고 하면은 얘도 이제 적당히 빠져나오도록 한번 수정을 해보도록 합시다 그래가지고 뭐 이제 이걸 어떻게 만들 거냐면은 여기 잡큐에서 지금 그냥 무한 루프를 돌면서 남은 일감이 0개면 종료하는 부분이 있는데 여기 안에다가 또 하나를 더 체크해 가지고 요런 식으로 현재 시간은 얼마 얼마입니까? , 이렇게, tickcount 64를 체크해가지고 현재 tick을 체크한 다음에 만약에 현재 now가 아까 위에서 우리가 정해준 이 end tickcount보다 뭔가 더 크다고 하면은 내가 원래 할당받은 시간보다 더 많이 소모를 한 셈이 되는 거니까 여기서도 그냥 빠져나오도록 할게요 요런 식으로 그리고 여유있는 다른 스레드가 또 이어서 호출하도록 요 부분도 같이 넣어주도록 하겠습니다 , 이렇게, 그리고 빠져나오도록 할게요 , 이렇게, 되면은 얘를 호출하는 와중에 열심히 열심히 얘를 비울려고 노력을 하고 있기는 하지만 내가 제한시간 안에 모든 일을 끝내지 못했다 즉 누군가가 계속 쑤셔넣고 있어 가지고 계속 푸쉬가 들어와 가지고 도저히 내가 처리할 수 없다고 하면은 이제 시간 안에 처리하지 못했으니까 다시 얘를 비워주고 그 다음에 글로벌 큐에다가 얘를 놓고 일단 빠져나오도록 할게요 그러면은 빠져나오면은 다시 여기서 빠져나와 가지고 그 다음 턴에 뭔가 시도를 하거나 하는 식으로 동작을 하게 된다고 보시면 되겠습니다 이래가지고 여기서 코드가 굉장히 단순한데 여러가지 굉장히 재미있는 아이디어들이 많이 들어가 있고 실질적으로 뭐 요런 식으로 만드는 것도 괜찮긴 합니다 그리고 이제 나머지 이런 세부적인 인자들 지금 64로 일단 하드코딩을 했는데 제가 예전에 얘기했던 기억으로 이런 부분을 어떻게 처리했냐면 그냥 하드코딩된 값을 넣는 게 아니라 어느 정도 체크를 해가지고 여기 있는 일감이 내가 제한된 시간 안에 끝내지 못하는 경우가 너무 많아진다고 하면은 여기 있는 틱을 조금 늘리는 식으로 약간 자동 보정이 되는 코드로 만들었던 걸로 이제 기억을 합니다. 근데 이제 기본적으로 뭐 시작을 할 때는 , 이렇게, 그냥 하드코딩 해가지고 시작을 하는 것도 나쁘지 않고 어차피 이런 코드들은 지금 우리가 간단한 그런 작은 게임을 만들 때는 티도 안 날 거예요. 뭐 CPU가 워낙 빠르니까 진짜 나중에 얼리얼 엔진이랑 연동도 하고 몬스터도 몇천마리 몇만마리 뿌리고 엄청 큰 MMO를 실행해야지만 이런 부분들이 빛을 보게 될 겁니다. 근데 지금은 , 일단은, 그냥 간단하게 스레드를 어떻게 분배할 것인가에 대한 아이디어만 살짝 보여드리기 위해서 그냥 , 이렇게, 연습을 해봤어요 그래서 요 부분도 잘 생각을 해보셔야 되는 거고 지금 아직 네트워크 라이브러리까지는 만들었지만 서버 구조 전체를 우리가 어떻게 만들어야 될지는 아직 감이 안 오실 수가 있을 겁니다 C-SHOP 강의를 만약에 끝까지 보셨다고 하면 이미 콘텐츠 유니티랑 연동을 해봤으니까 어느 정도 감이 오겠지만 그게 아니라고 한다면 지금 여기서 나중에 몬스터나 그런 애들이 막 생긴다고 했을 때 이걸 어떻게 운영해야 될지 약간 긴가민가할 수가 있어요 근데 기본적으로 여기서 이해해야 될 거는 딱 이 두 가지 부분을 깊이 이해할 필요가 있다는 거죠 IOCP 코어를 열심히 열심히 디스패치하면서 네트워크 입출력 처리가 왔으면은 걔가 어떤 식으로 호출이 되는지를 다시 한번 타고 가서 살펴보시기를 바랍니다. 디스패치를 때렸으면 여기서 GetQueueCompletionStats가 호출이 되고 IocpObject가 디스패치 되는데 우리의 IocpObject는 지금 사실상 리스너랑 더 중요하게는 Session이 들어가 있죠? 그래가지고 여기 우리가 Session 코드에서 넣어준 요기 있는 디스패치가 호출이 되면서 디스패치를 타고 간 다음에 요런 이벤트에 따라가지고 특히나 가장 빈번한 건 온 리시브가 될 것이고 온 리시브로 타고 온 다음에 요 부분이 , 일단은, 호출이 되겠습니다 물론 이게 만약에 패킷 세션이라고 하면은 이 프로세스 리시브가 여기 아래로 타고 와가지고 요 부분이 호출이 될거죠 온 리시브가 호출이 되면서 패킷 조립을 한 다음에 그거를 컨텐츠 쪽으로 온 리시브 패킷으로 뿅 떠 넘기게 될 것이고 그러면 다시 컨텐츠 단으로 가서 보면은 우리의 게임 세션에 온 리시브 패킷으로 얘가 빠져나와가지고 여기서 지금 핸들 패킷까지 호출이 된 다음에 핸들 패킷에 의해가지고 우리가 자동화 코드로 만들어 준 코드에 의해가지고 패킷을 하나를 아이디에 맞게끔 호출해준 다음에 그 핸들러로 호출해가지고 다시 이제 오른쪽으로 뿅 빠져나오게 된다는 거죠 이쪽으로 그래서 우리의 지금 사실상 인게임 컨텐츠가 결국에는 네트워크 그런 입출력 완료 통지에 의해 가지고 지금 호출이 되고 있는 요런 부분들이 있는데 얘네들은 이제 클라이언트가 어떤 요청을 했을 때 호출이 되는 부분이었고 그거와는 별개로 그냥 실행해야 되는 일감도 있을 텐데 그런 부분들을 처리하기 위해서 사실상 이런 글로벌큐도 따로 유지를 하고 있는 겁니다 , 사실, 글로벌큐는 여러 가지 용도가 있는데 여기서 미처 처리하지 못한 애들을 다시 예약을 해가지고 걔네들을 실행하는 역할도 있고 아니면 그냥 진짜로 인게임과 관련된 부분들을 실행해야 되는 부분들도 여기다가 예약을 해줄 수가 있겠죠 굉장히 다양한 용도로 활용할 수가 있을 겁니다 그래서 말 자체도 글로벌큐인 거죠 , 이렇게, 간단하게 실행을 해보면 기존과 마찬가지로 헬로월드가 잘 뜨는 현상도 확인할 수 있고요 이건 솔직히 뭐 그렇게 어려운 부분은 아니었으니까 당연하다고 생각이 드는 거고 여기서 가장 핵심적이었던 부분은 세부적으로 코드를 어떻게 짠다 이런 건 , 사실, 중요한 게 아니고 여러가지 컨셉들이 이제 중요한 겁니다. 그래가지고 왜 굳이 여러가지의 잡큐를 동시에 실행하지 않고 하나만 실행하도록 유도를 하고 다른 애들한테 떠넘겼는지 뭐 이런 부분들을 이해하는게 중요하다는 거죠. 그리고 요런 코드들 등등 네 그래서 나중에 이제 뭐 크게 서버를 이제 좀 연동을 하면은 요런 세부적인 수치들은 나중에 좀 변동을 해보면서 테스트를 해볼 것이니까 뭐 크게 중요하게 보실 필요는 없지만 이제 , 이렇게, 스레드를 어떻게 배분할 것인지에 대해서는 한 번 더 고민을 해보시기를 바라겠습니다 , 자, 이렇게, 가지고 뭐 이번 잡큐에 대해서도 마치도록 할게요.