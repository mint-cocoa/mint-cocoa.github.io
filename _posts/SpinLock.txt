자, 이제 이번 시간에는 스핀락을 간단하게 구현을 하는 실습을 해 보도록 할 건데요 스핀락을 구현하면서 굉장히 많은 것들을 배울 수가 있을 겁니다 그리고 다시 한번 강조를 드리지만 스핀락은 프로그래머, 게임 프로그래머 면접 때 굉장히 자주 등장하는 단골 주제이기도 해요 혹시라도 면접을 준비하시는 분들이라면 이 스핀락에 대한 개념은 반드시 숙지를 하셔야 되겠습니다 이게 왜 많이 나오는지 곰곰이 생각을 해봤는데 , 사실, 멀티스레드가 중요하면서도 멀티스레드와 관련되어서 스핀락만 물어보면은 이 사람이 정말로 멀티스레드에 대한 이해를 잘 하고 있는지를 굉장히 간단하게 테스트할 수 있는 그런 질문이기 때문에 이게 자주 나오는 것 같습니다 , 자, 그건 그렇고 오늘 실습을 해볼 거는 뭐 , 사실, 지난번에 만들었던 걸 잠시 다시 한번 복원을 시켜보도록 할게요 처음에 , 이렇게, 더하는 함수를 하나를 만들어 놓을 거고 , 자, 이거를 다시한번 복원을 시켜보도록 하겠습니다. 그 다음에 대충한 10만번정도 10만번정도를 , 이렇게, 돌거에요. 이게 지금 숫자가 늘은것 같네요. , 자, 10만번을 뺑뺑이를 돌건데 여기서 락가드를 해가지고 , 일단은, 락을 잡을것이구요. 뷰텍스에 관해서 가드를 만들어 준 다음에 그 다음에 썸뿔뿔을 해줄 것이고 얘를 복붙한 다음에 이제 똑같이 빼주는 서비라는 함수를 만들어 줄 것이고 아랫부분만 빼기로 바꿔주면 되겠죠 그 다음에 역시나 스레드를 2개를 만들어 줄 것이고 하나는 add라는 것을 만들어 줄 것이고 ctrl-d 복붙을 한 다음에 두번째는 sub이라는 것을 호출해 줄 겁니다 그리고 t1.join을 해서 기다려주고 t2.join을 해서 기다려주고 그 다음에 최종적으로 , 이렇게, 최종 결과물을 출력을 해 줄 거에요 그럼 지금까지 락에 대한 개념을 알아봤으니까 이게 당연히 지금 0으로 딱 정확히 떨어지고 있는데 이제 이 mutex가 아니라 우리가 자체적으로 구현한 그런 클래스를 이용해가지고 이제 이거를 바꿔치기해서 똑같이 0이 나오면 일단 오늘 테스트는 성공한게 될겁니다. , 자, 그래가지고 , 일단은, 뭐 여기다가 그냥 간단하게 스핀 락이라는 클래스를 만들어 주도록 할게요. 스핀 락 뺑뺑이를 돌면서 락을 획득하는 방법이라고 보시면 되겠습니다. , 자, 그래가지고 , 일단은, public private를 만들어 줄 것이고 , 일단은, 기본적으로 락을 걸어주는 함수랑 그 다음에 언락을 해주는 함수가 , 이렇게, 있을 겁니다 얘네는 참고로 대문자로 하면 안되고 소문자로 만들어줘야 됩니다 왜냐면 이 락가드라는 거에서 내부에서 이 락을 소문자로 호출해 줄 것이기 때문에 그 시그니처를 똑같이 맞춰줘야 되겠습니다 그래가지고 일반 락과 마찬가지로 락을 획득하는 함수 Lock 이라는 애랑 Lock을 풀어주는 함수 Unlock 이라는 애를 , 이렇게, 만들어주면 되겠죠 , 자, 그러면 아무런 배경 지식 없이 그냥 Lock 이라는 걸 한번 구현을 해보세요 라고 하면은 대부분 이제 어떻게 하시냐면은 어 요렇게 , 일단은, 만들어줍니다 Boolean 값을 하나 둬가지고 이게 , 일단은, 자물쇠 같은 거니까 화장실 자물쇠를 생각하면서 만들어 보자면 , 일단은, Boolean으로 Lock라는 Boolean 변수란을 만들어 줄게요 멤버 변수로 이제 잠겼냐 안 잠겼냐를 의미를 하는 거죠 만약에 false라고 했으면은 잠기지 않았다는 의미고 얘가 true면은 잠겼다라는 의미로 받아줄 겁니다 , 자, 그러면 락을 할 때는 얘가 이제 잠기는 게 풀려 있을 때까지 계속 뺑뺑이를 돌다가 내가 1바가 되었다고 하면은 확 가가지고 이제 문을 잠궈버리면 되겠죠 그러다보니까 왠지 이거를 굉장히 단순하게 한번 표현을 해보면 , 이렇게, 무한 루프를 돌면서 내 차례에 오기까지를 기다려 줄 것이고 그 다음에 여기까지 왔으면 락드를 트루로 , 이렇게, 바꿔치기를 해주면 되지 않을까 라는 생각이 듭니다 그러면 이 락드가 만약에 펄스였다면 이 무한 루프에서 바로 빠져나와 가지고 바로 이쪽으로 가니까 내가 , 이렇게, 락을 잡아버리는 상황이 되겠죠 거꾸로 언락을 할 때는 이제 락드를 내가 펄스로 바꿔주면 이제 그 다음 애가 똑같이 들어올 수 있지 않을까 라는 생각이 듭니다 , 이렇게, 일단 스핀 락을 간단하게 구현을 해봤구요 이게 되는지 한번 테스트를 해봅시다 여기 아래에다가 스핀 락이라는 변수를 만들어 줄 것이고 그 다음에 여기 락 가드를 뮤텍스가 아니라 스핀 락 클래스로 바꿔치기를 , 이렇게, 해준 다음에 그 다음에 스핀 락을 , 이렇게, 똑같이 넣어주면 되겠죠 , 자, 그래서 , 일단은, 빌드를 해보면 빌드 자체는 아무런 문제가 없다는 걸 알 수가 있고 Ctrl F5를 눌러서 실행을 해보면 불행하게도 값은 0이 아니라 이상한 값으로 나온다는 걸 볼 수가 있습니다. 즉 요 방법이 뭔가가 오동작하고 있다는 얘기가 되는 거죠. , 자, 근데 , 일단은, 여러가지 문제가 있는데 여기서 지금 요런 코드에서는 볼라틸 키워드를 , 일단은, 추가를 해줘야 됩니다 , 자, 근데 , 사실, 볼라틸 때문에 지금 문제가 있는 건 아니긴 해요 근데 이 볼라틸 키워드도 지금 나온 김에 같이 설명을 드리고자 하는데 C++에서 말하는 볼라틸 키워드는 C샵이나 Java에서 말하는 볼라틸이랑 완전히 다른 의미입니다 얘는 말 그대로 그냥 컴파일러한테 최적화를 하지 말아 달라고 우리가 부탁을 하는 거에 불과해요 그거에 불과합니다 C샵은 거기에다가 추가적으로 메모리 배려나 가시성과 같은 부분이랑 엮여있기 때문에 굉장히 많은 기능을 하지만 C++은 그냥 최적화만 하지 말아줘라는 그거에 불과합니다 근데 이걸 굉장히 많은 분들이 혼동을 하시는 이유가 구글에 검색을 해보면 컴파일러 최적화뿐만 아니라 캐시를 어쩌고저쩌고 사용하지 않고 뭐 이런 내용이 등장을 해요 근데 그건 어디까지나 C샵이나 자바를 기준으로 설명을 한 것이기 때문에 그렇게 얘기를 한 거고 C++은 그런 기능이 없고 이 키워드 같은 경우에는 , 사실, 거의 활용할 일이 없다고 보시면 되겠습니다 이런 몇 가지 케이스 외에는 , 자, 그런데 이게 뭘 하는 건지 한번 분석을 해보면 , 일단은, 여기다가 한번 예제를 한번 들어볼게요 , 자, 컴파일러를 최적화하지 말아 달라는 건 알겠는데 그게 무슨 의미인지 잘 와닿지 않을 수가 있겠죠 , 자, 이거를 간단하게 한번 예제를 들어보도록 하겠습니다 a라는 변수를 만들어 준 다음에 a는 1, a는 2, a는 3, a는 4라고 , 이렇게, 출력을 해주고 그 다음에 왠지는 모르겠지만 이 a라는 변수를 사용해 가지고 출력을 cout으로 해주도록 할게요 , 자, 그런데 여기서 이제 컴파일러가 우리가 만든 코드를 고지, 고때로 번역을 해 가지고 어셈블리 언어로 만드는 다음에 바이너리로 만들어 가지고 사용을 할 수도 있겠지만 여기서 만약에 우리가 디버그 모드가 아니라 이걸 릴리즈 모드로 바꿔 준다고 하면은 릴리즈 모드 같은 경우에는 온갖 최적화가 다 들어가게 됩니다 그래가지고 이 상태에서 여기다가 브레이크 포인트를 걸고 한번 코드를 살펴보도록 할게요 , 자, 일단은, 릴리스 모드로 지금 바꿔놨으니까 서버 코드 일단 다시 한번 빌드를 , 이렇게, 해줄 것이고요 그 다음에 게임 서버도 , 일단은, 실행을 해보도록 하겠습니다 그럼 여기서 일단 브레이크 포인트가 잡혔는데 요 상황에서 디버그 상 디스 어셈블리에 가가지고 살펴보면은 , 자, 우리가 실질적으로 a는 0, a는 1, 2, 3, 4를 , 이렇게, 각각의 했음에도 불구하고 그거와 관련된 내용들이 지금 딱히 보이지 않는다는 걸 알 수가 있습니다 사실상 이 컴파일러 입장에서는 이 코드를 분석한 다음에 느끼는 게 왜 , 이렇게, 쓸데없는 짓거리를 하고 있는지 이해가 안 가는 거죠 애당초 1, 2, 3 이라는 값을 넣어봤자 어차피 얘가 4로 덮었을 것이기 때문에 a는 4라는 값으로 바로 인지를 하면 되겠다라는 생각을 하는 겁니다 근데 이제 경우에 따라가지고 이게 정말로 왠지는 모르겠지만 프로그래머가 의도한 그런 코드일 수도 있겠죠 , 자, 그래가지고 만약에 volatile 키워드를 여기다가 , 이렇게, 붙여주게 되면은 이제는 컴파일러한테 최적화를 하지 말고 진짜로 요 쓸데없는 짓거리를 다 해달라고 부탁을 하고 있는 겁니다 그래서 요 상황에서 똑같이 다시 한번 브레이크 포인트를 잡아가지고 창 disassembly 가보면은 이제는 어떤가요? 실제로 a라는 변수에다가 1,2,3,4를 정말 의미 없지만 각각 , 이렇게, 넣어주는 부분이 들어간다는 걸 볼 수가 있습니다 말 그대로 컴파일러 최적화를 하지 말아 주세요 라는게 되는 거죠 , 자, 그러면 지금 여기서 말하는 거랑 이 위에 있는 volatile 불 여기랑 무슨 관계가 있냐면은 이것도 이제 똑같은 느낌으로 , 이렇게, 살펴본다고 하면은 , 자, 만약에 어떤 분리원 값이 있다고 하고 여기다가 무한 루프를 , 이렇게, 뺑뺑이를 우리가 돌고 있다고 가정을 해볼게요 이 코드를 한번 빌드를 한 다음에 여기다가 일단 브레이크 포인트를 잡아 보도록 하겠습니다 그럼 뭐 여기서 이제 무한 루프를 돌고 있는 그런 코드가 되긴 할텐데 여기서 똑같이 브레이크 포인트를 잡은 다음에 디버그 창 디스 어셈블리에 가서 보면은 그냥 이 플래그를 체크하는 게 아니라 그냥 막버로 여기다가 점프를 해가지고 이상한 대로 , 이렇게, 딱 돌아가는 걸 볼 수가 있습니다. 그러니까 실질적으로 이 플래그 값을 체크하는 코드가 날라갔던 얘기가 되는 거죠. 왜냐하면 역시나 여기 이 컴파일러 입장에서 보면 애장초 이 플래그는 true 이고 이 값은 어차피 트루이기 때문에 얘를 굳이 매번마다 와일문을 돌 때마다 체크를 할 이유가 전혀 없다고 생각을 하고 있는 겁니다. 근데 이 위에 있는 이 코드 같은 경우에는 이 락트를 매번마다 체크를 하는 이유가 있죠. 뭐냐면 이게 멀티스레드 환경에서는 이 락트라는 애를 다른 애가 기존의 값과는 다른 값으로 건드릴 수가 있기 때문에 얘를 매번마다 체크를 해가지고 그 값에 따라가지고 뭔가 변화가 일어나야 되는데 그럴 때 이제 우리가 이런 식으로 volatile 키워드를 딱 박아주면은 너 눈에 보기에는 이게 쓸모없을 수도 있지만 이게 다 우리가 깊은 뜻이 있는 거니까 이 FLAG에 대한 이 값에 대한 최적화를 하지 말아주라고 우리가 컴파이어에게 요청을 하고 있는 겁니다. 그래서 이 상태에서 똑같이 , 이렇게, 빌드를 해본 다음에 똑같이 디버그 창 디스 어셈블리에 가보면은 , 자, 이제 코드가 살짝 바뀌어 있는 거 볼 수 있습니다. 이 부분이 이 FLAG라는 거를 갖고 와가지고 체크를 한 다음에 그 값이 0이냐 아니에 따라 가지고 만약에 통과하지 못했으면 다시 여기 메인 플러스 20이라고 되어있는 요 부분으로 다시 , 이렇게, 돌아오는 걸 볼 수가 있어요 요 부분을 이제 뺑뺑이를 돌고 있는 거죠 진짜로 우리가 의도한 요 코드를 이제 실행해준다고 보시면 되겠습니다 , 자, 그래가지고 결국에는 이 볼라틸 키워드를 안 붙여가지고 혹시라도 얘가 최적화를 해가지고 문제가 발생하지 않았을까라는 이런 걱정에 얘를 붙여줬는데 , 사실, 조금 뜬금없지만 지금 요 상황에서는 그 문제가 아니기는 합니다 그래가지고 얘를 볼라틸 키워드를 추가를 한 다음에 다시 한번 똑같이 실행을 해도 결국 0이 안나오는거는 마찬가지라는 얘기가 되는거죠 , 자, 그러면은 결국에는 요 코드에서 어떤 문제가 있는지 굉장히 궁금하지 않을 수가 없는데 이 내용과 관련해서는 잠시 PPT를 보고 돌아오도록 하겠습니다 , 자, 이렇게, 해서 다시 PPT로 돌아왔고 오늘 그래서 구현하고 있는 스피락이 도대체 어떤 문제가 있는지 한번 그림으로 살펴보도록 하겠습니다 , 일단은, 스피락이라는 자체가 제가 이제 존버 메타라고 표현한 그 상황이었었죠 , 이렇게, 공용으로 화장실이 하나가 있고 자물쇠를 먼저 획득해 가지고 잠그는 쪽에서 , 사실, 그 화장실을 사용할 수 있는 권한을 얻게 되는 그런 상황이라고 제가 말씀을 드렸구요 그래가지고 지금 뭐 다수의 사람들이 너무 급해 가지고 화장실을 차지하기 위해서 지금 경쟁을 하고 있는 상황이라고 가정을 해볼게요 , 자, 그런데 여기서 문제는 뭐냐면은 사실은 화장실에 들어가는 행동이랑 그 다음에 들어가 가지고 자물쇠를 내가 잠가 버리는 행동은 , 사실, 한 번에 일어나야지 이게 말이 되겠죠 근데 지금은 , 사실, 딱히 그러한 제한이 없기 때문에 어떤 상황이 발생하냐면은 거의 동시에 두 명의 사람들이 달려가서 동시에 딱 , 이렇게, 화장실에 입장을 한 다음에 서로 승리자라고 주장을 하면서 같이 문을 잠궈버리는 이런 상황이 지금 발생한 겁니다 왜냐하면 결국에는 우리가 예전에 그 인트 정수를 대상으로 ++이랑 --할 때도 우리 눈에는 그게 ++이라는 게 한 번에 일어나는 것처럼 보였지만 사실상 세 단계에 걸쳐 가지고 레지스터에다가 갖고 왔다가 값을 1 증가시키고 다시 그 레지스터 값을 원래 메모리 갖다 놓는 식으로 세 단계에 걸쳐서 일어났던과 마찬가지로 지금도 결국에는 그 락에 대한 상태를 체크를 하는 거랑 그 다음에 락의 상태를 다시 바꿔주는 그 코드가 두 번에 걸쳐서 따로따로 분리되어서 일어났기 때문에 이런 상태가 , 일단은, 발생하고 있는 겁니다 결국에는 여기서 문제가 되는 상황은 무엇이냐면 이 아이가 화장실 안으로 들어가는 거랑 얘가 비었다는 걸 느끼고 이 자물쇠를 잠그는 이 행동 자체가 쪼개지면 안 되고 한 번에 일어나야 된다는 얘기가 되는 거죠 그리고 , 사실, 이런 용어를 여러 번 살펴본 적이 있는데 이게 아토믹하게 일어나야 된다고 일단 표현할 수 있겠습니다 즉 원자적으로 들어갔다가 잠그는 행동은 한 번에 모든 애들이 다 일어나거나 아니면은 애당초 실패할 거면 이 문에 들어가지 조차 못해야 된다는 얘기가 되는 거죠 그래가지고 요 상황에 대한 처리를 이제 하기 위해서 다시 일단 코드로 돌아가 보도록 할게요 , 자, 그래서 다시 코드로 돌아와 가지고 지금 여기서 어떤 상황이 문제가 되는지를 살펴보면은 여기서 와일문을 이용해가지고 현재 이 락트 상태를 봐가지고 잠겨있냐 안 잠겨있냐를 체크를 하는 요 상황이랑 실질적으로 잠그는 이 상황이랑 이 코드가 두 개로 분리가 되어있기 때문에 정말로 다수의 스레드가 동시에 락을 시도를 하면은 요 부분을 간발의 차이로 동시에 통과를 한 다음에 두 개의 스레드가 서로 여기까지 와가지고 내가 승리했구나라고 오해를 해서 둘 다 락을 , 이렇게, 따당 투로로 바꿔주는 이런 상황이 일단 발생할 수가 있겠습니다 사실은 한 번에 하나의 스레드만 통과를 해야 정상적이겠는데 지금은 요 코드랑 요 코드가 두 개로 분리가 되어 있기 때문에 요런 이상한 상황이 일단 발생한다고 보시면 되겠어요 그럼 결국에는 해결을 하기 위해서는 우리가 예전에 그 여기 썬뿔뿔과 관련된 문제를 아토믹으로 우리가 바꿨던 것과 마찬가지로 요 코드가 이제 한 번에 묶여가지고 동작하게끔 우리가 유도를 해줘야 된다는 얘기가 되겠습니다 , 자, 그래가지고 이거를 고치기 위해서 이 코드를 한방에 실행하게끔 아토믹으로 , 이렇게, 묶어주는 그런 일련의 함수들이 있습니다 그걸 이제 우리가 CAS compare and swap 계열의 함수라고 해요 그래서 이것도 이제 뭐 운영체질 따라서 interlocked 뭐 exchange add 뭐 이런 온갖 시리즈 다 , 이렇게, 들어가 있는데 지금은 이런거를 이런 식으로 사용할 필요 없이 우리가 지난 시간에 살펴봤던 이 Atomic을 이용하면 그 함수가 일단 포함이 되어 있습니다 참고로 이 Atomic을 사용하는 순간 Volatile 키워드는 이제 영영 잊어버리셔도 됩니다 얘가 , 사실, 그 기능까지 일단 포함하고 있다고 보시면 되겠어요 , 자, 그래가지고 이 Atomic이라는 것 자체가 뭔가 원자적으로 이제 사용하겠다라는 뭐 그런 의미로 우리가 일단 받아줄 수가 있었죠 그래가지고 실질적으로 이제 이 Atomic에 대해서 뿔뿔을 하거나 마이너스 마이너스를 했을 때 얘가 이제 원자적으로 동작한다는 걸 알 수가 있었는데 그거 말고도 다른 함수들이 여기에 또 묶여 있습니다 그래서 오늘 살펴볼 거 이제 굉장히 중요한 개념이고 이게 나중에 뭐 락프리 프로그래밍에서도 이 개념이 이제 굉장히 중요하게 등장하게 되는데 , 일단은, 점을 찍어 보면은 , 자, 여기서 compareExchangeStrong 이라는 요 함수가 있습니다 이게 이제 대표적으로 compare and swap을 나타낸다고 보시면 되겠어요 컴파인드 스트롱인데 이게 처음에는 굉장히 좀 개념이 어려워요 그래서 생각보다 까다로운데 이걸 이제 익숙해지게 되면 생각보다 그렇게 어려운 개념은 아닙니다 , 일단은, 요 함수를 원형을 보면은 Boolean을 뱉어주고 Boolean expected를 레퍼런스로 받아주고 그 다음에 desired라는 걸 , 이렇게, 받아주고 있다는 걸 볼 수가 있는데요 이게 이제 뭐 환경이나 언어에 따라 가지고 조금씩 모양이 조금씩 다릅니다 그래서 사용 방법은 비슷하지만 함수의 그 형태 자체는 조금씩 달라진다 라는 건 일단 참고를 하시면 되겠고 근데 지금 우리가 C++에서 보는 요 버전은 , 일단은, 어떤 의미인지 한번 분석을 해보면 , 자, 이걸 제가 의사 코드로 한번 보여드리도록 할게요 , 일단은, 여기서 얘기하고 있는 인자가 Boolean에서 아까 보면은 expected랑 desired라는 걸 받고 있습니다. 그러니까 이걸 , 일단은, 이렇게, expected라는 걸 만들어 놓고 desired라는 걸 만들어 놓은 다음에 여기다가 expected를 넘겨주고 desired를 , 이렇게, 일단 넘겨주고 시작을 하도록 할게요. 그러면 이 expected는 우리가 이 locked라는 값이 무엇인지를 , 일단은, 예상을 해주고 있는 겁니다. 근데 우리 같은 경우에는 , 일단은, 이 expected를 일단 false로 놓고 그 상황에 대해서 이 expected가 false면은 desired를 true를 일단 세팅을 해 줘 보도록 할게요 그 다음에 여기서 이제 얘가 Boolean을 return하는데 , 자, 요 코드를 이제 제가 풀어서 한번 써드리도록 하겠습니다 그럼 이제 이게 compare and swap에 일단 의사 코드를 살펴보면은 , 일단은, 요런 느낌이에요 locked라는 값이랑 expected라는 값을 , 일단은, 비교를 해 볼 겁니다 그러면 같을 수도 있고 다를 수도 있겠죠 그러면 만약에 같다고 가정을 하면 우리가 desired로 넣어준 이 값을 locked에다가 , 이렇게, 넣어준 다음에 그 다음에 여기다가 return true를 때려줄 거예요 그리고 그와는 별개로 애당초 원래 있던 이 locked에 들어가 있는 값은 여기 처음에 우리가 expected로 넣어준 이 값에다가 얘를 다시 , 이렇게, 세팅을 해주게 될 겁니다 그래서 요 함수가 사실은 이 코드를 , 일단은, 한방에 , 일단은, 실행을 한다고 보시면 되겠어요 근데 이게 좀 생각보다 처음에 보면은 로징이 굉장히 복잡하죠 이게 뭐 그래서 이걸 어떻게 사용해야 되는 것인가 굉장히 헷갈리는데 유심히 살펴보면은 이 expected랑 desired가 어떻게 보면 이제 굉장히 큰 의미를 갖고 있어요 , 자, 우리가 이 locked라는 값이 처음에 어떤 값이 되기를 , 일단은, expected 즉 기대를 하고 있는 겁니다 만약에 expect 이 locked라는 값이 여기서 보면은 false라고 한다면 즉 locked가 false라고 한다면 그러면은 우리는 이 락드를 투르로 지금 바꿔주고 싶은 상황이 되는거죠 말그대로 아까 화장실 문으로 비유를 하면은 락드가 펄스라는거는 문이 잠기지 않은 상태니까 들어가가지고 걔를 잠궈주겠다라는 의미가 되는거니까 expected는 펄스이고 before 상황은 false이고 after 즉 그 다음에 바뀌기를 원하는 상황은 true로 바꿔주는 상황을 우리가 얘기를 하고 있는 거죠. 그러니까 locked가 만약에 false였으면 locked를 true로 바꿔주세요 라는 부분이 이제 , 이렇게, 실행이 되는 겁니다. , 자, 그런데 만약에 요 코드가 요렇게 들어왔다고 하면은 우리가 성공적으로 값을 고쳤다는 얘기가 되는 거니까 실제로 이 락을 획득했다는 의미가 되는 건데 근데 만약에 경합에 실패해 가지고 다른 애가 선수를 쳤다거나 아니면 애당초 이 락드라는 값이 우리가 예상한 false 값이 아니라 얘가 이미 true 로 세팅이 되어 가지고 딴 애가 이 락을 소유하고 있는 상태라고 한다면 무조건 엘스문인 부분으로 들어오게 될 거예요 Exchange Strong이 실패한다는 얘기가 되는거죠 그래가지고 이거를 사용할 때 , 이렇게, 바꿔주면 됩니다 만약에 얘가 실패를 했다고 하면은 그냥 성공할 때까지 이제 무한적으로 계속 시도를 하겠다라는 의미가 되는거고 어 그러면 이제 이 두개의 코드를 이제 한방에 묶어준 셈이 되는거죠 근데 여기서 한가지 조심해야 되는거는 얘가 성공하건 실패하건 상관없이 기본적으로 이 expected 값이 원래 우리가 처음에 넣어줬던 값이 아니라 원래 들어가 있던 이 locked 코드가 이쪽으로 , 일단은, 이렇게, 들어간다는 문제가 살짝 있어요 그래서 얘를 다시 한번 보면은 그냥 Boolean이 아니라 Boolean의 레퍼런스를 받고 있죠 그러니까 이 값이 계속 매번마다 바뀌기 때문에 얘를 실행을 할 때마다 다시 원래 우리가 원했던 초창기 값으로 , 이렇게, 바꿔치기를 다시 해줘야 됩니다 이 부분만 살짝 조심하면 돼요 그래서 결국에는 이를 주석처리해서 다시 한번 보여드리자면 결국에는 expected desired를 세팅을 한 다음에 이런식으로 compound swap을 무한으로 계속 돌리면은 얘가 성공하는 순간 빠져나오게 될 것이고 성공했다는 의미는 결국에는 우리가 원하던 desired 값을 locked에다가 , 이렇게, 넣어준 상황이 되는 거죠. 즉, 이 코드가 묶여가지고 한 방에 지금 실행이 되고 있다고 보시면 되겠습니다. , 이렇게, 일단은, 바꿔주면 되겠어요. , 자, 그리고 여기서 락드는 false로 , 이렇게, 해도 , 일단은, 상관없긴 한데 이게 락드가 지금 아토믹 계열의 그런 변수인데 락드를 그냥 false라면 이게 불리언이지 아닌지 좀 헷갈리니까 이런 거를 이 스토어와 같은 별도의 함수를 이용해 가지고 , 일단은, 이렇게, 만들어 주도록 할게요 그래가지고 결국에는 아까랑 굉장히 뭐 논리적으로 보면은 , 사실, 달라진 점은 없기는 한데 요 의사코드가 지금 한방에 , 이렇게, 묶여가지고 아톰이 칸 함수로 , 이렇게, 들어갔다는 게 차이가 있는 거죠 그래서 컴패어 엑스체인지 스트롱을 이용해가지고 , 이렇게, 바꿔치기를 하는 부분을 , 일단은, 이렇게, 만들어놨습니다 그래서 이게 사실은 굉장히 간단하게 구현한 스피락의 기념이라고 보시면 되겠어요 진짜로 내가 이길 때까지 계속 뺑뺑이를 돌면서 시도를 하고 있는 거고 요 코드를 이제 다시 한번 실행을 해보면은 컨트롤 F4를 실행해보면 이제는 정상적으로 0이 뜬다는 걸 볼 수가 있습니다 얘가 진짜로 정상적인 락으로 상호 베터적인 락으로 , 일단은, 잘 동작을 한다는 걸 볼 수가 있는 거죠 그래서 이 코드를 다시 줄여 보자면 굉장히 생각보다 짧다는 걸 알 수가 있습니다 그래서 여기서 또 알 수 있는 거는 뭐냐면 결국에는 여기서 무한 루프를 돌면서 계속 시도를 하는 것 자체가 어떻게 보면은 효율적으로 돌아가는 것일 수도 있고 아닐 수도 있겠죠 지금 만약에 이 경합이 붙기는 했는데 이 락을 지금 점유하고 있는 다른 스레드가 얘를 금방 놔줄 것 같다고 하면 굳이 다시 커널 모드로 돌아가는 컨택스 스위칭을 하지 않고 유저 모드에서 , 이렇게, 뺑뺑이를 돌면서 계속 시도를 해가지고 다시 한번 용감하게 시도를 하는 게 , 사실, 맞을 것이고 그게 아니라 만약에 상대방 쪽에서 정말로 몇 시간 동안 이 락을 놔주지 않겠다고 가정을 하면 , 이렇게, 계속 무한정으로 실행하는 게 굉장히 무식한 그런 상황이 될 겁니다 그래가지고 이 스피드 락의 특징은 , 사실, 계속 뺑뺑이를 돌면서 락을 시도한다는 것도 있기는 한데 만약에 경합이 붙어 가지고 스피락이 서로 , 이렇게, 무한 루프를 계속 돌기 시작을 하면 cpu 점유율이 확 높아진다는 특징이 있습니다 왜냐하면 만약에 컨택트 스위칭이 되어 가지고 내 실행 소유권을 딴 애한테 넘겨줬으면 cpu 점유율이 낮아지면서 다른 애가 그거를 적절하게 필요에 따라서 잘 활용할 수 있게 되는 거지만 스피락에서 만약에 이 와일문을 계속 무한적으로 돌면서 이 Compound Exchange Strung을 체크를 하면서 계속 야 나 들어갈 수 있냐 들어갈 수 있냐 지금 비었냐 비었냐를 계속 체크를 하는 부분은 CPU를 쓸데없이 낭비를 하는 행동이기도 합니다 그래서 이게 양날의 검이라고 일단 보시면 되겠어요 하지만 스핀락 자체는 뭐 그렇게 어려운 개념은 아니죠 그냥 , 이렇게, 무한 루프를 돌면서 존버 메타 즉 화장실 앞에서 나올 때까지 기다린다는 그런 개념을 , 일단은, 이해를 해주시면 되겠고 이제 혹시라도 면접에서 스핀락 구현을 해봤냐고 스핀락은 무엇이냐와 관련된 내용이 나오면 이제 이런 내용들을 숙지하셔서 대답을 잘 해주시면 되겠습니다 , 자, 이렇게, 해가지고 , 일단은, 락에 대한 첫 번째 구현 방법 락을 , 이렇게, 획득할 때 누군가가 이미 들어가 있을 때 어떻게 처리를 할 것이냐에 관한 문제에서 , 사실, 가장 먼저 우리가 선택한 방법 계속 기다린다는 방법을 , 이렇게, 스피락으로 , 일단은, 구현해보고 이번 강의를 마치도록 할게요.