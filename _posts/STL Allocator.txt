자, 이렇게, 지난 시간까지 제가 개인적으로 굉장히 사랑하는 스톰업 얼로케이터에 대해서 알아봤구요 이제는 우리가 어느정도 실수를 하더라도 우리가 만들어둔, 준비한 이 방식을 이용해가지고 버그가 잡힐 거라는 믿음이 생겼다고 볼 수가 있겠습니다 굉장히 큰 발전이죠 그 다음에 이어서 오늘 알아볼 거는 지금 , 사실, 우리가 , 이렇게, 사용하고 있는 이 방법이 Xnew Xdelete를 이용해가지고 객체를 만들고 삭제하는 방법을 잡아줄 수 있다는 건 굉장히 아름답지만 그 다음에 또 생각할 문제는 우리가 일반적으로 그냥 게임을 만들 때 항상 객체를 , 이렇게, 하나하나 한 땀 한 땀 만드는 것만 있는 건 아니겠죠? 예를 들면은 우리가 뭐 항상 , 이렇게, 벡터 같은 걸 사용해 가지고 관리를 할 일도 생길 테고 맵을 사용해 가지고 여기다가 키 밸류를 이용해 가지고 맵을 사용할 일도 생길 테고 다양한 자료 구조들을 우리가 보통 stl 컨테이너를 이용해 가지고 , 이렇게, 활용하는 경우가 많은데 얘네들은 내부적으로 우리가 딱히 뭔가 지정해주지 않으면은 아직도 new delete를 이용해가지고 메모리 할당자를 활용하고 있을 겁니다 그래서 이제 요 부분을 고쳐보고 싶은데 그럼 이거는 어떻게 고치느냐 , 사실, 이것도 여러분들이 뭐 , 이렇게, 서버라던가 이런 메모리 풀링 같은 걸 해볼 일이 없었다면은 당연히 모르셨겠지만 fcb를 타고 가서 보면은 , 자, 여기 뭔가요 여기가 이제 우리가 넣어주는 데이터 타입이고 그 다음에 여기서 allocator라고 해가지고 할당자를 두 번째 인자로 옵션으로 받아주는 걸 볼 수가 있습니다 기본적으로 아무것도 넣어주지 않으면 요 기본타입 Allocator라는 걸 이용해가지고 얘가 이제 뭐 요랑 딜리트를 잘 해주게 되겠지만 경우에 따라가지고 우리가 조금 다르게 동작하는 그런 벡터를 원한다고 하면은 즉 우리만의 커스텀된 커스터마이징된 Allocator를 이용해가지고 얘가 진행이 되어야 된다고 하면은 여기다가 두 번째 인자로 넣어주면 된다는 얘기가 되는 거죠 어 그러면 끝인가? 만약에 우리가 뭐 베이스 얼로케이터를 이용해 가지고 만들어주길 원한다고 하면은 뭐 요렇게 일단 넣어줄 수 있다는 얘기가 되는 건데 근데 그렇다고 해가지고 아무 얼로케이터나 요렇게 넣어주면 안됩니다 여기서 당연히 내부적으로 기대하고 있는 그런 함수들이 있을 거에요 , 자, 그러면은 , 일단은, 뭐 다시 빌드 아이고 게임 서버를 빌드 해가지고 얘가 통과 되는지만 , 일단은, 살펴봅시다 그럼 당연한 얘기지만 지금 이런저런 문제가 , 이렇게, 뜨고 있다는 걸 볼 수가 있어요. 예를 들면 우리가 넘겨준 Allocator에서 기본적으로 여기다가 ValueType이라는 걸 찾으려고 하는데 우리가 딱히 이런 거를 정의해준 적이 없다 보니까 얘를 못 찾아가지고 지금 에러가 나고 있다는 걸 알 수가 있습니다. , 자, 그래가지고 오늘 작업할거는 요 stl에서 우리가 만들어준 그런 얼로케이터들을 할당해가지고 사용할 수 있도록 이제 뭔가 추가적인 작업을 해줄건데요 , 일단은, 얼로케이터 쪽에 돌아와가지고 스톰프 얼로케이터 밑에다가 새로운 애를 추가해주도록 하겠습니다 이름하여 str-stl-allocator 라고 이름을 지어보도록 할게요 str-allocator , 자, 요렇게 , 일단은, 만들어 줄 것이고 에세어 얼로케이터 같은 경우에는 일단 기본 형태가 템플릿으로 여러가지 데이터 타입을 받아줄 수 있기 때문에 얘는 , 일단은, 이렇게, 템플릿으로 만들어줘야 되고요. 그 다음에 아까 에러가 났던 거를 이제 살펴봐가지고 이제 하나씩 고쳐주면 됩니다. 기본적으로 여기 밸류 타입이라는 거를 이제 요구하고 있죠. 그래가지고 이거를 뭐 이런 식으로 밸류 타입을 정의를 해주면 됩니다. 우리는 요 데이터 타입이 밸류 타입이겠죠. 그래서 요렇게 , 일단은, 뭐 만들어주는 식으로 하나씩 하나씩 고쳐주면 돼요. , 자, 그 다음에 참고로 말씀을 드리자면 어 이거는 이제 여러분이 사용하는 비주얼 스튜디오 버전에 따라 가지고 얘가 요구하는 그런 모든 데이터들이나 형식들은 조금씩 차이가 있을 수가 있어요. 근데 지금 제가 사용하는 버전 기준으로는 어마어마하게 많은 내용을 포함할 필요는 없구요 이제 몇 가지만 추가를 해주면 됩니다 참고로 , 이렇게, 바꿔준 다음에 이제 Value Type이 추가 되었으니까 얘를 이제 다시 같이 봐가지고 여기다가 STL Allocator를 여기다가 , 이렇게, 한번 사용을 해보도록 하겠습니다 물론 여기서 사용하기 위해서는 위쪽에 가가지고 Include Allocator를 추가를 해줘야 되겠죠 , 자, 그러면 얘가 여기다가 뭐 인트32를 넣어준다고 가정하고 , 자, 그 다음에 여기서 다시 빌드를 하면은 이제 아까 밸류타입은 이제 알겠지만 나머지 부분을 이제 모를테니까 똑같이 뭐 이런저런 문제가 발생을 할겁니다 그럼 이제 요런 부분들을 채워줘야 되는데 , 일단은, 코드를 그냥 따라치시길 바랍니다 뭐 이거는 이런저런 연구를 하다보면 알게 되는건데 , 일단은, 생성자를 하나를 만들어줘야 되구요 그 다음에 두번째로 얘가 이제 삭제가 될 때 다른 타입을 받아가지고 여기다가 뭔가 , 이렇게, 카피를 하려는 시도를 하고 있는데 이거에 대해서 , 일단은, 이런 식으로 뭔가를 만들어 주긴 해야 됩니다. 여기서 내부 구현까지 뭐 할 필요는 없어요. 그냥 이런 인터페이스를 제공해야지만 여기서 발생하는 이 문제가 일단 없어집니다. 그 다음에 이제 실질적으로 데이터를 할당하고 해제하는 함수를 만들어줘야 되는데 얘는 대문자로 만들어주면 안되고 소문자로 만들어줘야 됩니다. allocate 그 다음에 , 이렇게, 해서 카운트를 받아줄 것이고요. deallocate 같은 경우에는 얘가 이제 릴리즈를 하는 부분인데 얘도 똑같이 요렇게 어떤 포인터랑 그 다음에 개수를 받아줍니다. , 자, 이게 메모리 사이즈를 의미하는 게 아니라 우리가 예를 들면 벡터에서 개체를 한 100개를 동시에 할당한다고 하면 그 100이라는 숫자가 여기 안에 들어오게 됩니다. 여기도 마찬가지고 그래서 요런 모습으로 일단 함수를 만들어 주시면 됩니다. 우리가 사용할 이 Allocator 기준으로 다시 한번 생각을 해보면 , 일단은, 메모리 사이즈를 개선을 해야 되는데 메모리 사이즈는 얼마가 되냐면은 카운트에다가 사이즈 오브 T를 이용해가지고 요렇게 계산을 해줄 수가 있겠죠? 요 객체 타입에다가 카운트 갭만큼을 만들어 주겠다 그게 이제 총 메모리 사이즈를 태고 그 다음에 어 여기다가 이제 메모리를 할당해서 뱉어주면 됩니다 이런 느낌으로 우리가 X-Alloc을 이용했으니까 똑같이 , 이렇게, 사용하도록 할게요 그러면 얘를 이제 이용하면 X-Alloc이라는 것 자체가 지금 우리 상태에서는 Base Allocator나 Stomp Allocator 이제 디버그 릴리즈에 따라가지고 얘를 골라주게 될텐데 , 이렇게, 일단은, 만들어주면 되겠고요 그 다음에 뭐 삭제할 때는 그냥 X-Release만 , 이렇게, 만들어주면 되겠습니다 그럼 이제 사실상 준비가 끝난거에요 , 자, 여기서 다시 서버 코어 빌드를 한 다음에 똑같이 게임 서버 빌드를 하면은 , 자, 이제 뭔가 에러가 다 없어졌다는걸 볼 수가 있습니다 그러면 이제 요 벡터 같은 경우에는 굉장히 재밌게도 내부적으로 new delete를 해주는 게 아니라 실질적으로 얘를 이용해가지고 뭔가 객체를 만들면 여기 allocate랑 deallocate로 코드가 들어오게 될 겁니다. 실제로 그런지 한번 테스트를 해보도록 할게요. 예를 들면 처음에 객체를 100개를 만들어 달라. 이런 식으로 동시에 예약을 , 이렇게, 만들어 주도록 하겠습니다. 예약이 아니라 실제로 객체를 100개를 만들어 보도록 하겠습니다. , 자, 그럼 이왕이면은 나이트로 만드는 게 좀 더 재밌을 것 같으니까 , 이렇게, 나이트를 이용해가지고 만들어 보도록 할게요. 그 다음에 여기서 실행을 딱 하면 여기다가 기다려보면 브레이크 폰트가 여기 정확히 딱 잡히는 걸 볼 수가 있습니다. , 자, 여기 첫번째로 잡힌 것은 무시하시고 다시 한번 실행을 하면은 두번째로 카운트가 100개 짜리가 정상적으로 , 이렇게, 만들어지는 걸 볼 수가 있어요 , 자, 그 다음에 여기서 이제 정상적으로 얘가 다 만들어진 다음에 다시 실행을 하면은 나중에 이제 메인 함수가 끝나다 보면은 얘가 날아가게 되면서 Deallocate를 호출해주고 그러다보면 여기서 릴리스가 호출이 되어서 이제 최종적으로 메모리가 날아간다는 것까지 일단 알 수가 있습니다 그리고 생성자 소멸제도 얘가 내부적으로 잘 호출해주고 있다는 걸 볼 수가 있어요 그러니까 메모리를 할당한 다음에 내부적으로 이 벡터 내부에서 생성자랑 소멸자는 잘 알아서 호출해주니까 그 부분 , 일단은, 신경 쓸 필요 없다는 얘기가 되는 거고 , 이렇게, 해가지고 굉장히 단순하게 우리가 어... 뭐가 사용하고 싶은 요 얼로케이터를 이용해가지고 벡터를 사용하는 그런 방법에 대해서 알아봤습니다 근데 벡터뿐만이 아니라 이제 뭐 큐라거나 맵이라거나 온갖 애들이 다 요런 어... 자신만의 그런 얼로케이터를 받는 그런 방법이 당연히 있을 겁니다 이제 그 부분을 편하게 사용할 수 있도록 일일이 하나씩 다 작업을 해주도록 할게요 이거는 메모리 쪽에 가가지고 헤더 하나를 추가를 할 것인데 어... 이름하여 그냥 컨테이너라고 합시다. 모든 컨테이너들을 다 여기서 우리가 재정의를 해가지고 사용을 할 예정입니다. 그래서 컨테이너라고 일단 이름을 지어주도록 하고요. 그 다음에 까먹지 않고 우리가 사용하는 이 코어 PCH에 돌아가가지고 대략적으로 이쪽에다가 컨테이너를 여기다가 추가를 해주도록 하겠습니다. 그 다음에 여기다가 컨테이너를 추가했으면 , 사실, 여기서 내부에서 사용하고 있던 이런 컨테이너들은 다 , 일단은, 끄집어내가지고 컨테이너 쪽에다가 , 이렇게, 옮겨놓도록 할게요 뭐 두 번 딱히 추가할 이유는 없으니까 여기다가 , 일단은, 다 갖고 왔구요 , 자, 그 다음에 여기서도 타입을 사용하기 위해서 include type을 여기다가 추가를 해주도록 할 거구요 그리고 Allocator도 사용할 예정이기 때문에 여기다가 Allocator도 , 이렇게, 갖고 오도록 하겠습니다. 그 다음에 여기서도 혹시 모르니까 using namespace std로 , 이렇게, 만들어주도록 하고 선언을 하도록 하고 이제 여기서 우리가 사용할 이 Vector 모양대로 그대로 넣어주면 되겠습니다. 어 그러니까 한마디로 여기서 만약에 우리가 vector, type, stl allocator라고 요 전체 부분을 매버마다 쳐야 된다고 하면 이걸 너무 귀찮아가지고 타이핑하기가 너무 힘들겠죠 그래가지고 이거를 재정리하는데 뭐 , 사실, 이거는 여러가지 뭐 네이밍 컨벤션이 있을텐데 , 자, 이런식으로 예전에 사용하던 프로젝트에서는 항상 X를 붙이는게 컨벤션이었습니다. 그래서 벡터 앞에다가 X벡터를 붙이면 우리가 작업하고 있는 그 Allocator를 이용해가지고 얘를 사용하겠다라는 의미였고 아니면은 저같은 경우에는 그냥 이거를 대문자로 하는 것도 좀 좋아합니다. 이런 느낌으로 이게 약간 C샵의 느낌이 나죠. 그래가지고 어떤 식으로든 여러분들이 편한 이름으로 만들어 주시면 되겠어요. 아이고 여기다가 그냥 Type이라고 , 이렇게, 이름을 지어주도록 할게요 뭐 T로 해도 상관없습니다 Type이랑 STL Allocator를 그대로 받아줘가지고 얘를 , 이렇게, Using을 넣어주게 됐으면 이제는 앞으로 사용하는 쪽에서는 이런식으로 매버마다 타이핑할 필요 없이 , 이렇게, 바꿔치기를 해주면 이제 정상적으로 아까 우리가 했던 거랑 마찬가지로 우리가 만든 Allocator를 이용해가지고 이제 벡터가 사용이 된다라고 볼 수가 있는 거죠. , 자, 요 작업을 나머지 컨테이너들에서도 쭉 해주면 되는데 너무 귀찮다 싶으면은 그냥 복붙을 다 하시면 되겠어요. 제가 코드는 다 올려드릴 테니까 이걸 그냥 그대로 복붙하시면 되고 , 자, 리스트도 일단 벡터랑 별다른 차이 없이 여기다가 두번째 인재로 Allocator만 받아주고 있구요 근데 이제 그 다음부터 조금 복잡해지는 애들이 있습니다 , 자, 맵같은 경우에 여기가 얘가 지금 어떻게 만들어져 있는지 보면은 여기다가 Key랑 Value를 , 일단은, 두개를 받아준 다음에 그 다음에 Predicate 즉 어떻게 비교를 할 것인지를 받아주고 있구요 그 다음에 최종적으로 Allocator를 여기서 이제 받아주고 있다는 걸 볼 수가 있습니다 , 자, 그래서 여기서 이제 맵을 작업을 해보자면 , 일단은, 키 타입을 먼저 받아 줄 것이고 그 다음에 벨류 타입을 , 이렇게, 받아 준 다음에 그리고 이어서 프레디켓을 받아 줄 것인데 얘 같은 경우에는 기본적으로 그냥 레스를 이용하겠다 , 이렇게, 일단은, 만들어주면 되겠습니다. using map은 맵을 사용할 것인데 key type predicate 이거 pred 그 다음에 stl allocator 이제 드디어 우리가 넣어준 할당자를 여기다가 , 이렇게, 넣어주면 되는 거죠. key type 그 다음에 하나 둘 셋 세 개짜리로 , 이렇게, 잡아주면은 이제 맵도 정상적으로 사용할 준비가 끝났다고 보시면 되겠습니다. , 자, 그리고 뭐 굉장히 비슷하지만 set 같은 경우에도 비슷한 느낌인데요. key랑 type name predicate 얘도 less로 , 이렇게, 만들어 주고요. 사실상 아까 맵이랑 동일한데 얘는 key 타입만 있고 value 타입이 빠졌다고 일단 볼 수가 있겠습니다. 그래서 set도 , 자, 이런 식으로 key랑 predicate 그리고 stl allocator 얘 같은 경우에는 키만 받아주는 형태로 , 이렇게, 완성이 됐고요. 여러분들이 뭐 자주 사용하는 컨테이너들의 기본 형식을 살펴본 다음에 그거에 맞게끔 이제 여기다가 추가를 해주시면 되겠어요. 저같은 경우에는 이제 뭐 큐랑 스택, 프라이럴 디큐 이런걸 뭐 자주 사용하기 때문에 얘네들도 똑같이 만들어주자면 , 자, 요렇게 데크도 만들어줄 수 있을 것 같구요 아이고 디큐가 아니라 데크 데크를 만들어준 다음에 type stl allocator type 만들어줬구요 그 다음에 이어서 Q랑 스택도 있는데 Q랑 스택은 좀 특이한 게 얘네들을 살펴보면 기본 컨테이너가 데크로 되어 있다는 걸 볼 수가 있습니다 그래서 우리도 마찬가지로 똑같이 이걸 만들어 주자면 type name type 그리고 type name 기본 컨테이너는 무엇으로 할 거냐 데크로 하겠습니다 , 이렇게, 얘를 이용해서 Q랑 스택이 구현되어 있다고 볼 수가 있는 거죠 그래서 using q는 q type container 닫아주고 , 자, 얘를 하나 더 만들어준 다음에 stack도 똑같이 요렇게 바꿔치기를 해주면 되겠습니다. 그 다음에 뭐가 있을까요? 이어서 우선순위 큐도 만들어 볼 건데 priority queue에서 여기서 살펴보면 type name이랑 기본 컨테이너가 vector로 되어 있다는 걸 알 수가 있고요 predicate은 뭐 여전히 less로 되어 있다는 걸 볼 수가 있습니다 그래서 이것도 마찬가지로 template type name type 그 다음에 type name container 기본 컨테이너는 우리가 vector로 만든다고 했으니까 얘로 일단 이뤄져 가지고 만들어져 있다는 걸 알 수가 있는 거고 그리고 그 다음에 type name predicate 같은 경우에는 less type name container 의 value type 이라고 치면 되겠습니다 , 자, 이게 조금 복잡하게 되어있는데 역시나 얘를 이제 컨닝 해가지고 만든 겁니다 그래가지고 얘가 priority q 라고 , 자, 요렇게 type container predicate 을 각자 받아 주도록 하겠습니다 그리고 몇 개만 더 해보자면 String 그리고 Wstring이 있겠죠? String, Wstring 얘도 이제 여기서 컨닝을 해서 오면은 String이라는 애가 기본적으로 어떻게 만들어지는지 살펴보면 되는데 여기서 들어가서 살펴보면은 Basic String이라는 걸 이용해가지고 Wstring이랑 String이 둘 다 만들어져 있다는 걸 볼 수가 있습니다. String, Basic String 그 다음에 Character, Trait, Allocator , 이렇게, 세 가지를 입력을 해주시면 됩니다. 귀찮다 싶으면 그냥 얘를 긁어가지고 여기다가 복붙을 한 다음에 얘를 고치는 것도 방법이긴 하겠네요 , 자, 그래가지고 일단 스트링이랑 여기서 W 스트링 이걸 뭐 어떻게 하실지 궁금한데 WS를 대문절 할지 얘를 , 이렇게, 할지는 여러분들이 선택을 하시면 되겠고요 , 이렇게, 두개를 , 일단은, 넣어주도록 할건데 Allocator는 우리가 만들어준 STL Allocator로 얘를 , 이렇게, 바꿔치기를 해주면 얘네들도 이제 완성이 될겁니다. 그리고 뭐 경우에 따라가지고 여기서 추가적으로 Unordered Map 그러니까 Hash Map을 사용하는 경우도 있겠죠? 그것까지만 , 일단은, 이제 완료를 해주면 거의 제가 사용하는 대부분의 그런 컨테이너들은 끝난 것 같네요 unordered map 얘같은 경우에는 또 복잡하게 되어있는데 key랑 value 그 다음에 여기서 hasher라고 해가지고 어떤 hash를 사용할 것인지 근데 얘네는 일단 기본값을 넣을 거니까 신경 안 쓸 것이고 그 다음에 여기서 Key Equal 이라고 해가지고 얘를 이제 어떤 식으로 비교를 할지 뭐 요런 부분들이 일단 들어가 있다고 하는 걸 볼 수가 있는데 얘도 , 일단은, 그냥 기본적으로 만들어 주도록 합시다 Template Type Name Key Type Name Type 그 다음에 Type Name 아까 Hasher 라고 했었죠? Hasher는 그냥 기본에 이게 뭔지 모르겠지만 뭐 해시값을 추출하는 그런 거겠죠? 그 다음에 Key equal 어떤 식으로 key equal을 할 것인지 equal to key 따단 하고 , 이렇게, 만들어 준 다음에 얘를 hash map이라고 이름을 지어 주도록 할게요. key랑 type, hasher 그리고 key equal 그 다음에 마지막으로 드디어 stl allocator에 pair const key type 에고 type 123 , 이렇게, 만들어 주시면 되겠습니다. 그리고 진짜로 마지막으로 Unordered Map이랑 혹시 키 없이 사용하는 Unordered Set도 사용할 수 있으니까 해시셋만 , 이렇게, 추가를 마지막으로 해주면 되겠죠. 얘같은 경우에는 타입을 안 받는다는게 조금 다르니까 얘만 , 일단은, 빼주면 되겠습니다. 그럼 나머지 부분은 비슷한데 아 여기도 STL Allocator에 그냥 키만 받아주도록 요렇게 삭제를 해주면 되겠죠. , 자, 그래서 나중에 이제 뭐 추가하고 싶은 게 있다거나 여기서 뭔가 좀 다르게 동작해야 될 게 있으면 이런 부분들을 이제 고쳐주면 되는데 굉장히 신기하게도 이제 STL을 굉장히 오랫동안 작업을 했었을 수도 있지만 그럼에도 불구하고 , 이렇게, 얼로케이터를 직접적으로 넣어줄 수 있다는 거는 , 사실, 저도 몰랐었어요 예전에 회사 가서 딱 처음 보고 아 그렇구나 라는 걸 알았는데 그래서 뭐 , 이렇게, 사용하게 되면 이제는 나중에 우리가 추가적으로 여기에 있는 STL 얼로케이터를 사용하고 있는 요 엑셀럭이랑 릴리즈가 메모리 풀을 사용하게끔 유도를 해주면은 사실상 우리가 사용하고 있는 요 벡터 리스트 등등 모든 컨테이너들이 다 메모리 풀을 이용해가지고 구현이 되겠습니다. 뭐 엄청난 발전이 있었던거죠. , 자, 그래가지고 이제 앞으로 어... 그냥 기본 손문자로 할게 아니라 이왕이면은 우리가 원하는 그런 메모리 안전한 메모리 체크를 하는 버전으로 뭔가 호출이 되길 원한다거나 하면은 이제는 뭐 , 이렇게, 대문자라거나 여러분들이 만들어준 요 이름 컨베이션을 지켜가지고 , 일단은, 뭐 사용을 해주시면 되겠습니다 뭐 이런 느낌으로 만들어 주면 된다는 거죠 맵 맵. 뭐... 100번 나이트를 뭐라고 부르겠다 뭐 이런 식으로 , 일단은, 만들어 줄 수가 있을 거라고 보시면 되겠습니다 그래서 이것도 빌드하면 아무 이상 없이 이제 다 통과가 될 겁니다 , 자, 이렇게, 해가지고 뭐 , 사실, 별다른 내용은 아니었지만 의외로 생각보다 그렇게 자료가 많지는 않아서 이런 게 가능했다는 걸 모를 수도 있었을 텐데 이제 드디어 새로운 뭐 그런 거에 대해서 알고 알게 됐고 STL을 사용하더라도 꼭 , 이렇게, 기본 뉴 딜리트와 같은 것만 사용할 수 있는 게 아니라 우리가 만든 커스텀 얼로케이터를 충분히 붙일 수 있다는 거에 대해서도 , 일단은, 알아봤습니다 , 자, 이렇게, 해가지고 이제 이어가지고 뭐 STL에서 우리가 만든 Allocator를 붙이는 방법에서 그냥 간략하게 알아봤습니다.