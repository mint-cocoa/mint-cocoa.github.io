자, 지난 시간까지 굉장히 새로운 발상의 전환을 해가지고 요런 식으로 가변 데이터를 밀어 넣을 때 바로 같이 섞어서 밀어 넣는 게 아니라 가변 데이터의 일종의 헤더를 먼저 만들어 가지고 걔를 , 이렇게, 고정 크기의 데이터로 먼저 만들어 준 다음에 가변 데이터들을 뒤에다가 밀어 넣어주는 방법으로 굉장히 신기하게 좀 수정을 해 봤습니다 그리고 , 이렇게, 했을 때의 장점은 이제는 설령 가변 데이터들이 여러 개가 등장한다고 해도 밸리데이션을 굉장히 빠르게 이 방법을 이용해가지고 이 offset count 등을 체크하는 방법으로 빠르게 빠르게 체크할 수 있다는 장점이 생긴 거고 밸리데이션을 한번 통과한 다음에는 그 다음 데이터들은 이제 안전하게 꺼내 쓸 수 있다는 , 일단은, 결론을 얻을 수가 있었어요 이것 자체로도 굉장히 신기한 부분이었는데 오늘 패키지 직열화 2탄에서 알아볼 부분은 이것보다 더 신기한 발상의 전환을 해보게 될 겁니다. 그리고 이 부분도 굉장히 중요한 게 뭐냐면은 사실은 우리가 패킷 직렬화를 할 때 크게 두 가지 , 일단은, 뭐 문파라고 할까요 두 가지 부류가 있어요 그리고 심지어 그게 구글에서 나중에 그 유명한 프로토퍼프랑 플랫퍼퍼의 차이이기도 한데 공곰히 생각을 해보면 지금 우리가 , 이렇게, 만들고 있기는 하죠 근데 여기서 새로운 발상의 전환을 해야 되는 건 뭐냐면은 , 자, 이런 식으로 임시 객체들을 만든 다음에 거기다가 버퍼에 있는 내용을 역직렬화 해가지고 데이터를 , 이렇게, 이렇게, 지금 꺼내 쓰고 있습니다 뭐 이게 너무나도 당연하게 느껴질 수 있겠죠 버퍼에 있는 내용을 꺼내 가지고 쓰긴 해야 되니까 마찬가지로 데이터를 만드는 부분도 다시 한번 살펴보면은 애당초 우리가 , 이렇게, 버퍼에다가 이 샌드 버퍼에다가 데이터를 밀어 넣기 위해서 사실상 우리가 임시 객체를 막 만들고 있습니다 예를 들면 이 벡터라거나 이 더블리스팅 이라거나 하는거는 엄밀히 말하면 우리가 컨텐츠 단에서 당장 필요하지는 않았을 수도 있는데 데이터를 밀어 넣기 위해서 , 이렇게, 벡터를 먼저 만들어 준 다음에 그거를, 이 벡터를 임시로 만들어 준 다음에 그거를 Make S 테스트에 전달을 해가지고 이 임시 객체를 통해 가지고 여기 있는 내용을 토대로 지금 버퍼를 채워주고 있습니다. 그리고 그게 뭐 딱히 잘못됐다는 방법도 아니고 , 이렇게, 하면 확실히 코드 가독성이라거나 코드를 만들 때 굉장히 편해지는 장점은 있긴 하지만 하지만 그럼에도 불부하고 이 벡터를 만들어주는 불필요한 복사 비용이 , 일단은, 들기는 하겠어. 그래가지고 오늘 이제 새로 알아볼 방법은 애당초 데이터를 만들고 읽을 때 임시 객체를 만들어서 데이터를 복사하는 과정을 일단 건너뛰고 바로 버퍼에다가 꽂아주고 그리고 데이터에 있는 내용을 바로 꺼내 쓰는 방법에 대해서 알아볼 겁니다 , 일단은, 이게 좀 내용이 좀 복잡하기 때문에 일단 리드하는 부분만 일단 먼저 작업을 해볼 거에요 , 자, 그래서 일단 오늘은 요 서버쪽은 냅두고 클라이언트 패킷 핸들러 쪽만 양쪽만 작업을 해볼 것이기 때문에 , 일단은, 클라이언트 패킷 헤더를 왼쪽에 그리고 cpp를 일단 오른쪽에 놓고 시작을 해보도록 할게요 , 자, 그래서 , 일단은, 첫 번째로 발상의 전환을 해야 되는 부분은 뭐냐면은 이 핸들 테스트를 할 때 요 아이를 과연 , 이렇게, 꺼냈어야 될까에 대한 부분입니다 사실은 우리가 버퍼에다가 데이터를 밀어 넣을 때 요 데이터 포맷 자체가 , 자, 얘를 다시 한번 복쇄해서 , 이렇게, 아래로 갖고 오자면 지금 정상적으로 고지 곧대로 지금 요 포맷대로 , 일단은, 들어가 있습니다 그리고 데이터도 실질적으로 정상적으로 요렇게 들어가 있는 상태죠 그거를 우리가 굳이 , 이렇게, 꺼냈을 필요 없이 , 자, 일단은, 굉장히 재밌는 걸 해볼 건데 얘를 이제 어떻게 해볼거냐면은 우선은 여기다가 데이터를 읽는 부분을 잠시 제거를 하고 , 이렇게, 하지 않을 것이고 이제 , 이렇게, 한번 바꿔보겠습니다. pks 테스트를 할건데 , 자, 포인터로 얘를 이제 인지를 할 것이고 리인터프렛 캐스트를 해가지고 굉장히 놀라운 작업을 할건데 그냥 버퍼 자체를 그냥 그대로 사용할거에요 다만 이 버퍼에 있는 시작 주소를 pks 테스트로 포인터로 , 일단은, 반환해가지고 인지를 해보도록 하겠습니다 사실은 이 버퍼에 있는 내용이 우리가 첫 주소를 pks 테스트로 인지해가지고 바꿔서 사용하면은 애당초 똑같은 의미죠 굳이 여기에다가 꺼내 쓰지 않다고 하더라도 버퍼에 있는 내용 그 자체가 pks 테스트에 있는 내용이랑 일치하기 때문에 그냥 , 이렇게, 캐스팅을 해 줘 가지고 이 주소를 pks 테스트로 인지해 가지고 데이터를 그냥 바로 꺼냈을 겁니다 그리고 심지어 지금 원래 우리가 요 방식에서 데이터를 꺼냈었을 때는 이 렌스가 반드시 pks 테스트보다 커야 된다는 보장을 한 다음에 , 이렇게, 안전하게 꺼냈었지만 지금은 그냥 , 이렇게, 다른 식으로 간주하는 거는 우리 마음이죠 그냥 , 이렇게, 바꿔붙이기를 해보도록 할게요 렌스 테스트 없이 , 자, 그러면은 물론 이게 만약에 패킷 조작 등등이 있었다고 하면은 사실상 우리가 패킷 애스트 테스트를 사용하면 안 될 수도 있어요 그러니까 요 내용 자체가 지금은 아직까지 확실한 거는 얘가 헤더 사이즈만큼은 최소한 파칭에서 넘어왔을 테니까 요 2바이트 2바이트 4바이트까지는 안전하게 사용할 수 있다는 건 알지만 그 다음 내용은 , 사실, 미지의 영역이기는 합니다 그 뭐 정상적으로 왔다고 하면은 데이터가 다 있을 것이고 그게 아니라고 한다면은 얘를 사용하면 안 되겠죠 , 자, 그래가지고 바로 이어가지고 밸리데이션을 여기서 막바로 , 이렇게, 때려 볼 건데 밸리데이션 코드를 보면은 우리가 안전하게 왔다고 가정을 하고 , 이렇게, 만들고 있지만 이거를 조금 분리해가지고 생각을 하면은 먼저 어 그 자체 여기까지 , 일단은, 안전하게 왔다는 건 아니까 그 다음 영역까지 , 일단은, 안전한지를 테스트를 하기 위해서는 요 부분에서 한 번 더 체크를 해주면 되겠죠 요기 있는 사이즈 자체를 테스트를 한 다음에 얘가 패킷 사이즈보다 크기만 하면은 요렇게 일단 패킷 사이즈가 크기만 하다는 것만 일단 체크해가지고 만약에 패킷 사이즈가 이 패킷 애스트 테스트 보다도 작다고 하면은 이건 당연히 뭔가 문제가 있는 상황이 될 겁니다 바로 리턴을 때려주도록 할 거예요 그러니까 사실상 아까 처음에 여기 이전에 했던 렌스 체크 자체를 여기다가 안에 넣어줘 가지고 해준 느낌이라고 일단 볼 수가 있는 거죠 한 번에 왜냐면 이 패킷 사이즈라는 것 자체가 우리가 이제 서버 코어 단에서 조립을 할 때 얘를 살짝 까봐 가지고 최소한 요 사이즈 만큼의 패킷을 모아 가지고 그거를 조립해가지고 우리한테 넘어온 상태이기 때문에 지금 요 조건만 , 일단은, 통과가 되었다고 하면은 패킷 사이즈가 최소한 여기 S 테스트라는 패킷 사이즈보다는 크다는 얘기가 되는 거니까 요걸 넘어가지고 이제 아랫부분까지도 여기까지도 , 일단은, 안전하게 사용해도 된다는 확신을 우리가 얻을 수가 있겠습니다 그럼 이제 나머지 코드를 요렇게 실행해 가지고 나머지 영역도 체크를 해 봐 가지고 여기서 여기까지 끝까지 , 일단은, 안전하게 내가 접근할 수 있겠구나 라는 확신을 얻을 수가 있게 되겠습니다 요렇게 일단 1차적으로 테스트를 할 거예요 , 자, 그렇게 해가지고 결국에는 요 PK 테스트 밸리데이션까지 , 일단은, 체크를 해서 통과했다고 하면은 , 사실, 여기서 나머지 부분을 그냥 우리가 꺼냈으면 되겠습니다 예를 들면 지금 버퍼 카운트 같은 경우에도 요렇게 당겨가지고 그냥 막바로 그냥 꺼냈으면 된다는 얘기가 되는 거죠 요런 느낌으로 , 자, 그래서 물론 이제 요 아래 부분에서 다시 버퍼를 꺼냈어 가지고 얘를 만드는 부분이 이제 옵셋이 살짝 꼬이게 될 것이기 때문에 얘가 정상적으로 실행이 되진 않겠지만 최소한 여기까지 , 일단은, 브레이크 포인트를 잡아 가지고 얘를 그냥 막바로 pks 테스트로 포인터로 바꿔 가지고 인지를 해서 만약에 진행을 한다고 치면은 그리고 얘를 실행해 보면 , 자, 여기 PKCAT에 정상적으로 데이터가 , 이렇게, 들어가 있다는 걸 볼 수가 있습니다 근데 사실상 이거는 복사한 게 아니라 그냥 버퍼에 있는 데이터를 그대로 우리가 다른 관점으로 분석을 해가지고 얘를 PKS 테스트라는 구조체로 분석을 해가지고 그냥 막바로 지금 , 이렇게, 사용을 하고 있는 거고 실질적으로 데이터가 다 , 이렇게, 잘 들어가 있다는 걸 볼 수가 있습니다 뭐 당연한 얘기죠 그러면은 그 다음으로 여기까지도 굉장히 신기한데 , 자, 그 다음에 요 리스트 같은 경우에도 얘를 굳이 이런 식으로 벡터를 이용해 가지고 꺼내 쓰지 않고 어차피 여기 있는 데이터가 뭐가 있는지는 우리가 확실히 알 수 있죠 여기 지금 offset이랑 count를 알고 있으니까 시작 위치랑 그 다음에 개수를 먼저 알고 있다고 가정을 하면은 우리가 뭐 연결 리스트 같은 경우에도 해당 노드에 접근해가지고 그 그러니까 벡터를 만약에 우리가 사용한다고 하면은 벡터의 시작 주소와 그 다음에 개수를 안다고 하면은 그 데이터를 그냥 막바로 우리가 접근해서 사용을 할 수 있었지 굳이 이거를 복붙해가지고 밖으로 꺼내 쓸 필요가 전혀 없었죠 그러니까 이것도 굉장히 비슷하게 막바로 꺼낼 수 있게 이제 유도를 해볼 건데 좀 일반적인 상황에서 이거를 활용할 수 있게 일단 클라이언트 패킷 핸들러에다가 , 자, 템플릿으로 , 일단은, 좀 헬퍼 클래스를 하나를 만들어 보도록 할게요 그래서 이름하여 class PacketList라는 이름으로 , 이렇게, 일단은, 만들어 볼 것이고요 얘가 public이랑 private를 들고 있는데 내부적으로 얘가 들고 있는 거는 시작 주소, 데이터라는 시작 주소랑 그 다음에 uint16으로 개수를, 카운트라는 걸 , 이렇게, 두 개를 만들어 줄 겁니다 이 데이터만 채워 준 다음에는 복사할 필요 없이 시작 주소의 개수를 알고 있으니까 그냥 배열처럼 똑같이 활용할 수 있다는 얘기가 되는 거죠 , 자, 그래서 생성자는 요렇게 만들어 줄 것이고 생성자에서 데이터는 널로 밀어주고 그 다음에 카운트는 0개짜리로 만들어 줄 것이고 그 다음에 두번째 생성자 같은 경우에는 정보를 채워가지고 시작 주소랑 그 다음에 카운트를 각각 입력을 해서 받아주도록 할게요 그러면 데이터를 넣어주고 카운트도 넣어주는 식으로 , 자, 요렇게 , 일단은, 만들어 줄 수가 있겠죠 이걸 좀 당겨서 보여드리도록 할게요 요런 느낌으로 그 다음에 요기서 이제 그냥 우리가 벡터를 사용하듯 이 괄호 오퍼레이터를 , 이렇게, 지원을 해줘가지고 인덱스에 대해서 꺼내 쓴다고 하면은 그냥 이런 식으로 막바로 데이터에 대해서 인덱스 번호를 건네주면 되겠습니다. , 자, 근데 혹시라도 오버플로우 체크를 하고 싶다고 하면은 여기다가 어세트 크래쉬를 넣어줘가지고 인덱스가 정말로 카운트보다 작은지를 안전하게 체크를 해주면 되겠죠. , 자, 이렇게, 일단은, 만들어주면 되겠습니다. 그리고 혹시라도 밖에서 궁금해한다고 하면은 뭐 카운트라거나 사이즈라거나 하는 이름으로 얘를 이제 뭐 뱉어주면 되겠습니다. 요렇게 , 일단은, 간단하게 패킷 리스트라는 걸 하나를 설계를 해봤어요. , 자, 그러면 이제 이거를 어떻게 응용할 수 있냐면은 우리의 패킷 S 테스트에 가가지고 얘도 마찬가지로 지금 여기 있는 데이터를 꺼내 쓰지 않고 그냥 버퍼에 있는 내용을 그냥 PKS 테스트로 인지해 가지고 사용을 했던 것처럼 여기 있는 내용들도 그냥 우리가 간단하게 패킷 리스트라는 걸 뱉어 줘 가지고 이런 일종의 배열, 벡터 같은 느낌으로 뱉어 줘 가지고 그냥 알아서 꺼내 쓸 수 있게 만들어 주도록 할 것 같습니다. 실제로 데이터를 복사하는 개념은 당연히 아니고 그냥 포인터로 그냥 얘를 바라보고 있는 상황이죠 다만 안전하게 개수는 체크해 가지고 오버플로우 해서 넘어가서 사용하지 않도록 얘만 이제 따로 넣어 줬다고 보시면 되겠습니다 사용 예제를 보여드리자면 이제는 어떻게 되냐면은 우선은 버프 리스트라는 거를 버프 리스트라는 거를 정의를 해줄 건데 요 아이는 패킷 리스트에 pkst 테스트의 버프리스트 아이템을 들고 있는 애다 , 사실, 요 타임레인 t가 , 사실, 데이터가 되는 거죠 요 데이터 자체가 요런 타입인데 그 리스트를 우리가 버프리스트라고 , 일단은, 명명하겠다라고 한 겁니다 그럼 이제 여기서 만약에 이 버프리스트라는 거를 어... 버프리스트 아 여기 s를 하나 넣어줄까요? 이름 컨벤션을 맞추기 위해서 이 버프리스트라는 걸 만약에 얘가 요청을 한다 나 리스트를 사용하고 싶은데 이 리스트를 이제 알고 싶어 라고 하면은 이제 주소 계산을 해주면 되겠죠 우선은 주소 계산을 하기 위해서 보면은 요기 시작 주소를 기준으로 offset만큼을 더 해가지고 점프를 하면은 요 시작 주소가 되겠습니다 그러기 때문에 시작 주소는 우리가 그냥 디스포인터로 알 수 있다 보니까 요런 식으로 캐스팅을 해가지고 바이트 포인터로 , 일단은, 변환해서 계산을 쉽게 해준 다음에 여기다가 버퍼 옵셋만큼을 더해주면 되겠죠 바이트가 1바이트 짜리니까 우리가 더해준 크기만큼이 정확하게 더해지게 될 겁니다 그래서 일부러 바이트 포인터로 만들어 준 거고 그 다음에 이제 버프리스트를 만들어 가지고 얘를 , 이렇게, 뱉어 줄 건데 요 상황에서는 요 데이터를 다시 리인터프렛 캐스트를 통해 가지고 얘가 원하는 이 타입으로 바꿔주게 될 겁니다. pkstestbufflistitem 이라는 이 타입으로 , 이렇게, 일단은, 데이터를 넣어 줄 것이고 이게 이제 데이터라고 했었죠. 이 타입으로 데이터 포인터를 캐스팅해주고 그 다음에 버퍼 카운트는 몇 개 있냐 버프 카운트는 이걸로 우리가 알 수 있었죠. 그래서 , 이렇게, 일단은, 뱉어주면 되겠습니다. 그래서 내부적으로 데이터가 뭐 어마어마하게 많게 100개가 있었다고 해도 100개를 복사하는 게 아니라 그냥 간단하게 , 사실, 이 패킷 리스트라는 어떻게 보면 포인터 하나랑 유인트 16짜리 하나를 만들어 준 게 일단 다입니다 그래서 그거를 , 이렇게, 만들어 줘 가지고 뱉어 주면은 이제 , 이렇게, 배열을 사용하듯 알아서 데이터를 버프에 있는 내용을 실질적으로 꺼내 쓸 수 있게 된다는 얘기가 되겠습니다 그래서 이제 이거를 아래서 테스트를 해보자면 이제는 여기서 뭐 여기 있는 벡터를 만들어 가지고 활용하는 개념이 아니라 , 자, 얘를 날려주고 요렇게 이제 활용하는 거죠 PKT 에다가 바로 GetBufferList를 사용하겠다라고 해서 이제 이 리스트를 만들어 주게 될 거예요 그러면 이 리스트는 PKTSTest의 BuffList라는 타입으로 , 이렇게, 만들어지게 되겠죠 근데 여기서는 데이터가 당연히 절대로 복사된 게 아니고 그냥 우리가 , 이렇게, 다른 관점으로 얘를 바라본 것과 마찬가지로 그냥 이 포인터를 지금 , 이렇게, 가리키고 있는 상태로만 지금 만들어진 겁니다. 요 차이가 굉장히 중요해요. 즉 불필요한 복사를 없앴다라는 얘기가 되는 거죠. 그 다음에 이제 뭐 실질적으로 사용을 할 때는 요렇게 꺼냈을 필요도 없이 그냥 막바로 접근해서 이제 사용을 하면 됩니다. 그래가지고 요 코드만큼 버프 카운트도 심지어 이걸로 접근해도 되지만 이왕 만들어놨으니까 카운트 개만큼을 이용해가지고 , 이렇게, 순환을 해주면 된다는 얘기가 되는 거죠 그래서 이 버프에 오퍼레이터를 우리가 , 이렇게, 지원을 해줬기 때문에 얘도 그냥 이런 식으로 바로 접근해가지고 버프 타임이랑 리메인 타임을 사용할 수 있다라는 얘기가 되는 거고 실질적으로 잘 동작하는지 빌드를 해본 다음에 그 다음에 한 번 실행을 해보도록 할게요 , 자, 그러면 굉장히 놀랍게도 놀라운 게 아니라 어떻게 보면 당연한 거지만 정상적으로 데이터가 잘 출력이 된다는 걸 볼 수가 있습니다 , 자, 그래가지고 데이터를 꺼내 쓰기 위해서 임시 객체를 만들어가지고 복사하지 않고 그냥 곧이곧대로 버퍼에 있는 내용을 우리가 바로 사용하고 있다라는 게 굉장히 중요하다 여기서 밑줄을 한 10개를 긋고 싶은데 그래서 이 방법이 복사를 줄여줄 수 있다 보니까 굉장히 우월하다는 걸 알 수가 있는 거죠 이게 이제 Flat Buffer의 원리라고 볼 수가 있겠습니다 반면 Protobuf는 여전히 임시 객체를 만들기는 해요 근데 임시 객체를 만드는 게 당연히 성능상으로는 불리할 수 있겠지만 그것도 좀 장단점이 있는 게 그래도 어찌됐건 개발할 때는 임시 객체를 만들어 가지고 사용하는 게 훨씬 더 편리하다고 , 일단은, 볼 수가 있겠어요 , 자, 그래가지고 일단 , 이렇게, 만들어 봤고 그래서 write 하는 경우에도 마찬가지로 임시 객체를 만들어 가지고 그 내용을 토대로 데이터를 기입을 해도 되지만 다음 시간에 알아볼 거는 이제 버퍼에다가 바로 데이터를 꽂아 넣는 방법에 대해서도 알아볼 건데 이거는 리드하는 것보다는 조금 더 복잡하고 고려할 게 많아지긴 합니다 , 일단은, 이 리드에 대한 내용을 좀 마무리 짓기 위해서 , 자, 지금 요렇게 , 일단은, 꺼내 쓴 것 까지는 뭐 알겠는데 근데 조금 여기서 아쉬운 부분은 우리가 원래 벡터 같은 경우에는 좀 다양한 형식으로 얘를 활용할 수 있었죠 예를 들면은 뭐 , 이렇게, 이터레이터 방식으로 버프에 비긴을 접근하고 버프에 엔드까지 ㅂㅂ 이터레이터라고 한 다음에 cout을 제가 그냥 복붙하도록 할게요 뭐 요런 느낌으로 이터레이터를 접근해 가지고 아이디를 사용한다거나 리메인 타임도 사용한다거나 하는 부분도 우리가 활용할 수 있었고 그 다음에 뭐 예를 들면은 이런 식으로 range4라는 문법을 이용해가지고 이걸 버프라고 할까요? range4 문법을 이용해가지고 마찬가지로 버프 인포를 뭐 , 이렇게, 출력을 할 수도 있었습니다. 그래서 예를 들면 버프에 버프 아이디 한 칸 띄고 버프에 리메인 타임 엔드 라인 근데 당연히 얘겠지만 지금까지 우리가 지원한 거는 요 배열 문법만 지원하고 있기 때문에 아직 비기니랑 엔드랑 요 문법은 지금 지원을 하지 않습니다 근데 , 사실, 요 부분은 크게 어렵지 않아요 그냥 Begin이랑 End 이터레이터만 똑같이 인터페이스를 맞춰줘가지고 지원을 하게끔 유도를 해주면 됩니다 이건 이제 C++ 강의에서 STL을 다룰 때 우리가 Vector의 이터레이터랑 List의 이터레이터 실습을 해볼 때 비슷한 실습을 해봤는데 그거랑 거의 비슷한 느낌으로 일단 만들어주면 된다고 보시면 되겠어요 그래서 요 부분까지 일단 한번 해보도록 하겠습니다 , 자, 이제 이터레이터라는 개념이 추가가 될 건데 , 일단은, 데이터 타입과 그 다음에 컨테이너 타입을 템플릿으로 각각 , 이렇게, 받아주도록 하겠습니다. packet iterator 라고 , 일단은, 이름을 지어보도록 할게요. , 자, 그래서 여기서 컨테이너는 요렇게 들고 있을 것이고 그 다음에 이 이터레이터의 인덱스 내가 몇 번째 데이터인지를 인덱스로 일단 들고 있도록 하겠습니다. , 자, 그리고 여기서 Packet Iterator에 생성자를 만들어 줄 것인데 먼저 컨테이너를 받아 줄 것이고 그 다음에 인덱스도 받아 줄 겁니다 몇 번째 배열의 몇 번째 그니까 어떤 배열의 몇 번째 데이터 이다라고 일단 생각하시면 되겠어요 그래서 컨테이너는 여기다가 그대로 넣어주고 그 다음에 인덱스도 인덱스에다가 그대로 넣어주고 생성자는 , 이렇게, 닫아주면 되겠죠 , 자, 이렇게, 좀 보여드리도록 할게요 그 다음에 , 사실, 뭐 이게 끝입니다 여기서 이제 각종 오퍼레이터들을 다 지원을 해주면 돼요 필요한게 몇가지가 있는데 이 비교하는 연산을 , 일단은, 지원을 해줘야 되구요 그래서 다른 패켓 이터레이터랑 other랑 비교를 하겠다라고 할 때 다른 애랑 비교를 하기 위해서는 , 일단은, 인덱스가 같은지만 체크를 해주도록 합시다 요렇게 인덱스가 어 나의 인덱스와 상대방의 인덱스가 다른지만 , 이렇게, 만들어주면 되겠고요. 그 다음에 const t로 해가지고 접근하는 거 , 이렇게, 만들어 주도록 할게요. 데이터에 접근할 때 container index 그리고 복붙을 한 다음에 const를 제거한 버전도 , 이렇게, 하나를 만들어 주도록 하겠습니다. 그 다음에 당기기 위해서 이 화살표 오퍼레이션도 지원을 해줄 거고요 얘 같은 경우에는 컨테이너 인덱스에 조속값을 뱉어주면 되겠고 그 다음에 패킷 이터레이터 어 전위 후위 증감 연산을 이제 지원을 해줄 겁니다 뿔뿔 요렇게 오퍼레이터 뿔뿔 인덱스를 1 늘려주고 리턴 디스를 해주면 되겠고 얘가 이제 전위고 그 다음에 후위도 지원을 해주도록 할게요 후이는 복사를 해서 Operator++을 한 다음에 Int32를 받아줄 것이고 뭐 항상 , 이렇게, 만들었죠 우리가 지금까지 , 자, 이거는 뭐 C++ 파트1 세번 실습인데 인덱스 증가시키고 리턴을 , 이렇게, 해준다 그래서 여기까지 뭐 지원을 해주면 나머지 코드들은 알아서 다 동작을 하게 될 겁니다 좀 줄맞춤을 해주도록 할게요 요렇게 컨테이너도 한 이쯤 그래서 여기까지 , 일단은, 지원을 해주면 되고 , 자, 그 다음에 패킷 리스트를 활용을 할 때 여기서 range-based for 지원을 하기 위해서 패킷 이터레이터만 , 이렇게, 다시 사용을 해주게 만들어 주면 됩니다 패킷 리스트 컨테이너 타입은 패킷 리스트고 데이터 타입은 T고 그 다음에 begin 이라는 걸 만들어 줄 건데 begin 같은 경우에는 패킷 이터레이터를 만들어 주고 요걸 이제 똑같이 만들어 줍니다 T타입에 패킷 리스트 T 얘가 컨테이너 타입이고 자기 자신 컨테이너를 , 일단은, 건네주는데 자기 자신을 넘겨주면 되고 시작 인덱스는 0번이 비긴이 될 것입니다 그 다음에 복붙 컨트롤 뒤로 복붙한 다음에 엔드 같은 경우에는 이제 요게다가 마지막에다가 카운트를 넣어 줘 가지고 구분을 해주게 될 거예요 begin, end 까지 지원을 해주면 된다는 거죠. 그래서 실질적으로 요 내부 코드가 이제 진행하는 걸 보면은 begin 이라는 이터레이터를 꺼낸 다음에 ㅂㅂ 을 해가지고 하나씩 하나씩 순회하게 될 겁니다. 그 ㅂㅂ 이라는 거는 우리가 여기다가 지원을 하게끔 만들어놨죠. 그래가지고 이터레이터랑 엔드랑 같은지 아닌지를 계속 체크할 것인데 이 같은 조건이라 하면 다르다는 조건이라 하면 결국 이 조건을 체크해가지고 인덱스가 같아질 때까지 계속 테스트를 한다 이거죠 그래서 이 조건에 의해가지고 엔드랑 엔드의 인덱스랑 이 인덱스랑 다를 때까지 계속 순회를 하면서 이제 데이터를 이 화살표로 땡겨 쓸 것이고 화살표는 우리가 여기서 지원을 해주고 있으니까 얘도 통과되고 그 다음에 이 4레인지 같은 경우에는 여기 비긴 엔드랑 그리고 나머지 이런 오퍼레이터를 다 지원하면은 자동으로 다 동작을 하게 됩니다 그래서 여기까지 , 일단은, 잘 동작하는지 , 일단은, 빌드를 한번 해 보도록 할게요 , 자, 그럼 , 일단은, 문제가 없어졌으니까 똑같이 실행을 하면은 요 버전이나 요 버전이나 요 버전이나 삼총사를 다 활용을 할 수 있다는 얘기가 되는 거고 실제로 데이터가 잘 출력이 되는지 보도록 할게요 , 자, 그러면은 데이터가 지금 , 이렇게, 뜨고 있는데 3개의 값이 다 똑같이 지금 뜨고 있다는 것도 볼 수가 있습니다 , 자, 이렇게, 해가지고 오늘 뭐 굉장히 재밌는 실습을 해봤는데 결국에는 지금까지 시리얼라이스를 해가지고 데이터를 밀어 넣은 다음에 걔를 꺼내 쓰기 위해서 역증열화를 해가지고 꺼내 쓰는 것 자체가 , 사실, 꼭 필수적인 사항은 아니었다 그냥 우리가 버퍼에 있는 내용을 그냥 고지곳대로 분석해가지고 사용을 할 수 있다는 굉장히 놀라운 사실에 대해서 알아봤고 만약에 이 방식을 채택한다고 하면은 복사 비용을 한번 아낄 수 있다는 굉장히 큰 차이가 생기게 된다라는 것까지도 , 일단은, 이해를 해주시면 되겠습니다 , 자, 이렇게, 해가지고 요 부분에 대해서 알아봤으니까 이제 다음 시간에는 거꾸로 요런 방식으로 임시적인 객체를 만들어 가지고 그 다음에 버퍼에다가 밀어 넣는 식이 아니라 그냥 막바로 데이터를 버퍼에다가 한 번에 밀어 넣는 그런 방법에 대해서 , 일단은, 실습을 해 보도록 할게요 , 자, 이렇게, 해서 패키징 열와 제 2탄에 대해서도 간단하게 마치도록 하겠습니다.