자, 이제 지난 시간에 이어가지고 이번 시간도 락 프리 스택에 대한 내용에 대해서 조금 더 알아볼 건데요 여기 락 프리 스택을 만들 때 우리가 지난번에 , 이렇게, 팝카운트라는 걸 추적을 해가지고 만드는 방법을 채택을 했는데 지난번에도 얼핏 말씀을 드렸지만 , 사실, 이 부분은 굉장히 다양한 그런 방법들이 존재합니다 그래가지고 이제 오늘 사용할 방법은 조금 더 다른 방법에 대해서 , 일단은, 공부를 해보는 그런 시간을 가져보도록 할 건데요 , 일단은, 좀 필요없는 주석을 잠시 날려보고 일단 지난번에 이 내용에 대해서 살펴보다가 혹시 느끼셨는지 모르겠지만 제가 여기서 삭제를 하는 부분에 대해서 말씀을 드릴 때 이게 만약에 C샵이나 자바 같은 경우라고 한다면 걱정할 필요 없이 그냥 여기서 끝난다고 했습니다 왜냐면 애당초 C샵이나 자바 같은 경우는 GC가 애당초 계속 돌면서 가베지 컬렉터라는 애가 계속 돌면서 메모리가 이제 해제되도 되는지를 걔가 알아서 체크하기 할 것이기 때문에 우리가 신경 쓸 필요가 없었다고 했었죠 , 자, 그런데 그 얘기를 들으면 바로 생각이 나는게 어 그러면은 , 이렇게, 포인터를 생 포인터를 사용하는 게 아니라 스마트 포인터를 사용하면은 약간 C샵 같은 느낌으로 이 코드를 바꿀 수 있지 않을까 라는 생각에서 일단 이번 강의를 시작을 해보도록 할게요 그래서 그게 어느정도 일리가 있는 얘긴데요 이제 기존에 했던 요 부분들을 스마트 포인터 기반으로 , 일단은, 한번 바꿔보고 그 다음에 일어나는 문제에 대해서 한번 언급을 해보도록 하겠습니다 , 자, 여기서 Shared 포인터로 이제 사용하도록 그냥 생 포인터를 사용하지 않도록 , 자, 이런식으로 데이터도 포인터로 노드도 포인터로 다 관리를 한다고 가정해볼게요 그럼 여기서 Value를 받았을 때 이제는 Make Shared를 통해 가지고 Smart 포인터를 , 이렇게, 만들어주면 되겠죠 Value를 넣어주고 그 다음에 어 , 자, 이제 트라이팝은 요 부분은 좀 삭제를 하고 , 자, 여기서 이제 다시 시작을 해볼 건데 요게 아토믹으로 되어있는 요 부분을 우리가 아토믹이 아니라 쉐어드 포인트로 바꿔치기를 해보도록 할게요 요런 느낌으로 , 자, 그래서 , 사실, 뭐 하는 방법은 거의 비슷한데 이제 얘가 Shared Pointer로 바뀌었다라는 차이가 생기게 되는 겁니다 , 자, 그래가지고 그 다음으로 이제 알아볼 거는 Push부터 다시 시작을 해볼 건데 요 부분이 이제는 원래 Node를 요런 식으로 만들었던 부분이 Shared PTR로 만들도록 바꿔치기를 해주면 되겠죠 이런 식으로 Make Shared를 해준 다음에 여기다가 Node를 만들어주게끔 유도를 해주면 되겠습니다 그 다음에 여기서 헤드도 끌고 와가지고 여기다가 뭐 저장을 하고 있고요 그 다음에 얘가 이 헤드값을 넣는 순간에 누군가가 또 새치기를 할 수 있으니까 얘를 여기서 끝내는 게 아니라 컴퍼니 수업을 해가지고 계속 뺑뺑이를 돌면서 시도를 하는 걸 알 수가 있는데 근데 이 컴퍼니 엑스체인지 같은 거는 일단 아토믹이라는 클래스에 들어가 있었던 거지 여기 자체는 일단 들어가 있지 않습니다 그러다 보니까 이걸로 이제 뭐 빌드하려고 하면은 당연한 얘기지만 뭐 이제 에러가 날 거예요 여기서 그럼 이걸 사용할 수 없느냐? 그건 아니구요. 여기서도 다양한 버전들이 있습니다. 예를 들면 Atomic Compare Exchange Week라는 버전을 사용하시면 , 사실, 이 아래 버전이랑 거의 비슷한데 여기 처음에 있던 이 head라는 애가 안에 첫번째 인자로 들어가게 된다는 차이가 생겨요. 그래서 요런 느낌으로 head를 먼저 넣어주고 그 다음에 node-next에 주소를 넣어주고 그 다음에 node를 넣어주고 이런 식으로 만들어주면 , 사실, 뭐 의미적으로는 똑같은 얘기가 됩니다. 그래서 방금 요 코드를 이제 요렇게 바꿔치기를 하면은 기존과 마찬가지로 이 헤드값을 추출한 다음에 내가 진짜로 얘를 차지해도 되는지를 , 이렇게, 루안 루프를 돌면서 계속 체키를 하고 있죠. 그래가지고 결국에는 내가 예상한 이 노드 넥스트 값을 갖고 있는 애가 승자가 되어가지고 이 헤드를 쟁취한 애가 실질적으로 헤드에 들어가는 코드가 , 이렇게, 만들어지게 된다고 보시면 되겠습니다. 그 다음에 이 트라이팝 같은 경우에는 이제 Boolean을 리턴하기보다 어차피 Shared Pointer로 바꿔준다고 했으니까 얘도 이런 식으로 바꿔줄 수가 있겠죠. 예를 들면 데이터도 만약에 Shared Pointer로 관리한다고 하면 트라이팝을 아예 한 번에 Shared Pointer로 뱉어주게 만들어줄 수 있습니다. 물론 기존과 마찬가지로 Boolean과 value의 레퍼런스로 반환해줘도 똑같은 얘기고요 근데 좀 기분 전환 겸 , 이렇게, 일단 바꿔보도록 할게요 그러면은 여기서도 마찬가지로 shared-btr에서 원래 했던 로직이랑 굉장히 비슷하게 여기서 이제 헤드를 꺼내와야 되는데 여기서 이제 한가지 좀 위험한 부분은 뭐냐면요 이 헤드라는 거를 꺼내 오는 것 까지는 좋은데 이 팝을 하는 순간 이 헤드를 꺼내올 때 이 헤드라는 것 자체가 아톰이 하지 않기 때문에 원래는 여기서 누군가가 얘를 참조할 때 레퍼런스 카운트를 1 증가시키고 그 다음에 누군가가 이제 나를 참조하지 않을 때 레퍼런스 카운트를 1 감소시키는 게 원래 이제 셰어드 포인터의 동작 방식입니다 근데 셔드 포인터가 레퍼런스 카운트를 줄이고 늘리고 그 다음에 자기 자신을 반환하고 하는 부분들이 원자적으로 일어나지 않기 때문에 , 이렇게, 고지곳대로 꺼내오면 문제가 일어날 수가 있어요 그래서 얘도 반드시 아토믹 버전으로 이런 식으로 만들어 놔야 됩니다 그래가지고 레퍼런스를 늘리는 거랑 줄이는 거랑 그리고 꺼내오는 거를 한 번에 해야 된다고 보시면 되겠습니다 네 그리고 뭐 그 다음에 이제 알아볼 거는 결국에는 여기서 올드 헤드를 하고 있는데 여기서 마찬가지로 atomic compare exchange week를 , 이렇게, 사용할 것이고 여기다가는 헤드의 값에다가 그 다음에 올드 헤드를 넣어주고 올드 헤드의 next를 , 이렇게, 넣어주는 방식으로 만들어준 다음에 만약에 올드 헤드가 똘 포인터라고 하면은 값이 없다는 얘기가 되는 거니까 셰어드 포인터를 그냥 빈채로 반환해주고 그게 아니라고 하면 올드 헤드에다가 데이터를 꺼내오는 식으로 일단 만들어줄 수가 있겠습니다 간략하게 만들어 보면 이런 느낌으로 만들어지게 되겠죠 그래서 얘를 이제 실행하기 위해서는 요 부분이 바뀌어야 되는데 이제 데이터를 받는 게 아니라 데이터를 요렇게 받아주는 식으로 , 자, 이런식으로 바꿔치기를 해주면 되겠죠 그래서 만약에 데이터가 널 포인터가 아니다 널이 아니다 라고 하면은 뭐 기존과 마찬가지로 출력을 할 거라고 하면은 데이터를 뭐 꺼내 가지고 시앤드 포인트에서 값을 꺼내 가지고 뭔가 사용하게끔 유도를 해줄 수가 있을 겁니다 뭐 요런 느낌으로 , 일단은, 만들어 볼 수가 있을 거에요 아 그리고 하다보니까 한가지 누락을 했는데 요게 아토믹 로드를 하는거와 마찬가지로 이 위에도 그냥 꺼내오면 안되고 , 이렇게, 아토믹 로드 버전으로 만들어줘야 됩니다 꺼내올 때 레퍼런스 카운트를 1 증가시킨 상태에서 그 해당 포인터를 요게다가 , 이렇게, 건네줘야 된다는 얘기되는거죠 만약에 고질고때로 아까처럼 헤드를 꺼내오려고 하면은 얘를 , 이렇게, 복사해가지고 꺼내오는 그 순간에 누군가가 이제 걔를 더 이상 사용하지 않아가지고 레퍼런스 카운트가 줄어들면서 그 메모리가 날라갈 수 있는 문제가 생기게 됩니다 그래서 뭐 , 이렇게, 바꿔치기를 하면은 어찌됐건 쉐도우 포인터를 이용해가지고 요렇게 , 일단은, 만들어 줄 수가 있기는 해요 그래서 얘를 실행해보면 , 일단은, 별다른 문제 없이 실행이 되고 있고요. 물론 메모리가 너무 늘어나는 것은 우리가 코드에서 자비없이 , 이렇게, 무한 루프를 돌면서 푸쉬를 하고 있기 때문에 얘가 훨씬 더 빨리 처리되고 있죠. 얘는 씨아웃을 하는 것도 아니니까. 그래가지고 발생한 문제고. 그렇게 해서 일단 만들 수가 있을 겁니다. 근데 여기서 이제 한 가지 문제는 뭐냐면은 NC 당초 우리가 이 만든 Shadow Pointer가 Lock Free 방식으로 동작한다는 보장이 전혀 없습니다. 뭐 이건 당연히 이제 뭐 여러분들이 하드웨어나 머신에 따라서 다를 수가 있긴 하지만 이거를 체크하기 위해서는 어 여기다가 이제 간단하게 Shadow Pointer를 뭐 아무거나 하나를 , 이렇게, 만들어 본 다음에 뭐 BT 하려고 할까요? 그 다음에 Atomic is Lock Free라는 걸 이용해 가지고 얘를 테스트를 해보면 됩니다. 근데 뭐 대부분의 상황에서는 얘가 락프리가 아닌 방식으로 출력이 될 겁니다 그렇다는 것은 우리가 지금까지 굉장히 복잡한 짓거리를 하고 있는 게 락프리 프로그래밍을 연습하기 위해서 하고 있는 것인데 이 셰어드 포인터가 락프리 방식으로 동작 안 한다고 하면 , 사실, 이 방식으로 처리하는 의미가 없게 되겠죠 그래가지고 , 일단은, 이건 동작하는 것까지는 알았는데 락프리 방식은 엄밀히 말해서 아니다 그러니까 우리가 여기서 락프리 스택이라고 했는데 , 사실, 거짓말을 하고 있다라는 걸 일단 알 수가 있는 겁니다 , 자, 그래가지고 요런 비슷한 느낌으로 뭔가 노드에 레퍼런스를 카운팅을 해 줘 가지고 우리가 수동으로 이제 만들어 주면은 어찌됐건 락프리를 이제 구현할 수 있다는 얘기가 드는 건데 이 부분은 잠시 주석을 처리함과 동시에 복붙해 가지고 다시 한번 만들어 보도록 할게요 이건 이제 여러분들이 혹시라도 궁금하실 수도 있으니까 이 코드는 그대로 남겨 두도록 할 거고 이제 이 Shadow Pointer를 사용하는 게 아니라 실질적으로 레퍼런스 카운팅을 우리가 직접 구현하는 방식으로 하나를 더 만들어 볼 거예요 그래서 이걸 하기 위해서 사실은 이 Shadow Pointer를 바꿔준 버전으로 만들고 있었던 거고요 이 버전은 이제 조금 다른데 이해하기가 처음에는 좀 어렵습니다 이게 Lock Free 프로그래밍이 대부분 이해하기가 굉장히 까다로운 부분이 있어요 그리고 여러분들이 아직까지는 이 락3에 대한 별 생각이 없을 수 있지만 이런 걸 공부하면 할수록 락 방식이 훨씬 낫다는 생각이 들 수가 있습니다 약간 경고 삼아 말씀을 드리는 거고 , 자, 일단은, 오늘 만들어 볼 아이는 , 이렇게, 만들어 보면 되겠어요 일단 Counted Node PTR이라고 해가지고 그냥 일반적인 포인터가 아니라 뭔가 내부적으로 참조 횟수를 같이 세는 포인터가 있다고 가정을 해볼게요 그래가지고 요렇게 스트럭트를 하나 만들어줄건데 포인터와 더불어서 여기서 external count라고 해가지고 말그대로 참조 횟수를 요렇게 관리를 해주게 될겁니다 , 자, 그리고 여기서 Node를 사용하고 있는데 이 Node는 아래에 등장하고 있기 때문에 일단 잠시 Node를 , 이렇게, 전방선을 처리를 해줄 것이고요. 그 다음에 여기서 이제 Node 같은 경우에는 얘가 일단 데이터를 , 이렇게, 받고 있고 그 다음에 여기다가 AtomicInt32로 InternalCount를 또 , 이렇게, 받아주도록 하겠습니다. 이 카운트가 두 개가 등장하는데 이 두 개의 의미는 이어서 코드에서 등장할 테니까 지금 당장 잊으셔도 되고요. 원래 , 이렇게, Shadow Pointer를 관리를 하던 것을 Shadow Pointer가 아니라 Counted Node PTR라고 우리가 만든 이 Struct를 이용해서 관리를 해주게 될 겁니다. 얘가 의도하는 바는 결국에는 포인터와 포인터 참조 횟수를 , 이렇게, 관리한다가 일단 핵심이 되겠어요. , 자, 그래가지고 뭐 나머지 부분은 , 일단은, 건드릴 필요가 없을 것 같구요 , 자, 여기 얘는 삭제를 해주고 그래서 , 이렇게, 노드가 지금 정리가 된 상태라고 볼 수 있는 거죠 , 자, 그 다음에 어 푸쉬랑 팝을 날려버리고 이제 새로운 마음으로 다시 작성을 해줄 것인데 , 일단은, 여기 헤드는 셰어더 포인터가 아니라 얘는 아토믹 타입의 카운트 노드 PTR로 , 이렇게, 만들어 주도록 하겠습니다. 이 우리가 만들어 준 카운티드 노드 PTR이 지금 요 아이인데 얘를 아토믹 타입으로 넣어준 상태라고 보시면 되겠어요. 그래서 결국에는 이 포인터와 참조 횟수를 이제 아토믹하게 우리가 관리하겠다라는게 우리 아이디어고 물론 여러분들의 환경에서 얘가 진짜로 락프립 방식으로 동작하지 않을지는 또 체크를 해봐야 되겠지만 설령 얘가 한 번에 락프립 방식으로 처리가 되지 않는다고 해도 , 일단은, 나중에 가서 고칠 방법이 있습니다. 포인터가 우리 일반적으로 64비트 환경에서 지금 얘가 지금 64 비트를 차지하고 있고 그 다음에 얘가 32 비트로 이루어져 있기는 하지만 이 포인터라는 주소 자체를 꼭 64 비트를 다 활용할 필요는 없습니다. 여러분들의 환경에 따라가지고 실질적으로 주소를 표기할 때 48 비트만 사용하는 경우도 있을 거예요. 뭐 그런 경우라고 한다면은 얘를 인트 16으로 바꿔주고 얘를 48개짜리를 차지하는 그런 인트로 바꿔줘가지고 잘 합쳐가지고 결국에는 얘가 뭐 인트64로 하나로 표현하게끔 유도를 한다고 하는 다양한 방식으로 얘를 이제 뭐 낑겨 넣을 수 있기 때문에 , 일단은, 얘는 락프리 방식으로 한 번에 이뤄질 수 있다고 가정을 하고 코드를 진행을 해보도록 할게요 네 그래가지고 요렇게 일단 만들어주도록 하구요 그래서 이제 락프리 프로그램을 할 때는 굉장히 꼼수가 많이 들어가게 됩니다 요런 식으로 뭐 여러가지 꼼수가 들어가게 되는 거고 어 그 다음에 이제 뭐 푸쉬를 푸쉬부터 , 일단은, 만들어 볼 건데 , 자, 이제 코드를 여기서 만들어 보도록 할게요 , 일단은, 얘가 하는 방식은 굉장히 간단한데 카운티드 노드 PTR 이라는 걸 , 이렇게, 만들어 준 다음에 노드를 그냥 직접 , 이렇게, 만들어 줍니다. 밸류를 넣어가지고 값을 넣어주고 그 다음에 엑스터널 카운트를 처음에는 1로 초기화를 해줄 거에요. , 자, 여기까지는 스택 메모리에다가 자기가 멋대로 그냥 만들어 준 부분이기 때문에 아무런 문제 없이 멀티 세도 환경에서 문제 없죠. 근데 여기부터 이제 살짝 위험해지기 시작합니다. 이제 얘를 여기에다가 바꿔치기를 해주게 될 거예요. 애당초 우리가 스택이라는 것 자체가 이런 식으로 데이터가 막 여러 개로 이루어지는 거에다가 헤드라는 애가 첫 번째 애를 가리키는 상태라고 했었죠. 그래서 우리가 이 첫 번째 노드를 만들어 준 다음에 이제 이걸 헤드에다가 넣어 주려고 시도를 할 텐데 근데 이 상황에서 우리가 정말로 경합을 이겨내고 맨 먼저 얘를 선점한다는 보장이 없기 때문에 역시나 여기부터는 컴페인 스왑으로 작성을 해야 됩니다 그래서 우리가 원하는 바는 여기 헤드에 있는 값을 꺼내 가지고 , 이렇게, 넥스트에다가 넣어주는 이거를 지금 테스트를 해볼 것이고 그 다음에 얘를 꺼내 온 다음에 우리가 이 헤드에 있는 값을 우리가 원하는 이 노드로 바꿔치기를 해줘야 되겠죠. 그러니까 새로 만든 노드를 만들어 준 다음에 그 노드가 이 헤드로 , 이렇게, 바꿔치기가 되게끔 유도를 해줘야 됩니다. 그래가지고 원래 있던 헤드를 우리가 새로 만든 요 노드에 넥스트로 , 이렇게, 연결해줬고 그 다음에 얘를 여기다가 , 이렇게, 갖다 넣는 식으로 작업을 해주면 될 거예요 하지만 이게 역시나 한 번에 실행은 된다는 보증이 없으니까 루프를 계속 돌면서 head.compareExchangeWeek를 통해 가지고 우리가 원하는 값이 성공할 때까지 얘를 트라이를 한다고 보시면 되겠습니다. next, node 그리고 first , 자, 요 패턴은 이제 굉장히 자주 나왔으니까 뭐 더 이상 설명을 안 드려도 이제 어느 정도 이해하실 것 같고 요 부분을 이게 만약에 우리가 처음에 여기까지 넣어준 값에서 변함이 없었다, 다른 애들이 건드린 적이 없었다고 하면은 이제 얘가 성공을 해가지고 빠져나오게 될 것이고 그게 아니라고 한다면 다시 얘를 성공할 때까지 계속 트라이를 하는 그런 부분이 되겠습니다. 그래서 경합을 통해가지고 내가 노드를 넣어주겠다라는 부분이 들어가는 거고 여기까지는 굉장히 간단합니다. 왜냐면 우리가 이제 이 카운트를 초기와 초기 값인 1로만 , 이렇게, 세팅을 해주고 여기서 경합이 일어나지 않기 때문에 대부분 푸쉬 같은 경우는 굉장히 단순해요. 그러니까 이 스택 기준으로 푸쉬는 뭐 항상 이제까지 크게 어려운 점이 없었고 이제 팝이 항상 어려웠었죠. 그래가지고 이제 돌아가가지고 팝을 이어서 만들어 볼 건데 여기부터 이제 머리가 좀 복잡해지기 시작합니다. , 자, 코드를 보고 조금씩 이제 생각을 해보시면 되는데 맨 먼저 할 거는 여기 헤드에 있는 값을 꺼내 올 겁니다 , 자, 여기서 다시 한번 그림을 그려보자면 지금 헤드에 가리키고 있는 이 값이 하나가 있을 텐데 걔를 여기다가 올드에다가 , 일단은, 꺼내 왔어요 그럼 얘가 , 일단은, 올드 헤드라는 것 자체가 사실은 어떤 포인터에다가 실질적으로 나를 그 노드를 참조하고 있는 애의 카운트를 , 이렇게, 같이 지금 관리를 하고 있는 그런 개념이었었죠 네, 그런다 보니까 어... 이거를 내가 사용하겠다라고 할 때 얘를 그냥 이렇게만 꺼내온다고 무조건 100% 확률을 사용할 수 있는 건 아니고 이제 선점폭을 해야 됩니다 , 자, 이게 무슨 느낌이냐면은 그래가지고 여기서 이제 무한 루프를 돌면서 , 일단은, 참조권 이건 제가 이제 부른 이름이에요 참조권을 , 일단은, 획득을 하기 위해서 노력을 해야 되는데 은행에서 번호표를 뽑아주죠 은행에서 , 이렇게, 대기를 탈 때 어, 기계에다가 뭔가 번호표를 딱 뽑으면은 63번 이런식으로 나만의 번호가 나와가지고 63번에 해당하는 번호가 불려지면 가는 식으로 그렇게 만들어지게 되겠습니다. 그래서 얘도 이제 마찬가지로 번호표를 받아가지고 접근을 할 수 있게끔 이 올드헤드를 그냥 꺼낸 다음에 이제 사용하는게 아니라 내가 얘를 사용하겠다라고 , 일단은, 한번 확인을 받아야 되는데 그 부분이 여기서 , 이렇게, 됩니다. , 자, 여기서 increase 헤드 카운트라는 함수를 우리가 만들어가지고 여기다가 올드 헤드를 넣어주게 될 건데 이 함수부터 이어서 만들어 보도록 할게요 , 자, 바로 아래다가 만들어 줄 것인데 increase head count 라고 해가지고 이 노드를 , 이렇게, 받아줘 가지고 결국 얘가 해야 되는 거는 이 카운터에다가 1을 증가시켜야 됩니다. , 자, 여기서도 머리가 굉장히 아플 겁니다. 미리 경고를 드리지만 그래가지고 일단 코드를 살짝 보면은 새로운 카운터를 , 이렇게, 만들어 줄 것인데 이 카운터라 함은 무엇이었냐면은 결국 포인터 더하기 횟수를 같이 1 플러스 1으로 포함하고 있는 애였죠. 그래가지고 이 포인터는 변함없이 얘가 사용할 것인데 내가 이 번호표를 뽑아왔다는 거는 결국에는 내가 카운트를 사용하겠다고 카운트를 1 늘려야 되는 상황이 된 겁니다. 그래서 결국에는 이 새로운 카운터가 엑스터널 카운트를 1 증가시킨 값으로 바꿔치기를 해야 된다는 얘기가 드는 건데 여기서 문제는 뭐냐면 내가 얘를 갖고 온 다음에 카운트를 1 증가시키는 이 상황에서도 누군가가 끼어들어가지고 이 똑같은 코드를 또 실행할 수 있기 때문에 얘가 100% 확률로 성공한다는 보전이 없습니다. 지금까지는 이 노드를 사용하는 횟수가 예를 들면 3이라고 가정을 했을 때 이제 그 다음 숫자인 4로 , 이렇게, 바꿔치기를 하는 애가 승자가 된다는 얘기가 되는 거죠 어떻게 보면 약간 눈치 게임 같은 느낌인데 그래가지고 여기서 여기도 마찬가지로 헤드에다가 컴팩트 엑스체인지 스트렁을 해보도록 할게요 , 자, 여기서는 이제 무한 루프를 이 안에서 얘를 와일리를 하지 않기 때문에 스트렁 버전으로 , 이렇게, 만들어놨고요 그 다음에 여기다가 올드 카운터 뉴 카운터를 , 이렇게, 넣어주게 될 겁니다 만약에 성공했으면 빠져나가라고 , 이렇게, 만들어주면 되겠어요 이게 어떤 의미냐면 결국에는 이 코드가 이제 락프리 프로그램을 많이 하다보면 이런 코드를 잘 읽을 줄 알아야 되는데 우리가 처음에 헤드의 값을 꺼내왔죠 근데 여기서는 아직 이 포인터는 똑같은 값이지만 ExternalCount는 원래 있던 그 값을 그대로 꺼내온 것이고 여기다가 내가 이 참조권을 획득하겠다라고 지금 선포를 하기 위해서 이 카운터를 1 증가시킨 값으로 여기다가 다시 바꿔치기를 해줘야 됩니다 그게 이제 우리의 미션인데 근데 , 이렇게, 고지곳대로 엑스터널 카운트를 증가시킨 다음에 헤드에 넣을 수는 없는게 이게 멀티스레드 환경이다 보니까 동시다발적으로 일어날 수 있어가지고 요 부분에서 경합이 일어날 수 있기 때문에 , 이렇게, 무한 루프를 돌면서 성공할 때까지 시도를 하는 거라고 보시면 되겠습니다 내가 운 좋게 1바로 , 이렇게, 이걸 한 번에 실행할 수 있다고 하면은 이제 내가 이 포인터를 참조할 수 있는 권한이 생긴 셈이라고 볼 수 있는 거죠 , 자, 그래가지고 여기서 다시 올드 카운터에 엑스터널 카운트를 이제 최종적으로 여기까지 왔으면 이제 안전하게 얘를 사용할 수 있다라고 , 이렇게, 바꿔치기를 해주면 되겠어요 그래서 헤드에다가 안전하게 우리가 그 원하는 값으로 넣어놨으니까 그 값을 다시 꺼내 가지고 여기다가 이제 올드 헤드에다가 넣어서 이제 사용을 하는 거라고 보시면 되겠습니다 말 그대로 일종의 번호표라고 볼 수가 있는 거죠 그래서 이 엑스터널 카운트라는 것 자체가 계속 늘어나기만 할 거예요 이게 1부터 시작을 해 가지고 1 2 3 4 5 6 7 8 9 10 이런 식으로 늘어나기만 하고 얘를 다 사용을 했다고 해더라도 이 카운터를 줄이지는 않을 겁니다 그러니까 예를 들면 우리가 은행에 가서 번호표를 받을 때도 1, 2, 3, 4, 5, 6, 7, 8, 9 이런 식으로 늘어나긴 하지만 10번을 받은 사람이 볼일을 보고 나간다고 하더라도 갑자기 그 다음 순번이 9번으로 줄어들지는 않죠 괜히 9번으로 줄어들었다가 번호가 겹치고 꼬이는 문제가 발생할 수도 있으니까 그렇게나 하진 않고 항상 번호가 늘어나는 방향으로만 , 일단은, 증가하는데 그런 느낌이라고 보시면 되겠습니다 그래서 무조건 현재 카운트에서 늘리는 쪽으로 그 다음 1을 늘려가지고 얘를 넣어주는 사람이 획득할 수 있다가 일단 여기까지 , 일단은, 로직이라고 보시면 되겠어요 굉장히 복잡하죠? 그래서 여기까지 , 일단은, increase head count까지 통과했으면 결국에는 최소한 external count가 지금 2보다 큰 상태겠죠? 처음에 우리가 1로 세팅했고 거기다가 1을 늘려놨으니까 최소한 2보다는 클테니까 일단 이 노드는 삭제하면 안되고 내가 안전하게 접근할 수 있는 그런 상태가 되었다고 보시면 되겠습니다 말 그대로 내가 참조할 수 있는 권한을 획득했다라고 볼 수가 있는 거죠 그럼 여기에다가 이제 이런 식으로 PTR을 꺼내 가지고 이제 이걸 이용해 가지고 작업을 할 건데 먼저 체크할 것은 데이터가 있는지를 먼저 체크를 해볼겁니다. 데이터가 없으면은 뭐 볼 것도 없이 그냥 데이터가 없는 거니까 뭐 별걸 할 필요는 없고 여기다가 그냥 리턴을 그냥 때려주도록 할게요. 근데 그 다음에 데이터가 있다고 하면은 , 자, 이제 그 데이터를 꺼내 가지고 반환을 하기는 해야 되는데 여기서도 또 문제가 되는 게 뭐냐면은 이 참조권까지는 획득하는 건 굉장히 아름다운데 참조권을 또 여러 명이 획득할 수가 있어요 왜냐면은 같은 포인터를 대상으로 지금 참조권을 획득해 가지고 여기까지 넘어왔다고 하면은 이 PTR을 동일한 애들이 지금 얘를 사용할 수 있다는 얘기가 되는 거죠 그래가지고 결국에는 두 번째로 해야 되는 건 뭐냐면은 이제는 또 소유권을 획득을 해야 합니다 이것도 제가 지은 용어입니다 이게 뭐 공식 용어 같은 건 아니에요 그래서 이 소유권을 이제 획득하기 위해서는 결국에는 ptr next로 헤드를 바꿔치기 한 애가 일단 이기는 상황입니다 참조로 참조권 같은 요 아이 같은 경우는 external count를 현 시점 기준 플러스 1 한 애가 이기는 그런 상황이었었죠 그래서 이제 여기서 또 경합을 해가지고 내가 소유권을 획득할 건데 이 소유권 획득은 뭐냐면은 여기서 지금 참조권까지 획득해가지고 요 노드를 바라보고 있을 때 얘를 꺼내 쓰겠다라는 이걸 대상으로 지금 경합을 하고 있는 겁니다 처음에 참조권은 그냥 얘를 사용하겠다라는 걸 이거를 이제 성포하기 위해서 경합을 한 거고 두번째는 말그대로 얘를 내가 쓰겠다라고 이제 진짜 2라운드가 시작이 된 거죠 , 자, 그래가지고 여기서도 마찬가지로 다시 한번 , 이렇게, Compare Exchange Strung을 때려볼 것이고 여기서 올드 헤드에다가 ptr next로 , 이렇게, 일단은, 만들어주면 되겠어요 일단 if else 그래서 이게 만약에 true로 떴다는 거는 내가 소유권을 획득했다는 얘기가 되는 거고 소유권을 획득하기 위해서는 아까 꺼내온 그 올드 헤드랑 헤드값이 완전히 일치하다는 얘기가 되는 건데 얘가 일치하기 위해서는 포인터뿐만 아니라 여기서 참조하고 있는 횟수 즉 이 external count도 완전히 같은 상태가 돼야 된다는 얘기가 되는 거죠 혹시라도 누군가가 카운트를 1 증가시켜 가지고 똑같이 참조권을 획득해 가지고 번호표를 받아가지고 여기 넘어 왔다고 하면은 이제는 이 헤드값이 이미 바뀌었기 때문에 이 헤드랑 올드헤드가 다른 값이 될 겁니다 아주 절묘하게 얘랑 얘랑 같은 애만 승자로 인정해 가지고 ptr next 즉 요거였죠. 다음 데이터를 가리키고 있으니까 이 헤드에 그 다음 데이터를 헤드로 인정하고 얘는 이제 꺼내올 수 있는 상황이 된 겁니다. 그게 이제 여기까지 코드예요. 그래서 요게 들어왔으면 , 일단은, 내가 소유권을 획득한 것이니까 어... 그냥 데이터를 꺼냈으면 됩니다. 여기부터는 그래가지고 뭐 이런 식으로 수합을 통해가지고 데이터를 , 일단은, 꺼내왔고요. 이제 이거를 반환해줄 겁니다. 짜잔 하고 이런 식으로 리소스를 , 이렇게, 반환해 가지고 사용을 하면 되고 , 자, 그 다음에 여기서 이제 살짝 애매한 건 뭐냐면 결국엔 데이터를 꺼내 쓰는 것까지는 허락이 되었는데 그럼에도 불구하고 이 꺼내 쓴 노드 자체를 삭제해도 되느냐는 또 별개의 문제입니다 우리가 뭐 이제까지 알아보고 있었지만 얘를 삭제를 하고 싶으면은 다른 애가 접근을 하지 않는 상태여야지만 얘를 삭제해도 된다고 했는데 결국에는 얘가 지금 경쟁을 해가지고 똑같이 동일한 노드에 대해서 참조권을 획득해가지고 요로 넘어온 애들은 다들 동일한 데이터를 지금 참조해가지고 사용하고 있는 거니까 그때는 얘를 삭제를 하면 안 되고 기다려야 됩니다. 그런 요런 문제가 있는 거죠. 그래가지고 이제부터는 삭제를 하기 위해서 , 일단은, 시도를 해볼거에요. 근데 그걸 알기 위해서는 나 말고 또 누가 있는가를 먼저 체크를 해볼겁니다. 그거를 체크하기 위한 코드가 요렇게 되요. 인턴 아카운트가 이제 개입을 할거고 , 자, 여기다가 fetch add 에고 , 일단은, 자, 여기서 일단 카운팅을 먼저 할 건데 , 자, 이건 , 일단은, 먼저 작성하고 설명을 드릴게요 올드 헤드에 엑스터널 카운트의 2를 빼준 다음에 여기다가 방금 계산한 카운트 인크리즈를 fetch add를 해주고 그게 만약에 요 숫자랑 일치하면은 내가 나밖에 없다는 게 인정이 되어 가지고 얘를 삭제를 할 것이다 라는 코드가 , 일단은, 이렇게, 작성이 되어 있고 그게 아니라고 한다면은 , 자, 얘도 일단 작성하고 설명을 드리는 게 나을 것 같아 가지고 같이 , 일단은, 뭐 만들어 보자면 얘는 Fetch Sub을 할 것인데 1을 줄여서 그 값이 1이면은 얘가 삭제를 하는 상황이 되겠습니다 참조권은 얻었으나 소유권은 실패 그래서 뒷수습은 내가 한다 요런 로직이에요 , 자, 여기서 , 일단은, 이 external count랑 internal count에 대해서 , 일단은, 알아볼 건데 결국 external count는 시작값이 1이었고 얘는 시작값이 0이었죠 그래서 이 ExternalCount는 일종의 그 번호표와 같이 참조권에 해당하는 아이였습니다. 그래서 이 노드를 참조하겠다라는 순간 그 값을 1로 1을 늘려놨었죠. 그래가지고 예를 들면 나만 이 값을 사용한다고 하면은 이 숫자가 1이 늘어난 2가 될 것입니다. 그리고 요 값은 결국에는 계속 늘어나기만 한 상태고 이제 이 사용을 다 끝내 가지고 더 이상 데이터를 사용 안 할 때가 되면은 기본적으로는 이 인터널을 1 줄여주게 됩니다 그게 이제 기본 상태에요 얘는 항상 늘어나고 얘는 이제 줄어드는 형태로 일단 기본적으로 동작은 하긴 하는데 여기서 만약에 다른 애가 아무도 없고 나밖에 없는 상황이라고 한다면 이제 메모리를 날릴 수가 있겠죠 그러다 보니까 이제는 계산을 해주고 있는 겁니다 여기서 , 이렇게, 계산을 해주고 있는데 external count에서 2를 뺀 값을 먼저 계산을 해볼 거예요 지금 같은 경우는 나밖에 없다고 하면 이게 정확히 0이 되겠죠 그러면은 여기서 fetch add을 해가지고 0을 더해줄 테고 0을 더해주기 이전에 있던 값을 체크를 해볼 건데 그게 0이다 보니까 어? 나밖에 없네? 라고 인지를 해가지고 삭제를 할 수 있는 굉장히 아름다운 상황이 된 겁니다 , 자, 이건 이제 굉장히 이상적인 상황이고요 근데 만약에 그게 아니라 요 참조권을 여러 명이 획득해가지고 애당초 지금 여러 명이 들어온 상황이라고 한다면 요 엑스턴이라는 애가 나밖에 있는 게 아니기 때문에 여기서 조금 더 데이터가 추가가 될 겁니다 예를 들면 지금 동시에 나 말고 또 두 명이 있다고 하면은 예를 들면 이게 나 때문에 증가한 게 플러스 1 어 그리고 남 때문에 증가한 게 플러스 2가 된 요런 상황이 되는 거죠 그러면 요런 상황이라고 만약에 가정을 하면은 이제 여기서 또 이 카운트 인크리즈를 계산해보면 4에다가 2를 빼면은 이제 2가 남게 될 것이고 거기다가 인터널 카운트에다가 2를 더하면은 그 값 자체가 애당초 2가 되겠죠 하지만 여기 fetch add도 굉장히 헷갈리는데 얘는 더한 다음에 그 이전에 더하기 이전에 값을 뱉어줍니다 그러니까 count increase 여기 internal count가 원래는 0이었을 텐데 우리가 여기다가 fetch add를 해가지고 2를 증가시킬 테니까 얘가 2로 증가하게 되겠지만 얘가 뱉어주는 결과 값은 원래 이전에 있던 0을 뱉어주게 될 거예요 그러면 0이랑 마이너스 2랑 비교를 해볼텐데 같지 않으니까 , 일단은, 삭제를 하지 않고 넘어갈 겁니다 여기서 넘어가는 이유는 결국 뭐냐면 이 숫자가 , 이렇게, 여기 떨어지지 않는다는 거는 나 말고 누군가가 있다고 , 일단은, 볼 수가 있는 겁니다 그래가지고 이 엑스터널 카운트랑 인터널 카운트를 계속 장난을 쳐가지고 나 말고 누군가가 있는지를 , 이렇게, 탐지를 하고 있는 상황이라고 보시면 되겠어요 , 자, 그래서 결국에는 얘가 이제 , 이렇게, 정확히 이 공식이 떨어지지 않는다고 하면은 나 말고 또 누군가가 있기 때문에 삭제는 다시 하지 않고 그냥 리소스만 쭉 뽑아먹고 도망가는 셈이 되는 거죠 그러면 이 노드를 삭제하는 누가 되는 거냐면은 이 참조권을 획득해가지고 들어왔지만 소유권 획득해낸 지인 그 누군가가 이제 뒷처리를 처리해주고 있는 상황이 이제 일어나게 될 겁니다 이 상황에서 만약에 다른 애들은 울며 궤져먹기로 도망간 상황이라고 한다면 지금 요 상황에서 인터널 카운트가 2가 지금 증가된 상태였죠 인터널이 지금 2로 증가된 상태가 될 것이고 요 상황에서 나머지 애들은 나갈 때 인터널 카운트를 1씩 줄여주게 될 겁니다 얘를 1 줄여주고 0으로 바뀌게 될 건데 맨 마지막으로 얘를 줄이는 애 즉 마지막으로 줄였다는 것은 이 인터널 카운트가 1만 남은 상태죠 즉 나만 남은 상태에서 얘를 최종적으로 줄여주는 애가 즉 얘가 이제 0으로 바뀌게 될 텐데 그 0으로 바뀌기 이전의 값이 1인 애가 마지막 애가 될 거니까 걔가 이제 , 이렇게, 문을 닫아주는 상황이라고 보시면 되겠습니다 뭐 비유하자면은 뭐 어떤 회사에서 직원들이 막 10명씩 있는데 맨 마지막에 나가는 사람이 불을 꺼야 되는 그런 상황이라고 보시면 되겠어요 그래서 기본적으로 이 External Count랑 Internal Count는 그런 용도였습니다 External Count는 말 그대로 참조건처럼 먼저 들어오는 애가 이 노드를 사용하겠다라고 일식 증가시키는 횟수였고 Internal Count는 모든 애들이 다 나갔는지 진짜 불이 꺼졌는지를 체크하기 위한 숫자이고 기본적으로는 이런 식으로 나가는 애가 일식 줄여가지고 나가는 형태로 동작을 한다고 보시면 되겠습니다 근데 소유권을 획득한 애는 아싸 기분이다 하고 얘도 이제 전체 체크를 해가지고 내가 혼자 남았는지를 이런 식으로 공식으로 체크를 하는 걸 볼 수가 있습니다 , 자, 이게 좀 숫자가 굉장히 복잡하긴 한데 뭐 결국에는 여기서 중요한 건 이 세부적인 숫자가 중요한 게 아니라 이런 식으로 숫자를 두 개를 줘 가지고 나만 남았는지를 이런 식으로 계속 체크를 하는 게 굉장히 흥미롭죠 그래가지고 요 부분이 이제 잘 실행이 되면은 결국에는 락프리 방식으로 모든 게 잘 동작을 하게 될 겁니다 근데 물론 이거를 제가 오리지널하게 처음부터 다 만든 건 아니고 이게 이제 Concurrence in Action 이라는 유명한 책에서 나온 내용입니다 왜냐하면은 여기서 딱 봐도 알겠지만 이게 느낌적인 느낌으로는 알겠는데 이게 정말로 아무런 문제 없이 잘 실행이 되는지는 정말 뭐 수학적인 점검 등 굉장히 논리적으로 많은 점검이 필요하기 때문에 Lock-free 프로그래밍은 여러분들이 생각나는 대로 그렇게 하면 절대 안됩니다 그래서 이게 논문에도 굉장히 연구되는 학문인게 이런 로직에 구멍이 없는지를 잘 파악을 할 수 있어야 되기 때문이죠 그래가지고 일단 , 이렇게, 간단하게 코드를 만들어 봤구요 이 상황에서 똑같이 , 일단은, 실행을 해보면 여기서 문제가 일어나는 거는 이 부분에서 지금 문제가 일어나고 있는데 ptr 의 데이터 아 이거네요 여기서 리소스 점을 찍어 줘야 되는데 이 부분이 잘못 됐네요 , 자, 그래서 점을 찍어 줘 가지고 오케이 통과 됐으면 다시 실행을 해보면 뭐 아까 마찬가지로 크래시가 나지 않고 잘 실행이 되는 걸 볼 수가 있습니다 역시나 메모리가 , 이렇게, 증가는 거는 뭐 우리가 너무 극단적인 상황에서 예를 여기 무한 루프를 돌면서 푸시하기 때문에 그런 것이고 그게 아니라 어느 정도 텀을 둬가지고 예를 들면 1ms마다 푸시를 하게끔 , 이렇게, 유도를 해주면 이제 안전하게 외모리가 유지되는 것도 확인할 수가 있을 겁니다 그래가지고 이런 식으로 락프리 프로그래밍을 , 일단은, 작업을 할 수가 있다는 걸 알 수가 있었고요 이제 락프리에 대한 내용을 두 번째 방법으로 우리가 이 스택을 작업하고 있는데 어떤 느낌이 드시는지 모르겠어요 이게 정말로 그냥 락을 거는 방식에 비해서 빠를지를 일단 먼저 생각을 해봐야 되는데 , 일단은, 팝을 대상으로 생각을 해보면 팝에 만약에 경합이 굉장히 많이 붙는다고 하면 얘가 지금 참조권을 먼저 획득을 하고 소유권을 획득하고 이 두 개의 경쟁에서 이긴 애만 실질적으로 데이터를 뽑아갈 수 있는 거고 나머지 애들은 굉장히 쓸모없이 경쟁을 한 다음에 딱히 뭔가를 하지 않고 , 이렇게, 무한 루프를 돌면서 데이터를 뽑으려고 노력을 하게 됩니다. 그러니까 결국엔 한 번에 데이터를 뽑아가지고 실패는 한 게 아니라 내가 경합을 하는 도중에 나 말고 딴 애가 새칭해가지고 승자가 일어났으면 나는 처음 단계부터 다시 시작을 해야 된다는 얘기가 되는 거죠. 이게 락프리 프로그램의 맹정입니다. 그래가지고 락을 걸지 않고 한다는 건 굉장히 아름답지만 결국에는 , 이렇게, 경험이 붙을 경우에는 모든 로직을 다시 처음부터 실행해야 되는 경우가 굉장히 빈번하게 생긴다고 보시면 되겠어요 그래서 락을 거는 방식은 , 일단은, 멈추고 시작조차 하지 않고 내 차례가 오거나 내가 이제 락을 획득했으면 나만 진행할 거야 즉 한 번에 한 명만 실행한다는 차이가 있고 락 프리 프로그래밍에서는 동시에 다발적으로 여러 명이 진입은 할 수 있지만 결국에는 최종적으로는 결국에는 한 명만 성공할 것은 마찬가지기 때문에 그 한 명을 제외한 애들은 롤백이 되가지고 다시 처음부터 실행하는 그런 코드가 전형적으로 만들어지게 된다는 걸 이제 기억을 해주시면 되겠습니다 , 자, 이렇게, 해가지고 이 코드가 잘 이해가 가실지 모르겠는데 천천히 좀 살펴보시기를 바라고 이런 코드를 우리가 아무리 서버 프로그래밍을 한다고 해서 매일마다 작성하게 되진 절대 아니니까 일단 안심하시면 되겠습니다 그래서 너무 어렵다 진짜 이해가 안 간다고 하시면 그냥 아 진짜 락프리는 버려야 되겠구나라는 것만 깨닫고 , 일단은, 넘어가시면 될 것 같아요 , 자, 이렇게, 해가지고 락프리 스택에 대한 내용을 마치도록 하겠습니다 코드는 마찬가지로 올려드리도록 할게요.