자, 이렇게, 해서 지난 시간까지 메모리 풀과 옵젝트 풀에 대한 내용을 쭉 알아봤고요 이제 이어서 오늘 할 내용은 캐스팅과 관련된 내용에 대해서 잠시 다뤄보고자 합니다 이 내용을 할까 말까 솔직히 조금 고민을 했어요 왜냐하면 뭐 그렇게 어마어마하게 필수적인 기능이라고 하기는 뭐 한데 그럼에도 불구하고 제가 이걸 다루는 이유는 , 사실, 코드 자체에서 굉장히 많은 것을 제가 배운 그런 부분이기 때문에 이거를 여러분들한테도 좀 소개를 시켜드리고 싶었어요 참고로 말씀드리면 이 내용은 , 자, 여기 Modern C++ Design 이라는 굉장히 유명한 책이 있습니다 이 빨간 책이고 이게 한국어로도 번역본이 있기는 해요 근데 뭐 보시다시피 굉장히 오래된 책이어 가지고 당연히 절판되어서 요즘에는 이제 뭐 , 이렇게, 중고 상품으로 밖에 웃돈을 주고 구할 수밖에 없는 굉장히 유명한 책인데 이 빨간 책이 그냥 어마어마한 책입니다 제가 본 역대급 책 중에 다섯 번째 탑5 안에 일단 든다고 보시면 되는 거고 실질적으로 제가 일했던 프로젝트에서 사용하는 굉장히 많은 기법들이 저 책에서 , 사실, 차관되어서 만들었었어요 우리가 이전 시간에 알아본 메모리 풀도 마찬가지고 나중에 알아볼 그런 잡큐 같은 것도 마찬가지고 오늘 알아볼 이 타이프 캐스팅과 관련된 내용들도 저 책에 다 들어가는 내용들입니다 물론 저 책의 코드들이 좀 옛날 시플플루 올드하게 좀 만들어져 있기 때문에 그 책을 보면서 좀 현대적인 시플플루 만들어 보는 것도 좋은 연습이 됩니다 그래서 어찌됐건 저 책에서 나오는 내용이다 라는 걸 , 일단은, 언급을 드린 거고요 , 일단은, 내용을 살짝 삭제를 해보고 오늘 다룰 내용의 필요성에 대해서 , 일단은, 제가 한번 설명을 드릴게요 이걸 왜 사용해야 되는지 어 우리가 나중에 게임을 만들다 보면은 요런 식으로 굉장히 다양한 클래스가 생기게 될 겁니다 필연적으로 나이트도 있을 것이고 그 다음에 뭐 메이지 같은 법사도 있을 것이고 막 , 이렇게, 상속 구조로 이리저리 이뤄져 가지고 나중에 코드가 사용이 되겠죠 , 자, 그런데 어 우리가 설령? 예를 들면 지금 나이트랑 메이지가 있다고 가정을 해볼게요 그럼 뭐 가장 기본적으로 사용하는 방식은 뭐 , 이렇게, 뉴 나이트를 만들고 나이트 포인터를 이용하거나 아니면은 뭔가 메이지를 만들어 가지고 메이지를 이용하거나 라고 생각할 수도 있겠지만 의외로 , 이렇게, 각자를 이용해 가지고 관리하는 경우는 의외로 생각보다는 많이 없고 보통은 최상위 클래스 같은 애들로 , 이렇게, 뭉뚱그려 가지고 한 번에 관리하는 경우가 많습니다 우리가 pvp 기능을 만든다거나 아니면 전투 기능 이런저런 기능을 만들 때 라이트로만 대상으로 뭔가 , 이렇게, 따로 특별하게 움직이는 개념은 아니고 보통 직업과는 무관하게 플레이어끼리 공통적으로 기능이 다 여기 안에 들어가 있겠죠 그러다보니까 어떤 함수에서도 예를 들면 어떤 플레이어를 공격해라 이런 어택 플레이어 같은 걸 받아줄 때 대부분 이런식으로 플레이어 포인터를 뭔가를 받아줄겁니다 그리고 나중에 NPC나 몬스터같은 애들이 생긴다고 하면 그것도 마찬가지로 플레이어가 아니라 더 상위 클래스인 크리처같은 애들로 요런 식으로 받아가지고 아주 얘네들끼리 뭐 전투를 붙인다거나 하는 식으로 이제 만들어진다는 얘기가 되는 거죠 그래가지고 결국에는 모든 애들을 이런 식으로 상위 어 클래스로 요렇게 관리를 하게 될 예정인데 근데 그럼에도 불구하고 뭐 아까 예를 들면은 뭐 어택 플레어 같은 함수 내부에서 어 어떤 애만 특별히 처리하고 싶다 예를 들면은 기사로 대상으로만 뭐 이제 뭐 치명타를 주고 싶다거나 라는 뭐 그런 사양이 있다고 하면은 이게 어디까지나 다시 나이트로 다시 , 이렇게, 변신해야 될 상황이 충분히 생깁니다 기껏 P1을 플레이로 관리하고 있었는데 얘를 다시 나이트로 , 이렇게, 뭐 캐스팅을 해야 된다는 얘기가 되는거죠 물론 이건 약간 C스타일의 캐스팅이고 뭐 C++스타일의 캐스팅은 , 사실, 요렇게 스태틱 캐스트나 다이나믹 캐스트를 이용하는 거죠 , 자, 근데 이 스태틱 캐스트를 하면은 약간 위험한게 뭐냐면은 , 사실, 얘는 내부적으로 , 이렇게, P2 같은 애들도 사실상 얘가 메이지였음에도 불구하고 얘를 자연스럽게 캐스팅을 해줘가지고 요렇게 되면 사실상 메모리 오염이 일어날 확률이 굉장히 높아집니다 만약에 얘가 얘랑 얘랑 접근할 수 있는 멤버 변수의 크기가 맞지 않고 동일하지 않고 구조가 다르다고 하면은 사실상 우리가 , 이렇게, K1을 이용해가지고 뭔가를 접근하는 순간 엉뚱한 메모리를 우리가 지금 건드리고 있는 셈이 되니까 굉장히 무시무시한 짓거리를 하고 있는 거죠 그래가지고 이거에 대한 대안으로 다이나믹 캐스팅하는 게 하나가 더 있죠 4대 캐스팅, 캐스팅 4개 중에서 다이나믹 캐스트라는 게 있는데 다이나믹 캐스트 같은 경우에는 우리가 캐스팅을 막 , 이렇게, 하다가 만약에 이 캐스팅이 되지 않는 그런 객체라고 하면 얘를 널 포인터로 변환해 준다는 그런 차이가 있습니다 , 자, 그런데 다이나믹 퀘스트 같은 경우에는 뭐 , 일단은, rtti 를 활용해 가지고 바꿔주기 때문에 지금 보시는 바와 같이 다양 클래스 형식이 뭔가 있어야 된다고 합니다 즉 가상함수가 뭐 하나라도 있어야 된다는 얘기가 되는 거죠 예를 들면은 뭐 버추얼 플레이어라고 , 이렇게, 해가지고 가상함수를 하나를 만드는 순간 이제 얘가 없어지는 걸 볼 수가 있습니다 뭐 이거는 그렇다 치고 그 다음에 두 번째로 약간 아쉬운 부분은 뭐냐면은 얘가 생각보다 속도가 좀 느려가지고 어... 다이나믹 퀘스트를 막 난무할 수가 없고 대부분의 경우에는 여전히 스태틱 퀘스트를 성능상의 이유로 이제 사람들이 더 선호를 할 수밖에 없게 됩니다 근데 얘는 어디까지나 위험하다는 그런 문제가 있죠 그래가지고 나중에 이제 좀 규모가 큰 게임을 만들 때는 이걸 그럼 어떻게 하는 것이냐? 스태틱 캐스트를 활용하고 싶은데 안전하게 하고 싶으면은 이거를 뭐 어떤 타입을 주겠죠? 예를 들면은 뭐 이런 식으로 플레어 타입 같은 요런 이넘을 만들어가지고 얘는 뭐 예를 들면은 나이트 타입이고 메이지 타입이고 이런 식으로 뭔가 타입을 하나씩 정해준 다음에 여기다가 내부적으로 걔를 들고 있게 만들어 주겠죠 뭐 예를 들면은 어떤 타입 플레어 타입은 무엇이냐라고 관리를 해 준 다음에 나이트 같은 경우에는 생성자에서 이 타입은 나이트 타입이다 이런 식으로 적어주고 메이지 같은 경우에도 똑같이 자신의 타입을 , 이렇게, 넣어준 다음에 이 타입으로 이제 구분하는 방법이 있습니다 그러면은 이 코드에서 우리가 이 플레이어의 타입이 무엇인지를 봐가지고 얘가 만약에 나이트 타입이라고 하면은 그거를 그제서야 안전하게 이런 식으로 나이트로 변신을 시켜 가지고 사용할 수가 있겠죠 근데 이제 나중에 클래스가 또 굉장히 많아진다고 하면은 요런 코드를 일일이 만드는 것도 정말 일입니다 그리고 역시나 혹시라도 요런 체크를 누락했다거나 당연하다고 생각을 해가지고 얘를 그냥 누군가가 막 작업을 했었는데 다른 애가 고치다 보니까 뭐 이게 살짝 꼬여가지고 지금 잘못된 애가 들어온다거나 하는 상황도 발생할 수도 있고 뭐 요런 저런 문제들이 발생할 수가 있겠죠 그래가지고 이런거를 뭐 이제 별도의 함수로 빼가지고 여기 뭐 플레이어 내부에서 나이트로 뭐 내가 캐스팅을 할 수 있느냐 뭐 이런거를 , 일단은, 만들어 줄 수가 있긴 할겁니다 여기다가 뭐 캐스팅 나이트로 변환해가지고 예를 들면은 뭐 이런식으로 나이트 플레이어 2 나이트 같이 나를 캐스팅 해주겠다 뭔가를 할 때 이런 식으로 뭔가 변환해주면 되지 않을까 라는 생각을 우선 할 수 있겠어요 물론 꼭 여기 플레이어 내부에 넣어야 된다는 얘기는 아니지만 뭐 이런 식으로 캐스팅하는 그런 함수들을 만들어 가지고 얘를 이제 뭐 관리하면 되지 않을까 라는 생각이 들긴 하는데 이것도 일일이 만드는 것도 굉장히 귀찮은 일이긴 합니다 그래가지고 오늘 뭐 , 사실, 이런 부분들과 관련되어서 얘기를 해볼 건데 실제로 언리얼 엔진 같은 경우에도 이런 식으로 다이나믹 캐스트를 우리가 직접적으로 활용하지 않고 내부적으로 지원해주는 캐스팅이 있어가지고 그게 , 사실, 다이나믹 캐스트를 더 빠르게 사용할 수 있게끔 지원을 합니다 사실상 요런 짓거리를 조금 더 편하게 할 수 있게끔 만들어 준다라고 볼 수가 있는 거죠 그래서 오늘 알아볼 내용은 , 사실, 요렇게 캐스팅을 하는 거를 , 이렇게, 안전하게 탭을 체크한 다음에 스태틱 캐스트를 하는 요런 방법을 좀 편리하게 그리고 빠르게 사용하는 뭐 그런 방법에 대해서 , 일단은, 알아보는 게 오늘의 주제라고 보시면 되겠어요 , 자, 근데 이거를 , 일단은, 만들기 위해서 좀 산이 많습니다 근데 이게 이제 개인적으로 생각을 했을 때 꼭 사용해야 되는 건 아니지만 이걸 처음에 공부했을 때 굉장히 템플릿에 대한 많은 도움이 되었어요 이해하는데 그래가지고 여기다가 새로운 헤더 파일을 하나를 만들어 줄 건데 오늘 작업할 내용은 다 여기다가 다 넣어 주도록 할 것이고 이름하여 typecast라는 파일을 하나를 , 이렇게, 만들어 주도록 하겠습니다 , 자, 얘는 include type은 추가를 해 줄 것이고요 , 자, 그 다음에 이제 하나씩 하나씩 템플릿 흑마법을 이제 공부를 해보도록 할 건데 맨 먼저 타입 리스트라는 걸 우리가 만들어 줄 거예요 근데 얘가 하는 건 뭐냐면은 , 자, 우리가 어떤 리스트를 만들어 주는 과정을 합시다 요런 리스트 같은 거 근데 일반적으로 우리가 리스트에서는 얘가 어떤 타입인지를 요렇게 지정을 해줬죠 그 다음에 그 다음에 리스트에다가 넣는 거는 요런 동일한 타입만 우리가 넣어 줄 수가 있었어요 그런데 그게 아니라 어떤 리스트인데 여기다가 이런 클래스 타입을 넣어주는 리스트를 우리가 만들고 싶다고 가정해봅시다 예를 들면 지금은 문법상 말이 안 되지만 플레어라는 타입이랑 나이트라는 타입이랑 메이지라는 타입을 우리가 넣어주고 싶다라는 이런 느낌의 리스트를 우리가 만들어주고 싶다고 가정을 하면 당연히 STL에는 이런 기능이 없으니까 우리가 뭔가 템플릿 흑마법을 이용해가지고 얘를 만들어야 됩니다 그래서 이거를 잠시 한번 시작을 해볼 건데 , 자, 여기부터 이제 약간 템플릿과 관련된 굉장히 많은 아이들이 들어갑니다 그래서 , 일단은, 어... 여기서 pragma region type list라는 영역을 만들어가지고 첫번째는 end region type list과 관련된 애들을 , 일단은, 쭉 만들어 보도록 하겠습니다 , 이렇게, 집어주고 , 자, 그 다음에 먼저 struct type list , 이렇게, 템플릿으로 만들어 줬고요 , 자, 이거를 , 일단은, 코드를 3개를 다 만들어 드린 다음에 분석을 해보도록 할게요 type name u 그리고 얘는 type list인데 이번에는 head는 t 그리고 tail은 u 가 될 것이고 마지막에는 타임네임 t . . . u 베레딕 템플 이용해 가지고 헤드는 t 그리고 테일은 타임리스트 u . . . 땡 하고 , 이렇게, 만들어 주면 됩니다 , 자, 당연히 뭐 이게 무슨 코드인지 이해가 가시면 뭐 대단한거고 대부분은 이게 약간 외계어처럼 느껴지시는게 당연합니다 저도 처음엔 그랬고 그래서 요 부분을 일단 설명을 드리자면 , 자, 일단은, 어... 이쪽에다가 좀 간략하게 한번 표현을 해볼게요 이게 만약에 두개가 있다고 가정해봅시다 T가 있고 템플릿 U가 있고 그 다음에 이거를 우리가 type list라고 만약에 이름을 짓는다고 가정하고 첫번째 A 같은 경우는 우리가 head라고 이름을 지을 것이고 두번째 A 같은 경우는 tail이라고 이름을 지어줄 거에요 그러면은 이제 요 코드에서 우리가 알 수 있는 거는 뭐냐면은 , 자, 요 에러는 뭐 쓸데없는 문제 같구요 어... 여기서 만약에 우리가 이런 식으로 타입 리스트를 한 다음에 메이지랑 나이트를 우리가 요렇게 만든다고 가정해봅시다 요런 느낌으로 그러면 여기서 이제 우리가 헤드를 이용해가지고 어떤 타입을 정의해줄 수가 있겠죠? Who am I? 라고 할거야 나는 누구인가 그 다음에 역시나 두번째로 테일을 이용해가지고 Who am I to? 라고 하면은 여기서 굉장히 재밌게도 아이고 이게 타입 네임입니다 이래서 일어난 거네요 얘는 메이지를 가리키고 있고 얘는 이제 나이트라는 걸 나타내게 됩니다 즉 우리가 뭔가 std 페어와 같은 느낌으로 약간 이런 느낌으로 여기다가 두 개를 집어 넣어 줬고 그 중에서 첫 번째 애를 꺼내는 건 헤드라는 걸로 우리가 사용하고 있고 두 번째 애를 사용할 때는 테일이라는 걸 이용해 가지고 둘 중 하나를 골라 줄 수가 있게 된 거예요 그래가지고 이게 사실상 이런 타입 리스트라는 mage, knight 라는 우리가 struct를 이용하면은 여기서 이 둘 중 우리가 넣어준 애 중 둘 중 하나를 골라줄 수가 있게 된 거죠 뭐 여기까지는 뭐 굉장히 단순한데 근데 그 다음에 하고 싶은 거는 뭐냐면은 이제 만약에 여러 개 중에서 골라줘야 된다 예를 들면 여기서 knight, mage 뿐만 아니라 제 3에 역시나 아처가 들어가야 되겠죠 뭐 아처가 일단 있다고 가정해봅시다 뭐 이건 잠시 삭제를 하도록 하고 그러면 이제는 2개가 아니라 짝이 아니라 이제 3쌍이 돼야 되는 건데 그럼 이제 3쌍은 어떻게 처리해야 되느냐 이 함수를 이 스트럭트를 유심히 보면은 애정초 우리가 예를 들면 벡터 안에다가도 벡터를 , 이렇게, 넣어줄 수가 있었죠 템플릿은 특성상 요 U라는 것 자체가 뭐가 돼야 된다는 거를 얘가 강요를 하지 않습니다 그러다 보니까 얘를 , 이렇게, 응용할 수가 있어요 타이플리스트를 만들어 주는데 여기다가 나이트를 넣어주는 게 아니라 또 한 번 타이플리스트를 만들어 주고 여기다가 나이트와 아처를 , 이렇게, 넣어줄 수가 있다는 얘기가 되는 거죠 그러면 사실상 굉장히 복잡해 보이지만 얘가 1번 2번 3번 , 이렇게, 3개의 지금 세 개의 클래스 타입을 얘가 지금 , 이렇게, 저장하고 있는 상태라고 생각할 수가 있겠습니다 그럼 얘를 사용할 때는 이제 헤드를 이용하면은 얘가 뭐 3번이라고 하면은 얘는 그대로 메이지를 나타내게 될 것이고 나머지 애들을 접근하고 싶다고 하면은 테일에다가 헤드를 접근하게 되면은 얘가 이제 두 번째 애의 첫 번째 애니까 얘가 이제 나이트가 될 것이고 그 다음에 테일의 테일을 이제 이용하게 되면은 얘는 아처를 의미하게 될 겁니다 요런 느낌이에요 그래가지고 요런 코드가 일단 , 이렇게, 동작한다는 걸 우리가 아는 상태에서 요 코드를 이제 다시 보면은 얘는 이제 C++11의 문법인 Veridic Template 이용해가지고 요기 안에 너가 원하는 개수의 그런 템플릿을 인자를 넣어줄 수 있다고 그냥 허락을 해주는 겁니다 이게 뭐 100개가 될 수도 있고 200개가 될 수도 있고 상관을 안 하겠다 근데 만약에 여기서 이제 두 가지 길을 우리가 주고 있는 건데 , 이렇게, 여러 가지 옵션을 주면은 실질적으로 컴파일러가 자기가 가장 가까워 보이는 애를 찾아가지고 그 애로 , 일단은, 컴파일이 됩니다 예를 들면 지금 이 케이스 같은 경우에는 데이터가 두 개밖에 없는 상황이다 보니까 그러게 되면은 헤드는 T, 테일은 U , 이렇게, 이 버전으로 빌드가 될 거예요 , 사실, 우리가 여기서 테스트하는 이 코드가 지금 이거랑 똑같은 얘기가 되는 거고 근데 만약에 데이터가 2개를 넘어가 가지고 3개가 있다고 가정을 하면은 그러면 이제는 재기적으로 우리가 얘기를 해주고 있는 겁니다 데이터가 3개가 있다고 하면은 그리고 어 첫번째에는 우리가 T라고 이름을 지었고 나머지 애들 2번 3번 4번 이상의 애들은 우리가 U..으로 표현하고 있는데 그렇다면 무조건 첫번째에는 우리가 Head 즉 T로 표현을 하겠다라고 했고 그 다음에 나머지 애들은 우리가 , 이렇게, Tail이라고 이름을 지었는데 그 Tail은 Type List에 U..으로 우리가 정의를 해준 거죠 , 사실, 이 부분이 잘 이해가 가셨다면 이 코드가 , 사실, 이거랑 똑같은 의미입니다 얘가 헤드, 그 다음에 두 번째 기준으로 테일은 요 아이다 라고 , 이렇게, 표현을 해준 거죠 그래가지고 뭐 이거를 왜 뜬금없이 그래서 어떻게 쓰느냐 이제 나머지 , 사실, 헤드 테일 헤드 테일 , 이렇게, 꺼내 쓰는 게 너무 복잡하니까 이거는 당연히 뭐 매번 마다 , 이렇게, 할 수는 없을 건데 이게 , 사실, 기초가 되어 가지고 어떤 여러 가지 타입의 리스트를 우리가 , 이렇게, 관리를 하고 있는 거라고 , 일단은, 먼저 이해를 해주시면 되겠습니다 그래가지고 여기서 , 사실, 템플릿 특수화라는 걸 이용해가지고 부분 템플릿 특수화를 이용해가지고 이 두 가지 버전 중 하나를 골라주기에 우리가 유도를 해준 거죠 그래서 얘는 , 사실, 구현도 안 해도 되는 게 얘는 어차피 걸리지가 않고 나머지 둘 중 하나로 걸리게 될 겁니다 그래가지고 이런 타이플리스트라는 걸 먼저 , 이렇게, 만들어 줬고요 그 다음에 이제 만들어 줄 거는 Lens라는 걸 만들어 주도록 하겠습니다 똑같이 이번에는 렌스 기능 어떤 프라그마 앤드 리전을 한 다음에 이번에는 거꾸로 , 이렇게, 타입 리스트가 있을 때 요 아이의 길이는 몇 개짜리 인지 예를 들면 얘가 우리가 벡터라고 했으면 벡터 안에 들어간 개수를 우리가 사이즈로 이용해 가지고 추출할 수 있었는데 그런 느낌이라고 볼 수 있는 거죠 근데 이 타임리스트가 일반적인 벡터 리스트랑 다른 점은 이런 애들은 컴파일 타임에 모든 것이 다 결정이 됩니다 그리고 이게 굉장히 중요한 차이가 있어요 우리가 일반적으로 리스트나 벡터를 사용할 때는 그 아이들은 사실상 데이터가 런타임에 들어가는 거다 보니까 컴파일 타임에 정해지는 게 아니에요 근데 컴파일 타임에 얘네들이 정해진다 하면 실질적으로 우리가 빌드를 다 끝나가지고 얘를 실행하는 상태에서는 그 이후에는 전혀 부담이 안 걸린다는 얘기가 되는 거죠 그냥 0, 1, 2, 3 같은 우리가 고정된 값을 사용하는 거랑 완전히 똑같다는 얘기가 되는 겁니다 그래서 이제 이어가지고 렌스를 만들어 볼 것인데 어 약간 비슷한 느낌으로 만들어 볼 수가 있어요 , 자, 예를 들면은 먼저 요렇게 렌스라는 애를 만들어 줄 것이고 그 다음에 두 가지 케이스에 대해서 또 골라주도록 유지해줄 겁니다 첫 번째는 type list인데 , 이렇게, 비어있다고 하면은 이 type list가 비어있다고 하면은 우리가 얘를 value는 0이라고 뱉어줄 거예요 얘도 유심히 보면은 이넘 안에다가 넣어준 이유가 이넘도 마찬가지로 여기 안에 있는 값이 컴파일 타임에 다 결정이 되는 애들입니다. 그래서 우리가 앞으로 여기서 지금 컴파일 타임에 작업이 될 수 있는 애들을 사용하는 것이기 때문에 나머지 기능들도 다 컴파일 타임에 딱 지정이 되는 애들만 서로 꺼내쓸 수 있어요. 그래가지고 , 이렇게, 이넘을 사용한 거구요. 이어가지고 , 자, 타임네임 t, 타임네임 ... u를 해가지고 이제는 그러면 일반적인 상황에 대해서는 어떻게 처리를 할 것이냐? t, u.. 그 다음에 요 코드가 이제 이해가 가실지 모르겠는데 1 플러스 랜스에 타입 리스트 u.. value 라고 요렇게 , 일단은, 정의를 해줄 수가 있을 겁니다 요 아이의 의미는 이제 뭐냐면은 일단 사용하는 것부터 살짝 살펴보면은 어... 이런 타입리스트가 만약에 , 이렇게, 정해졌다고 가정해봅시다 그러면은 여기다가 여기다가 일단 인클루드를 해주도록 할게요 인클루드 타입캐스트를 추가한 다음에 여기서 사용하는 방법은 Lens를 사용할 것인데 Lens에다가 요런 타입리스트를 우리가 넣어주는 거죠 요런 느낌으로 그래서 요렇게 넣어줬을 때 요 아이의 Value는 얼마이냐 요 아이의 Length는 얼마이냐를 우리가 물어보고 있는 겁니다 네 아 이거 하나를 더 만들었나 보네요 그래가지고 Length 1번 그리고 얘를 만약에 Knight, Mage, Archer까지 포함된 버전이 있다고 하면 얘를 Length 2번이라고 하면은 각각의 숫자가 지금 2랑 3으로 요렇게 나온다는 얘기가 되는 거고 우리가 아직 뭐 빌드를 하지 않았음에도 얘가 , 이렇게, 숫자가 나온다는 것은 이게 빌드하는 시점, 빌드한 다음에 런타임에 결정되는 게 아니라 컴파일 타임에 모든 것이 다 결정된다고 우리가 결정된다는 걸 알 수가 있는 거죠 그래서 지금 이 코드를 유심히 보면 얘가 뭘 해주고 있는 거냐면 역시나 두 케이스 중 하나를 골라주게 될 건데 일반적인 케이스는 이제 이 케이스입니다 렌스 안에 우리가 타입 리스트를 넣어준 이런 케이스를 얘기하고 있는 거예요 T랑 U.. 첫번째 애는 즉 메이지 지금 요경우에서 메이지가 T에 들어갈 것이고 나머지 애들 두번째 이상의 애들은 U.. 으로 들어가게 될 건데 이때 요아이의 길이는 얼마이냐 지금 데이터가 몇 개 있냐라고 했을 때 첫번째 애를 없앤 다음에 나머지 애들을 대상으로 똑같이 렌스를 한 번 더 호출해주고 있어요 그러니까 우리가 제기함수를 만드는 거랑 완전히 똑같은 느낌인 거죠 얘네들을 카운팅하라고 했더니만 사실상 이런 느낌입니다 , 자, 여기서 지금 너 데이터가 몇 개 보여 라고 했을 때 , 일단은, 한계는 있는 건 확실하고 그때 이 두 가지 애들을 대상으로 똑같은 함수를 더 호출한 다음에 1을 더해준다는 얘기가 되는 겁니다 즉 얘를 없애고 1 더하기 나머지 숫자를 새겠다 라고 또 호출해줄 것이고 얘를 다시 호출해주게 되면은 또다슨 재기적으로 호출이 되면서 나이트랑 아처가 이제 요 렌스가 호출이 되는데 나이트를 없애면서 다시 1을 더해주고 마지막으로 아처도 없애주고 , 이렇게, 되는 거예요 그럼 마지막에는 더 이상 데이터가 없으니까 여기 빈 타입 리스트로 얘가 넘어오게 될 것이고 얘는 0 이라는 걸 인지해 가지고 , 이렇게, 계산이 된다는 얘기가 되는 거죠 그래가지고 , 이렇게, 우리가 템플릿을 이용해 가지고도 막 재규적인 템플릿을 만들어 가지고 컴파일 타임에 막 계산이 되는 걸 사실상 , 이렇게, 만들 수가 있습니다 그래서 결과적으로는 여기 이 타입 리스트 안에 들어가 있는 데이터 개수는 몇 개입니까? 라는 질문에 대해서 요렇게 우리가 또 요런 struct 템플릿 클래스를 이용해 가지고 구할 수가 있다는 얘기가 되는 거죠 굉장히 신기하게도 그래서 , 이렇게, 구해주는 것까지도 , 일단은, 확인을 했습니다 , 자, 그 다음에 렌스뿐만 아니라 이제 또 그 다음에 이제 만들어 볼 거는 뭐냐면은 type at 이라는 걸 만들어 보도록 하겠습니다 pragma and region 에고 프라이크 마그 다음에 타입 애쉬 하는거는 뭐냐면은 우리가 당연히 , 이렇게, 헤드테일 헤드테일 텔 힐 뭐 이런걸 막 해가지고 조입해 가지고 만들 수는 없겠죠 이게 나중에 데이터가 막 10개가 넘어가면은 우리가 몇 번째로 지금 접근하는지도 당연히 헷갈리니까 요거는 맞는 방법이 아닙니다 그래서 우리가 요렇게 1년에 그런 데이터를 모아놨을 때 0번 인덱스에 해당하는 메이지다 그리고 2번 인덱스에 해당하는 아처이다라는 걸 꺼내줄 수 있는 이제 그런 거를 만들어 볼 건데 그걸 typeH라는 기능으로 만들어 보도록 할 거예요 , 자, 얘도 이제 분석을 해보시면 되겠는데 , 일단은, 이렇게, 인덱스를 이용해 가지고 템플릿과 그냥 어떤 숫자를 받아주도록 할 겁니다 typeH 그리고 두 번째로 템플릿 타임네임 헤드 타임네임 점점점 테일 스트로크 타입 앳 타임리스트 헤드 테일 점점점 영 뮤징 리설트는 아이고 리설트는 헤드 , 자, 이 코드도 이제 뭐 제가 이어서 분석을 해드릴텐데 , 일단은, 이해가 가시는지 한번 분석을 해보시길 바랍니다 먼저 인덱스 를 받아주고 struct typeAt typeListHeadTail..index 그 다음에 usingResult는 typeName typeAt typeListTail..index-1의 result가 , 일단은, 돼야 되겠죠 , 자, 요렇게 , 일단은, 코드를 만들어 줄 수가 있어요 , 사실, 우리가 지금 여러 번 비슷한 작업을 하고 있기 때문에 얘도 굉장히 비슷한 느낌인데 이 경우가 일반적인 경우였고 이 경우가 마지막 경우였던 것처럼 얘도 사실상 비슷한 느낌입니다 그래가지고 얘가 해주고 싶은 건 뭐냐면은 우리가 , 이렇게, 타입 리스트가 있을 때 이 인덱스 번에 해당하는 그 타입을 찾아주고 싶은 겁니다 그러면 그 인덱스 번에 해당하는 걸 찾아줄 것인데 만약에 운 좋게 우리가 0번째 인덱스에 해당하는 데이터를 추출하고 싶었다라고 하면 지금 , 이렇게, 되겠죠 지금 예를 들면 mage, knight, archer가 있을 때 이 head가 지금 mage를 의미하고 있는데 딱 우리가 0번째 인덱스에 해당하는 애를 찾고 싶다고 하면 더 이상 서치할 것도 없이 정확히 첫 번째 아이를 그냥 뱉어주면 됩니다 그렇기 때문에 0인 경우에 대해서는 그냥 result를 head로 하고 바로 끝낼 수가 있다는 얘기가 되는 거죠 근데 만약에 그게 아니라 우리가 요렇게 타입 리스트가 지금 Mage, Knight, Archer로 되어있는 상태에서 요 TypeAt을 호출하고 거기서 뭐 인덱스가 2번인 애를 찾고 싶다라고 했으면은 이제 여기서 2라는 숫자가 들어가 가지고 이제 얘를 이제 서칭을 하게 될 거예요 그러면 얘가 하는 것은 뭐냐면 첫 번째 l을 없앤 다음에 1을 줄여 가지고 똑같은 type at을 한 번 더 찾아 주고 있습니다 즉 이런 느낌이 되는 거죠 여기서 우리가 인덱스가 2번인 애는 무엇입니까 라고 질문했을 때 똑같이 얘를 찾아가지고 , 일단은, 얘를 까준 다음에 얘는 첫번째 애니까 헤드를 없애준 상태에서 인덱스를 1 줄인 상태에서 나이트 아처만 있을 때 인덱스가 1번인 애는 누구입니까 라는 질문을 다시 한번 재기적으로 던졌고 그 다음에 재기적으로 타입 애쉬 한번 더 실행이 되면서 계속 , 이렇게, 양박하기를 하듯 헤드를 계속 없애주면서 진행을 한다고 보시면 되겠습니다 그래서 마지막 질문은 아하 그러면은 아처만 있고 인덱스가 0번인 애는 얼마입니까 라고 딱 질문을 할 것인데 요 경우까지 왔으면은 요 경우에 해당하는 거니까 타입 리스트에다가 0번이 들어간 게 정확히 요 버전이니까 이제 요 버전이 아니라 요 버전을 얘가 알아서 선택을 해주게 될 겁니다 그러면 요 질문에 대해서는 아 0번인에는 무조건 Archer, 즉 첫번째 데이터가 그 타입이라는 걸 알고 있으니까 결국엔 얘는 Archer를 뱉어줄 것이고 재기적으로 다시 가면서 얘도 Archer, 얘도 Archer를 뱉어주게 된다는 얘기가 되는 거죠. 그래가지고 , 이렇게, 이제 응용을 하면은 우리가 type at을 이용해가지고 , 자, 예를 들면은 지금 요 아이를 우리가 대상으로 하려고 해봅시다. using tl을 요렇게 해가지고 요 타입 리스트를 우리가 tl이라고 부른다고 하면은 이제 이 tl에 해당하는 우리가 0번째 애를 구하고 싶다라고 했을 때 여기서 result를 통해 가지고 mage가 알아서 추출이 된다는 얘기가 되겠습니다. whoami 6번이라고 해봅시다. 나는 누구입니까? 그럼 얘는 굉장히 신기하게 mage를 골라줬다는 걸 알 수가 있는 거죠. 마찬가지로 1번, 2번에 해당하는 애는 각각 knight와 archer라는 걸 , 이렇게, 알 수가 있습니다. 그래가지고 , 이렇게, type list를 만들어 준 다음에 여기서 이 중에서 0번 1번 2번을 골라주는 그런 마법의 템플릿 코드를 , 이렇게, type at 이라는 걸 , 이렇게, 만들어 줄 수 있다라고 , 일단은, 볼 수가 있겠고요 , 자, 그 다음에 이제 거의 끝나가는데 그 다음에 만들어 볼 것은 거꾸로 region index of 라는 기능을 만들어 볼 거예요 이제 얘 가는 거는 거꾸로인데 우리가 몇 번 인덱스, 즉 0번, 1번, 2번에 해당하는 타입은 무엇입니까? 라는 질문을 타입 s 를 통해 가지고 구현을 했다면 인덱스 오브는 거꾸로 우리가 어떤 클래스를 던져 줄 것이고 이 메이지라는 애가 이 타입 리스트 중에서 몇 번째 인덱스에 해당합니까? 라는 질문을 우리가 던져 줄 겁니다 그래서 얘도 똑같이 만들어 주자면 이런 식으로 만들어 줄 수가 있어요 어떤 tl 이라는 타입 리스트에서 T라는 애를 찾아줄 것이다. 그리고 그거를 우리가 indexOf라고 부를 것인데 여기서 두 가지 케이스를 또 우리가 컴파일러한테 떠넘길 겁니다. 이번에는 tail과 T 그리고 struct indexOf type list t tail... t 그 다음에 innum value는 0 , 이렇게, 만들어줄 것이고요. 그리고 어 템플릿 타임네임 t struct index of 빈 타입 리스트일 경우 얘는 그냥 못 찾은 경우일 때고 못 찾았으면은 그냥 밸류를 마이너스 1로 뱉어 주도록 할 겁니다 그 다음에 이어가지고 템플릿 타임네임 head 타임네임 점점점 테일 type name t 일반적인 경우는 이제 이것도 역시 재기 함수를 돌릴 것인데 재기적으로 찾아 줄 것인데 type list에 head, tail.. 그 다음에 t 를 찾아 주는 상황이다 그리고 요 상황에 대해서는 , 자, 두 갈래로 그러니까 private로 , 일단은, 먼저 임시로 템프라는 걸 찾아 줄 것이고 type list tail... t 의 value 그 다음에 여기서는 value는 템프가 마이너스 1 이다라면은 그냥 마이너스 1로 뱉어줄 것이고 못 찾은 거니까 그게 아니라 뭔가를 찾았으면은 1을 더해줘가지고 뱉어주도록 하겠습니다 요렇게 이제 우리가 index of를 만들어 줄 수 있다는 얘기가 드는 거죠 그럼 여기서 거꾸로 이제 , 이렇게, 사용할 수 있겠죠 index of 라고 한 다음에 tl에서 우리가 메이지라는 걸 찾고 싶은데 그 아이의 인덱스는 얼마입니까? 라는 거를 인덱스 1번이라고 한다면 , 이렇게, 찾아줄 수가 있다는 거죠 메이지 그리고 뭐 아처는 몇 번입니까 그리고 아주 생뚱맞은 거 예를 들면 여기다가 뭐 클래스 그냥 개라는 클래스를 만들어 가지고 완전히 뜬금없는 애를 우리가 여기다가 찾아본다고 하면 이것도 무슨 값이 될지 굉장히 궁금하니까 , 이렇게, 찾아볼 수 있다는 얘기가 되는 겁니다. 그러면 여기서 각각 값이 0, 2, 마이너스 1이 나오는 것도 볼 수 있고 우리가 아직 실행하지 않았음에도 얘를 찾았다는 건 역시나 얘가 컴파일 타임에 모든 거를 다 계산해 줄 수 있다는 얘기가 되는 거죠 그렇게 , 이렇게, 해가지고 요 타입 리스트라는 거 안에서 우리가 어떤 타입을 찾아 달라고 했을 때 그 결과를 요렇게 인덱스 오브라는 기능을 만들어가지고 찾을 수 있다라는 것에 대해서 , 일단은, 알아봤습니다 , 자, 그래가지고 요렇게 계속 지금 중간 부품들을 만들고 있는 거고 그 다음에 이제 만들어야 되는 부품은 이전 conversion 이라는 클래스를 만들어 볼 건데 이것도 굉장히 특이한 코드에요 여기서 만들어 볼 것은 from 에서 to 라고 이 from 타입의 포인터에서 to 타입의 포인터로 변환이 가능한지를 우리가 체크해 주는 그런 아이를 만들어 보도록 하겠습니다 private public , 자, 그 다음에 이제 요 코드가 굉장히 신기 만개한데 이게 책에 나오는 방식입니다 , 일단은, 아주 작은 타입을 우리가 요렇게 만들어 줄 건데 int 8 자리를 우리가 small 이라고 , 일단은, 이름을 지을 거고 그 다음에 요 아이랑 다른 크기의 사이즈로 예를 들면 int 32 자리로 얘를 big 이라고 , 일단은, 만들어 준 다음에 그 다음에 , 이렇게, 여러가지 함수를 만들어 줄 거에요 const to 이런 식으로 return은 아무거나 return 0를 해줄 것이고 그 다음에 big test... return 0 그리고 static from make from 얘 같은 경우도 그냥 return 0 이 값은 아무런 상관이 없고 이걸 왜 하는지 이어서 나올 건데 그 다음에 exist 변환이 존재한다라고 하면 test make from 사이즈 오브 스몰 이 돼야 된다 요 코드가 이제 굉장히 처음 봤을 때 약간 멘붕이 온 코드였는데 얘가 하는 거는 뭐냐면은 얘도 이제 컴파일러가 우리가 여러가지 옵션을 줬을 때 자기가 가장 그럴싸한 거를 먼저 찾아 준다는 특징을 이용하고 있는 겁니다 그러니까 예를 들면 우선 make from 이라는 걸 호출하는데 make from 이라는 것 자체가 from 이라는 걸 지금 반환을 해주고 있을 겁니다 근데 반환을 해줄 것이고 이 from 자체가 이제 만약에 2라는 거로 변환이 가능하다라고 하면은 요 윗버전이 호출이 되어가지고 윗버전이 호출된다고 하면은 무조건 반환하는 게 스몰이 될 테니까 요 값이 2로가 나올 것이고 그게 아니라 만약에 얘가 실행이 될 수 없다 즉 자동적으로 이 from이라는 게 2로 변환이 되지 않는다고 하면은 나머지 케이스에 대한 이 ...이 실행이 되어가지고 요 버전으로 이제 얘가 만들어 줄 거예요 결국에는 , 이렇게, 여러가지의 버전으로 우리가 동일한 이름의 함수를 여러개를 오버로딩 해놓은 다음에 컴파일러가 가장 그럴싸하게 이 점점점 보다는 우선순위가 나머지 데이터 높기 때문에 얘를 먼저 하려고 하는데 애정추 얘가 안된다는 거는 우리가 뱉어준 이 from이 to로 변환이 되지 않는 경우니까 요 아이로 들어오게 된다는 걸 이제 이용하는 거죠 , 이렇게, 해가지고 두 갈래의 길을 준 다음에 강제적으로 어떤 길을 선택하게 만들어가지고 그 결과 값을 이용해가지고 이제 판별할 수가 있을 겁니다 그리고 얘 같은 경우 , 사실, 여기 있는 구현부를 아예 뭐 만들어주지 않아도 , 사실, 상관이 없습니다 왜냐면 얘는 애당초 런타임에 뭔가 실행되고 이런 개념이 아니라 지금 요 함수가 어떤 거로 이제 호출이 될지를 예상해가지고 그냥 얘만 이용해가지고 우리가 판별을 하고 있는 거예요 그래서 얘도 결국에는 컴파일 타임에 모든 것이 다 결정이 될 수가 있습니다 근데 이 초록줄을 없애려면은 뭐 이런 식으로 리턴 아무거나 해줘도 상관이 없고요 그래서 결국에는 이걸 어떻게 활용할 수 있느냐 여기서 사용 예제를 한번 보면 이런 식으로 사용할 수가 있어요 Conversion을 한 다음에 어떤 플레이어에서 Knight로의 변환이 있는지 Exist , 자, 그러면은 원래 우리가 플레어에서 나이트로 변환하는거가 되는지를 생각을 해보면 원래는 안되죠 플레어보다 나이트가 더 큰 개념이다 보니까 나이트에서 플레어로 변환하는거는 상관없지만 플레어에서 나이트로 변환하는건 원래 금지가 되어있을겁니다 그래서 요런걸 이제 뭐 테스트를 해볼수 있는거죠 나이트에서 플레어로 변환은 될까요? 아니면은 뭐 나이트에서 개로 변환은 됩니까? 라는 여러가지 질문들을 던져가지고 얘를 뭐 예를 들면 캔컨버트라고 이름을 지어서 한번 , 이렇게, 살펴볼수가 있을거에요 예를 2번, 예를 3번이라고 한다면 얘도 역시나 굉장히 신기하게도 결과 값이 컴파일 타임에 다 , 이렇게, 나오는 걸 볼 수 있습니다 0, 1, 0 즉 요 아이는 된다는 얘기가 되는 거죠 나이트를 플레이어로 변환하는 거는 아무런 문제가 없다라고 지금 얘가 얘기를 해주고 있는 겁니다 그래서 이런 컨버션이라는 우리가 헬퍼 클래스를 이용해 가지고 이런 식으로 컴파일 타임에 얘가 진짜로 변환이 되는지를 테스트할 수 있다라는 걸 , 일단은, 알아봤습니다 , 자, 그리고 이제 진짜 마지막으로 이제 진짜 모든 부품들이 다 준비가 된 것 같으니까 잠시 영역을 좀 접어주고 이제 이어가지고 만들어 줄 아이는 뭐냐면요 벌써 여러 가지를 만들어놨는데 이제 드디어 Pragma, Region, Typecast라는 기능을 만들어 주도록 할 겁니다 Pragma and Region , 자, 그래서 , 일단은, 얘도 좀 어려운 개념인데 어떤 타입 리스트를 , 이렇게, 넘겨 줄 때 예를 들면 우리가 TLE Mage, Knight, Archer를 줬을 때 이 아이들끼리 Mage에서 Knight로 변화는 되는지 Knight에서 Archer로 변화는 되는지를 등등을 테이블을 만들어서 관리를 해주게 될 겁니다 예를 들면 우리가 여기서 3개를 지금 데이터로 입력을 했으면 3x3 배열을 만들어 가지고 거기다가 0, 0, 1 같은 값으로 변환이 되는지를 이제 얘기를 해줄 거에요. 근데 뭐 우리는 지금은 메이즈 아치 나처가 서로 변환이 안되니까 아무런 의미가 없지만 여기다가 예를 들면은 플레이어 같은 타입을 넣어주게 되면은 나이트에서 플레이어의 변환은 되고 아처에서 플레이어의 변환은 되고 메이지에서 플레이어의 변환도 되고 뭐 이런식으로 몇개는 이제 트롤로 뜨게 될겁니다 뭐 이런식으로 , 일단은, 만들어줄수가 있다는 얘기가 되는거죠 그래서 요 테이블을 만들어줄것인데 먼저 , 자, 어 얘가 들고있을 여러가지 각들 중에서 , 일단은, 렌스는 우리가 렌스라는 기능을 만들어놨으니까 TL의 Value를 이용해가지고 추출을 해주게 될겁니다 그 다음에 아래쪽에다 Static으로 Conversion Table을 만들어 주도록 할게요 Convert라고 해가지고 Length와 Length 원래 배열에서도 우리가 딱 컴파일 타임에 고정되는 값만 넣어줄 수 있는데 얘는 이넘 안에 들어간 애다 보니까 얘도 컴파일 타임 안에 결정이 되어가지고 이런 식으로 아무런 위화감 없이 우리가 사용할 수 있던 것도 눈여겨볼 부분이고요 그 다음에 아래에다가 template-tl-boolean type-conversion에 tl-type에 대한 s-convert를 여기다가 , 이렇게, 만들어 주도록 할게요 그 다음에 또 뭘 하면 될까요 , 자, 이제 여기서 여기서 이제 여기 부분이 좀 어려운데 type-conversion이 만약에 생성자가 호출이 됐다고 가정을 하면은 , 사실, 우리가 일반적인 runtime 코드라고 했으면 , 사실, 이런 느낌으로 코드를 만들고 싶은 거예요 지금 뭔가 렌스까지 뺑뺑이를 돌면서 그 다음에 j도 이런식으로 렌스까지 뺑뺑이를 돌면서 결국에는 i번째 j번의 컨벌트가 무엇인지를 우리가 채워주고 싶은 그런 상황인겁니다 그리고 여기서 뭐 채워줄 때는 컨벌션에 뭐 일단 이게 몇번째, 그러니까 이 i번째, j번째에 해당하는 type이 무엇인지 먼저 알아야 되겠죠? 이거는 이런 식으로 구해줄 수가 있어요. from type은 우리가 만들어준 type at을 이용해가지고 tl에 i번째 n은 누구입니까? 마찬가지로 to type 변환 후의 type은 j번째 n은 누구입니까? 라고 한 다음에 만약에 conversion 뭐 from type에서 to type으로의 변환이 존재한다면 그러면은 이 sconvert를 뭐 true로 켜줄 것이고 아니라고 한다면은 얘를 false로 켜주면 되겠죠 이런 코드를 만들고 싶어요 간단하게도 근데 여기서 문제는 여기서 i, j 같은 경우 우리가 type s란 걸 이용하기 위해서는 요 아이들이 계속 변하는 데이터면 안 되고 얘도 역시나 컴파일 타임이 딱 고정되는 값이여야 합니다 이게 약간 좀 어색하죠 이런 코드를 작성해 본 적이 없었다 보면은 그래가지고 요 코드를 지금 이제 만약에 type conversion 이라는 걸 실제로 만들어 보려고 하면은 여기서 바로 이제 에러가 날 겁니다 뭐 예를 들면은 type conversion tl test 만들어보고 싶다 라고 하면은 뒤늦게 얘가 불평을 하게 될 거에요 여기서 비정적 저장기간을 사용하는 변수는 모시기 모시러 하는데 한마디로 i랑 j가 컴파일 타임에 결정이 되지 않아가지고 이 코드를 실행할 수 없다고 지금 불평을 하고 있는 겁니다 그래서 우리가 사실상 실행하고 싶은 코드는 이 코드인데 이것도 역시나 컴파일 타임에 얘가 만들어질 수 있도록 템플릿 흑마법을 최대한 이용해가지고 장난을 쳐야 돼요 그래서 이걸 이제 어떻게 만들어줄 것이냐 우선은 컴파일 타임에 i랑 j라는 이런 숫자들은 컴파일 타임에 정해지는 것이 아니기 때문에 컴파일 타임에 뭔가 구분을 지어가지고 정해질 수 있는 애로 얘를 바꿔줄 겁니다 그래가지고 이럴 때 굉장히 재밌게 사용할 수 있는 애가 하나가 있는데 이런 식으로 int2 type 이라고 해가지고 정수에다가 우리가 하나의 타입으로 얘를 만들어 주도록 할 거예요 무슨 말이냐 이런 느낌으로 밸류를 만들어 가주면 이제 Int2Type 이라는 걸 우리가 사용할 때 Int2Type 0번이랑 Int2Type 1번이랑 , 이렇게, 숫자가 바뀌는 순간에 얘는 아예 별도의 클래스로 인식이 되어 가지고 따로따로 만들어지고 그걸 이용해 가지고 우리가 얘네들이 이제 구분을 해줄 수가 있게 됩니다 1, 2, 3 같은 거랑 좀 느낌이 다른 거죠 그래서 어떤 숫자 자체를 하나의 클래스로 우리가 인지를 하게끔 지금 만들어 준 거예요 그 다음에 여기서 이어서 할 거는 여기서 코드를 살펴보면 , 일단은, 템플릿 역시나 템플릿 흑마법을 이용해 줄 건데 i번과 j번이 고정이 된다고 가정을 하고 그때 make table 이라는 함수를 만들어 가지고 int2 type을 , 이렇게, 만들어 주도록 하겠습니다. int2 type을 이용해 가지고 두 가지의 고정된 타입으로 우리가 이 숫자를 넣어 준다고 가정을 하고 그 다음에 이 코드를 다시 한번 긁어 가지고 , 이렇게, 넣어 준 다음에 , 이렇게, 되면 이제는 아까와는 다르게 이 i랑 j라는 숫자가 뭔가 이런 스택에 들어가는 그런 런타임에 실행되는 그런 변수가 아니라 애당초 이 메이크 테이블이라는 걸 만들어줄 때 우리가 여기다가 넣어주는 인자에 따라 가지고 고정이 되어서 이 메이크 테이블이라는 함수가 , 사실, 여러 개가 만들어지는 개념이라고 생각하면 돼요 그래가지고 요렇게 하면은 또 , 일단은, 아무런 문제가 없이 이제 빌드가 된다고 생각을 하시면 되겠습니다 그건 그렇고 음 여기서 이제 실행을 할 때는 그럼 이제 어떻게 해야 되느냐 먼저 메이크 테이블을 실행해 줄 건데 얘를 이제 포문을 돌아가지고 할 순 없고 요렇게 0번과 0번을 이용해 가지고 얘를 만들어 가지고 실행을 해줄 거에요 그러면은 요 두가지 타입에 대한 메이크 테이블의 함수가 하나가 만들어질 것이고 그래서 0번 0번에 대한 정보가 채워지게 되겠죠 그 다음에 이제 0번에 대한 정보를 채웠으면 그 다음 숫자로 이제 이동을 해야 되는데 그거를 여기다가 , 이렇게, 재기적으로 만들어 줄 겁니다 여기서 약간 멘붕이 오죠? 이게 처음 보는 코드일 확률이 굉장히 높은데 나중에 완성된 걸 분석하면 어느 정도 이해가 갑니다. j 플러스 1을 대상으로 또 , 이렇게, 만들어줘요. 아이고, 여기는 Int2 타입입니다. 아이고, Int2 타입. 그래가지고 이 Maketable를 다시 호출해주고 있는데 얘는 이제 아예 이 타입이 바뀌었다 보니까 타입이 바뀌게 되면은 이 Maketable이라는 , 사실, 이름을 재사용해가지고 재사용만 할 뿐이지 실질적으로는 아예 다른 함수가 만들어지게 될 겁니다 얘는 애당초 템플릿으로 넣어놨기 때문에 이제는 i번과 j플러스 1번에 해당하는 메이크 테이블 함수가 하나가 더 만들어지게 될 것이고 그 아이는 역시나 컴파일 타임에 결정이 될 겁니다 그러다보면 얘를 실행하게 되면은 우리가 00부터 시작을 해가지고 얘가 0, 0을 실행한 다음에 채워주고 그 다음에 0, 1번에 대해서 즉, 이 j가 1 늘어난 상태로 이제 이어가지고 make table이 한 번 더 호출이 된다고 보시면 되는 거죠 그렇게 해가지고 계속 j가 1씩 쭉 늘어나다가 그럼 언젠가는 멈춰야 될 텐데 그 멈추는 거를 우리가 , 이렇게, 만들어주면 되겠습니다 역시나 template int i 그 다음에 make table이라는 걸 만들어줄 것인데 이번에는 int to type I번에다가 맨 마지막에 Int2Type 렌스까지 왔으면 요 버전이 일단 호출이 되게 만들어 준 다음에 요 버전에서 해줄 거는 무엇이냐면은 얘를 더 이상 호출해줄 필요는 없고 이제 우리가 포문을 둘 때 이중포문을 돌 때 항상 하던 게 J값을 0으로 초기화한 다음에 I를 1 늘려가지고 다시 한번 이제 루프를 돌아줘야 됐었죠 이중포문을 생각하면 됩니다 이중포문을 , 이렇게, 어거지로 제기함수를 우리가 만들고 있는 느낌이라고 생각하시면 돼요 그래서 이제 i를 1 늘려주고 그 다음에 int2 type 0번으로 요런 느낌으로 이제 j를 초기화 시켜가지고 다시 i를 쭉, 그니까 i를 다음 값으로 이용해가지고 돌아달라라고 요청을 하는 거죠 그 다음에 마지막으로 i도 이제 1 쭉 늘어나게 될겁니다 이제 이중포문에서 i가 쭉 늘어나가지고 i도 언젠가는 끝까지 도달하게 되겠죠 그러면 더이상 아무 일도 해주면 안되니까 끝나는 걸 이제 여기다가 , 이렇게, 만들어 주도록 할게요 int2 type length 그 다음에 얘는 int2 type에 그냥 아무런 j라는 해당하는 애 즉 이 첫번째 값이 length까지 왔다고 하면은 사실상 더이상 호출할게 없으니까 얘는 그냥 비워두면 되겠습니다 요런식으로 그래서 요렇게 해가지고 이제 이 타이크 컨벤션이라는게 만들어지게 되면은 , 자, 이러면 한번 빌드를 해볼까요? 오케이 아 제가 요 코드가 너무 어지러워가지고 작업을 하다가 오타를 냈는데 , 일단은, 이 V가 대문자가 아니라 소문자로 얘를 맞춰줘야 되고 그럼 얘같은 경우는 타임네임이 아니고요 이걸 잘못했네요 그냥 인트로 만들어줘야 됩니다 즉 우리가 어떤 정수한테 정수한테 우리가 그거에 대한 클래스 타입을 붙여주겠다라는 의미로 만들어 준 것이기 때문에 얘는 이제 타임네임이 아니라 그냥 일반 인트로 , 이렇게, 만들어줘야 되겠어요 네 그래서 다시 한번 빌드를 해주고 CM 서버도 빌드를 해준 다음에 이제 , 이렇게, 통과가 됐고 여기서 한번 브레이크 포인트를 잡아보도록 할게요 그러면은 이제 여기서 테스트가 실행이 된 다음에 여기서 브레이크 포인트가 잡힐 것이고 여기서 결국엔 우리가 내부적으로 만들어준 요 코드들이 막 실행이 되었을 겁니다 그러다 보면은 실리티적으로 테스트를 요 아이를 이제 여기다가 까보면 어.. 아 여기서 안보이네요 테스트의 S컨버트를 우리가 살펴보도록 합시다 그래서 테스트에 s-convert를 이용해가지고 요 아이를 , 일단은, 0 같은걸 살펴보도록 할껀데 , 자, 이런식으로 컨버트가 지금 뜨고 있는데 true, false, false, false, true, true, false, false를 알아서 다 , 이렇게, 사바이사가 만들어 줘 가지고 채워졌다는 걸 알 수가 있는 거죠 그렇게 해가지고 이제 요 테이블을 참조해 가지고 얘가 어떤 의미인지를 보면은 대각선으로는 당연히 다 1이겠죠 자기 자신으로는 변형이 된다는 걸 알 수 있는 거고 1에서 0번은 다 켜져 있다는 걸 볼 수가 있습니다 1, 1, 0, 2, 0, 3, 0 그 의미는 무엇이냐면 1 0 2 0 3 0 즉 메이즈 나잇 아처에서 플레어로 가는 길은 열려있다 얘네들끼리는 캐스팅이 된다라고 얘가 테이블을 , 이렇게, 친절하게 만들어 준 겁니다 그래서 이제 이거를 최대한 잘 활용을 해주면 되는데 매번 마다 , 이렇게, 뭐 스태틱한 타입 컨버션을 만들어주기도 그러니까 이것도 이제 알아서 , 이렇게, 챙겨주도록 inline pool canConvert라는 함수를 만들어주도록 하겠습니다. from번 인덱스에서 to번 인덱스로 만들어줄 때 typeConversion이라는 기체를 알아서 만들어줄 것인데 한 번만 만들어주게 static으로 , 이렇게, 만들어줄 것이고요. 얘가 만들어지게 되면은 내부적으로 maketable 호출이 되어가지고 테이블이 빵 채워지게 될 것이니까 그 다음에는 return sconvert를 이용해가지고 from과 to로 , 이렇게, 만들어 주도록 하겠습니다 물론 이 테이블이 채워지는 거는 런타임에 채워지긴 하는데 얘네들을 채워야 된다는 이 식 자체가 즉 이 아이들을 이용하는 것 자체가 , 일단은, 컴파일 타임에 된다고 , 일단은, 생각을 하는 게 맞겠습니다 용어를 제가 섞은 것 같아 가지고 네 그렇게 해가지고 뭐 요렇게 , 일단은, 만들어졌다고 가정을 할 수가 있겠구요 , 자, 그 다음에 어... 이제 이어가지고 이거를 좀 편하게 사용할 수 있는 그런 여러가지 기능들을 만들어 보도록 하겠습니다 이제 진자진자 거의 끝나가요 type name from 요 아이는 첫 번째로는 type cast라는 함수를 만들어 줄 것인데 우리가 어떤 포인터, from 포인터를 넣어준 다음에 그걸 우리가 변환하고 싶은 to라는 아이를 넣어줄 것인데 그걸로 얘가 변환을 해주게 될 겁니다. 일종의 다이나믹 캐스트를 만들어 준 거죠. 만약에 포인터가 null이면은 더 이상 볼 것도 없이 그냥 nullptr을 뱉어줄 것이고 그 다음에 이제 우리가 이 from이라는 객체에다가 tl이라는 타입 네임을 우리가 내부적으로 만들어줄 거예요. 그러니까 정의를 해줄 거예요. 이건 나중에 완성을 해주면 되는데 일단 , 이렇게, 만들어주시면 되겠고요. from의 tl 이라는게 누구인지 이 type list type 을 찾아가지고 만약에 type conversion 을 해가지고 can convert 를 호출한 다음에 우리가 넣어줄 어떤 타입 아이디를 넣어줄 것인데 그 아이를 이용해가지고 서칭을 할 것이고 두번째로 2에 대해서는 얘는 인덱스 오브를 이용해가지고 TL에 대해서 2타입이 있는지를 체크할 것인데 혹시라도 이 2타입에 포인터까지 포함을 해줄 수도 있으니까 리무브 포인터 타입을 이용해가지고 , 자, 이것도 이제 뭐 템플릿을 공부 안하셨으면 굉장히 어려울 수 있는데 , 일단은, 템플릿을 너무 깊게 다룰 수는 없으니까 참고하시면 되겠어요 요 아이는 포인터를 없애준 타입을 뱉어주게 됩니다 그래서 우리가 뭐 나이트 포인터를 넣어줬으면은 그냥 나이트 타입으로 얘를 인지를 한다고 보시면 되겠어요 그 다음에 여기다가 어 이 나이트 타입의 위치는 인덱스는 얼마인지를 찾아가지고 그거를 요기다가 요렇게 넣어줘서 만약에 얘가 트루라고 하면은 아하 안전하구나 라고 해가지고 스태틱 캐스트를 요렇게 바로 해줄겁니다 이제는 안전한거고 그게 아니라고 하면은 얘가 변환이 안 된다는 얘기가 되는 거니까 , 이렇게, 널 포인터를 뱉어 주도록 하겠습니다. , 자, 그 다음에 뭐 비슷한 느낌으로 하나를 더 만들어 줄 것인데 그냥 얘를 일단 복붙할게요. 복붙을 한 다음에 이번에는 타입 캐스팅은 아니고 캐스트가 되는지 여부를 체크를 해 주도록 합시다. 이게 C Sharp으로 치면은 그 Is랑 Is 문법을 지금 만든다고 보시면 되겠어요. 이게 뭐 캐스팅이 되느냐 안 되느냐 여부만 체크하고 싶다고 하면은 뭐 CanCast를 이제 호출하도록 합시다. 그래서 얘는 똑같이 Ptr이 너리면 false, 너리면 false. 그리고 여기서는 CanConvert가 되면은 그냥 true로 이턴해줄 것이니까 이 자체를 이턴해주면 되겠네요. , 이렇게, 끊어가지고 얘를 뱉어주도록 하겠습니다. , 자, 그러면은 이제 이거를 최종적으로 이제 어떻게 사용하면 되느냐 요기다가 우리가 사용할 만약에 플레어랑 나이트 메이지 대상으로 우리가 사용한다고 하면은 먼저 첫번째 조건이 요런 타입 아이디라는걸 만들어줘야 됩니다 요기 내부에 우리가 이름을 정해가지고 예를 들어서 타입 아이디라고 요렇게 사용을 하도록 할게요 이 이름은 상관없구요 그냥 인트 타입이라고 가정을 하고 그 다음에 요기다가 내부적으로 usingTL은 어떤 어떤 타입 리스트를 사용할 것이다 를 정해줘야 됩니다 예를 들면은 우리가 뭐 UI를 사용하겠다 라고 정해놨다고 하면은 얘를 먼저 , 이렇게, 전방선언을 한과 동시에 타입 리스트를 , 이렇게, 만들어 줄 수 있을 거에요 그러면 이제 요 타입 리스트를 사용하겠다라고 usingTL은 TL이라고 , 이렇게, 만들어 주면 되겠죠 , 자, 그래가지고 여기서 이제 내부적으로 사용할 때는 이 type id 라는게 있다고 가정을 하고 이 id 를 먼저 생성자에서 채워주게 될 겁니다 예를 들면은 type id 는 index of tl의 player의 value 이다라는 걸 입력을 하는 거죠 여기서 에러나는 것은 우리가 헤더를 여기 아래에다가 넣어 줘 가지고 그런 건데 이거를 core-b스위치에다가 옵젝트컬 안에다가 우리가 공식으로 넣어 주도록 하겠습니다 그 다음에 서버코어를 다시 한번 빌드를 해주고 돌아오면은 이제 여기서 TL 이라는 것을 유증을 해주는 이유는 우리가 여기 내부 코드에서 이름 컨벤션 자체를 , 이렇게, 만들어놨습니다. 이 from 이라는 클래스의 TL을 사용할 것이다. 그렇기 때문에 이 TL 자체가 우리가 어떤 타입 리스트를 사용할 것인지를 여기다가 , 이렇게, 정의를 해주는 상태라고 보시면 되겠어요. 그래서 찾아주는 거죠. , 자, 그래가지고 요 typeid라는 것 자체가 이제 얘는 , 사실, runtime에 들어가는 그 typeid라고 볼 수가 있겠어요? 얘가 어떤 타입에 해당하는지를 생성자에서 찾아가지고 그 아이디를 자신 객체에다가 박아주게 될 겁니다. 그러면은 이제 마찬가지로 night 같은 경우에도 똑같은 코드를 이제 반복해서 만들어줄 건데 코드가 너무 반복되니까 이런 것도 뭐... 아래에다가 예를 들면은 define declare tl 이라고 해가지고 , 자, 요코드 using을 한 다음에 typeid를 넣어주는 요 부분을 같이 여기다가 넣어주도록 하겠습니다. 얘를 하고 그 다음에 이런 식으로 typeid도 정의를 해주고 뭐 요런 코드를 , 일단은, declare tl 이라고 이름을 불러주도록 하고 그 다음에 init tl 이라고 해가지고 얘는 자기가 어떤 타입인지를 넣어주게 되면은 typeid는 index of TL의 타입을 찾아준 다음에 그 아이의 밸류를 타입 아이디에다가 넣어주겠다라는 걸 , 이렇게, 만들어줄 수가 있을 거예요. 그러면 이제 뭐 앞으로 할 때는 얘를 사용할 때 뭐 declare TL을 한번 만들어주고 생성자에서는 init TL이라고 해가지고 아이고 init TL이라고 한 다음에 자기 자신의 타입을 , 이렇게, 넣어주면 되겠습니다. 그리고 나머지 애들도 똑같이 얘는 declare는 필요 없고 player가 이미 갖고 있으니까 night , 이렇게, 넣어주고 그 다음에 마지막으로 메이즈 같은 경우에도 , 이렇게, 넣어주면 되겠죠 아 얘가 지금 protected로 넣어놔야 되는데 일단 여기다가 넣어도록 할게요 이 변수를 접근할 수 있어야 될 테니까 declare tl을 , 이렇게, 넣어줄 것이고 그 다음에 마찬가지로 archer도 이런 식으로 넣어주게 되면은 객체가 만들어질 때 자기 자신의 타입이 무엇인지를 typeid라는 이 변수에다가 01234 같은 숫자를 넣어주게 될 것이고 이제 그걸 이용해가지고 우리가 판별을 해줄 수가 있을 겁니다 , 사실, 처음에 우리가 이넘을 만들어가지고 숫자를 지정한 다음에 캐스팅을 했던 거랑 완전히 , 사실, 똑같은 내용이긴 한데 그걸 이런 식으로 약간 자동화 처리를 해가지고 사용하고 있다라고 볼 수가 있는 거죠 , 자, 그럼 이제 이거를 최종적으로 테스트를 해볼 건데 이 짓을 왜 했는지를 다시 한번 살펴보자면 얘는 일단 없애줘도 되고요 , 이렇게, 할 수가 있겠죠? , 자, 영역을 새로 집어준 다음에 요 아이들은 , 일단은, 주석처리를 해주도록 하겠습니다. 필요 없으니까. 그 다음에 우리가 해주고 싶은 거는 뭐 요런 상황인거죠? 플레어를 새로 만들어준 다음에 뭐 플레어를 날려줄 것인데 중간에다가 뭔가 캔 캐스트 얘 캐스트 할 수 있느냐를 테스트하고 싶다라고 하면은 요런 식으로 우리가 테스트할 수 있을 거예요. 그리고 역시나 나이트로 만약에 우리가 변환을 하고 싶다라고 하면은 타이크 캐스트를 통해 가지고 요 아이를 이런 식으로 변환해줘 라고 요청을 해줄 수도 있다는 얘기가 되는 거죠 여기서 breakpoint를 잡아가지고 한번 실행을 해보도록 하겠습니다 , 자, 그러면 코드가 실행이 됐고 여기서 멈춘 다음에 cancast first 그 다음에 night로 변환도 실패한 걸 볼 수 있습니다 플레이어에서 night의 변환은 안전하지 않으니까 얘가 자동으로 , 이렇게, 사실상 dynamic cast랑 마찬가지의 작업을 해줬다고 볼 수 있는 거죠 근데 만약에 우리가 처음에 만들어 준 게 Knight라고 했으면 이 객체가 만들어질 때 애당초 자신의 ID가 박혀 있을 거예요 여기 생성자에서 이 부분이 이제 실행이 되겠죠 물론 플레이어도 이 작업을 해주지만 얘가 뒤늦게 실행이 되면서 덮었을 테니까 자기 자신의 타입 번호를 제대로 들고 있을 겁니다 그렇기 때문에 이 상태에서 똑같이 다시 한번 호출을 해주게 되면은 이제는 굉장히 신기하게 트루라 그리고 , 이렇게, 변환이 제대로 되는 걸 볼 수가 있습니다. 즉, 완전히 자신의 타입의 그 번호를 이용해 가지고 다이나믹 캐스트랑 완전히 똑같이 작업을 하고 있다는 걸 볼 수가 있는 거죠. 근데 이미 다 계산된 이 테이블을 이용해 가지고 이 테이블만 빠르게 참고해 가지고 이거를 체크한 다음에 그 다음에 자기 자신을 스태틱 캐스트로 컨버트를 하고 있다라는 작업을 해주고 있는 겁니다. 그렇게 해가지고 , 이렇게, 사용을 했던 프로젝트가 있었는데 이게 한번 만들 때는 어려운데 이게 은근히 굉장히 편리합니다 얘를 한번 만들어두면 왜 좋냐면은 이제 나중에 우리가 막 타입을 체크하고 이런 걸 할 필요 없이 그냥 무조건 일단 타이캐스팅 해가지고 체크를 한 다음에 얘가 널 포인터인지 아닌지를 참고해가지고 얘가 널인지 아닌지를 봐가지고 얘 널이었으면 애당초가 나이트가 아니라는 의미가 됐겠죠 요런 식으로 그냥 쿨하게 작업할 수 있다는 얘기 되는 거죠 아니면 거꾸로 얘가 null이 아니었다고 하면 얘가 애당초 night였다는 뜻이 되는 거니까 그냥 이어가지고 얘가 night라고 가정을 하고 계속 뭔가를 코드를 만든다거나 하는 식으로 이제 실행할 수 있다는 얘기가 되는 겁니다 물론 포인터뿐만 아니라 이제 그러면 나중에 우리 Shared Pointer 쓰기로 했는데 Shared Pointer는 어떻게 해야 되느냐 그것도 똑같은 방법으로 얘를 이제 Shared Pointer 대상으로도 사용할 수 있게 이제 하나를 더 만들어주면 됩니다 예를 들면 뭐 이쪽에다가 Shared PTR From으로 이제 하나를 만들어 줄 것이고 요 아이는 Shared PTR To로 , 이렇게, 열어주면은 이제 만약에 얘가 Shared PTR 이라고 따면은 요 버전이 이제 알아서 컴펠러가 골라주게 될 겁니다 그러면 나머지 코드는 뭐 딱히 변할 필요 없고 요 부분에서 우리가 어 스마트 포인터 Shared PTR 대상으로 할 때는 Static Pointer Cast 라는 요 기능을 이용해 가지고 만들면 되죠 , 이렇게, 가지고 똑같이 그냥 변환을 해줄 수가 있고 마찬가지로 캔 캐스트도 마찬가지로 요 생 포인터 버전이 아니라 Shared PTR 버전이 필요하다고 하면은 이것도 이런 식으로 만들어 주면 되겠습니다 from 버전을 이용해가지고 요 아이가 있을 때 얘가 to type으로 변환이 되는지를 보고 싶다 라고 하면은 어 그냥 , 이렇게, 얘는 뭐 바꿀 필요도 없을 것 같네요 그냥 , 이렇게, 똑같이 만들어 주게 되면은 이제 shared pointer로도 잘 작동하는 코드가 완성이 된다고 보시면 되겠습니다 그래서 예를 들면은 , 자, 얘도 일단 잠시 주석처리를 하고 또 새로운 영역을 찝어가지고 한번 테스트를 해보자면 , 자, shared ptr night를 만들어 줄 것인데 우리가 Make Shared라는 걸 만들어줬었죠 지난 시간에 이 Knight를 이용해가지고 만들어주면 얘가 이제 이 영역을 벗어나면 알아서 삭제가 될 것이고 그 다음에 Type 테스트를 통해 가지고 얘가 Player로 변환이 되는지 뭐 이런 식으로 우리가 테스트를 해볼 수가 있을 겁니다 얘가 플레어 타입의 쉐어드 포인터로 다시 변환이 되냐 안되냐를 이런식으로 살펴볼 수가 있겠죠 마찬가지로 캔 캐스트 같은 것도 얘가 근데 플레어로 캐스팅은 되는건 맞냐? 라는 질문을 요렇게 던져볼 수가 있을거에요 여기다가 브레이크 포인트를 잡아가지고 실행을 해보면 나이트는 당연히 플레어로 변환이 되야되니까 플레어 정상적으로 얘가 캐스팅이 되고 캔캐스트는 투로로 뜨는 걸 볼 수가 있습니다 근데 만약에 완전 뜬금없는 애로 얘를 캐스팅하고 있다 뭐 예를 들면은 얘는 지금 플레어로 들고 있기는 한데 갑자기 뜬금없이 얘를 타이 캐스트를 뭐 아처로 한다거나 요런 상황이 되면은 , 사실, 실패해야 되겠죠 다이나믹 캐스트랑 완전 똑같이 동작을 하게 될 테니까 얘가 아쳐로의 변환이 실패하게 될 겁니다 얘는 메이지로 한번 변환을 해볼까요 요런 느낌으로 , 일단은, 테스트를 해보면 그리고 실행을 해보면 플레이어가 아쳐로 했는데 얘는 셔어 포인트가 MT로 떴죠 왜냐면 애단초 얘는 나이트였으니까 원본이 그리고 캔 캐스트도 실패한다는 걸 볼 수가 있습니다 , 자, 이렇게, 해가지고 굉장히 긴 내용이었고 , 사실, 전 처음에 요 코드를 봤을 때 전혀 이해 못했어요 고해성자를 하자면 저도 뭔 소리인지 하나도 이해를 못했는데 뒤늦게 그 아까 말한 그 빨간 책을 보면서 그 내용 똑같은 내용이 있더라구요 그래가지고 이걸 보면서 굉장히 많은 그런 공부를 하게 되었습니다 그래서 이 기회에 템플릿 흑마법에 대해서 좀 관심을 갖게 되는 계기가 되셨기를 바라면서 이걸 , 일단은, 준비해 봤고요 이런 식으로 우리가 자체적으로 만드는 좀 빠르게 동작하는 다이나믹 퀘스트를 만들어도 된다라는 걸 , 일단은, 보여드리고 싶었습니다 이런 내용을 뭐 굳이 서버에 넣어도 되느냐라고 한다면은 뭐 이왕 만든 거 쓰셔도 되고 아니면은 그냥 나는 원래 방법대로 그냥 이넘을 이용해가지고 거기다가 넣어준 다음에 헬퍼함수를 여러개 만들어가지고 캐스팅하는 걸 직접 하고 싶다고 하면은 그것도 뭐 , 사실, 크게 문제가 되는 방법은 아닙니다 , 자, 이렇게, 해가지고 타이프캐스트에 대한 내용을 요렇게 간단하게 마치도록 할게요.