자, 이제 지난 시간에 이어서 이번 시간에는 샌드 버퍼 작업을 해보고자 하는데요 리시브 버퍼는 뭐 그래도 비교적 간단했었는데 샌드 쪽은 리시브랑은 완전히 다른 그런 문제가 기다리고 있었다고 말씀을 드린 적 있었죠 지난번에 우리가 간단하게 샌드 이벤트 방식으로 얘를 만들어 주기는 했는데 지금 이 방식의 문제가 무엇인지 다시 한번 복귀를 해보자면 가장 심각한 문제는 여기 복사 비용이 든다는 거죠 이런식으로 매번마다 복사를 해야 되는데 어 나중에 가면은 , 자, 여기 우리가 클라이언트나 서버쪽 콘텐츠에서 샌드를 할 일이 비일비재하게 생기게 될 겁니다 이런 식으로 근데 지금은 그냥 단순하게 하기 위해서 에코 서버를 만들어 가지고 자기가 받은 내용을 그대로 다시 , 이렇게, 반사해주는 식으로 만들어 놨었죠 그 다음에 여기 샌드 내부에서 여기서 이제 데이터를 복사해 가지고 이벤트한테 물고 있게끔 만들어 줬습니다 근데 , 이렇게, 뭐 한 명한테만 데이터를 전송하는 경우도 간혹 있긴 하겠지만 대부분의 경우에서 MMO를 만들 때는 주변에 있는 모든 애들한테 똑같은 정보를 뿌리는 경우가 굉장히 자주 생기게 될 겁니다 예를 들면은 몬스터가 스폰이 되었다라는 사실을 한 유저한테만 알려주는 게 아니라 그 스폰되는 위치에 주변에 있는 모든 유저들한테 우리가 싸그리 다 보내줘야 되기 때문에 한마디로 예를 들면 유저가 100명이 몰렸다고 하면 똑같은 정보를 100명한테 우리가 보내야 될 일이 생길 수도 있어요 지금 방식에서는 100명한테 만약에 보낸다고 하면 그 애들마다 한 명 한 명씩 다 , 이렇게, 맴 커피를 해가지고 데이터를 복사해가지고 그 유저가 들고 있게끔 뭔가 , 이렇게, 만들어주는 부분이 들어갔는데 이 부분이 진짜 이제 너무 마음에 안 든다는 거죠 , 자, 그래가지고 샌드 버퍼는 좀 어려우니까 여러 번에 걸쳐 가지고 만들어 볼 건데 오늘은 가장 직관적이고 그리고 간단한 방법으로 , 일단은, 만들어 보도록 하겠습니다 , 자, 그래가지고 , 일단은, 뭐 샌드 버퍼라는 새로운 클래스를 , 일단은, 만들어 놔가지고 여기서 이제 작업을 이어가 보도록 할게요 , 자, 샌드버퍼 헤더는 왼쪽으로 그 다음에 cpp는 오른쪽으로 이동을 시키고 , 자, 요렇게 , 일단은, 시작을 해보도록 하겠습니다 , 자, 샌드버퍼 새 식구를 , 일단은, 환영해보도록 합시다 샌드버퍼 그러면은 사실은 우리가 기존에 만들었던 이 방식 자체를 클래스화해서 관리를 하면 되니까 , 이렇게, 간단하게 작업을 해 보도록 할게요 데이터는 , 일단은, 동적 배열로 그냥 벡터로 , 이렇게, 들고 있도록 할 것이고 그 다음에 샌드 버퍼를 만들어 줄 때 생성자에서 버퍼 사이즈를 지정을 해 주도록 합시다 소멸자는 딱히 필요 없을 것 같지만 , 일단은, 만들어주긴 할 것이고 그 다음에 여기서 데이터 포인터에다가 접근을 하는 함수를 일단 하나 만들어줄 거고요 buffer.data를 , 이렇게, 뱉어주면 되겠고 그 다음에 이제 이 데이터 버퍼만큼을 다 풀로 사용할 수도 있겠지만 버퍼는 크게 잡되 그 일부분만 사용할 수도 있다 보니까 어 이거를 라이트 사이즈라는 변수를 하나를 또 두도록 하겠습니다 얘는 실질적으로 이 버퍼를 사용하는 크기를 얘기하는 거고 이 버퍼의 크기는 이 라이트 사이즈보다 더 클 수 있다는 얘기가 되는 겁니다 , 자, 그러니까 이거를 이름하여 라이트 사이즈라고 해가지고 return 라이트 사이즈를 그대로 뱉어 줄 것이고 실제 버퍼의 크기 자체는 Capacity란 용어를 활용합시다 , 이렇게, 일단은, 만들어 보도록 할게요. return, 얘 같은 경우는 static cast int 32를 한 다음에 버퍼의 사이즈를 , 이렇게, 뱉어주면 되겠죠. , 자, 이렇게, 일단은, 만들어 보도록 하겠습니다. 그 다음에 copy data 라고 해가지고 이 데이터 안에다가 데이터를 복사하는 그런 함수를 , 일단은, 이렇게, 만들어 놓고 , 자, 이쯤에서 , 일단은, 완료가 된 것 같네요 그리고 혹시 모르니까 enable share from this 까지 , 일단은, 적용을 시켜 줘 가지고 혹시라도 자기 자신에 대한 스마트 포인터가 필요할 수도 있으니 그렇게 만들어 주도록 하겠습니다 , 자, 그 다음에 하나씩 , 일단은, 구현부를 다 , 이렇게, 만들어 주고요 일단 카피 데이터 까지만 만들어 놓으면 되겠네요 , 자, 그 다음에 오른쪽으로 넘어가 가지고 이어서 작업을 해 보도록 하겠습니다 샌드 버퍼 같은 경우에는 이 버퍼 사이즈라는 것을 인저로 받았으면은 뭐 그냥 간단하게 버퍼를 리사이즈 해가지고 요 버퍼 사이즈 크기만큼으로 만들어 두도록 하겠습니다 동적 배열이다 보니까 , 이렇게, 사용할 것이고 그 다음에 카피 데이터 같은 경우에는 이제 요 버퍼에다가 데이터를 밀어 넣는 작업을 하게 될 겁니다 어 근데 혹시 모르니까 요게 어서트 크래쉬를 한번 해가지고 오버플로우가 일어나지 않는지를 한번 체크를 해보도록 할게요. 즉, 이 여유 공간, 캐페시티가 우리가 복수하려는 공간보다는 커야 된다라고 , 일단은, 이렇게, 체크를 하는 것이고 그 다음에 램 카피를 그냥 해가지고 버퍼 위치에다가 데이터를 그냥 , 이렇게, 복붙 하도록 하겠습니다 뭐 어찌되건 한번은 , 일단은, 데이터를 우리 버퍼에다가 복사를 해주긴 해야되겠죠 그 다음에 뭐 이어가지고 라이트 사이즈는 얼마얼마이다 요 렌스로 얘를 채워줘가지고 이제 사용을 해주면 되겠습니다 간단하게 , 일단은, 샌드 버퍼를 만들어 봤어요 , 자, 그러면은 이제 실질적으로 이 아이를 사용하는 부분을 다시 복귀를 해보면 예를 들면 우리로 치면 게임 서버 이쪽 부분이 되는 거죠 이 게임 서버 쪽 부분에서 데이터를 보낼 때 이런 식으로 샌들을 바로 호출하는 게 아니라 이쪽에서 샌드 버퍼를 하나를 만들어 가지고 이제 데이터를 넣어준 다음에 우리한테 넘겨주게 될 겁니다 , 자, 그런데 이것도 결국에는 내부적으로 이 샌드 안에 들어간 다음에 결국에는 얘도 일종의 레퍼런스 카운팅이 이제 필요해집니다 왜냐면은 내가 이 샌드 버퍼를 하나만 할당해서 만들어 준 다음에 여러 명한테 꽂아줘 가지고 레지스터를 뿅 해버릴 텐데 레지스터 샌드를 하는 순간에 WSA 샌드까지 만약에 호출이 됐으면 우리의 이 세션과 마찬가지로 우리가 실질적으로 여기 넣어준 이 버퍼의 데이터도 데이터가 실질적으로 다 사용이 돼서 실질적으로 이 WS 샌드가 완료 통지가 올 때까지는 항상 유지시켜 줘야 된다고 했었죠. 그렇기 때문에 결국에는 이 샌드 버퍼도 레퍼런스 카운팅의 대상이 되어야 된다고 , 일단은, 볼 수가 있겠습니다. , 자, 그래서 여기 타입에 가가지고 이 아래 뽑고 탄 다음에 샌드 버퍼도 관리 대상으로 하기 위해서 샌드 버퍼 랩이라는 거로 , 일단은, 이렇게, 관리를 해 주도록 하겠습니다. , 자, 그 다음에 다시 닫아가지고 결국 잠시 서버코어 한 번만 , 이렇게, 빌드를 해주고 위쪽에 가가지고 결국에는 게임 세션 쪽에서 얘를 사용할 때는 뭐 이런 식으로 샌드 버퍼를 만들어 준 다음에 나중에는 뭐 풀을 사용하거나 해서 만들어도 되겠지만 , 일단은, 그냥 간단하게 실시간으로 , 이렇게, 만들어 보도록 할게요 대충 4kb를 만들어 주고 그 다음에 여기서 뭔가 카피 데이터를 통해 가지고 데이터를 일단 한 번은 넣어 주도록 할 겁니다 넣어 준 다음에 요 데이터 자체를 이제 샌드에다가 , 이렇게, 건네주게 된다는 얘기가 되는 거죠 , 자, 여기 지금 에러가 뜨는 거는 코어 P스위치에 가 가지고 이제 샌드 버퍼는 이리저리 많이 활용할 거기 때문에 샌드 버퍼를 , 이렇게, 전혀 어디서든 활용할 수 있게 코어 P스위치에다가 , 일단은, 넣어 주도록 할 거고요 , 자, 그 다음에 샌드하는 부분에 가가지고 요 부분을 바이트 포인터와 렌스를 받는게 아니라 아예 아싸리 샌드 버퍼만 받을 수 있게 요 부분을 그냥 강제로 수정을 해보도록 할게요 , 자, 근데 , 일단은, 위에 있던 거를 잠시 컨닝하기 위해서 복붙한 다음에 샌드 버퍼 레퍼런스를 받는 버전을 하나를 더 만들어주고 다 고친 다음에 얘를 날려주도록 하겠습니다 , 자, 요렇게 , 일단은, 만들어주도록 할게요 네 그래서 , 일단은, 요 코드가 아니라 요 코드로 이제는 실질적으로 다 옮겨야 된다라는 얘기가 되는 거고요 , 자, 그 다음에 우리가 여기서 위에서 보면은 샌드 이벤트를 호출할 때마다 매번 , 이렇게, 뉴를 해가지고 만들어주고 나중에 삭제를 하고 있었죠 이 방법보다는 제가 이전에도 살짝 이 부분에서 언급을 드렸지만 어차피 리저스터 샌드를 샌드를 할 때마다 매번 마다 막 호출하기보다는 그냥 리시브와 마찬가지로 한번 걸어주고 SS 샌드가 끝나 가지고 프로세스 샌드로 이제 완료 통지가 올 때 그 다음 리저스터 샌드를 순차적으로 호출시키는 게 뭐 성능상 조금 이점이 있다고 했었죠 그래야지만 패킷을 막 이리저리 막 보낸다고 해도 걔네들 최대한 뭉쳐서 보낼 수가 있다고 했습니다 , 자, 이거는 잘 와닿지 않을 수도 있는데 오늘 완성된 코드를 보면 좀 이해가 가실 거에요 아주 결국에는 샌드 이벤트를 , 이렇게, 매번마다 만들지 않고 얘도 우리가 지금까지 뭐 리시브랑 다른 애들을 관리했던 것처럼 요기에다가 , 이렇게, 멤버 변수로 샌드 이벤트를 들고 그냥 얘를 재사용하겠다라는 얘기가 되는 겁니다 샌드를 여러 번 보내도 얘를 한 번만 걸어주고 그 다음 턴에 또 걸어주고 이런 식으로 모아서 관리를 해주게 될 거예요 그래서 , 이렇게, 일단 샌드 이벤트는 내부적으로 관리한다 라고 볼 수가 있는 거고요 먼저 해야 될 거는 현재 레지스터 샌드가 걸리지 않은 상태라면 걸어준다 라는 얘기를 해야 되고요 그 다음에 만약에 그러면은 이미 레지스터 샌드가 이미 실행되는 중이어 가지고 내가 당장 WS 샌드를 할 수 없다 즉 샌드 이벤트를 지금 아직까지 사용할 수 없다고 하면은 걔는 그럼 이제 어떻게 하느냐 그냥 Q에다가만 놓고 빠져나오도록 할 겁니다 따라서 이거를 뭐 예를 들면 Q로 , 일단은, 잠시 들고 있도록 할게요 샌드 버퍼 샌드 Q 라고 , 일단은, 요렇게 이름을 지어보도록 하겠습니다 줄 좀 좀 찍어 주도록 할게요 , 이렇게, 그 다음에 , 일단은, 아토믹 타입으로 샌드 리지스터드 여부를 추적을 할 건데 리지스터드 처음에는 false인 상태였다가 얘가 false면은 보내도록 , 일단은, 유도를 해주도록 하겠습니다 즉 오늘 이제 두 가지가 추가가 된 거죠 , 자, 멀티셋 환경이다 보니까 일단 라이트락을 걸고 진행을 해볼 건데 나중에 가면은 뭐 요 샌드큐는 뭐 락프리큐나 다른 구조를 일단 바꿀 수도 있습니다 그건 참고하시고 , 일단은, 간단 간단하게 만들기 위해서 일단 락을 건 다음에 먼저 샌드큐에다가 요 새로운 새로 전달해야 되는 샌드 버퍼를 일단 , 이렇게, 밀어넣어서 푸쉬를 해줄거에요 그 다음에 어... 여기서 샌드 리지스터를 체크해가지고 엑스체인지를 해줄건데 얘를 true로 설정하고 싶은데 이전의 값이 false였다고 하면은 리지스터 샌드를 때려줄겁니다 , 자, 요런식으로 요 코드가 이게 오랜만에 등장한 Atomic 함수죠 이게 사실상 이런 의미입니다 sendRegistered가 만약에 false라고 하면은 sendRegister를 true로 설정하고 register send를 호출하겠다라는 의미랑 똑같은 얘기입니다 이게 Atomic이기 때문에 , 이렇게, 한 거고 뭐 락을 잡았으니까 굳이 아토믹 타입을 사용하지 않고 그냥 일반 불리안을 사용해도 되지 않느냐? 뭐 물론 그래도 돼요 근데 혹시라도 나중에 샌드큐를 락프리 방식으로 바꾼다거나 할 때를 대비해가지고 , 일단은, 그냥 , 이렇게, 만들어 봤습니다 네 그래서 요 코드랑 요 코드랑 아래 코드랑 똑같은 의미라고 보시면 되는거고 Exchange에서 뱉어주는 값이 원래 이전에 얘를 넣기 이전의 값을 뱉어주니까 이전의 값이 false였다고 하면은 이제 요 코드가 이제 , 이렇게, 되는 거죠 그러면 그때 true 값 들어가고 그 다음에 register send가 요렇게 일단 들어가게 될 겁니다 , 자, 그건 그렇고 지금 register send 같은 경우에 이제 더 이상 필요 없으니까 윗버전은 삭제를 할 거구요 그리고 삭제를 하고 보니까 리지스터 샌드 같은 경우에도 기존에 원래 했던 그 흔적이 남아있기 때문에 여기서 샌드 이벤트를 , 이렇게, 넣어주고 있다는 걸 볼 수가 있는데 우리가 이제는 얘를 멤버 변수를 들고 있어서 얘를 한 번만 재생할 것이기 때문에 매버마다 만들어 줄 것이 아니기 때문에 여기 프로세스랑 리지스터 샌드 부분에서 관련된 부분을 , 일단은, 다 삭제를 해주도록 할게요 프로세스인데 샌드 쪽에서도 , 자, 샌드 이벤트를 , 이렇게, 일단은, 삭제를 해주고요 그 다음에 뭐 문제가 일어나는 부분을 찾아가지고 하나씩 고쳐주면 되겠죠 네 여기 , 일단은, 뭐 에러를 당장 없애기 위해서는 여기 레지스터 아이고 샌드 이벤트 쪽 코드를 , 일단은, 교체를 해주도록 하겠습니다 샌드 이벤트 점 퍼퍼 샌드 이벤트 점 버퍼 이런식으로 수정되면 될것이고 여기서는 , 이렇게, 주소값을 이용하도록 그 다음에 여기서도 점을 찍어주면 되고 지금 동적활동한게 아니니까 엑스 딜리트는 해줄 필요가 없겠죠 이런식으로 , 일단은, 수정을 해볼거고 그 다음에 또 찾아보면은 프로세스 샌드 같은 경우도 마찬가지로 점을 찍어주고 언더바 찍어주고 일리즈 레퍼런스는 이제 , 이렇게, 호출이 될 것이고 그 다음에 뭐 또 문제가 없는지 찾아보면은 프로세스 샌드를 처음에 호출한 요 부분에서도 마찬가지로 , 이렇게, 제거를 해주면 이제 완벽하게 기존의 흔적이 , 일단은, 사라졌습니다 그래가지고 다시 리지스터 샌드를 살펴보자면 여기서 지금 해주고 있는 부분이 , 일단은, 먼저 리지스터 샌드도 마찬가지로 한 번에 한 스레드만 일단 호출을 해주게 될 겁니다 우리가 만든 방식에서 그래가지고 그 값을 우리가 샌드 리지스터드 불리언 값을 통해 가지고 내가 얘를 실행해야 되는지 말지를 판단하고 있고요 들어왔다고 하면은 그 다음에 얘가 해야 되는 거는 무엇이냐 먼저 이 리지스터 나머지 애들이랑 굉장히 비슷한 패턴을 보이게 되겠죠. 요 부분도 이제 똑같이 복붙 해준 다음에 샌드 이벤트로 얘를 바꿔칭 해가지고 우리가 IOCP에다가 WC 샌드를 호출할 준비를 , 일단은, 해주도록 하겠습니다. , 자, 그 다음에 이제 살짝 달라져야 되는 부분은 뭐냐면은 여기서 우리가 데이터를 하나만 꺼내 가지고 지금 , 이렇게, 복사를 해주고 있었어요 , 자, 근데 이 버퍼라는 것 자체가 애당초 우리가 임시적으로 만들어 놓은 것인데 지금은 애당초 요 버퍼를 더 이상 사용하지 않을 것이고 요 역할을 샌드큐가 지금 대신 해주고 있죠 그래가지고 처음에 보면은 어 샌드큐 자체에다가 우리가 이런 식으로 데이터를 밀어 넣어준다는 걸 볼 수가 있습니다. 즉 여기에 내가 보낼 데이터를 지금 쌓아놓은 상태고 그 상태에서 우리가 레지스터를 한다는 얘기는 이 큐에다가 있는 데이터를 꺼내 가지고 걔를 이제 보내줘야 된다는 차이가 생기게 되는 거죠. 즉 아까랑은 살짝 흐름이 달라지게 됩니다. , 자, 그래가지고 이제 먼저 여기서 해줄거는 보낼 데이터를 , 일단은, 샌드 이벤트에 등록을 시켜줄거에요 , 자, 요 용역을 집어서 일단 락을 걸어줄게요 이미 락을 잡고 실행했는데 왜 또 잡느냐 이건 나중에 경우에 따라가지고 이 위에 코드가 바뀌어서 락을 안잡고 리지스터 샌드를 호출을 해주게 바뀔수도 있기 때문에 혹시 모르니까 이중으로 , 이렇게, 잡아주고 있습니다 , 자, 이건 나중에 바뀔 코드 때문에 그런거고 , 자, 그래가지고 지금 여기 버퍼로 되어있는 이 부분을 살짝 수정을 해가지고 템프로 되어있는 이 영역을 그냥 바이트 베어를 들고 있는 게 아니라 여기다가 샌드 버퍼 랩프를 얘가 들고 있게 만들어 줄 겁니다 샌드 버퍼스라고 해가지고 그래서 우리가 큐에다가 밀어 넣어가지고 예약한 데이터를 실질적으로 보내기 위해서 샌드 이벤트한테 , 일단은, 옮겨준다는 얘기가 되는 거죠 왜 굳이 그런 번거로운 짓을 해야 되느냐 말 그대로 SS의 샌드를 하는 순간에 걔가 절대로 없어지지 않게끔 레퍼런스 컴팅을 유지시켜 줘야 되는데 이 큐에서 만약에 우리가 데이터를 빼내는 순간 레퍼런스 컴팅이 트가 줄어들면서 사라질 수 있기 때문에 그거를 다시 한번 여기서 이제 보관을 해주는 개념이라고 보면 되겠습니다 그래서 뭐 대충 이런 느낌으로 라이트 사이즈를 추적을 할 것인데 어 , 일단은, 기본적으로 지금은 간단하게 하기 위해서 샌드큐가 완전히 비워질 때까지 그냥 다 하나씩 하나씩 꺼내 주도록 합시다 샌드 버퍼 랩을 꺼내 가지고 먼저 샌드큐에 프론트를 이용해서 데이터를 꺼낸 다음에 그 다음에 샌드큐에 팝을 해줘 가지고 , 이렇게, 꺼내 줄 것이고 그 다음에 샌드 이벤트에 샌드 버퍼에다가 샌드 버퍼를 그대로 다시 , 이렇게, 옮겨 주도록 할게요 그러면 애당초 얘를 큐로 관리하지 않고 벡터로 관리해가지고 그냥 벡터를 통으로 복사해도 되지 않느냐 라고 생각하실 수 있는데 그것도 맞는 얘기입니다 그런데 여기서 굳이 , 이렇게, 하는 이유는 여기 라이트 사이즈를 추적을 해가지고 나중에 가면은 너무 많은 데이터를 보내지 않게 여기서 어느 정도 컷을 해줘야 됩니다 우리 샌드 버퍼도 초기에 정한 크기가 있을 테니까 그거를 뛰어넘지 않도록 대충 어느 정도 조절을 해 줘 가지고 이제 보낼 필요가 있어요 너무 많은 데이터를 보내도 이제 안 되기 때문에 이걸 추적해 주다가 여기서 뭔가 예외 체크를 통해 가지고 빠져나온다거나 하는 코드가 이제 들어가긴 해야 됩니다 그 경우에 따라서 모든 데이터를 다 보낼 수 없을 수도 있다는 얘기가 되는 거죠 아 그리고 이 벡터는 대문자를 해 줘 가지고 우리가 사용하는 그 메모리 풀링이 적용되게 만들어 주도록 할게요 그래서 일단 보낼 데이터를 큐에서 빼와가지고 , 일단은, 샌드 이벤트에다가 등록하는 부분이 요렇게 실행이 됐으면 여기까지는 , 일단은, 락을 잡고 우리가 작업을 하고 있었는데 빠져나온 순간에는 더 이상 멀티스레드를 고려할 필요가 없죠 애당초 리지어스 샌드는 한 번에 한 명만 호출할 수 있으니까 여기부터 다시 안전하게 된 겁니다 , 자, 그러면 이제 그 다음에 해야 될 거는 이 ws의 버퍼를 만들어줘야 되는데 , 자, 이번에 해볼 거는 뭐냐면은 ws의 샌들을 할 때 얘를 한 개만 딱 사용해 가지고 보내줄 수도 있지만 이거를 뭉쳐 가지고 모여 가지고 한 번에 보내주는 기법이 있는데 그거를 scatter gather 란다 한다고 제가 언급을 드린 적이 있는 것 같습니다 흩어져 있는 데이터들을 모아서 한 방에 보내는 기법이에요. 그리고 당연히 요 함수가 그거를 지원을 해주기 때문에 WSA버퍼를 그냥 한 개만 만들어주는 게 아니라 이제는 얘를 여러 개를 만들어주도록 할 거예요. 똑같이 벡터로 WSA버퍼를 , 이렇게, 벡터 형태로 만들어준 다음에 먼저 리서브를 해줘가지고 샌드 이벤트에 샌드 버퍼의 사이즈만큼으로 , 일단은, 예약을 빵 때려주도록 할게요 리서브를 해주고 그 다음에 샌드 버퍼를 하나씩 하나씩 순회를 하면서 샌드 이벤트에 샌드 버퍼를 하나씩 순회를 하면서 이제 요 부분이 똑같이 만들어지게 될 겁니다 하나하나씩 데이터를 꺼내가지고 이 버퍼에다가 WSB 버퍼를 만들어주는 거죠 reinterpret cast 캐릭터 포인트로 만들어준 다음에 sandbuffer의 buffer를 꺼내가지고 여기에 데이터가 있을 것이고 그 다음에 size를 넣어주어야 되는데 얘는 static cast long으로 한 다음에 sandbuffer의 light size에 우리가 실제적으로 우리가 복사한 데이터 크기가 들어가 있었죠? 걔네 둘을 , 이렇게, 꺼내줘서 여기다가 입력을 해준 다음에 이 전체를 wsa-buffer-pushback에다가 , 이렇게, 넣어줄 겁니다 그래서 여기 있는 데이터의 정보들을 우리가 다 여기다가 전달을 해준 거죠. 시작 주소는 이거이고 데이터 크기는 얼마 얼마이다 라고 , 이렇게, 입력을 해가지고 만약 우리가 큐에 쌓였던 데이터가 10개라고 했다면 그 10개를 한 번에 보낼 수 있게 모든 정보들을 다 이 WSA 버퍼라는 데다가 우리가 넣어준 셈이 되는 겁니다. 그럼 여기다가 넣어줄 때는 뭐 이런 식으로 시작 주소를 받아주고 있는데 일단 배열 형태로 지금 얘가 예상을 하고 있는데 벡터가 동적 배열이다 보니까 시작 주소를 , 이렇게, 넣어주면 될 것이고 그 다음에 몇 개가 있느냐는 뭐 이런 식으로 Static Cast Deward를 한 다음에 SSA 버퍼의 사이즈를 그냥 , 이렇게, 두 번째 인자로 전달해주면 우리가 기존에는 한 번 한 번씩 보냈던 거를 한 번에 모아가지고 흩어져 있는 데이터들을 모아가지고 한 번에 보낼 수가 있게 된 겁니다. 요렇게 , 일단은, 개선사항이 있는 거예요. , 자, 그러면은 요렇게 리지스터 샌드가 완료가 되었구요 그럼 다시 돌고 돌아가지고 어... 살펴보면은 내가 맨 먼저 지금 호출을 해가지고 이 샌드 리지스터드가 아직 false인 상태라고 하면은 걔가 먼저 , 일단은, 보내주게 될 것이고 그 다음에 얘가 아직 완료가 되지 않은 상황에서 즉각 우리가 ws 샌드를 예약을 해서 걸어둔 상태지만 어... 아직 완료 통지가 오지 않는 상태에서는 그냥 기존과 마찬가지로 여기 Q에다가만 계속 쌓이게 될 겁니다 그래서 일부의 데이터만 사실상 보내질 수 있고 그 이후에 오는 거는 계속 쌓이는 형태가 될 수 있다는 얘기가 되는 거죠 그럼 이제 그 다음의 데이터는 이제 어떻게 해야 되느냐 이 리지스터 샌드라는 거 자체가 언젠가는 우리가 걸어준 샌드가 완료가 되어 가지고 프로세스 샌드 쪽으로 호출이 될 겁니다 그러면은 프로세스 샌드 쪽에서 이제 후처리를 해주면 되는데 먼저 샌드 이벤트에 샌드 버퍼에 클리어를 해줘 가지고 여기서 릴리즈 레퍼런스를 해주도록 할게요 이제 버퍼를 다 사용했으니까 이제 깔끔하게 밀 수 있다는 얘기가 되는 거죠 아 그리고 참고로 하나 까먹은 것 같은데 여기 리지스터 샌드를 할 때도 마찬가지로 여기 코드를 다시 보면은 리지스터 샌드를 하고 있는데 여기서 ws send를 했는데 만약에 실패했다 즉 요 부분에서 오면은 원래 우리가 항상 이런 식으로 release reference를 해줬는데 얘도 넣어줘야 되겠죠 실패해서 error 코드가 pending이 아니라고 하면은 진짜 문제가 일어난 거니까 완료 통지가 뜨지 않을 테니까 여기서 그냥 정리를 해주도록 하겠습니다 이건 , 사실, 우리가 지금까지 작업하던 패턴이랑 굉장히 유사한 거죠 얘도 release reference를 해주는 거고 그 다음에 마찬가지로 send register도 펄스로 그냥 다시 바꿔치기를 해주도록 하겠습니다 이제 다음 누군가가 또 호출해줘라 라는 얘기가 되는거죠 , 자, 그러면 얘가 이제 누락된 부분을 채웠고 다시 프로세스 샌드로 돌아와가지고 하던 얘기를 마저 하자면 여기서 , 일단은, on, on은 null로 밀어줬고 샌드버퍼 클리어해주고 해가지고 버퍼를 다 사용했다고 , 일단은, 이제 밀어준거고 그 다음에 컨텐츠 코드에서 재정의하는 쪽으로 와가지고 on 샌드가 호출이 될거고 이제 그 다음에 해야되는건 무엇이냐 이제 다시 샌드큐를 체크를 할거에요 샌드큐를 체크해가지고 더이상 데이터가 하나는 없다 내가 모든 데이터를 다 보냈다고 하면은 그러면은 샌드 레지스터를 다시 false로 바꿔치기 해줘가지고 이 다음에 누군가가 또 샌드 함수를 호출했으면 이제 걔가 담당해가지고 데이터를 보낼 수 있게 만들어 줄겁니다 하지만 만약에 그게 아니라고 한다면은 애던초 샌드큐가 그 와중에 누군가가 또 데이터를 밀어 넣은 상태라는 얘기가 되는 거니까 다시 한번 우리가 리지스터 샌드를 여기서 빵 호출해 주게 될 거예요 그죠 이 상태에 왔다면은 우리가 샌드 리지스터를 아직 false로 바꿔주지 않고 얘를 이제 계속 호출하던 애가 담당을 해가지고 이제 뭐 계속 보내준다는 그런 얘기가 되겠습니다 그리고 여기서 write lock을 걸어야 되겠죠 왜냐면 이 샌드큐는 멀티셋 환경에서 동시 접근을 할 수 있으니까 샌드를 하는 애들마다 이 샌드큐에다가 데이터를 넣어 놓고 있다 보니까 여기서 라이트 락을 , 이렇게, 일단은, 걸어 넣어주면 되겠습니다 , 자, 이렇게, 해가지고 뭐 한 번에 한 명만 데이터를 사실상 보낼 수 있는 거죠 동일 세션에 대해서는 그리고 완료 통지가 와서 프로세스 샌드가 호출이 되면은 정리를 해준 다음에 내가 또 데이터가 보낼 데이터가 있다면은 여기 리지스터 샌드를 호출해 줄 것이고 아니면은 완료 되었다 라고 샌드 레지스터들을 , 이렇게, 스토어 펄스로 바꿔치기를 해주고 있습니다 , 이렇게, 해서 , 일단은, 서버 코어는 완성이 된 것 같으니까 잠시 빌드를 해서 문제가 없는지를 체크를 하고요 그 다음에 여기까지 , 일단은, 완료가 되었으면 윗부분을 다시 한번 수정을 해보도록 합시다 , 일단은, 게임 서버 쪽에서 데이터를 보내는 부분은 일단 , 이렇게, 수정을 해주면 될 것이고 그 다음에 마찬가지로 더미 클라이언트 쪽에서도 지금 이제 우리가 게임 서버를 빌드하면 문제가 없을 수 있겠지만 얘는 이제 또 문제가 되고 있죠 이런 부분들이 문제가 되고 있는데 얘도 마찬가지로 대칭적으로 바꿔치기를 해주면 되겠습니다 이 부분을 , 일단은, 통으로 묶어서 Connected to 서버가 떴으면 일단 샌드 버퍼를 하나를 만들어 가지고 데이터를 지금 복사해줘야 되는데 얘를 복사해줘야 되는데 얘가 하필이면 이름이 같다 보니까 그냥 sand data라고 얘를 바꿔치기 해주도록 하겠습니다 이름을 그 다음에 요 부분을 sand data만큼을 size of sand data를 요렇게 복사를 , 일단은, 해준 다음에 그 다음에 sand를 때려주도록 하겠습니다 요렇게 , 일단은, 만들 수가 있다는 얘기가 되는 거죠 그 다음에 R에서 Receive한 결과물을 다시 뱉어주고 있는데 얘도 , 일단은, 그냥 위에 있는 코드를 복붙해가지고 다시 한번 Hello World를 그냥 보내도록 해주도록 하겠습니다. 세션마다 이 작업을 반복하는 거죠. 그러면 이 상태에서 예를 들면 여기 있는 메인을 한 개가 아니라 한 5개를 만들어가지고 5개의 클라이언트가 동일한 작업으로 계속 보내게 된다고 가정을 해볼게요. , 자, 그리고 여기까지 완료가 되었으면 일단 클라 빌드를 한 다음에 , 일단은, 뭐 별다른 문제가 없는지 실행을 해보도록 하겠습니다 그러면 아까 뭐 한 코드랑 , 사실, 완전히 유사하게 , 일단은, 동작을 해야 되는데 , 자, 근데 여기 하나 버그가 있어요 여기 지금 락과 관련된 버그가 하나 뜨고 있는데 이걸 제가 지난번에 하다가 이걸 안 고치고 넘어갔더라구요 그래가지고 이거에 대해서 , 일단은, 잠시만 언급을 드리자면 지금 락을 거는 상태에서 문제가 있는데 락 자체는 문제가 없는데 락 프로파일러 쪽에서 살짝 문제가 있어요 그래서 여기서 락을 우리가 잡고 풀어줄 때 프로파일링을 하기 위해서 데드락 프로파일러라는 걸 지금 계속 활용을 해가지고 잘 사용을 하고 있는 것까지는 괜찮은데 여기서 유심히 보면은 애당초 데드락 프로파일러가 처음에 설계될 때는 멀티셋 환경을 고려하지 않고 얘가 TLS 영역에 들어갈 거로 예상을 하고 만들다 보니까 살짝 문제가 발생했어요 그게 뭐냐면은 여기 락 스택이라는 것 자체가 스레드마다 자기가 호출하고 있는 그 락의 순서가 달라지게 되겠죠 예를 들면 어떤 A라는 Thread는 Session 락을 잡은 다음에 Sand Pop 그 다음에 다른 락을 잡고 예를 들면 0번 락을 잡고 1번 락을 잡고 2번 락을 잡을 수 있고 그 다음에 다른 Thread는 3번과 1번 뭐 , 이렇게, 다른 애들을 호출하고 있고 요 순서를 이제 우리가 락스택이라고 부르고 있는 건데 제가 까먹고 이거를 안 빼주고 공용으로 지금 사용하고 있습니다. 그러다 보니까 분명히 어떤 애는 0일을 사용하고 있었는데 다음 데이터가 막 끼어들어서 다른 액괴에 끼어들고 하다보니까 이러면 락스택이 꼬여서 누가 어떤 순서를 호출했는지가 명확하지가 않게 된겁니다 네 이런 문제가 있었는데 이걸 고치는 방법은 굉장히 단순한데 그냥 이 락스택이라는 것 자체를 TLS로 만들어서 스레드마다 자기의 락스택을 관리할 수 있게끔만 만들어주면 , 일단은, 됩니다 그래가지고 데드락 프로파일러 자체를 TLS로 만들던가 아니면은 락 스택이라도 최소한 TLS 영역으로 빼주면 된다는 얘기가 되는건데 , 일단은, 이 락 스택 자체를 TLS로 바꿔주도록 할게요 그래서 얘를 , 일단은, Ctrl-R-R을 이용해가지고 L-LockStack이라고 , 일단은, 이름을 한번에 빵 다 바꿔주도록 하겠습니다 , 자, 그래가지고 이제는 LROCKSTACK이라고 이름이 다 일단 바뀐 걸 볼 수 있고요 단축키는 Visual Assist가 없으면 Ctrl R R 영문 R , 이렇게, 두 번 해가지고 만들어 주시면 되겠습니다 , 자, 그리고 , 이렇게, 해가지고 다 마커치기 한 다음에 얘는 , 일단은, 복붙을 해가지고 잠시 삭제를 해주고 TLS에 넘어가가지고 여기서 정의를 해 주도록 할게요 , 자, 근데 여기서 일단 스택 자체는 아직 얘가 존재를 모르기 때문에 include stack을 추가해주고 그 다음에 extern thread local std stack 이라는 것까지 , 일단은, 추가를 해주시면 되겠어요 그 다음에 lock stack 이라고 요렇게 만들어 주면 되겠습니다 그 다음에 core-tls-cpp에 가가지고 마찬가지로 이제 이 아이를 이제 똑같이 복붙을 해서 여기 만들어 준 다음에 X턴만 없애주고 , 이렇게, 일단은, 만들어 주면 락 스택이 스레드마다 존재를 하게 될 거에요 그러면은 이 락 하는 부분에서도 이제 아무런 문제 없이 홀출이 될 겁니다 락 추적을 할 때는 뭐 쓰레드마다 자신만의 락 스택이 있어야 된다 근데 히스토리는 공용으로 관리해야지만 우리가 이 데드락 상황을 확실히 더 편하게 잡을 수 있으니까 얘는 이제 그대로 냅두도록 할 겁니다 , 자, 이렇게, 해가지고 다시 한번 클라도 빌드하고 서버도 빌드해가지고 실행을 해보시면 , 일단은, 정상적으로 데이터가 오고 가는 것까지 , 일단은, 확인을 할 수가 있을 거예요 그래서 요 상황에서 onReceive, onSend, onReceive, onSend가 제 옆화면에서 지금 정상적으로 , 이렇게, 잘 호출이 되고 있는 걸 이제 확인을 할 수가 있습니다 , 자, 그리고 이걸 이제 조금 더 극단적이라고 하긴 뭐하고 일반적인 상황에서 이제 보자면은 지금은 , 이렇게, 한 번에 하나씩만 보내주고 있지만 말 그대로 이제 브로드 캐스팅이라는 개념에 대해서 슬슬 익숙해지시기 시작을 해야 됩니다 , 자, 브로드 캐스팅은 뭔지 간단하게 살펴보자면 나중에 우리가 게임 서버를 이제 구현을 할 때 어떤 식으로 구현을 할 거냐면 여기다가 게임 세션 일단 매니저라는 애를 일단 만들어 보도록 할게요 네 , 이렇게, 일단은, 이 클래스를 만들어 주고 그 다음에 이제 게임 세션 이라는 파일을 만들어 줘야 되는데 여기 지금 게임 세션이라는 클래스 이름이 있어가지고 얘가 안 만들어질 테니까 잠시 얘를 바꿔치기 하고 야매로 일단 게임 세션이라는 클래스를 , 이렇게, 또 새로 만들어주도록 할게요 오케이 , 자, 그럼 얘네 둘을 , 일단은, 메인으로 복사한 다음에 게임 서버에서 우리가 사용하고 있던 요 아이를 , 일단은, 복붙 해가지고 좀 분리해서 관리를 해주도록 합시다 여기 게임 세션 안에다가 , 일단은, 다 놓고 다시 2는 없애서 , 이렇게, 바꿔치기를 해줄 것이고 그 다음에 include Session을 추가해서 이제 얘를 사용할 준비를 해주도록 하겠습니다. 반대로 게임 서버 쪽에서는 이제 Include Game Session을 추가해야 되겠죠. , 자, 이렇게, 일단은, 바꿔치기를 해줄 것이고요. 그러면은 게임 세션 매니저에서는 거꾸로 이 모든 게임 세션들을 관리하는 매니저가 될 겁니다 물론 우리가 서비스라는 이 코어에서도 얘를 이제 게임 세션들을 묶어가지고 지금 들고 있기는 하지만 그거는 이제 서버 코어에서 들고 있어가지고 샌드랑 리시브 용도로 이제 활용하는 것이고 실제적으로 컨텐츠 전에서 편하게 사용하기 위해서 그냥 한 번 더 세션 매니저라는 걸 만들어가지고 여기서 , 일단은, 또 들고 있도록 하겠습니다 그래가지고 뭐 대충 얘가 들고 있는 뭐 그런 애들은 유스락을 사용할 것이고 게임 세션 레퍼런스로 , 이렇게, 들고 있도록 할게요. 얘를 Sessions라고 , 일단은, 이름을 불러주도록 하겠습니다. , 자, 그 다음에 전방선언, 게임 세션 전방선언을 해주고 그 다음에 UsingGameSessionReference는 SharedPtrOfGameSession이라고 , 이렇게, 정의를 해주도록 하겠습니다. 그 다음에 간단하게 add, 추가하는 함수, 세션을 추가하고 그 다음에 리무브 없애고 그 다음에 브로드 캐스트 하는 함수를 각각 하나씩 만들어 볼 건데 브로드 캐스팅 할 때는 샌드 버퍼 랩프를 받아 가지고 샌드 버퍼 자체를 받아 가지고 얘가 들고 있는 모든 애들한테 다 브로드 캐스팅을 하는 그런 함수를 만들어 주도록 하겠습니다 그리고 역시나 쉽게 사용할 수 있도록 전역으로 게임 세션 매니저를 들고 있도록 할게요 g-session-manager 매니저 , 이렇게, 일단은, 만들어 본 다음에 각각 구현부를 만들어 주도록 하겠습니다 얘도 만들어 주고 브로드캐스도 , 이렇게, 만들어 주도록 할게요 , 자, 그러면은 이제 이 게임 세션 매니저를 오른쪽 cpp 에서도 일단 , 이렇게, 만들어 주신 다음에 추가를 할 때는 라이트 락을 걸어 주고 Sessions에다가 인서트를 해서 요 Session을 추가해줄 것이고 리무브를 해야되는 상황이라고 한다면은 Write-Lock을 걸어준 다음에 Sessions-Erase를 해가지고 요 Session을 삭제를 해줄 것이고 이제 오늘 테스트하고 싶은 거는 요 아이였습니다. 브로드 캐스팅 할 때는 Lock을 잡아준 다음에 for_each문을 돌아가지고 게임 세션 랩프를 계속 돌 것인데 여기서 모든 애들한테 Send를 해주도록 할게요. 요런 식으로 , 자, 여기 위에다가 include 게임 세션을 추가해서 여기 지금 빨간 줄을 없애고요 그래도 브로드 캐스팅을 하는 것은 무엇이냐 브로드 캐스팅이라 하면 내가 들고 있는 모든 세션을 하나씩 순회하면서 동일한 데이터를 보내주겠다라는 의미가 되는 겁니다 근데 우리가 처음에 오늘 작업한 이전 버전으로 했다고 하면은 매번마다 루프를 돌면서 보낼때마다 복사 비용이 일어났겠지만 지금은 딱 한번 샌드버퍼만 만들어주게 되면 얘는 그대로 꽂아주는 형태로 이제 동작을 하게 되죠 그러니까 불필요한 복사가 , 일단은, 사라졌다는 굉장히 큰 장점이 생기게 된겁니다 그 다음에 이제 이쪽에 돌아가가지고 게임 세션 쪽에서는 지금 생성자 소멸자 On Receive와 On Send가 , 이렇게, 정리되어 있는데 얘를 , 일단은, 복붙해가지고 게임 세션 오른쪽에다가 , 일단은, 이렇게, 만들어 놓도록 할게요 오버라이드 없애고 없애고 그 다음에 게임 세션 땡땡이를 붙여줄 것이고 그 다음에 여기서 include 게임 세션 매니저를 얘는 거꾸로 추가하고 얘는 , 자, 이렇게, 구현부는 없애고 , 이렇게, 선언만 해주도록 하겠습니다. 그 다음에 void onConnected랑 onDisconnected도 오버라이드를 해줘가지고 , 이렇게, 각각 만들어 줄 것이고 이게 실질적으로 사용할 때는 이제 거의 이런 식으로 사용이 될 겁니다 on send, on receive, on disconnect 뭐 이런 애들을 다 하나씩 오버라이드를 해 준 다음에 만약에 connected, on connected 상태가 일어났다고 하면은 이제 우리 매니저 쪽에다가 얘를 전달해 줄 겁니다 g session manager add를 한 다음에 뭐 예를 들면 이런 식으로 스태틱 포인터 캐스트를 한 다음에 게임 세션에다가 sheared from this from this로 변환을 해줘서 뭐 요렇게 넣어주면 되겠고 리무브, 디스코넥트가 일어났다고 하면은 얘는 거꾸로 리무브를 해주면 되겠죠 요런 느낌으로 , 자, 이렇게, 해가지고 간단하게 만들어 봤구요 그 다음에 어떤 패킷을 받았을 때는 요렇게 어... 해주고 이제 서버쪽에서 어떤 패킷을 받았을때는 그냥 한명한테만 그대로 얘를 토스해주는게 아니라 브로드캐스팅을 해주도록 합시다 얘를 이런식으로 c세션 매니저의 모든 애들한테 이 세션이 나한테 전달해준 데이터를 모든 애들한테 다 다시 토스를 해줘가지고 전달을 해주도록 할게요 요런 패턴이 이제 자주 일어나게 된다는 얘기가 되는 거죠 예를 들면 어떤 클라이언트가 나는 A라는 유저를 공격할래 라는 패킷을 우리한테 전달해줬으면 우리는 그거를 모두한테 알려서 모든 애들이 똑같은 화면을 볼 수 있게끔 만들어줘야 되기 때문에 이런 식으로 브로드 캐스팅 하는 일이 빌빌지 하다라는 얘기가 되는 거죠 , 자, 그래서 딱히 별다른 문제가 없는지 체크하기 위해서 지금 요 상황에서 실행을 해보면은 , 일단은, 클라쪽에서 받는 데이터를 보면은 이제 우리가 브로드 캐스팅을 하다보니까 다섯 명이 데이터를 받은 거를 다섯 명한테 다 쏴주다 보니까 이런 식으로 경우에 따라서 이씨브가 좀 초과해서 12바이트가 아니라 72바이트씩 오는 걸 확인할 수가 있습니다 근데 , 일단은, 게임 서버 보내는 거에서는 뭉쳐서 보내지 않고 12바이트만 보낸 걸 확인할 수 있는데 이걸 만약에 경우에 따라가지고 예를 들면 브로드캐스팅을 강제로 우리가 5번을 연속해서 한다거나 하는 식으로 조절을 해주면은 이제는 패킷이 어느정도 뭉쳐가는 상황이 종종 발생하게 될 겁니다 그래서 다시 한번 , 이렇게, 실행을 해보면 , 자, 이제는 12바이트만 곧 보내는 경우도 있지만 굉장히 자주 12바이트가 아닌 나머지 데이터들을 모아가지고 보내는 그런 행동들이 자주 관찰이 된다는 것도 , 이렇게, 확인할 수가 있습니다. , 자, 이렇게, 가지고 패킷을 어느 정도 모아 보내는 그런 부분에 대해서 , 일단은, 알아봤고요. , 사실, 오늘 한 내용에 대해서 가장 중요한 부분은 뭐 어차피 이런 매니저 관리하는 이런거는 나중에 또 실습을 할 일이 있을거고 콘텐츠를 만들게 될 때 괜히 많이 해보겠지만 당장 중요한거는 요 브로드캐스팅이 일어났을 때 우리가 샌드버퍼라는 것만 한 번만 만들어 줘가지고 어 그 데이터를 이제 걸어주는 거였죠 샌드를 우리가 한 번만 만든 샌드버퍼를 계속 우리가 이리저리 다 걸어주면은 걔네들이 다 샌드큐에 , 이렇게, 알아서 잘 들어가게 되었구요 샌드큐에 들어갈 때는 샌드 버퍼의 레퍼런스 카운트가 1 증가하긴 하겠지만 내부적인 데이터가 복사가 일어나진 않을 겁니다 이게 굉장히 큰 차이가 있는 거죠 우리가 지난번에 이 작업을 하기 이전 단계에서는 매번 복사해 줘 가지고 그 데이터를 보관하게끔 만들어 줬었는데 그게 아니라 이제는 , 이렇게, 우아하게 관리가 되고 그 다음에 샌드를 동일한 샌드 버퍼를 여러 명한테 꽂았더라도 레퍼런스 카운팅이 계속 되고 있다 보니까 정말로 100% 확률로 확신하게 이 레지스터 샌드가 완료가 될 때까지는 그 데이터가 삭제가 되지 않고 유지가 될 거라는 걸 우리가 기대를 할 수가 있게 되는 겁니다. 그리고 이런 부분에 대해서 작업을 하면 역시나 Add Reference, Release Reference 시리즈가 계속 등장하다 보니까 실질적으로 샌드 버퍼가 잘 사라지는 게 맞는지도 테스트를 해보는 게 중요합니다 이거는 브레이크 포인트를 잡아서 간단하게 살펴봐도 되고요 나중에 이런저런 스트레스를 테스트하다가 이게 진짜로 메모리 릭이 있는 상황이라고 하면 메모리 사용량이 그냥 기아 급수 쪽으로 계속 증가하게 될 거예요 그런 식으로 확인을 해도 됩니다 지금은 여기 보면 프로세스 샌드가 완료가 된 다음에 이런 식으로 소멸자로 잘 들어오는 것도 확인을 할 수가 있고요 그리고 이걸 계속 켜놓는다고 해서 메모리가 계속 늘어나지 않는다는 것만 봐도 샌드 버퍼가 정상적으로 잘 소멸이 되고 있는 상황이라고 , 일단은, 예측을 할 수가 있을 겁니다 , 이렇게, 해서 간단하게 샌드 버퍼에 대한 기념에 대해서 알아봤고요 그래가지고 이제는 앞으로 이 수신 버퍼와 송신 버퍼를 만드는 방법이 굉장히 다양하게 있기는 하겠지만 기본적으로 어떠한 차이점이 있고 어떠한 문제를 해결을 해야 되는지에 그 차이점에 대해서는 일단 이해를 하는 게 중요합니다 그리고 역시나 샌드를 할 때 지금 우리처럼 , 이렇게, 샌드 이벤트를 그냥 한 개만 만들어 가지고 Get을 재사용하는 방법도 있지만 샌드를 할 때마다 이 Iocp 이벤트를 만들어 가지고 매번 마다 샌들을 그냥 중첩해 가지고 거는 경우도 더러 있기는 합니다 이것도 이제 뭐 여러가지 방법이 있다라는 것도 이제 인지를 하셔야 되고 양쪽에 뭐 그런 장단점에 대해서도 어려운 부분 이제 이해를 하셔야 된다는 얘기 되는 거죠 근데 이 방법이 물론 이전에 보내던 게 완벽히 보내 가지고 완료 통제가 올 때까지 다음 패킷을 안 보낸다는 게 어떻게 보면은 조금 아쉬울 수도 있겠죠 왜냐면은 이제 반응성 측면에서 조금 더 늦게 갈 테니까 근데 뭐 MMO 기준으로는 MMO는 FPS 게임처럼 반응성이 엄청 빠르게 요구되는 게임이 아니라 우리가 몇 천 단위의 그 유저들을 고루고루 다 데이터를 균일하게 잘 보내주는 게 중요하기 때문에 매번마다 빠르게 데이터를 보내는 것보다는 모두를 만족시키면서 어느 정도 데이터가 왔으면 그 데이터를 뭉쳐서 보내는 게 , 일단은, 조금 더 좋다고 볼 수가 있겠어요. 제 관점입니다. 그리고 이 scatter gather, 이것도 굉장히 중요한 개념인데 이런 식으로 버퍼를 여러 개를 합쳐가지고 한 번에 보낸다는 개념에 대해서 기억을 해주시면 되겠습니다. , 이렇게, 해가지고 샌드 버퍼에 대한 내용을 간략하게 , 일단은, 맞춰보도록 할게요.