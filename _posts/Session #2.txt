자, 이렇게, 해가지고 지난 시간까지 Receive와 관련된 Session 작업을 , 일단은, 좀 시작을 해봤구요 물론 이전 시간에 했던 작업이 아직 완전하지는 당연히 않습니다 왜냐면은 나중에 가면은 우리가 Receive 한 데이터 중에서 아직 처리가 미처 되지 않은 데이터들은 건드리면 안 되기 때문에 이런식으로 Receive Buffer 에다가 그냥 쿨하게 모든 데이터를 복사하는 형태로는 당연히 만들 수가 없을 겁니다 , 자, 그래서 뭐 나중에 수정은 하긴 해야 된다 라고 볼 수 있는 거구요 근데 이제 기본적으로 그럼에도 불구하고 틀을 계속 만들어 보는 연습을 하면서 이제 조금씩 조금씩 모습을 갖추게 될 건데 이 부분은 나중에 리시브 퍼퍼로 대체가 되겠지만 오늘 , 일단은, 이어서 할 것은 지난 시간과 마찬가지로 모양을 잡아 보는 작업을 해보게 될 겁니다 그래서 이번에는 거꾸로 리시브가 아니라 샌드를 할 때는 이제 어떻게 해야 될까를 고민을 해봐야 되는데 샌드랑 리시브는 정책이 완전히 반대입니다 왜냐하면 우리가 리스너 같은 경우에 맨 처음에 누군가가 연결이 되었을 때 여기 프로세스 커넥트를 호출해주고 여기서 리지스터 리스브를 한번 최초로 호출해 줬었죠 낚시대를 물에 던진다 라고 제가 표현을 드린 거고 어차피 Receive는 이미 그냥 처음에 한 번만 걸어 놓으면 나중에 실질적으로 데이터가 올 때 알아서 완료 통지가 뜨면서 이제 IOCP에 의해 가지고 여기 일감이 디스패치되면서 프로세스 Receive 쪽으로 , 이렇게, 들어오고 다시 한번 Receive를 거는 형태로 이제 계속 반복해서 동작을 하게 될 겁니다 그래서 사실상 한 번에 한 번씩만 리시브를 해주게 되겠죠 멀티스레드 환경이라고 해도 프로세스 리시브가 중첩해서 여러 번 호출되는 상황은 발생할 수가 없습니다 그건 그렇고 그럼 이제 샌드는 어떻게 만들 것이냐 샌드는 조금 문제가 다른게 이런식으로 receive를 먼저 걸어둔 다음에 기다리는 게 아니라 우리가 진짜로 보낼 데이터가 있을 때 그때야 비로소 우리가 send를 호출해 주게 될 겁니다. 그러니까 완전히 정책이 달라져야 되는 얘기 되는 거죠. , 일단은, 만들면서 이 부분에 대해서 논의를 해볼 건데 , 일단은, 첫 번째 영역은 외부에서 사용하는 함수들을 이쪽에 다 모아 놓을 것이고요. 오늘 간단하게 만들어볼 아이는 , 일단은, send입니다. 어떤 버퍼에다가 크기를 입력 받아주면 여기 있는 내용을 보내주는 식으로 만들어주도록 할게요 그리고 참고로 이 byte는 그냥 unsigned 캐릭터로 우리가 처음에 설정을 해놓은 그 아이입니다 뭔가 캐릭터라고 하면은 진짜로 문자열 같으니까 진짜 어떤 데이터를 보낸다는 의미로 byte형 포인터로 일단 , 이렇게, 만들어 놨어요 , 자, 그러면은 역시나 여기서 이제 좀 고민해드릴 문제는 , 일단은, 리시브 이벤트를 우리가 , 이렇게, 재사용을 해서 사용했던 것처럼 얘도 일단 사용하면 되지 않을까 라는 생각을 할 수 있지만 샌드 같은 경우는 여기서 이제 고민할게 좀 생깁니다 생각할 문제 그래서 실질적으로 세션을 만들 때 이 샌드쪽이 가장 어려워요 기본적으로 먼저 뭐 버퍼 관리에 대한 부분도 있고요 그 다음에 샌드 이벤트를 어떻게 관리할지 단일로 할지 여러 개로 할지 그리고 실질적으로 SS의 샌드는 중첩해서 호출할 수 있을지 등등의 문제를 , 일단은, 생각을 해야 됩니다. 이게 무슨 말이냐면 샌드 같은 경우에는 나중에 우리가 MMO를 만드는 과정을 해볼게요. 그러면은 이거를 그냥 한 번에 한 명씩만 정말 차례를 지켜가지고 호출하는 게 아니라 언제 어디서 이 샌드가 호출이 될지 우리가 예상을 할 수가 없습니다. 예를 들면 내가 주변에 있는 몬스터를 사냥한다고 하면은 그 몬스터에 대한 정보가 클라한테 계속 보내져야 되기 때문에 이 샌드가 호출이 될 것이고 그 와중에 어떤 플레이어가 해당 플레이어한테 귀속말을 한다고 하면은 그 귀속말을 한 정보 자체도 그 플레이어한테 보내줘야 되니까 또 샌드가 뜰테고 이런식으로 샌드가 막 중복해가지고 날라가게 될겁니다 그러면은 이런식으로 샌드 이벤트를 내부에서 딱 하나만 만들어서 사용하게 되면은 이제 샌드가 과연 딱 한 번이 아니라 여러 번 호출했을 때 그거를 반복해서 처리를 할 수가 없는 문제가 생기게 되는 거죠 그래서 약간 고민이 되는데 , 일단은, 가장 기본적으로 임시적으로 어떻게 만들어볼 거냐면 이걸 실시간으로 만드는 형태로 , 일단은, 냅두도록 할게요 제 샌드 이벤트를 여기서 그냥 동적으로 실시간으로 , 이렇게, 만들어줄 거고요 샌드 이벤트 , 이렇게, 일단은, 샌드 이벤트를 만들어줄 것이고 만들었으니까 owner를 shared from this로 , 이렇게, 연결을 해서 reference count를 1 증가시키도록 할게요 그 다음에 send event 에다가 어 이제 버퍼를 연동해줘야 되는데 버퍼도 마찬가지로 , 자, 우리가 뭐 기존에 receive buffer 라는걸 여기다가 임시로 만들어 놨으니까 뭐 비슷한 형태로 예를 들면은 막 이런 식으로 send buffer 에다가 실질적으로 뭐 보낸 크기를 , 이렇게, 관리하면 되지 않을까 라는 생각이 듭니다 근데 이것도 약간 문제가 되는게 여기 있는 데이터가 우리가 샌드를 빵 때린 다음에 얘가 유지된다는 보장이 없죠? 이걸 어떻게든 이 데이터를 살려놔야지만 우리가 예약한 SS 샌드가 완료가 될 때까지 유지를 해야 되는데 그런 보장이 없다 보니까 살짝 고민이 듭니다 그러면 첫 번째 방법은 여기 있는 데이터 자체를 우리 샌드 버퍼에다가 , 일단은, 복사를 해 줘 가지고 이 복사한 데이터를 고대로 WS 샌드한테 넘겨주면 되지 않을까 라는 생각이 , 일단은, 드는데 역시나 문제는 뭐냐면 리시버 보버에서 , 사실, 비슷한 문제가 있기는 했지만 샌드를 여러 번 계속 계속 호출하면 기존에 있던 영역을 덮어쓸 수는 없습니다 그러니까 최대한 뭔가 영역을 집어 가지고 예를 들면 내가 여기서 여기까지 지금 사용했으면 덮어쓰면 안 되고 그 다음 부분부터 데이터를 밀어 넣는 식으로 작업을 해야 된다는 얘기가 드는 거죠 이런 식으로 계속 계속 그 다음 데이터 부분에다가 밀어 넣고 겹치지 않게끔 잘 유도를 해줘야 되고 그러다 보면 언젠가는 끝에 도달하게 될 텐데 그때는 다시 처음부터 시작을 해가지고 이쪽에다가 밀어 넣는 식으로 , 일단은, 작업을 해줘야 돼요 이게 첫 번째 방법입니다 샌드 버퍼를 하나 내부에서 둔 다음에 계속 복사를 하되 서로 영역이 안 겹치게 , 이렇게, 열심히 조절해주는 방식이고 이게 사실은 순환 버퍼 어 써큘러 버퍼의 약간 기초라고 볼 수 있는 거예요 근데 이 방법이 저는 개인적으로 안 좋아하고 추천을 드리지 않는 이유가 뭐냐면은 복사 비용이 조금 있습니다 샌들을 할 때마다 여기서 이제 계속 복사 복사 복사 해가지고 어 데이터를 밀어 넣어야 되는데 나중에 이건 뭐 나중에 후반부에 또 나올 얘기지만 나중에 가면은 동일한 패킷을 굉장히 많은 세션한테 우리가 전역으로 뿌려주는 일이 굉장히 자주 빈번하게 생깁니다 근데 그럴 때마다 이 샌들을 세션마다 돌면서 호출해주게 될 텐데 그때마다 세션마다 , 이렇게, 복사 복사 복사 하는 게 이제 굉장히 비용이 많이 들 수 있다는 얘기가 되는 거죠 그래서 이런저런 이유로 저는 , 이렇게, 샌드 버퍼를 사용하는 걸 별로 선호하진 않는다라고 말씀을 드리고 있는 거고 이걸 이제 나중에 어떻게 사용할지는 뭐 또 언급을 드리겠지만 , 일단은, 오늘은 이걸 역시나 좀 모양만 간단하게 간단하게 만들어 보기 위해서 그리고 , 이렇게, 순한 버퍼를 만들어 주는 것도 은근히 귀찮은 작업이기 때문에 잠시 샌드 버퍼 쪽에다가 임시적으로 여기다가 샌드 버퍼를 하나를 만들어 주도록 할게요 사이즈가 얼마 될지 모르니까 그냥 벡터로 만들어 줄 것이고 여기 샌드 이벤트에다가 그냥 데이터를 복사해가지고 , 일단은, 관리를 해주는 식으로 데이터를 살려 놓도록 하겠습니다 물론 이게 당연히 효율적이지 않으니까 나중에 고치긴 해야 될 거예요 그래서 , 이렇게, 리사이즈를 해서 데이터를 잡아준 다음에 memcpy를 통해 가지고 데이터를 바로 복사를 해주도록 합시다. send event에다가 buffer에다가 .data buffer에 lens 뭐 이런 식으로 해가지고 여기 있는 데이터를 복사를 한다 라고 볼 수가 있는 거고 그 다음에 이제 이어서 이 데이터를 보내주면 되겠죠 지금까지 우리가 항상 사용하던 걸 보면은 항상 이 패턴 register process register process 형식으로 우리가 만들어 놨으니까 이제 이어서 register send를 이쪽에서 호출을 해주도록 하겠습니다 register send 안에서도 결국에는 우리가 내부적으로 wsa send를 호출을 할 것인데 요 정보를 , 일단은, 받아와야 되겠죠 왜냐면 얘 같은 경우는 이제 멤버 변수로 우리가 들고 있는 애가 아니다 보니까 어떤 식으로든 리지스터 샌드를 할 때 요 인자를 넘겨줘야 됩니다 그렇기 때문에 이 샌드 이벤트를 역시나 잠시 이쪽에다가 요렇게 옮겨 놓도록 할게요 리지스터 샌드를 할 때는 샌드 이벤트를 받아가지고 처리를 하도록 네 요렇게 , 일단은, 만들어주면 되겠습니다 그래서 얘를 , 일단은, 그대로 , 이렇게, 넘겨서 작업을 해보도록 하겠습니다 요런 느낌으로 오늘 작업하는 코드는 샌드와 관련된 부분들이 여러분들이 단계별로 이해할 수 있도록 나중에 삭제될 코드가 많이 들어가기는 합니다. 이건 한번씩 해봐야지만 어떤 문제가 있는지 그리고 어떤 해결법들이 있는지를 쉽게 이해할 수가 있어요. , 자, 그래가지고 , 일단은, 그 다음으로 할 거는 여기 이스커넥티드 자체를 똑같이 복붙 해가지고 , 이렇게, 일단은, 막아주도록 하고 커넥션이 끊겼다고 하면은 샌드를 하면 안되니까 요렇게 만들어주고 그 다음에 WSA 버퍼를 하나 만들어 주도록 합시다 이거는 뭐 역시나 샌드 이벤트에 넣어서 WSA 버프를 관리도 되고 아니면 , 이렇게, 스택에서 그냥 임시로 만들어 가지고 관리해도 됩니다 , 자, 캐스팅은 그냥 아무렇게나 할게요 어차피 임시로 등장하는 코드이기 때문에 어 샌드 이벤트에 퍼퍼에 데이터를 꺼낼 것이고 WSA 버퍼의 렌스는 얼마이냐면은 유롱으로 캐스팅할 건데 버퍼의 사이즈다 라고 , 이렇게, 일단은, 입력을 해주고 그 다음에 여기서 WSA 샌드를 이제 호출해주면 되겠죠 소켓을 받아주고 WSA 버퍼를 받아주고 버퍼 카운트는 일단 한 개만 넣어 줬고요 그 다음에 numberOfByteSand 를 받아 주고 있으니까 여기다가 numberOfByte 라는 변수를 만들어 준 다음에 요 아이를 , 이렇게, numberOfByte 로 넘겨 주도록 합시다 그 다음에 0 그리고 overlap되는 sand event 그리고 nullptr 를 이용해 가지고 컴필션 루틴은 없으니까 , 이렇게, 만들어주면 되고 이게 만약에 실패했다 소켓 에러가 떴다라고 하면은 사율을 체크해야 된다고 했었죠 이게 , 사실, 실패가 실패가 아니고 대부분의 경우에는 그냥 펜딩 상태라는 것이니까 뭐 그럴 때는 딱히 문제가 없는 겁니다 WSA get last error 근데 만약에 에러 코드가 펜딩이 아니다 ws에 펜딩이 아니다 라고 하면 진짜로 어떤 문제가 일어난 상황일 테니까 역시나 아이고 핸들 에러로 얘를 그냥 넘겨주도록 합시다 그 다음에 어 우리가 레퍼런스 카운팅을 1 눌러놨으니까 그걸 다시 줄여줘야 되겠죠? 오너를 다시 널 btr로 밀어주고 릴리스 레퍼런스 어 그 다음에 하는 김에 딜리트 해가지고 샌드 이벤트까지 여기서 그냥 삭제를 핫 해주도록 하겠습니다 , 이렇게, 일단은, 간단하게 만들어 볼 수가 있을 거예요 , 자, 그러면은 뭐 이 부분에 바로 들어와서 문제가 있으면은 , 이렇게, 되겠지만 그게 아니라고 하면은 일반적인 상황에서는 펜딩 상태가 뜰 것이고 아니면은 뭐 경우에 따라서 바로 완료가 돼서 소켓 에러가 안 뜰 수도 있겠죠 근데 어떤 경우에건 얘가 결국에는 우리가 IOCP에다가 관찰 대상으로 넣어놨기 때문에 실질적으로 완료가 되면은 프로세스 샌드 쪽으로 얘가 넘어오게 될 겁니다 그럼 이쪽으로 넘어오게 되겠죠 근데 여기서도 마찬가지로 우리가 내부적으로 리시브 이벤트를 들고 있는 게 아니기 때문에 실질적으로 프로세스 샌드가 떴을 때 날씨였습니다. 어떤 데이터가 어떤 인자로 넘어오는지를 알 수가 없죠 그러니까 얘도 , 일단은, 샌드 이벤트를 똑같이 프로세스 샌드 첫 번째 인자로 받아주도록 하겠습니다 그래서 , 일단은, 요렇게 수정을 해보도록 하고 그 다음 이어가지고 프로세스 샌드를 사용하는 부분에서도 , 자, 요 부분에서도 똑같이 얘를 넘겨주면 되겠죠 스태틱 캐스트 샌드 이벤트로 바꿔가지고 , 자, 요런 식으로 iocp 이벤트를 넘겨주면 이제 완료가 된 겁니다 그러면 프로세스 샌드 내부에서 얘를 다시 처리할 수가 있는 거고 대칭적으로 우리가 항상 여기 들어왔으면 기존에 늘려놨던 레퍼런스 카운트를 1줄에 줬었으니까 얘도 마찬가지로 send event의 owner를 nullptr로 밀어주면서 release 레퍼런스를 여기서 빵 때려주도록 할게요 볼일 다 봤다 이거죠 그리고 하는 김에 여기서 필요 없으니까 send event도 그냥 삭제를 해주도록 하겠습니다 어 그리고 이제 뭐 여기서 만약에 문제가 있다 넘버 오브 바이트가 진짜로 0 이다라고 하면은 뭐 보내는 게 실패하는 그런 상황일 테니까 그냥 디스커넥트를 빵 때려 주도록 할게요 연결이 끊긴 상황이겠죠 샌드 제로 사유로 , 일단은, 리턴을 해 주도록 하고 그게 아니라고 한다면 여기서는 이제 컨텐츠 코드에서 오버 로딩을 해 가지고 샌드한 사실을 , 이렇게, 알려주도록 합시다 근데 대부분의 경우에는 리시브를 할 때는 컨텐츠 코드에서 처리할게 많지만 뭔가를 보낼 때는 , 사실, 뭐 딱히 어마어마하게 처리할게 많지는 않습니다 일반적으로 뭐 굳이 따지자면 너무 지나치게 한 명한테 많은 데이터를 막 보낸다는 건 이상한 상황일 수도 있으니까 그런 부분만 체크한다거나 하는 식으로 나중에 구현하게 될 거예요 , 일단은, 우리 인터페이스 상으로는 커넥트, 디스커넥트, 리시브, 샌드에서 다 컨텐츠 쪽으로 넘겨주는 거니까 그 부분을 , 이렇게, 똑같이 그냥 만들어 봤습니다 , 자, 이렇게까지 하면 기본적으로 샌드하는 부분도 완료가 될 것이고 누군가가 데이터를 받아야 된다고 하면 우리가 이 샌드함수를 빵 호출해주면 될 겁니다 그래서 이런 식으로 간단하게 버퍼를 관리하고 있는데 여기서도 이제 생각할 게 여러 가지가 있다고 했었죠 버퍼는 그냥 우리가 임시적으로 , 이렇게, 놓는다고 해도 이제 그 다음 고민은 뭐냐면 이 샌드를 진짜로 컨텐츠 쪽에서 여러 번 빠바바밤 호출할 때 이게 진짜 가능한가가 일단 고민입니다 즉 지금은 샌드 이벤트를 우리가 단일로 관리하지 않고 여러 개를 만들어 가지고 리지스터 샌드로 넘겨주고 있고 리지스터 샌드로 넘어오면 이 부분이 호출이 될 텐데 첫 번째 질문은 어 근데 이 SS 샌드라는 게 스레드 세이프 한가 멀티 스레드 환경에서 그냥 막 불러도 되는가 라는게 고민입니다 근데 msdn 문서를 살펴보면은 이 샌드 같은 경우에 스레드 세이프 하지 않기 때문에 우리가 어떤 식으로든 순서를 보장을 해줘야 된다고 합니다 예를 들면 여기서 라이드 락을 해준다고 하는 식으로 잠시 막아주면 되겠죠 , 일단은, 근데 그렇게 해가지고 , 일단은, 한 번에 한 슬리드만 접근을 시킨다고 해도 그래도 이제 문제가 완전히 끝나지는 않는 게 뭐냐면은 그 다음으로 이제 고민되는 문제는 뭐냐면은 우리가 SSS을 설령 한 번에 한 번만 호출한다고 해도 이걸 여러 번 중복해가지고 막 호출을 한다고 가정해봅시다 이전에 우리가 걸어준 SSS가 끝나지 않았음에도 불구하고 얘를 또 걸어주면 그때는 어떤 일이 벌어질까가 이제 살짝 헷갈립니다 그런데 정답부터 말씀을 드리자면 , 사실, 딱히 문제가 되지는 않아요 여러 개를 걸어 줘도 되기는 합니다 그러면 이제 어떻게 되냐면 그 중에서 하나가 펜딩이 떴으면 나머지들도 대부분 펜딩으로 딱 걸어지게 되겠죠 그래서 내가 실질적으로 SS핸드를 호출한 순서대로 데이터가 가기는 해요 근데 이제 그 다음에 문제는 뭐냐면 SS핸드가 끝나가지고 디스패츠가 완료되어 가지고 프로세스 쪽으로 넘어오게 되면은 이쪽으로 넘어오게 되면은 이 프로세스 샌드라는 것 자체는 결국에는 이 IOCP 코어에서 워커스레드들이 GetQueueCompletionStatus를 하면서 여기 대기하고 있던 애들이 깨어나가지고 디스패츠를 때리는 거기 때문에 요 부분에서는 , 사실, 순서 보장을 100% 우리가 할 수가 없습니다 대부분의 상황에서는 우리가 ABCD 순서로 보내줬으면 그 ABCD 순서제로 얘가 프로세스 샌드가 호출이 되겠지만 그게 아닐 수도 있다는 얘기가 되는 거죠 만약에 그게 문제가 되는 상황이라고 하면은 조금 까다로워질 수가 있고요 그리고 뭐 그런 문제를 떠나가지고 또 하나의 안 좋은 경우는 뭐냐면은 애당초 펜딩이 떴다는 거는 우리의 커널 쪽에 샌드 버퍼가 이미 꽉 차가지고 용량이 부족해가지고 우리가 데이터를 복사할 수 없는 상황이라는 건데 그 상황에서 굳이 불필요하게 데이터를 또 추가적으로 막 밀어 넣는 게 과연 좋을까는 생각을 해볼 문제입니다 실질적으로 우리가 SSND를 보낼 때 여기 인자로 버퍼랑 랜스를 넘겨주는데 지금 당장 할 수는 없다고 해도 언젠가는 커널 쪽에서 우리가 넘겨준 이 주소에 있는 데이터를 커널 버퍼로 복사해야 되기 때문에 사실상 아무런 코스트 없이 얘를 사용하는 게 아니고 얘를 , 일단은, 주시를 하면서 좀 추가적인 작업을 합니다 이거 너무 고급 주제여 가지고 당장은 얘기 안 할 거지만 페이지 락이라는 개념이 들어가 가지고 얘를 이제 언제 어디서는 빠르게 사용할 수 있도록 뭔가 추가적인 작업을 한다고 일단 이해를 해주시면 되겠어요 뭐 페이징 교체가 안 된다 뭐 이런 쪽이 있는데 그래가지고 결국에는 얘도 이제 그냥 아무런 코스트 없이 막 남발할 수 있는 애들은 아니다 라는 얘기가 되는 거고 두 번째로는 WSSN들을 작은 데이터를 대상으로 막 반복해서 호출하기보다는 데이터를 하나에 한 번에 모아가지고 보내는 게 좋습니다 그래가지고 이게 실제적으로 인자도 보면은 WSA 버프 하나만 보낼 수도 있지만 이런 애들을 여러개를 모아가지고 버퍼를 여러개를 모아놓은 다음에 걔네들을 한번에 모아가지고 보낼 수 있도록 스케터 개더라는 기법을 이용한다고 했었죠 그래가지고 이 두번째 인자랑 세번째 인자가 그런 용도로 사용하는건데 그걸 무시하고 매번마다 한번씩 보내주는게 굉장히 성능적으로 아쉽다는 얘기가 드는거죠 그래가지고 뭐 결국 이런식으로 매번마다 샌드를 할 때마다 , 이렇게, 리지스터 샌드를 매번마다 하기보다는 여기 있는 데이터를 어떤 식으로든 이 세션 쪽에다가 모아놔가지고 그거를 한 번에 보낼 수 있도록 유도를 하는 게 , 일단은, 조금 더 성능상 유리하다는 그런 결론을 얻을 수가 있습니다 근데 이제 그 작업을 지금 당장 하기에는 좀 양이 많기 때문에 , 일단은, 그냥 , 이렇게, 무식하게 매번마다 리지스터 샌드를 그냥 호출하는 식으로만 , 이렇게, 냅두고 , 일단은, 넘어가도록 할게요 , 사실, 샌드는 정책도 다양하고 실제적으로 제가 여러 번 이 코드 저 코드를 봤을 때 이거는 구현하는 방법이 굉장히 다양하긴 했어요 그리고 결국에는 , 이렇게, 해서 샌드를 만들어 놨으면 이제 거꾸로 클라이언트 쪽에서 얘를 사용할 수가 있겠죠 , 자, 근데 지난번에 여기 샌드와 관련된 부분 하기 전에 리시브와 관련된 부분에서 이거 onReceive를 아마 지금 호출 안하고 있을 텐데 , 자, 프로세스 리시브에 잠시 돌아가 가지고 지난번에 하다 만 그런 부분만 살짝 채워 보자면 프로세스 리시브를 했으면 여기 우리가 to do로 , 이렇게, 해놨는데 일단 로그는 일단 삭제를 하고 여기에다가 onReceive를 이제 호출해 줘 가지고 컨텐츠 쪽으로 얘를 넘겨 주도록 할 거예요 지금 , 일단은, Receive Buffer랑 Number of Bytes 이렇게만 넘겨주도록 하겠습니다 내가 어떤 버퍼를 몇 바이트만큼 지금 받았다라고 일단 넘겨주고 있는 거죠 에러가 나는 것은 우리가 Receive 버퍼를 캐릭터로 만들어 놨는데 얘를 그냥 Byte로 수정을 해주도록 하겠습니다 그래서 , 이렇게, onReceive로 이제 버퍼와 렌스를 넘겨주는 형태로 만들어 주면 될 것이고 마찬가지로 onSend 같은 경우에도 우리가 위에서 , 이렇게, 만들어 놨으니까 컨텐츠 오버로딩 코드가 이제 두 개가 들어갔다고 볼 수가 있는 거예요 일단 주속을 , 이렇게, 써놓도록 하겠습니다 , 자, 그러면은 이제 클라이언트 쪽이랑 서버 쪽에 다시 가가지고 , 일단은, 게임 서버 쪽에서 , 자, 우리 게임 세션에다가 뭐 요런 이런저런 기능들을 한번 추가를 해보도록 합시다 , 일단은, virtualint32 onReceive라는거를 오버로딩 해가지고 오버라이드 해가지고 어 int32 , 자, 이렇게, 오버라이드를 한 다음에 만약에 어떤 데이터를 받았으면 에코서버처럼 동작하게끔 유도를 해주도록 합시다 , 일단은, 로그를 간단하게 찍고 onReceive 렌스는 얼마얼마이다 를 여기다가 , 일단은, 옮겨 놓도록 할게요 그 다음에 바로 샌드를 해쳐가지고 해당 버퍼에다가 렌스를 그대로 넘겨서 데이터를 그냥 다시 건네주도록 할게요. 여기서 이 렌스를 다시 뱉어주는 이유는 뭐 나중에 나올 거니까 일단 스킵을 하시고 , 이렇게, 해가지고 세션이 데이터를 받았으면 다시 샌들을 호출해 줘 가지고 실질적으로 데이터를 보내주게 될 겁니다. , 자, 여기서도 , 일단은, 로고를 간단하게 찍어 보도록 합시다 뭐 , 사실, 이거는 온샌드 쪽에다가 얘도 이제 오버라이드를 해가지고 만들어 줘도 되긴 하겠죠? 온 리십이라는 것 자체가 우리가 결국에는 여기 놓고 보면은 온샌드라는 거를 , 이렇게, 오버라이드에서 사용할 수 있으니까 여기다가 , 일단은, 만들어 주도록 할게요 오버라이드 그 다음에 복붙 해가지고 온샌드 렌스는 얼마 얼마이다 라고 , 이렇게, 만들어 주도록 하겠습니다 그럼 , 일단은, 뭐 더미 클라이언트 쪽에서는 데이터를 당장 리시브 하지는 않으니까 얘가 실질적으로 받지는 않겠지만 , 일단은, 우리 커널 버퍼 쪽으로 데이터가 복사가 되면 샌드가 성공적으로 뜨긴 할 테니까 , 일단은, 간단하게 샌드 테스트만 하기 위해서 얘를 이제 실행해 보도록 할게요 일단 서버 코어를 빌드 해가지고 문제가 없는지 살짝 테스트를 해 본 다음에 그 다음에 게임 서버도 빌드하고 그 다음에 이제 뛰어가 가지고 리시브랑 샌드가 정상적으로 뜨는지 한번 살펴 보도록 합시다 , 자, 그러면 기다려보다면 실행을 해보면 , 자, 이런식으로 onReceive, onSend, onReceive, onSend 이런식으로 왔다갔다 하면서 지금 데이터를 받고 보내고 받고 보내고 하는게 정상적으로 동작한다는걸 일단 알 수가 있습니다 , 자, 이렇게, 해가지고 사실은 아직 뭐 갈 길이 굉장히 멀고 이 샌드쪽도 고칠게 굉장히 많기는 한데 이런저런 문제들에서 , 일단은, 고민을 하는 시간을 가져봤고요 샌드 이벤트는 , 일단은, 실시간으로 만들어주고 있고 그 다음에 이 리지스터 샌드에서 이 WS 샌드를 중첩해서 호출할지 말지에 대한 문제에 대해서 , 일단은, 간략하게 논해봤는데 이게 이제 굉장히 중요한 개념이라고 , 일단은, 보시면 되겠어요 , 자, 이렇게, 간단하게 샌들을 구현을 해봤구요 그 다음에 이런 코드를 작업할 때 까먹지 않고 레퍼런스 카운팅 관련한 테스트를 틈틈이 해주는게 좋습니다 여기다가 브레이크 포인트를 잡아가지고 혹시 모르니까 다시 빌드를 하고 우리가 클라이언트를 강제로 종료했을 때 진짜로 세션이 잘 삭제되는지를 살펴봐야 되겠죠 그래서 물론 나중에 가서 이걸 한 방에 잡아도 되긴 하지만 너무 작업을 많이 하다 보면 이게 실질적으로 어떤 애 때문에 릭이 일어나는지 알기가 힘들기 때문에 중간중간 , 이렇게, 한 번씩 테스트를 해보는 습관이 좋습니다 그래서 더미 클라이언트를 빵 꺼주면 지금은 정상적으로 세션이 소멸되는 걸 볼 수가 있어요 그래서 뭐 아직까지 별다른 문제 없이 잘 동작하는구나 라는 걸 알 수 있었고 이번 시간은 간단하게 그냥 샌드 작업만 해보고 , 일단은, 마치도록 하겠습니다. 그래도 조금씩 조금씩 우리 세션이 모양을 갖춰 나가고 있는 걸 , 일단은, 알 수가 있네요.