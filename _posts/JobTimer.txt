이렇게, 지난 시간까지 계속 잡에 대한 내용에 대해서 한 바퀴를 쭉 돌아봤고요 굉장히 중요한 내용에 대해서 많이 다뤘습니다 이게 좀 반복적인 내용도 많은 것 같고 잡이 아직 무엇인지도 와닿지 않는데 이렇게까지 깊이 할 필요가 있을까 싶긴 하지만 이게 진짜 중요한 내용입니다 그러니까 네트워크도 당연히 중요하죠 서버다 보니까 네트워크 코어도 당연히 중요하겠지만 결국에는 MMO에서 네트워크 못지않게 중요한 부분은 우리가 수십만 마리 몬스터와 AI와 뭐 스킬 같은 그런 오브젝트들을 어떻게 잘 배분을 해가지고 스레드들이 실행을 할지가 , 사실, 굉장히 중요하고 그거를 결정 짓는 것들이 결국에는 이런 잡 방식이기 때문에 뭐 굉장히 다양한 수업을 하려 해가지고 이것에 대해서 , 일단은, 강조를 드리고 있는 겁니다. 그리고 오늘도 이어서 마지막으로 이와 관련된 한 가지에 대해서만 더 알아볼 건데 잠시 그걸 하기 전에 지난 시간에 했던 부분을 한 가지만 수정을 해보도록 할게요. , 자, 우리가 이제 뭐 이리저리서 다 Shared Pointer를 지금 활용해 가지고 코드를 만들고 있습니다. 사실상 이 REF가 붙은 것도 다 Smart Pointer, Shared Pointer죠. 그리고 Shared Pointer를 활용하게 되면 당연한 얘기지만 스마트 포인터 특성상 레퍼런스 카운팅이 되기 때문에 오염된 메모리를 건드린다거나 아니면 댕글링 포인터가 일어난다거나 하는 확률은 당연히 줄일 수가 있겠지만 반대로 이제 메모리 릭이 일어날 확률이 또 높아지게 됩니다 약간 트레이드를 하는 거죠 근데 , 사실, 메모리 릭이 뭐 크래쉬 나는 것보다는 뭐 좋을 수도 있다고 볼 수도 있겠지만 이게 경우에 따라 가지고 진짜 잡기가 어려울 수가 있습니다 그래서 제가 처음에 일했던 프로젝트에서는 이제 서버를 오랫동안 띄우면은 조금씩 조금씩 메모리가 고갈이 되어 가지고 한 2주 동안 서버를 연속해서 띄우면 한 번씩은 이제 서버를 내리고 다시 띄워야 됐었습니다 이런 릭이 계속 쌓이고 쌓이게 되다 보면 그것도 이제 무시 못한다는 얘기가 되는 거죠 그래서 연습 삼아서 하나만 해보자면 , 사실, 우리가 지난 시간에 만들고 있던 코드가 소멸자가 지금 여기 게임 세션 소멸자로 로그를 찍어 놨는데 언제부턴가 소멸자 로그가 찍히지 않고 있었습니다 놀랍게도 즉 이제 슬슬 메모리 릭이 일어나고 있다는 얘기가 되는 거죠 근데 뭐 지금은 코드 분량이 많지 않으니까 코드만 봐도 어디서 일어난지 딱 감이 옵니다 플레어 랩프를 만들었는데 플레어 랩프를 만들었는데 플레어랩프를 만들었는데 플레어랩프를 만들었는데 플레어랩프를 만들었는데 플레어랩프를 만들었는데 플레어랩프를 만들었는데 플레어랩프를 만들었는데 플레어랩프를 만들었는데 플레어랩프를 만들었는데 플레어랩프를 만들었는데 플레어랩프를 만들었는데 플레어랩프를 만들었는데 플레어랩프를 만들었는데 플레어랩프를 만들었는데 플레어랩프를 만들었는데 플레어랩프를 만들었는데 플레어랩프를 만들었는데 애당초 이 플레어 처리를 안 해줬기 때문에 얘가 영영 지금 해제가 되지 않고 있는 겁니다 그리고 마찬가지로 이 플레어도 심지어 우리가 룸 안에다가 넣어놨는데 여기서 이제 빠져나오게끔 뭔가 유도를 해줘야 되는데 그런 부분도 없다 보니까 여기에도 플레어 레프가 들고 있고 여기서도 내부적으로 여기 있는 플레어 레프에 인해가지고 게임 세션에 레퍼런스 카운트가 해제가 되지 않는 그런 여러가지 문제가 지금 막 얽히고 섞인 거죠 그래서 뭐 이런 부분에 대한 처리에 대한 실습을 그냥 간단하게 해보고자 하는데 뭐 , 일단은, 처음에 이제 플레이어가 들어왔을 때 로그인을 할 때 우리가 클라이언트 패킷 핸들러에서 여기 플레이어와 관련된 부분들을 지금 요렇게 연결을 해주고 있었습니다 근데 이제 그 다음에 이제 선택을 해가지고 플레이어가 선택을 해가지고 내가 어떤 플레이어로 로그인 할 거야라는 패킷을 이제 정해주게 되면은 즉 C 언더바 엔터 게임을 호출하게 되면은 여기서 플레어를 이용해가지고 선택만 해줄 뿐만 아니라 내가 어떤 플레어를 이용해가지고 지금 로그인을 하고 있는지 그리고 내가 현재 어떤 방에 들어가 있는지 등등의 정보를 게임 세션에서 들고 있다가 나갈 때가 되면 그걸 처리해주는 게 필요하다는 얘기가 되는 거죠 뭐 그런 부분을 일단 간단하게 한번 작업을 해볼게요 , 자, 일단 플레어 래프를 Current Player 라고 해가지고 내가 현재 어떤 플레어로 지금 접속을 하고 있는지를 저장할 것이고 그 다음에 룸 같은 경우에는 내가 지금 없을 수도 있으니까 그냥 위크 포인터로 , 일단은, 그냥 , 이렇게, 만들어 보도록 할게요. 물론 이거를 쉐어드 포인터로 만들어도 상관이 없긴 합니다. 그냥 사이클을 우리가 잘 끊어줘야 될 뿐이에요. 그럼 이제 예를 들면은 지금 여기서 밸리디션 코드 아래서 원래는 그냥 우리가 플레어라고 말을 했던 요 부분을 이제는 요런 식으로 바꿔치기를 해주면 되겠죠. 현재 플레어는 누구누구이자 그래가지고 여기서 마찬가지로 게임 세션의 룸 같은 경우에도 까먹지 않고 뭐 이런 식으로 내가 현재 어디에 속했는지 등등의 정보를 뭐 , 이렇게, 연결을 해주면 되겠습니다 , 이렇게, 그냥 포인터로 들고 있는 게 마음에 안 들면은 아이디를 들고 있게 한 다음에 그 아이디를 이용해 가지고 뭐 빠르게 딕셔넬이라거나 아니면은 뭐 해시 테이블 같은 굉장히 빠르게 접근할 수 있는 그런 자료 구조를 통해 가지고 빼오는 것도 방법이 있기는 해요 , 일단은, 그냥 포인터로 들고 있게 만들어 보자면 이런 느낌으로 만들어 줄 수가 있는 거죠 , 자, 그래가지고 여기서 이제 , 이렇게, 만들고 있고요 그 다음에 여기서 CurrentPlayer를 다시 , 이렇게, 넣어주도록 하겠습니다 여기도 , 이렇게, 고쳐보도록 할게요 그럼 이제 이 포인터를 통해 가지고 내가 지금 어떤 플레이어로 어떤 방에 접속해 있는지를 이제 알 수가 있게 된 겁니다 그러면은 이제 이어가지고 만약에 연결이 끊겼다라고 할 때 onDisconnected가 호출이 될 텐데 여기서 확실히 끊어줘야 된다는 얘기가 되는 거죠 만약에 CurrentPlayer가 null이 아니라고 하면은 얘를 이제 해제를 시켜줘야 되니까 방을 찾을 건데 방도 있을 수도 있고 없을 수도 있겠죠 우리가 방을 테스트 삼아서 지금 위크 포인터로 들고 있으니까 얘를 , 이렇게, 락을 통해 가지고 쉐어드 포인터로 변환한 다음에 얘가 만약에 그 타이밍에 이미 소멸이 되었으면 얘가 null로 반응이 될 것이고 null이 아니라고 하면은 여기서 do async를 한 다음에 room에 leave를 해주세요 라고 요 부분을 이제 예약을 해주면 되겠죠 이 current player라는 애를 이제 소멸시켜줘 라고 한 다음에 그 다음에 얘를 이제 nullptr로 , 이렇게, 밀어 버리면은 기존에 있던 레퍼런스 카운트도 날아가게 될 것이고 그 다음에 players도 클리어 해줘 가지고 여기서 들고 있던 정보도 미리 날려주면 되겠죠 뭐 요런식으로 이런저런 코드들을 같이 섞어주면은 이제 레퍼런스 카운팅이 0이 되가지고 끊기는 현상이 이제 일어나게 될 겁니다 그러니까 사이클을 끊어주게 될 겁니다 , 자, 요렇게 , 일단은, 만들어 준 다음에 음 그냥 간단하게 한번 빌드를 해보고 지금 게임 세션 이 부분까지 , 일단은, 들어오는지를 한번 테스트를 해보도록 할게요. 만약에 여기도 아직까지 안 들어오면 또 문제가 있는 거니까 한번 또 찾아보도록 합시다. , 자, 그래서 , 이렇게, 일단은, 간단하게 한번 실행을 해봤구요. 네 그 다음에 조금 기다려 가지고 실행이 되고 있는데 실행이 된 다음에 여기 이제 더미 클라이언트 쪽을 강제로 끊어 가지고 살펴보면은 , 자, 이제는 정상적으로 여기 소멸적으로 들어오는 걸 볼 수가 있습니다 뭐 이런 느낌으로 중간 중간에 한 번씩 레퍼런스 카운트가 잘 미뤄지고 있는지를 테스트해 보면 되겠죠 물론 , 이렇게, 브레이크 포인트를 잡지 않고 그냥 이제 클라이언트 쪽에서 더미 클라이언트가 지금은 그냥 연결하고 그냥 메시지만 보내고 있는데 연결했다 끊었다 연결했다 끊었다 하는 그런 반복적인 작업을 해보면서 세션을 인위적으로 계속 늘렸다가 줄였다가 늘렸다가 줄였다가 하는 테스트를 해보면 그 상태에서 메모리가 그냥 우상향으로 그냥 쭉 무한대로 늘어난다고 하면은 뭐 메모리 릭이 있을 것이고 그게 아니면 어느 정도는 이제 안전하다고 볼 수가 있는 거죠 그럼 요런 테스트도 중간중간 해줘야 됩니다 , 자, 뭐 그건 그거였고 이제 오늘 그래서 이어서 할 내용은 뭐냐면은 다시 잡으로 돌아가가지고 , 자, 우리가 이제 잡큐에다가 doAsync라는 요 함수를 이용해가지고 일감을 밀어넣는 작업까지는 뭐 잘 되었습니다 , 자, 그런데 여기서 막상 이것만 이용해가지고 게임을 또 만들어 보려고 하면은 굉장히 아쉬운 부분이 하나가 있는데 어 우리가 보통 뭐 스킬이건 아니면은 뭐 AI건 뭐 어떤 것도 상관.. 마찬가지겠지만 무한적으로 무한대로 틱을 돌면서 막 실행하는 경우는 많이 없습니다 물론 클라이언트 같은 경우에는 애당초 렌더링을 해야 되니까 그래픽스를 계산해가지고 그거를 화면에 그려야 되고 그거를 빨리 그리면 그릴수록 화면이 부드러워지니까 그냥 온갖 성능을 다 끌어올려가지고 계속 루프를 돌면서 처리를 하겠지만 서버 같은 입장에서는 그렇게 진짜 1초에 몇백 번씩 갱신을 하면서 한 오브젝트를 갱신할 이유가 전혀 없습니다 그래가지고 보통은 이제 뭐 한 1초 단위로 만약에 인공지능이라고 하면은 뭐 한 2초? 1초? 그 정도 단위로 주기적으로 체크만 하면서 객체를 이제 업데이트 해가지고 로직을 실행시키는 게 이제 일반적이겠죠 뭐 그게 길찾기가 될 수도 있고 아니면 그냥 앞으로 이동하는 것일 수도 있고 뭐 아니면 그냥 데미지 판별일 수도 있고 여러가지 뭐 그런 경우일 수가 있겠지만 결국에는 그렇게 아주 빠르게 빠르게 빠르게 연산할 필요는 없다는 겁니다 클라에 비해서. 그런데 지금 상태로는 딱히 그렇게 1초마다 뭔가를 처리한다고 해도 그걸 딱히 처리할 방법이 없죠 우리가 가장 처음에 프로그래밍을 배울 때 특히 클라이언트 쪽에서는 별로 신경을 안 써서 만약에 만들다고 하면 이런 쿨타임 체크 같은 걸 어떻게 하냐면 그냥 현재 시간을 체크한 다음에 예를 들면 이런 느낌으로 현재 T카운트는 얼마인지를 뭐 이런저런 함수들이 유행해가지고 T카운트 64 같은 걸로 체크를 한 다음에 여기다가 뭐 예를 들면 1000을 더한게 이제 1초 후에 시간이 되겠죠 이게 뭐 예를 들면은 엔드라고 가정해볼게요 그러면 여기다가 이제 현재 시간이 요 엔드를 지났는지 안 지났는지를 체크하기 위해서 그냥 매 프레임마다 요렇게 루프를 돌면서 매 프레임마다 체크를 하다가 시간을 다시 계산해가지고 현재 시간은 언제인지를 다시 계산을 해가지고 요 시간이 엔드 시간보다 더 큰지 아닌지를 판별한 다음에 만약에 요 시간보다 더 크다고 하면은 1초가 경과 되었다라고 판별할 수가 있을 겁니다 요런 식으로 루프를 굉장히 많이 돌면서 처리하는 게 일반적인데 서버 같은 경우에는 MMO 서버는 특히나 객체가 몇십만 몇백만 단위가 되는데 그 1초마다 라는거를 판별하기 위해서 몇백만번의 루프를 계속 무의미하게 도는거는 좀 말도 안되는 직원이겠죠 그래가지고 결론적으로 말씀을 드리자면 일종의 예약 시스템이 필요합니다 1초 후에 라는거를 딱 걸어주면은 정말로 그 1초 후에 뭔가 , 이렇게, 딱 실행이 되는 그런게 필요하다는거죠 그리고 이건 , 사실, 대부분의 클라이언트 게임 엔진에서도 다 존재하는 개념입니다 뭐 유니티에서도 우리가 콜 루틴을 이용해가지고 뭐 yield new for second 같은 걸 이용해가지고 뭐 쿨타임을 만들곤 하죠 1초 후에 2초 후에 뭔가 실행이 돼야 될 때 그렇게 잠시 뭐 텀을 뒀다가 뭐 실행해라 라는 걸 이제 예약을 할 수가 있는데 그거랑 마찬가지로 우리도 어떠하게 뭔가 , 이렇게, 예약할 수 있는 시스템이 필요하다는 게 일단 오늘의 결론이겠습니다 근데 이제 예약을 하려고 하면은 조금 머리가 아파지는 게 우리가 지금까지는 윗감을 즉흥적으로 바로 만들어서 꽂아주는 식으로만 지금 작업을 하고 있었어요 그래서 요 푸쉬라는 잡키의 푸쉬도 보면은 내가 일바로 들어왔다 하면은 대부분의 경우에는 이제 실행을 할 것이고 이미 실행 중인 잡키가 있다고 하면은 그냥 윗감만 밀어 놓고 빠져 나오겠다 라고 요렇게만 만들어 놨습니다 그런데 이제 만약에 조금 다른 케이스가 되어 가지고 일감을 예약을 해야 된다고 하면 지금 당장은 개를 실행할 필요 없고 1초 후에 개를 넣어줘야 된다는 얘기가 되는 거니까 지금 하던 방식이라는 살짝 뭔가 로직이 달라져야 될 필요가 있다고 볼 수가 있겠어요 그래서 이 예약 시스템도 당연한 얘기지만 만드는 방법이 굉장히 다양하게 있어요 근데 오늘 간단하게 한번 보여드릴 방법은 중앙 통지를 이용하는 방법입니다 이제 우리가 앞으로 예약할 일이 있으면 만약에 우리가 여기 잡 큐 안에다가 일을 예약을 한다고 가정해 볼게요 여기다가 , 이렇게, 잡을 들고 있는 것처럼 하나를 더 만들어 가지고 뭐 예를 들면 우선순위 큐 같은 프라이럴티 큐 같은 걸 사용해 가지고 내가 예약한 잡을 들고 있다고 가정을 해 봅시다 근데 그 예약한 잡이라는 거는 언제 실행이 될지 당장은 예측하기가 힘들죠 그게 10초 후가 될 수도 있고 100초 후가 될 수도 있고 언제가 될지 모르니까 걔를 매번 마다 체크해 가지고 실행을 하려면은 이것도 약간 굉장히 애매해집니다 그래서 이걸 잡큐마다 하나씩 두고 여기서 일감을 들고 있기보다는 그냥 중앙 시스템을 만들어가지고 중앙에서 그 모든 예약된 일감들을 들고 있다가 걔네들 좀 빠르게 체크해가지고 , 이렇게, 뿌려주는 방식으로 한번 만들어 볼 거예요 물론 말로 하면 항상 너무 얘기가 어려우니까 일단 코드로 간단하게 한번 보여드리자면 , 자, 오늘 추가할 애는 일단 잡타이머라는 이름으로 부르도록 할게요 뭔가 시간과 관련된 애니까 잡타이머라고 부를 것이고 그 다음에 잡타이머를 이쪽으로 쭉 이쪽에다가 , 이렇게, 배치를 시켜주도록 합시다. , 자, 그 다음에 SPP는 오른쪽에다가 , 이렇게, 만들어 주도록 하고 주석을 , 이렇게, 좀 영역을 집어보도록 하겠습니다. 그 다음에 얘는 이제 잡타이머가 될 것인데 어... 먼저 잡데이터라는 걸 , 이렇게, 만들어 줄 겁니다. 잡데이터에서는 위급 PTR로 그 해당 잡을 실행해야 될 오너를 , 일단은, 들고 있도록 할게요 근데 위크 포인트로 들고 있는 이유는 예를 들면 우리가 이 잡을 한참 후에 예약할 수도 있는데 예를 들면 100초 후에 예약할 수 있는데 걔가 실행이 될 때까지 만약에 얘를 쉬드 포인트로 물고 있으면 생명 주기상 얘가 최소한 그 시간 동안은 수멸되지 못하게 될 수가 있기 때문에 뭔가 좀 찜찜하다 보니까 그런 부분을 좀 우회하기 위해서 그냥 위크 포인터로 일단 들고 있도록 할게요 그리고 얘는 어차피 자주 체크하는 것도 아니고 딱 실행할 때 한 번만 필요하다 보니까 그냥 위크 포인터로 들고 있는 것도 괜찮을 것 같습니다 , 자, 그래서 , 이렇게, 일단 만들어 보고 잡데이터의 생성자는 그냥 간단하게 다시 , 이렇게, 만들어주도록 할게요. 잡귤을 넣어주고, 오너를 받아주고, 잡 레퍼런스, 내가 실행해야 될 일감을 각각 받아준 다음에 그걸 , 이렇게, 멤버 변수로 들고 있도록 하겠습니다. 그냥 이게 끝이고. , 자, 그 다음에 타이머 엘레먼트라고 해가지고 타이머 아이템이라고 할게요. 이제 우선승의 큐에 들어갈 아이템을 설계를 해주도록 하겠습니다. 얘는 유인트64로 실행돼야 되는 Execute Tick이라고 실행돼야 될 Tick을 , 일단은, 들고 있을 것이고 그 다음에 위에서 만들어준 잡 데이터를 여기다가 일단 들고 있도록 할게요. , 예를 들어, 포인트로 들고 있는 이유는 이 아이템이 나중에 아무리 Priority Queue 안에 들어가 있다고 해도 이리저리 위치가 알고리즘 특성상 바뀔 수도 있는데 그때마다 복사를 하면 여기 있는 스마트 포인트와의 레퍼런스 카운트가 1 증가하고 줄어들고 하는 부분에 영향을 줄 수 있으니까 효율적으로 만들기 위해서 그냥 생 포인트로 들고 있도록 할 겁니다 어차피 이 엘레먼트의 포인트는 여기 내부에서만 사용을 하고 해제를 해줄 거예요 네, 그래서 , 이렇게, 만들어 줄 것이고 그 다음에 이 비교 오퍼레이터를 만들어 줄 것인데 콘서트 타이머 아이템 다른 애랑 비교를 해 주어서 얘를 이제 어떤 식으로 비교를 해 줄 거냐면 그냥 Execute Tick을 비교해 줘 가지고 상대방의 Execute Tick이랑 , 이렇게, 비교를 해 줄 것입니다. 뭐 , 이렇게, 일단은, 그냥 간단하게 만들어 볼 수가 있을 거예요. , 자, 그 다음에 어... 이제 이어가지고 Public으로 , 이렇게, 만들어 준 다음에 reserve 라고 해가지고 , 자, 일단은, 유니트 64 tick after를 받아 줄 것이고 위크 포인터를 받아줄 것이고, 오너를 받아줄 것이고, 그 다음에 잡 랩프를 통해 가지고 잡 자체도 , 이렇게, 받아주도록 하겠습니다. 이게 첫 번째 함수, 즉 뭔가 이 잡 타이머에 예약을 한다라는 그런 부분이고요. 그래서 참고로 얘는 일단 락을 사용할 것이라서 유스 락을 넣어줄 것이고, 그 다음에 프라이오리티 큐를 사용해가지고 타이머 아이템을 , 이렇게, 들고 있도록 할게요. 아이템스라고. , 자, 그 다음에 아토믹 타입으로 불리언을 들고 있을 건데 distributing 이라고 해가지고 내가 얘를 지금 어 뭔가 이리저리 실행을 하고 있는지 즉 다시 , 이렇게, 배치를 하고 있는지 요구를 또 , 이렇게, 기억을 해주도록 하겠습니다 즉 한 번에 한 명만 실질적으로 일간 배분을 막겠다라는 정책을 이제 우리가 만들 거예요 , 자, 이건 좀 코드를 만성된 걸 보는 게 좀 나을 것 같고 , 자, 그 다음에 이제 이어서 함수들은 Distribute라고 해가지고 이제 지금 여기 들어가 있는 일감들을 시간이 된 애들을 배분해가지고 원래 Owner에다가 이 job을 꽂아주는 거를 이제 우리가 배분한다라는 느낌으로 Distribute라는 함수로 , 이렇게, 만들어 주도록 할게요 그냥 뭐 Execute나 다른 이름도 당연히 상관없습니다 그냥 왠지 기분 삼아 , 이렇게, 좀 이름을 바꿔봤어요 뭐 대충 한 줄 , 이렇게, 맞춰 보도록 합시다 , 자, 그 다음에 이제 오른쪽에 가가지고 이어서 코드를 만들어 줄 건데 Implementation을 각각 하나씩 하나씩 , 이렇게, 만들어 준 다음에 얘 같은 경우는 이제 전역으로 들고 있을 예정입니다. 그 잡타이머는 전역으로 만들어 줄 예정이에요. 그건 참고삼아서 기억을 해주시면 되겠고 , 자, 그 다음에 위에서 , 일단은, Include 잡큐를 추가를 해주고 시작을 하도록 할게요. , 자, 그 다음에 먼저 계산을 해야 되는 거는 Execute Tick 몇 초 후에 리설브를 하겠다라는 식으로 넣어놨으니까 , 일단은, getTickCount64에다가 plus tick after를 이용해가지고 내가 실행돼야 되는 그 tick을 개선을 해준 다음에 그 다음에 job data를 만들어 주도록 할게요 object pool을 이용해가지고 job data를 만들어 준 다음에 pop을 해가지고 여기다가 생성자에는 owner랑 job을 넣어 주도록 하겠습니다 그 다음에 여기다가 items에 push를 해가지고 타이머 아이템을 만들어 줄 것인데 여기다가는 execute tick이랑 job data를 각각 , 이렇게, 넣어주도록 하겠습니다 근데 얘가 이제 전역으로 지금 사용할 것이기 때문에 여기다가 write lock을 이쯤에서 걸어 주도록 할게요 , 자, 여기까지는 , 사실, 뭐 이미 여기는 락이 걸려있고 얘는 뭐 딱히 다른 애들이랑 경합을 하는 개념이 아니니까 여기까지는 상관없었지만 여기부터 이 아이템에 접근하는 순간은 얘는 이제 쓰레드 세입하지 않기 때문에 요렇게 , 일단은, 락을 잡아준 겁니다 , 자, 그 다음에 좀 내려가지고 클리어 함수부터 만들어보자면 클리어 함수는 이제 무엇을 해야 되느냐 뭐 , 사실, 얘는 굳이 사용할 일은 없을 거예요 근데 뭐 그냥 이왕이면은 좀 정리하는 함수도 만들어보자면 뭐 대략 요럭적인 느낌이겠죠 items가 mt가 false일 때까지 즉 뭔가 하나라도 남을 때까지 계속 뺑뺑이를 돌면서 여기서 타이머 엘레멘트를 뭐 , 이렇게, 꺼내줄 수가 있을 겁니다 items.top을 이용해가지고 아이템을 꺼내줄 것이고 그 다음에 object pool에 다시 jobdata에 push를 해줘가지고 타이머 아이템의 jobdata를 뭐 , 이렇게, 반환을 할 수가 있을 겁니다 그 다음에 아이템 스팟을 해가지고 이제 일감을 꺼내주면 되겠죠 근데 뭐 어차피 잡타이면은 전역으로 있을 것이고 얘를 딱히 일감을 넣어준 다음에 클리어 해줄 일은 뭐 딱히 없긴 할 거예요 이왕이면 좀 정리함수도 만들어주는 게 좋은 거니까 그냥 해봤고 그 다음에 이제 요 부분이 중요한데 먼저 한 번에 한 스레드만 일단 통과를 시켜줄 겁니다 다른 애가 이미 여기 디스트리뷰트 작업을 하고 있으면 나머지 애들은 그냥 뭐 빠져나온다는 거죠 한 번에 한 명만 해주게 될 겁니다 그래가지고 지금까지 우리가 뭐 이런 코드는 많이 만들어 봤는데 엑스체인지를 일단 트롤을 해줄 것인데 여기서 이전 값이 튀어나오는데 이전 값이 true 였다고 한다는 것은 누군가가 이미 요 함수를 지금 실행 중인 상태라는 되는 거니까 그냥 바로 return 을 떼어주고 만약에 모든 일이 다 맞췄다 즉 여기 끝까지 와 가지고 끝났으면 풀어 주도록 하겠습니다 그래서 여기서는 다시 distributing 을 First로 이제 , 이렇게, 리셋을 시켜 주도록 할게요 그 다음에 중간에 어 먼저 이제 무엇을 해볼 거냐면은 애당초 이 아이템 자체는 락을 잡아 가지고 지금 딴 애가 접근할 수 있기 때문에 최대한 빠르게 여기 있는 아이템들을 다 꺼내 와 가지고 작업을 해보도록 합시다 , 자, 그래가지고 최소한으로 락을 잡기 위해서 요런 식으로 임시벡터를 만들어가지고 요기다가 , 일단은, 아이템을 다 복사를 하도록 할게요 뭐 , 사실, 이렇게까지 할 필요는 없긴 하지만 네 , 일단은, 요렇게 일단 만들어 보도록 하겠습니다 락을 잡아가지고 아이템스가 엠티... 엠티가 펄스일 때까지 뭔가 아이템이 있을 때까지 계속 실행을 할 것인데 어... 그 다음에 타이머 아이템을 체크해가지고 타이머 아이템을 아이템스에 items at top을 체크해가지고 만약에 now가 timer item의 execute tick이랑 비교해가지고 현재 시간이 execute tick보다 작다는 얘기는 아직 때가 되지 않았다는 얘기가 되는 거죠 그러니까 여기서 바로 브레이크를 때려주도록 하겠습니다 근데 여기까지 브레이크가 아니라고 하면은 실행할 때가 됐다는 얘기니까 벡터에다가 타이머 아이템을 밀어 넣도록 할게요 그 다음에 아이템 쓰는 이제 팝을 해줘서 프리오리티 큐에서 빠져나오는 거죠 요 큐에서 , 일단은, 얘를 빼주도록 하겠습니다 그래서 여기까지 실행이 되면은 락을 잡고 재빠르게 지금 실행될 때가 된 애들만 쏙쏙쏙 뽑아온 거니까 그 다음에 안전하게 나 혼자서 지금 단일 스레드만 지금 실행하고 있으니까 여기부터는 락을 걸어줄 필요 없고 , 이렇게, 하나씩 하나씩 스냐를 하면서 체크를 해보도록 합시다 잡, 큐, 랩으로 owner를 다시 추출을 해줄거에요 jobdata에 owner는 lock을 이용해가지고 우리가 weak pointer를 smart pointer로 그러니까 shared pointer로 변환하는게 lock이였죠 그거를 요기다가 재입을 해주는겁니다 요거 이 꼬리 꼬리 아니에요 이겁니다 걔를 요기다 넣어준 다음에 null 체크까지 해가지고 null이 아니면 요기로 들어온다라는 패턴으로 이제 만들어 준겁니다 한줄짜리니까 요기다가 만들어 보자면 owner에 push를 해가지고 어 이제 아이템에 jobdata를 , 자, 요런식으로 꺼내가지고 여기다가 밀어 넣어준 다음에 그 다음에 object pool을 이용해가지고 다시 잡 데이터를 푸쉬해서 아이템 점 잡 아이고 아이템 점 잡 데이터를 이제 소멸을 시켜주도록 하겠습니다 뭐 요런 느낌으로 일단 만들어질 거에요 , 자, 근데 일단 푸쉬로 돌아가 가지고 요게 지금 에러가 나오고 있는데 아 우리가 그냥 지난 시간에 이걸 오른값으로 만들어 놨는데 그냥 이거는 삭제 하도록 할게요 굳이 그렇게까지 신경 쓸 필요는 없고 그냥 얘를 복사 한번 하더라도 레퍼런스 카운트 한번 증가는 증가하고 줄어드는 거니까 뭐 그 정도까지는 그냥 허락을 해주도록 하고 그 다음에 얘가 이제 퍼블릭으로 열어줘야 되겠죠 그래서 요렇게 , 일단은, 만들어주면 되겠습니다 Push, Execute 이제 사이좋게 들어가 있고 그러면은 요 부분도 이제 에러가 없어지고 만약에 이 Owner가 아직까지 소멸이 되지 않았다고 하면은 걔한테 다시 Push를 해주도록 할게요 근데 여기서 기존에는 우리가 Push를 할 때 보면은 이 코드를 다시 한번 살펴보면 내가 1바로 들어왔으면 항상 걔를 실행하는 것까지 담당을 하려는 시도를 하고 있었는데 지금은 그냥 이를 배분하는 역할만 하기 위해서 이거 옵션을 하나를 더 주도록 합시다 여기 push에다가 두 번째 인자로 boolean pushonly라는 것을 옵션으로 줘가지고 기본 값은 false이긴 한데 얘를 만약에 우리가 세팅을 한다고 하면은 즉 여기에다가 얘를 세팅해서 true로 한다고 하면은 push only가 켜져 있으면은 execute는 하지 않고 무조건 이 글로벌 큐에다가 놓고 빠져나오도록 할게요 push only가 false면은 실행한다 그래서 원래는 내가 처음이었다 prepcount가 0이었다고 하면은 항상 실행까지 담당했는데 이제는 우리가 옵션을 줘가지고 그냥 배분하려는 의도로만 만약에 사용하고 있었다고 하면은 여기다가 그냥 global q에다가 넣고 그게 아니라고 하면은 원래대로 실행을 하는 식으로 뭔가 , 이렇게, 두 가지 케이스로 구분해서 만들어 주도록 하겠습니다 그러면 이제 코드가 얘는 그래도 엄청 비교적 빨리 실행할 수 있는 거죠 그냥 일감을 쫙 꺼내가지고 현재 시간이 된 애들을 추려가지고 여기에다가 밀어넣고 바로 빠져나온다라는 식으로 이제 Distribute라는 요 부분이 이제 만들어지게 된다고 볼 수가 있겠어요 그럼 이제 이거를 어떻게 사용해야 되느냐 얘는 이제 전역으로 하나만 들고 있겠다고 했으니까 코어 글로벌 쪽에 돌아가 가지고 요 부분에서 아래다가 엑스턴 클래스 잡 타이머를 딱 한 개만 만들어 주도록 합시다 뭐 요런 느낌으로 줄 맞춰주고, 그 다음에 오른쪽 가가지고 Include JobTimer를 추가해준 다음에 여기 바로 아래다가 JobTimer를 전역으로 하나를 만들어 주도록 할게요. JobTimer는 nullptr이다. 줄 맞춰주고, 그 다음에 여기서 새로 만들어 주도록 할게요. JobTimer를 만들어 준 다음에 그 다음에 여기서 바로 아래서 gJobTimer를 소매를 또 시켜주도록 하겠습니다. , 자, 요렇게 해가지고 , 일단은, 뭐 소멸과 생성도 만들어졌고 잡타이머가 , 이렇게, 만들어졌으니까 실질적으로 잡규에서 우리가 뭔가 예약이 필요할 때는 그럼 이제 어떻게 사용하냐면은 요 부분 또 안 만들어놨네요 , 자, 이제 그럼 예약이 필요하다고 하면은 여기서 doAsync를 호출하는게 아니라 , 자, 이거에 다른 버전 함수를 더 두개를 만들어 줄겁니다 일단 얘는 두개를 그대로 복붙을 한 다음에 이름을 doTimer라는 이름으로 바꿔치기를 해주고 그 다음에 여기 앞에다가 tick after라고 해서 몇 밀리 세컨드 후에 실행을 할지를 , 이렇게, 지정을 해주도록 하겠습니다 예약 시스템인거죠 그래서 이름도 다른거고 그러면 이제 예약을 해야 되니까 여기서 이 부분이 좀 바뀔 건데 원래 , 이렇게, 먼저 잡을 우리가 먼저 만들어 줬습니다 이런 식으로 잡을 만들어 준 다음에 걔를 바로 푸쉬를 이용해 가지고 꽂아 줬는데 그게 아니라 잡 타이머를 통해 가지고 리설브를 해서 tick after 에다가 shared from this 주인님은 나고 그리고 잡을 , 이렇게, 예약을 하고 바로 빠져나오도록 할게요 위에 가가지고 Include 잡 타이머를 추가해주면 되겠죠 그래서 일감을 넣고 바로 빠져나오겠다 라는 의미가 된다고 보시면 되겠습니다 그 다음에 아래서도 마찬가지로 여기 푸쉬를 빼서 이 부분을 이제 딱 빼면은 여기까지 원래 잡을 만드는 부분이었었죠 잡의 스마트 포인트가 만들어질 것이고 그 다음에 여기서 마찬가지로 이 부분을 긁어가지고 다시 똑같이 잡을 예약하는 식으로 만들어 보도록 할게요. 그럼 이제부터는 두 타이머를 이용해 가지고 잡을 성공적으로 예약을 할 수가 있게 된 것이고 나중에 누군가가 얘를 꺼내 가지고 다시 배분을 해서 우리가 넣어준 이 스마트 포인터를 이용해 가지고 주인을 찾아 가지고 다시 우리의 큐에다가 푸쉬를 해주는 형태로 뭔가 동작을 하게 되겠죠. 그래가지고 이런 식으로 , 일단은, 잡 타이머를 설계를 해 봤고요. , 일단은, 문제가 없는지 서버콜 한번 빌드를 해 보도록 할게요. , 자, 버그가 없으면은 , 일단은, 뭐 문제가 없이 통과가 될 것이고 그 다음에 이제 얘를 그럼 어떻게 사용하느냐 게임 서버 쪽으로 돌아가가지고 한번 테스트 해보도록 합시다 , 자, 여기다가 , 일단은, 우리가 뭐 쓰레드를 어떻게 배분할지를 지난 시간에 계속 논의를 하고 있었는데 이제는 누군가가 여기 있는 일감을 꺼내가지고 배분을 시켜줘야 되긴 합니다 근데 그거를 만약에 한 해가 담당하게 하면은 조금 불공평할 수도 있겠죠 그래서 우리 정책은 뭔가 모두가 다 만능형 직원이 돼가지고 요리도 하고 서빙도 하고 결제도 하고 하는 식으로 만들고 있었으니까 그냥 비슷하게 , 자, 여기다가 , 일단은, 바로 아래다가 새로운 함수를 만들어가지고 뭐라고 할까요? Distribute Reserved Jobs 예약된 일감들을 뭔가 배치를 한다 배분을 한다 라는 이름으로 , 일단은, 함수를 하나를 파주도록 하겠습니다 그 다음에 여기 내부에서 이제 해야 되는 거는 뭐 현재 시간을 계산해 가지고 윈트64 now를 일단 추출해 가지고 gettcount64를 , 일단은, 꺼낸 다음에 그걸 이용해 가지고 g잡타이머에 접근해서 distribute를 , 이렇게, 해주면 되겠죠 그러면 Distribute가 실행이 되면서 지금까지 여기 Priority Queue에 들어가 있던 애들을 하나씩 하나씩 꺼내가지고 걔를 다시 여기서 배분을 해주는 부분을 이제 실행을 해주게 될 겁니다 , 이렇게, 간단하게 한번 만들고 , 자, 이렇게, 만들어놨으니까 서버 코드를 다시 빌드를 한 다음에 그 다음에 게임 서버로 돌아와가지고 글로벌 Queue에서 여기 두 글로벌 Queue 바로 위에다가 배분을 하는 코드를 , 일단은, 추가를 해주도록 하겠습니다 배분을 하는 코드를 추가하기 위해서 이쪽에다가 Thread Manager의 Distribute Reserved Job 이라는 코드를 여기다가 , 이렇게, 넣어주면 되겠죠 , 이렇게, 만들어가지고 , 사실, 얘가 예약된 일감 뭔가 예약된 일감 처리를 하는 부분이 여기 들어가게 된다고 보시면 되겠습니다 그래서 실질적으로 사용할 때는 예를 들면 예약이 필요하다라고 하면 G룸에 두 타이머를 이용해가지고 1초 후에 무엇이 실행이 되었으면 좋겠다라고 한다면 이런 식으로 일감을 밀어넣을 수가 있겠죠? hello 1000이라고 합시다 이런 느낌으로 그래서 , 이렇게, 함수를 만들어서 사용하면 된다 두 개만 더 만들어 보도록 하겠습니다 2초, 3초 2초, 3초 1초 후에, 2초 후에, 3초 후에 각각 실행이 된 일감을 , 이렇게, 만들어 본 다음에 실행을 해보도록 할게요 , 자, 지금 너무 더밍 클라이언트가 많으면 보기 귀찮으니까 잠시 더밍 클라이언트의 개수를 한 개로만 줄여 보고 얘가 정상적으로 실행이 되는지 한번 테스트를 해보도록 하겠습니다 , 자, 이렇게, 해가지고 실행을 하면은 doWorkerJob에 이어가지고 예약된 일감을 다시 배분하는 역할도 지금 여기서 내부적으로 해주게 될 거니까 여기서 코드를 보면은 hello가 뜨는데 어 근데 순서가 좀 뒤바뀌어 있네요 , 자, 이거는 왜 그러냐면은 doTimer를 만들 때 , 자, 요 코드를 순서를 거꾸로 , 이렇게, 뒤바꿔 주도록 하겠습니다 지금 우리가 여기 우리가 프라이오틱 큐를 사용할 때 이게 less로 되어 있다 보니까 큰 거에서 작은 거 순으로 정렬이 되어 가지고 튀어나오게 됩니다 우리가 원하는 것은 작은 시간부터 먼저 추출이 되기를 원해요 즉 작은 시간이라는 것 자체가 가장 내가 가까운 시간에 해야되는 거 순서로 꺼내가지고 그 중에 하나라도 만약에 실패했다는 얘기는 실패했다는 얘기는 나머지 애들은 볼 곳 없이 빠져나올 수 있다는 얘기가 되는 거죠 그래가지고 우리가 priority 큐를 사용하는 건데 요 부분이 이제 부호가 뒤바뀌어서 그런 것 같네요 그래서 다시 한번 빌드를 해보도록 하겠습니다 뭐 아니면 이거를 자체를 요기 조건을 뭐 그레이터로 바꾸던가 해도 되는데 뭐 그걸 굳이 바꿀 필요는 없을 것 같고 다시 요렇게 실행을 해서 살펴보도록 할게요 그러면 통과가 되면 다시 한번 실행을 해보면 1초 후, 2초 후, 3초 후에 각각 헬로 1000, 헬로 2000, 헬로 3000이 각각 출력이 된다는 걸 알 수가 있을 거예요 , 이렇게, 실행을 해보도록 하겠습니다 이런 부분들이 완료가 되면 그리고 정상적으로 잘 실행이 되면 우리가 1초, 2초, 3초 이런 식으로 정상적으로 다 처리가 되고 있는 것도 확인할 수가 있었고 예약 시스템이 어느 정도 만들어진다고 하면 콘텐츠를 굉장히 편하게 만들 수 있게 됩니다 물론 지금 이런 부분들이 너무 경합이 심해진다거나 하는 것이 우려가 된다고 하면 여기는 잡타이머를 조금 수정해서 더 효율적으로 만드는 것도 고려를 해볼 수 있겠죠. 어지간해서는 이 정도로도 충분하긴 합니다. , 자, 그리고 한 가지만 더 이제 뭐 언급을 드리자면 왜 굳이 여기서 한 번에 한 스레드만 통과하게끔 막아놨을까도 이제 굉장히 좀 희한하긴 하죠 그냥 어차피 여기서 락을 잡고 있으니까 그냥 통과시켜 줘도 되지 않을까 싶은데 그거는 왜 그러냐면은 , 자, 만약에 이건 약간 극악의 그런 상황을 지금 생각하고 있는 건데 어 정말 간발의 차이로 밀감이 두 개가 있다고 가정해 볼게요 그러니까 , 사실, 여기서 문제는 뭐냐면은 우리가 거의 동일한 요런 객체에서 두 타이머를 연속해 가지고 , 이렇게, 여러 개를 만들어 놨다고 하면은 1초 2초 3초이다 보니까 얘가 1번 2번 3번 순서로 호출이 되는 걸 당연히 예상하고 있을 겁니다 근데 얘가 만약에 우리가 글로벌로 요렇게 지금 밀어 넣었다고 가정을 하고 그 다음에 여러 스레드가 동시에 접근을 해 가지고 일감을 막 꺼내 쓴다고 가정을 하면은 정말로 운이 나쁘게 경우에 따라 가지고 한 애가 뭐 첫번째 일감을 여기서 꺼낸 다음에 걔를 이제 , 이렇게, 밀어넣으려고 하는 그 순간 다른 애가 또 나머지 부분을 실행을 해가지고 정말로 운이 좋게 뭔가 렉이 걸렸던가 하는 등등의 이유로 인해가지고 나머지 두번째 세번째 일감을 꺼낸 다음에 걔가 약간 앞서가지고 실행이 된다거나 하는 부분이 일어날 수가 있어요 여기까지는 락을 잡았지만 그 다음부터는 락을 안 잡았기 때문에 여기서 이제 뭐 다른 부분에서 뭔가 랙이 걸린다거나 하면은 그런 부분에 의해 가지고 일감 순서가 꼬일 수 있는 문제가 정말 극악의 확률로 일어날 수 있기 때문에 무조건 한 번에 한 명만 처리를 할 수 있게끔 , 이렇게, 만들어 놓은 겁니다 그런 부분을 이제 예방하기 위해서 근데 이거는 , 사실, 정말 극악의 확률이니까 어지간해서는 재현이 되지 않는데 그런 재현이 되지 않는 버그가 한 번씩 발생하면 그게 더 골치가 아픕니다 원인을 찾기 정말 힘들기 때문이죠 , 자, 그건 그렇고 , 이렇게, 해가지고 , 일단은, 예약 시스템까지 성공적으로 만들어놨으니까 이제는 뭐 어느 정도 스레드 모델이라거나 아니면 우리가 어떻게 컨텐츠를 만들지에 대한 내용도 그게 큰 틀로 일단 만들었다고 보시면 되겠어요 그래서 앞으로는 뭐 이런 부분들을 잘 조합을 해가지고 서버를 만들게 될 것이다 근데 물론 이제 얼리얼 엔진부터 공부를 해야 되니까 아직 먼 길이 남기는 했죠 그래서 언젠가는 뭐 이런 부분들을 잘 조립을 해가지고 컨텐츠를 만들게 될 거다라는 걸 , 일단은, 요약을 할 수가 있겠습니다 , 자, 이렇게, 가지고 굉장히 굉장히 길었는데 잡규와 관련된 내용을 이제 마무리 짓도록 할게요.