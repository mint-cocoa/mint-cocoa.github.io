자, 이렇게, 해가지고 이제 xml 로 우리가 만들어 준 테이블 설계를 긁어 가지고 분석을 할 수 있는 토대를 만들어 놨구요 이번 시간에 해볼 것은 진짜 진짜로 얘를 그냥 분석만 하는 게 아니라 이거에 맞게끔 우리의 데이터베이스를 업데이트 하는 부분까지 , 일단은, 만들어 볼 겁니다 굉장히 놀라운 일이죠 일종의 ORM을 만들어 보는 그런 실습을 해볼 건데 물론 우리가 만들어 준 이 xml 설계대로 그냥 테이블을 만들어 주고 하는 식으로 해도 되지만 이왕이면은 현재 DB 상태를 긁어와 가지고 그 구조가 지금 , 이렇게, XML로 정의된 형태랑 일치하는지를 판단을 해서 만약에 일치하지 않는다고 하면은 바뀐 부분만 바뀌어야 되는 부분만 업데이트를 해주면 되겠죠 만약에 똑같다고 하면은 안 바꾸고 여기다가 뭐 컬럼이 추가가 돼야 된다거나 없어져야 된다거나 뭔가 다른 점이 있다고 하면 그 부분만 업데이트 하는 식으로 동작을 시켜볼 겁니다 당연한 얘기지만 코드 양이 좀 생각보다 많아요. 오늘도 타이핑은 할 수가 없을 것 같고 제가 붓붓 위주로 작업을 하고 여러분들이 분석을 해주시면 되겠습니다. , 자, 그래서 갈 길이 굉장히 먼데 일단 지난 시간에 제가 지지난 시간에 작업했던 코드에서 살짝 버그가 하나 있었는데 어 뭔가 작업하다 보니까 여기 파라미터 카운트를 그대로 복붙했더라구요 이 컬럼 같은 경우에는 컬럼 카운트로 , 자, 얘로 일단 만들어줘야 되는데 이게 언제부터 제가 잘못 쓴 건지 모르겠지만 요 부분이 하나가 잘못되어 가지고 네 뭐 스택 오버플러가 일어나더라구요 이 부분만 , 일단은, 고치도록 할 것이고 , 자, 그 다음에 어 오늘 이제 뭐 좀 로그를 찍어 볼 거에요 로그를 그냥 우리가 씨하우스로 출력을 했었는데 조금 더 이쁘게 색색으로 로그를 찍어 보기 위해서 새로운 폴더를 일단 하나를 만들어주도록 하겠습니다. 필터를 로그라는 이름으로 만들어주고 나중에 가면 크래쉬 덤프라거나 아니면 콘솔 로그 뿐만 아니라 파일에다가 로그를 남기는 기능 등등도 다 여기다가 , 일단은, 넣어놓도록 할 거예요. , 일단은, 오늘은 그냥 간단하게 콘솔 로그만 찍어주는 로거를 여기다가 , 일단은, 넣어놓고 시작을 하도록 하겠습니다. 콘솔 로그는 복붙에서 만들기로 했으니까 그냥 쿨하게 복붙을 빠르게 할게요. 그래서 , 이렇게, 일단은, 만들어 주시면 되는데 뭐 어마어마한 기능은 없습니다. 그냥 색상을 선택해 가지고 로그를 찍을 수 있다는 게 좀 특징이 있고요. 그래서 여기서 보면은 , 일단은, 아웃핸들이랑 에러핸들 원래 , 이렇게, 두개를 받아온 다음에 이걸 이용해가지고 그냥 출력을 하고 있어요 근데 출력을 할 때 색상을 선택해가지고 여기 setColor 라는걸 호출하고 있는데 여기서 이런식으로 setConsoletextAttribute 라는 함수를 이용해가지고 색상을 정해줄 수가 있다 라는 부분만 뭐 그냥 특이한거고 그 나머지 부분들은 뭐 별다른 부분이 없습니다 이거는 이제 뭐 가변인자 처리하는 그런 약간 꼼수 같은 C 문법인데 뭐 이거는 크게 중요한 부분은 아니라서 뭐 생략을 하도록 할 것이고 그래가지고 , 이렇게, 해가지고 그냥 로그를 찍어 주겠다 라고 , 일단은, 볼 수가 있는 거고 이제 뭐 경우에 따라서는 이 로그를 찍는 거는 찌는 것을 단일 스레드 한테, 하나의 스레드가 담당해서 몰빵을 해주고 나머지 스레드들은 그 스레드한테 일감을 던져주는 식으로 만드는 경우도 종종 있긴 한데 솔직히 로그를 그렇게 자주 찍을 건 아니라서 그렇게까지 할 필요는 없을 것 같습니다 그래가지고 그냥 , 이렇게, 모두가 다 접근해가지고 그냥 락 걸지 않고 사용하게끔 , 일단은, 만들어 주도록 할 거예요 , 자, 그리고 이제 코어 글로벌에 가가지고 이쯤에다가 코드를 이제 추가를 해주도록 하겠습니다 , 자, 이런식으로 콘솔 로거를 일단 추가해서 언제 어디서든 편하게 사용할 수 있게끔 유도를 해주도록 할 것이고 그 다음에 오른쪽에 가가지고 , 일단은, 방금 추가한 콘솔 로그를 추가를 해주도록 하겠습니다 그 다음에 바로 여기 아래다가 , 이렇게, 콘솔 로거를 추가를 해줄 것이고 그 다음에 한 이쯤에다가 New를 만들어 주고 Delete도 역시나 여기 아래쪽에서 , 이렇게, 만들어 주고 시작을 하도록 할게요 , 자, 이거는 뭐 그렇게 뭐 대단한 기능은 아니고 그냥 로그를 이쁘게 찍어 주겠다라는 것이고요 그 다음에 이제 오늘 본격적으로 만들어 볼 아이들은 여기 DB 쪽에다가 내용이 추가가 될 거예요 그래서 DB 관련된 기능을 두 개를 만들 건데 , 일단은, DB 모델이라고 해 가지고 우리가 XML이건 DB에서든 긁어 가지고 사용하는 DB 정보를 모델링 하기 위한 클래스를 하나를 , 이렇게, 만들어 줄 것이고 그 다음에 이어서 DB Synchronizer 라고 해서 DB에 싱크를 맞춰준다 라는 기능을 하게 될 클래스를 하나를 더 파주도록 하겠습니다. 그래서 , 일단은, 두 개를 , 이렇게, 이동을 시키고 시작을 해보도록 할게요. 다시 말씀드리지만 내용이 조금 많이 길어요. 이번 거는 특히나 더 길기 때문에 이거 만약에 제가 타이핑 해가지고 일일이 만들었다고 하면 뭐 한 2, 3시간은 걸릴 분량입니다. 그래가지고 조금 내용이 길긴 하지만 그래도 되게 재밌는 기능이 들어가 있으니까 , 일단은, 복붙을 하고 시작을 하도록 할게요. , 자, 헤더도 복붙을 하고 cpp도 복붙을 하고 일단 db 모델부터 작업을 해줄건데요 , 자, 그 다음에 아 네임스페이스 이번에는 좀 다르게 요게 지금 사용하는 이름들은 혹시라도 나중에 컨텐츠에서 뭐 사용할 수 있는 그런 이름들이다 보니까 네임스페이스를 정의해가지고 사용을 하도록 할거에요 그래가지고 뭐 네임스페이스를 네임스페이스 db 모델 뭐 이런식으로 감싸서 사용을 해도 되는데 요렇게 만들어 주면은 뭐 문제가 있는건 아니지만 탭으로 한 칸 띄워서 나머지 애들이 들어가는게 조금 안 이쁘게 보일수도 있습니다. 그래서 경우에 따라서 프로젝트에 따라서 , 이렇게, 매크로를 만들어서 사용하는 경우가 있는데 그냥 그 방식으로 일단 만들어 봤어요. 그래가지고 코어 매크로 쪽에 가가지고 매크로 두개를 , 이렇게, 추가해줄겁니다. namespace-begin 이랑 namespace-end 라고 해가지고 그냥 시작하는거랑 끝나는거 가로 닫는거 이걸 두개를 그냥 매크로로 , 이렇게, 만들어 놨어요 그래가지고 그 부분이 namespace-begin 과 맨 끝에 namespace-end 로 , 이렇게, 붙어있다 라고 볼 수가 있는거고 네 그 나머지 부분들은 뭐 크게 어려운 부분은 없습니다 , 자, 이런 식으로 , 일단은, 사용할 것이다 , 자, 그래서 어 , 일단은, 자, 이거 좀 내용이 길어가지고 어디부터 좀 분석을 해야 될지 조금 난감하긴 한데 어 , 일단은, 지금 작업하고 있는 게 SQL 서버 기준으로 만든 겁니다 다른 데이터베이스 제품으로 만약에 만들었다고 하면은 코드가 좀 수정이 되야 될 수 있으니까 그냥 SQL 서버로 실습을 하시길 추천드립니다 그래서 여기 지금 데이터 타입이라고 해가지고 우리가 사용할 모든 타입들을 , 이렇게, 정의하고 있는데 요런 번호들이 그냥 제가 임의로 정한 게 아니라 이게 SQL 서버 기준으로 각 실제 데이터의 오브젝트 타입 번호입니다. 그래서 이거는 이제 구글링에서 찾아보면은 각 번호가 요렇게 나온다는 걸 알 수가 있고요. 네 그 다음에 , 자, 이거 하나씩 접어서 보면은 진짜로 이제 모든 우리가 디베에서 사용할 모든 그런 애들을 다 , 이렇게, 클래스로 지금 만들고 있어요 진짜 진짜 하나씩 그래가지고 먼저 칼럼 부터 열어 보자면 , 자, 칼럼에 지금 얘가 들고 있을만한 정보가 요렇게 지금 다 들어가 있습니다 그래가지고 칼럼의 이름, 칼럼 아이디같은건 이제 DB에 한정적인거고 DB에서 나중에 긁어올 그 아이디를 얘기하는겁니다. , 이렇게, DB라는 주석이 붙어있으면 얘는 DB에서만 당장 사용하는 정보다라고 일단 보시면 되는거고 그 다음에 경우에 따라서 주석으로 XMLE를 붙어있으면 그건 이제 XML에서만 사용하는 그런 아이라고 일단 보시면 되겠습니다. 이런 애들은 이제 XML에서만 사용할 것이고 얘가 이제 DB 용도로 활용할 것이다 라고 일단 보시면 되겠어요. 그래서 , 일단은, 지금 하려는 방식이 우리가 만들어준 XML에서 정보를 쫙 긁어올 것이고 그 다음에 DB에다가 쿼리를 날려가지고 , 사실, 이거랑 똑같이 테이블과 컬럼, 인덱스, 그리고 프로세저 등등의 정보를 다 긁어올 거에요 그래서 둘 둘 비교를 해주게 될 건데 그걸 일단 메모리 상에 들고 있어서 둘 둘 비교하기 위해서 일단 메모리 상에 들고 있을 건데 그 메모리 지금 구조 자체를 요렇게 잡고 있는 겁니다 그래서 컬럼에 우리가 컬럼을 정의하기 위해 필요한 모든 정보를 지금 요렇게 나타내고 있다고 보시면 되겠어요 굉장히 익숙한 애들이 많죠? 이걸 잠시 , 이렇게, 옆으로 좀 켜가지고 비교를 해보자면 여기 컬럼에 이름, type, not null 요렇게 들어가 있는데 이름 그 다음에 얘네 둘이 이제 타입을 나타내는 거고 그 다음에 notNullable로 notNull을 체크할 수 있고 그 다음에 만약에 경우에 따라가지고 여기에 이제 identity가 붙어있다 그러니까 일식 증가하는 애를 이제 identity라고 하는데 뭐 그런 애들이 붙어있다고 하면은 그것도 이제 좀 팟싱을 할 겁니다 아 참고로 identity는 붙여주도록 합시다 , 자, id가 지금 프라이머리 키니까 identity 아이고 identity 그 다음에 1,1로 , 이렇게, 만들어주도록 할게요 그래서 여기 만약에 identity가 있으면 걔도 이제 얘가 true로 설정이 될 것이고 그 다음에 여기 seed value랑 increase value, increment value가 , 이렇게, 삼총사가 결국은 이 identity를 가리키고 있는 거고 그 다음에 뭐 경우에 따라 가지고 default 값도 있을 수도 있겠죠 예를 들면 우리가 뭐 default 0이라거나 어떤 기본 값을 설정할 수 있는데 그런 것도 지금 , 이렇게, 관리를 해주고 있는 겁니다 그래서 이런 정보가 다 채워지면은 이 컬럼에 대한 모든 정보를 우리가 알 수 있다는 얘기가 되는 거죠 그리고 여기 creatext는 뭐하는 거냐면 나중에 우리가 테이블을 만들 때 테이블 만드는 문법에서 이런 식으로 만들죠 create 테이프를 모시기 모시기 한 다음에 여기서 우리가 인자두를 나중에 어떤 컬럼을 만들어 줄지를 뭐 네임에다가 얘는 어떤 타입이고 널러블인지 아닌지를 하고 이런 식으로 만들 거니까 그 문법을 이 중간에 있는 문법을 생성해 주기 위한 그런 함수라고 보시면 되겠습니다. 그래서 텍스트를 만들어 준다. 이 컬럼을 생성하기 위한 그 텍스트를 만들어 준다라는 이름으로 , 일단은, 되어 있다고 보시면 되겠어요. 그리고 여기 format 이라는 함수는 이제 앞으로 자주 사용할 건데 우리가 로그에서 사용했던 것처럼 그냥 가벼운 인자를 받아가지고 그냥 만들어주는 그런 굉장히 단순한 함수입니다. 일종의 그 C 언어에서 사용하는 printf 라고 보시면 되겠어요. 그래서 여기 이런 식으로 %d %d 라고 하는게 여기 뒤에 있는 값으로 치환이 되어가지고 이 값이 여기 들어가서 만들어진다 라고 일단 볼 수 있겠어요. 좀 편하게 이런 문제를 만들어줄 수 있는 그런 헬퍼 함수라고 보시면 되겠습니다. 네 그건 그렇고 컬럼은 뭐 , 이렇게, 만들어 준다 라고 볼 수가 있는 거고 나머지도 결국에는 인덱스나 뭐 그런 애들도 다 비슷한 느낌입니다 그래가지고 진짜로 요게 있는 정보들만 다 채워주면은 이제 이 인덱스의 정보가 꽉 찬다는 얘기가 되는 거죠 인덱스 같은 경우에는 다시 예를 놓고 보면은 얘가 뭐 프라이머리 키인지 아닌지 그리고 이제 클러스터 타입인지 노노 클러스터 타입인지 그 다음에 이 인덱스가 걸려있는 컬럼들은 누구누구인지 등등을 갖고 있어야 되니까 그 정보들이 고지곳대로 다 여기 들어가 있다는 걸 볼 수가 있습니다 그리고 뭐 나머지 이런 함수들은 뭐 굉장히 직관적이니까 뭐 딱히 어려운 부분은 없을 것 같고 그냥 내용을 살펴보시면 뭐 굉장히 단순하게 되어 있습니다 네 그래서 우리가 이름에 대한 컨벤션을 , 이렇게, 정해줘 가지고 얘가 들고 있는 정보에 따라 가지고 고정적인 이름이 , 일단은, 출력이 되게 될 거예요 나중에 뭐 이런 식으로 이름을 비교해서 양쪽의 정보가 일치하는지를 뭐 비교할 수도 있겠죠 네 그래가지고 , 이렇게, 인덱스도 있을 거고 테이블도 똑같은 느낌으로 온갖 정보를 갖고 있는데 테이블의 이름, 그 다음에 테이블에 소속되어 있는 컬럼과 인덱스 정보들이 , 이렇게, 들어가 있습니다. 테이블 안에 있는 컬럼들과 인덱스 정보가 , 이렇게, 들어가 있다라고 표시가 있는 거죠. 마지막으로 프로세저, 스토어 프로세저라고 해가지고 지금 이런 함수들을 얘기하고 있는 건데 얘네들도 마찬가지로 자기 자신의 이름과 그리고 body라고 해가지고 , 이렇게, 내용물 어떤 쿼리로 되어있는지 그리고 어떠한 인자들을 받고 있는지를 , 이렇게, 받아주고 있습니다 여기까지 굉장히 단순하죠 그래가지고 그냥 뭐 요런 느낌으로 , 일단은, 정보를 저장하면 된다라고 볼 수가 있는 거고 결국에는 우리가 이전 시간에 요런 식으로 그냥 잠시 임시 메모리에다가 저장하고 날리는 게 아니라 이제는 진짜 요런 클래스들을 만들어가지고 요런 구조 형태로 다 저장을 하겠다는 얘기가 되는 거죠 , 자, 그리고 이제 실질적으로 그런 애들을 저장하는 거를 이 DB Synchronizer라는 애가 해줄 건데 얘가 이제 오늘 작업 발끝판왕이라고 보시면 됩니다 굉장히 코드가 길어요 , 자, 그래서 이것도 너무 양이 많아가지고 타이핑은 못할 것 같고 , 자, 이렇게, 일단 복붙을 해서 보여드리도록 하겠습니다 아 참고로 아까 추가한 콘솔 로고 같은 경우에는 이제 로고는 이리저리서 찍을 확률이 굉장히 높으니까 코어 PCH 쪽에 돌아가가지고 여기다가 코어 로고를 추가해주도록 할게요 아, 콘솔 로고였죠 콘솔 로고를 , 이렇게, 추가해주도록 하겠습니다 그 다음에 닫고 , 자, 이제 얘도 어디부터 시작을 해야 할까 굉장히 난감한데 , 자, , 일단은, 여기부터 시작을 하도록 할게요 먼저 음... , 자, 이 흐름을 보시면 됩니다 얘를 이제 나중에 호출을 할 때는 내용이 굉장히 많기는 하지만 사용방법은 굉장히 단순해요 그냥 이 DB Synchronizer라는 걸 호출해가지고 Synchronizer를 빵 한번 호출해주면 끝입니다 그리고 걔가 이 순서로 작업을 하고 있어요 xml을 먼저 파싱을 한다 이 xml 파일을 얘기하는 거죠 이 xml 파싱을 해가지고 여기 있는 구조를 다 분석을 해가지고 메모리상에 들고 있겠다라는 부분이고 그 다음에 여기 gather db 모시기라는 시리즈가 진짜로 우리 db에 접근해가지고 쿼리를 날려가지고 테이블 정보도 긁어오고 인덱스 정보도 긁어오고 sp 정보도 긁어오는 부분이 이제 실행이 될 거예요 그래서 얘랑 얘랑 한 번씩 끝났으면 이제 이 XML 형식의 데이터와 그리고 DB 형식의 데이터를 양쪽에 긁어온 거니까 그 다음에 이제 둘둘을 비교해 줘 가지고 둘의 정보가 일치한지 아닌지를 봐 가지고 만약에 뭐 다르다라고 하면은 이제 뭐 업데이트를 하건 크레이트를 하건 내용을 이제 맞춰주는 템이 되는 거죠 즉 이 XML 형식이 맞게끔 우리 DB를 업데이트 해주겠다라는 예 되는 거고 먼저 예약만 해준 다음에 실질적으로 실행하는 부분은 여기 아래에서 이제 실행을 쫙 해주게 될 겁니다 요런 일단 흐름으로 되고 있어요 그래서 사실은 이 흐름으로 된다는 것만 이해하고 세부적으로 분석을 하면은 그렇게 어려운 내용은 아닙니다 그냥 내용이 많을 뿐이지 그 다음에 이제 하나 볼 거는 위쪽에다가 좀 굉장히 묘한 내용이 있습니다. 제가 namespace sp라고 여기에다가 넣는 내용이 있는데 얘를 보면은 , 자, 뭔가 외계어 같은 엄청 긴 쿼리가 있는데 얘는 말 그대로 테이블이랑 컬럼 정보들을 싹 긁어오는 그런 쿼리입니다. 이건 뭐 제가 즉흥적으로 막 짠 건 아니고 저도 열심히 구글링을 해보면서 뭐 좀 알아봤어요 테이블이랑 컬럼을 어떻게 얻을 수 있는지 등등을 보면서 조금씩 수정을 가면서 만든 거고 여기서 이제 굉장히 많은 정보들을 쫙 긁어오게 될 겁니다 그리고 우리가 뭐 지난번에 만들었던 이 dbbind 기능을 이용해 가지고 얘를 좀 편하게 꺼내 쓸 수 있게끔 , 이렇게, 만들어 준 클래스가 getdbtables 이라는 애고요 여기 이제 처음부터 0번부터 12번까지 하나씩 하나씩 다 채워준 다음에 그걸 Fetch 해가지고 여기 있는 정보를 다 긁어오게 될 겁니다 그래서 이 정보를 그렇게 긁어올 것이다 테이블과 컬럼 정보를 긁어올 것이다 라고 볼 수가 있는 거고 그 아래도 마찬가지로 인덱스를 긁어오는 쿼리는 , 이렇게, 되어 있고 그거에 맞게끔 DB에서 데이터를 긁어오게끔 GetDbIndexes라는 클래스를 또 , 이렇게, 만들어놨어요 마지막으로 StubProcedure도 , 이렇게, 긁어온다라고 부분이 있겠습니다 그래가지고 , 일단은, 좀 막막하긴 했지만 우리가 XML에서 파싱을 해가지고 테이블, 컬럼, 프로세저, 인덱스 등등의 정보를 긁어왔던 거랑 비슷하게 이제는 이 아이들을 이용하게 되면은 실제 DB에 접근해가지고 그 현재 DB 상태를 우리가 편하게 긁어올 수 있다는 얘기가 되는 겁니다 이제 그 부분이 여기 들어가 있는 거예요 , 자, 그거부터 일단 분석을 했고 그 다음에 path.xml.div 이라는 애에서는 뭐 하는 거냐 우리가 지난 시간에 하다가 막아 있었죠? 즉 요 부분에서 만들고 있었던 거를 그대로 옮겨 놨습니다. 선글라스의 메인 함수에서는 얘는 이제 더 이상 필요 없으니까 여기까지는 이제 날려주도록 할게요. 그리고 그 부분이 요기에 들어갔습니다. 뭐 거의 코드가 비슷하죠? 그래서 파스터를 만들어서 파스터먼트 파일을 한 다음에 여기서 루트를 꺼내오고 그 다음에 루트 파인드 철드렌 해가지고 지난 시간에 했던 내용 그대로 들어가 있습니다 테이블을 수뇌를 하면서 하지만 이제 좀 달라지는 거는 그냥 수뇌해가지고 그냥 체크하고 끝나는 게 아니라 진짜로 그 해당 갱체를 만들어가지고 메모리에다가 지금 들고 있다는 게 달라지는 거죠 그래서 한 땅 한 땅 읽어보시면 대단히 신기한 내용은 없고 좀 노가다성이긴 한데 지난번에 했던 내용을 메모리상에 다 들고 있게끔 , 이렇게, 지금 만들어주고 있습니다 그리고 실질적으로 그 정보는 결국에는 여기 XML 테이블 안에 , 이렇게, 들어가 있어요 얘네 두 쌍이 이제 XML에서 설계한 우리의 구조를 나타내고 있는 거고 그 다음에 여기 두 개 아래 두 개가 DB에서 지금 현재 상태 테이블과 프로세서 상태를 , 이렇게, 긁어오게 될 겁니다. 둘둘을 긁어오고 이제 둘둘을 서로 비교해 보면서 다른 점이 있는지를 체크하면 되겠죠. 여기 리무브 테이블은 중요하지 않으니까 넘어가셔도 되는데 나중에 가면 이제 뭐 삭제해야 될 애들도 생기게 될 텐데 설령 우리가 정의한 이 xml 파일에 그 해당 테이블 정보가 없다고 해도 그 테이블을 당장 날리면 좀 위험할 수도 있겠죠. 그러니까 삭제하는 부분은 당장 진행하지는 않을 것이고 진짜로 어떤 테이블이 삭제되길 원한다고 하면은 여기다가 추가적으로 리무브 테이블 노드를 만들어 가지고 그걸 추가하길 원하기 있기 때문에 걔가 추가가 된 건데 뭐 그건 일단 무시하셔도 돼요. 뭐 크게 당장 중요한 내용은 아니고 , 일단은, 얘는 무시하고 , 이렇게, 둘둘만 분석을 해주시면 되겠습니다. 그래서 이런 식으로 굉장히 긴 함수를 통해 가지고 현재 XML 구조를 파싱해 가지고 그거를 다 여기 메모리에다가 들고 있겠다라는 부분이 이제 쫙 실행이 된다고 보시면 되겠습니다. 그 부분이 , 일단은, path.xml.db 였어요. 끝. 그러면 이제 여기 있는 프로세서랑 테이블 정보가 완료되었고 마찬가지로 db에서도 접근해가지고 db 테이블 관련된 정보, db 인덱스 관련된 정보, 그 다음에 sp 관련된 정보를 하나씩 하나씩 긁어옵니다. 이 코드는 지난번에도 살펴본 거랑 굉장히 유사하죠? , 이렇게, 인다드를 만들어가지고 바인드를 통해가지고 , 이렇게, 하나씩 하나씩 연결해준 다음에 그 다음에 execute를 빵 때려주면은 얘가 false가 뜨지 않았다고 하면은 그 다음부터 이제 fetch를 하면서 얘가 true가 뜰 때까지 데이터가 여러 개 있을 수 있으니까 계속 무한 루프를 돌면서 하나씩 하나씩 추출을 하겠다라는 얘기가 되는 겁니다 추출을 하다가 뭐 혹시 중복된 데이터가 또 뜨는지를 체크하면서 없다고 하면은 이제 걔를 이제 만들어주는 부분이 들어가 있다고 보시면 되겠어요 칼럼도 , 이렇게, 지금 만들어주고 있는 거 볼 수가 있습니다 칼럼 정보도 만들어가지고 Column Name, ID, Type, Text, Max Length 이 Max Length 같은 경우에는 뭐 경우에 따라가지고 바차같은 그런 문자열 같은 경우에는 이제 이 Length 자체가 필요할 수 있죠? 그러니까 우리 DB로 치면은 요런 부분을 긁어오기 위한 Length라고 보시면 되는 거고 Nullable, Null을 넣을 수 있는지 아닌지, Identity인지, Seed, Increment Value 등등 요런 정보들도 다 파생을 해서 들고 있다라고 보시면 되겠습니다 , 자, 그래가지고 이것도 그냥 보시면은 그렇게 어려운 부분은 없구요 이런 식으로 결국 Getter 시리즈를 이용해가지고 인덱스도 마찬가지고 그 다음에 여기 Store Procedure도 마찬가지로 정보를 싹 긁어온다라고 , 일단은, 볼 수가 있겠습니다 그래서 여기까지 일단 호출이 완료가 되면은 그럼 이제 어떻게 할 수 있느냐 둘 둘 긁어왔죠? 그럼 이제 Compare DB 모델을 통해가지고 1대1로 하나씩 비교를 해보는 겁니다 뭐가 달라졌는지 그래서 CompareDB 모델에 가서 보면은 , 일단은, 여기 주석을 읽으시면 얘가 뭘 하고 있는지 굉장히 잘 설명을 해놨어요. XML인 목록을 먼저 싹 갖고 온 다음에 그 다음에 DB에 실존하는 테이블들을 돌면서 우리가 XML에서 정의한 내용들이랑 이제 1대1로 비교를 해주고 있는 겁니다. 그래서 뭔가 만약에 다르다 라고 하면은 다르다고 하면은 그 정보를 이제 나중에 기입을 해가지고 업데이트를 해준다는 얘기가 되는 거죠. 그래서 compare tables 뭐 이런 내부적으로 이제 들어가 가지고 살펴보면은 이제부터 compare 시리즈들이 있습니다. 둘둘을 비교해 가지고 다른 부분을 찾는 숨은 그림 찾기를 해주고 있는 거예요. 그래서 이런 부분들이 이제 실행이 될 것이다. 근데 이거는 제가 말로 설명을 드리기보다 그냥 좀 분석을 해보시기를 추천드립니다. 그리고 이게 아직 완벽하게 100% 정확하지 않을 수도 있어요. 제 기억을 토대로 열심히 복원을 좀 해보면서 만든 거라서 이게 좀 버그가 있을 수 있으니까 그런 부분은 감안하시고 뭐 이런 식으로 주석대로 지금 로직을 하나하나씩 지금 실행하고 있습니다. 그래가지고 결국에는 돌고 돌아가지고 다시 Synchronize에서 Compare DB 모델이 호출이 되면은 내가 업데이트해야 될 애들을 이 업데이트 스텝 순서대로 , 일단은, 기입만 해두게 됩니다. 여기 업데이트 스텝이라고 해가지고 업데이트 쿼리가 일단 채워지게 될 거예요. 중간중간에 만약에 내가 뭔가를 해야 된다고 할 때 이런 식으로 업데이트 쿼리에다가 그 부분을 지금 넣어주고 있어요. 그게 아까 Compare 하는 도중에 계속 일어나게 될 겁니다. 뭔가가 업데이트 해야되겠네 라고 하면은 여기다가 , 이렇게, 커리를 만들어가지고 뭐 예를들면 드랍 테이블 라거나 이라거나 뭐 이런식으로 하나씩 커리를 만들어주고 당장 실행하진 않고 실행 순서는 나중에 이제 그걸 모아가지고 엑세큐트를 할 때 실행을 합니다. 왜냐면 서로 디펜덴시가 걸려있다거나 하면은 먼저 하나를 삭제함으로써 뭐 다른 애가 오류가 나고 할 수도 있기 때문에 항상 순서를 지켜가지고 그냥 요 순서로 해주고 있어요 인덱스를 만들어주려는데 이런저런 변화가 일어나가지고 뭔가 변동이 있다고 하는 건 좀 곤란하니까 순차적으로 안전한 순서대로 , 이렇게, 해주고 있는 겁니다. 근데 이 순서를 조금 바꾼다고 크게 문제될 부분은 없어요. 여기 alter column, add column을 먼저 한다고 뭐 크게 문제가 일어나는 건 아니긴 하지만 그래도 기본적으로 안전한 순서를 , 이렇게, 정리해놔가지고 이 순서로 작업을 할 것이다 라고 붙여있는 거죠. , 자, 그래가지고 컴페어 DB 모델까지 끝났으면 이제 진짜로 내가 실행해야 될 쿼리들을 정보가 다 채워주신 거고 그건 이제 한번 분석을 해보시길 바라고 그 다음에 이제 진짜로 하나하나씩 스뇌를 하면서 모든 지금 예약된 모든 쿼리들을 이제 다 실행을 빵 때려주게 됩니다 그게 일단 전부예요 그래서 요 기능글 자체 보면은 코드는 굉장히 길긴 하지만 약간 노가다성이 굉장히 많고 실질적으로 내용은 그렇게 어려운 게 없다고 보시면 되겠습니다 헷갈릴 때는 항상 요 Synchronize부터 처음부터 실행을 해서 분석을 해주시면 돼요 xml 만들고 읽어가지고 메모리에 로드하고 db 긁어서 정보 로드해가지고 메모리 로드하고 둘 둘 비교 그 다음에 다른 부분 신행 네 요렇게 , 일단은, 진행이 된다라고 보시면 되겠습니다 , 자, 그렇게 가지고 일단 서브코어를 잠시 한번 , 이렇게, 빌드를 해보도록 할게요 문제가 없는지 한번 빌드를 해보도록 하고 , 자, 그 다음에 지금 아직 뭐 사용 예제가 좀 난감할 수 있으니까 그냥 사용하는 걸 바로 보여드리도록 하겠습니다. 이거를 이제 사용하는 방법은 굉장히 단순한데 다시 우리 게임 서버 쪽으로 돌아가 보도록 할게요. , 자, 그 다음에 여기 첫번째에서 , 일단은, 커넥션 풀을 우리가 하나를 만들어 놨던 것은 똑같고요 현재 DB에 , 이렇게, 접근하고 있습니다 저는 로컬 DB에 게임 서버라는 데이터베이스에 접근해 가지고 지금 붙고 있고요 그 다음에 DB 커넥션을 일단 하나를 꺼내 옵니다 DB 커넥션 gdb커넥션 풀에서 팝을 해가지고 하나를 꺼내온 다음에 그 다음에 오늘 만들어준 db 싱크로나이저를 켜주면 돼요 , 이렇게, 만들어줍니다 db 콘을 넣어주고 , 자, 근데 db 싱크로나이저는 헤더를 추가해야 되겠죠 새로 내니까 db 싱크로나이저 그러면 됐고 그 다음에 db 싱크에서 싱크로나이즈를 호출해가지고 어 여기다가 게임디비.xml을 , 이렇게, 입력을 해줍니다 그러면 이제 xml 파싱 해가지고 나머지 부분이 짱 이어서 실행 될 거예요 그냥 여기서 끝입니다 , 이렇게, 사용하면 끝이에요 , 자, 그리고 현재 설정상 데이터베이스는 요 아이를 사용할 건데 기존에 있던 내용물 한번 날려보고 새로 다시 데이터베이스를 추가해서 깔끔하게 서버 DB를 초기화를 하도록 하고 그 다음에 지금 여기다가 브레이크 포인트를 잡고 바로 실행을 해보도록 하겠습니다 짜잔 그럼 여기서 바로 Synchronize 바로 다음으로 넘어왔고 , 자, 이런식으로 테이블이 만들어졌다, 인덱스 걸어줬다, 그 다음에 프로세저 두개 만들어줬다라고 , 이렇게, 업데이트를 해주고 있는걸 볼 수가 있습니다. 그리고 다시 한번 끄고 실제로 뭔가 바뀌었는지 한번 살펴보도록 하면은 , 자, 이런식으로 진짜 진짜로 우리가 원하는대로 id, gold, name, create date가 , 이렇게, 생성이 된걸 볼 수가 있습니다. 그리고 여기 이제 프로그래밍 기능 쪽에 저장 프로세저 쪽에 우리가 만들어준 일종의 함수리라고 볼 수 있는 스톱 프로세저가 두 개가 생성이 된 걸 볼 수가 있어요. 뭐 이런 식으로 관리하는 거죠. 그럼 이제는 이 xml 파일만 잘 관리를 하면 된다는 얘기가 되는 겁니다. 만약에 버전이 바뀌어 가지고 여기다가 컬럼에 하나가 추가가 되어 가지고 테스트라는 컬럼이 추가되었다고 과정해 볼게요. 뭐 int, not null, false 뭐 이런 식으로. 그러면 요 상태에서 얘를 이제 그대로 서밋을 해줘가지고 버전 관리를 같이 해주게 되면은 이제는 다음에 이제 만약에 또 우리가 프로그램을 켜게 되면은 싱크로나이스에 의해 가지고 얘가 자동으로 갱신이 될 겁니다 근데 물론 라이브에서 , 이렇게, 강제로 갱신하는 건 좀 위험하니까 라이브에서는 SQL 퀄리를 만들어가지고 직접 DBA가 서버 뜨기 전에 DBA가 직접 그 퀄리를 돌리도록 하고 우리가 개발할 때는 이런 식으로 편하게 DB를 강제로 우리 XML로 맞춰주면 되겠죠 이 상태에서 다시 한 번 실행을 해서 살펴보면 이런 식으로 add-in column 이라고 해서 골드 테스트 컬럼이 추가되었습니다 라는 로고가 뜨는 것도 볼 수가 있습니다 그리고 다시 한 번 끄고 이제 진짜로 잘 바뀌었는지 이걸 확인해 보면 테스트라는 애가 하나가 늘어났다는 걸 볼 수가 있어요 이런 식으로 XML로 관리해서 우리만의 ORM을 만드는 것도 제가 굉장히 좋아하는 방법이고 지금까지 이런 저런 프로젝트에서 여러 가지 방법을 봤지만 이 방법이 저는 제일 인상이 깊었던 것 같아요 그래서 굉장히 작업하기가 편리해집니다 이러면 그래서 DB 버전과 관련한 골치 아픈 문제도 신경 쓸 필요 없이 간단하게 새로운 애를 추가하거나 삭제할 때도 그냥 XML을 통해서 모든 걸 할 수 있다는 굉장히 큰 장점이 생기게 된다는 거죠. , 자, 이렇게, 해가지고 우리만의 간단한 ORM에 대해서 만들어 봤구요 여기서 이제 한 가지만 만약에 더 더 더 추가를 한다고 하면은 이제 요런 부분이 되겠죠 우리가 스토어 프로세저를 만들어 놨는데 요런 부분을 이제 알아서 잘 파싱을 해 가지고 우리가 이전에 DB Synchronizer 에서 요런 클래스들을... 아 여기가 아니었나요? 아 여기서 이런식으로 GetTable 클래스라거나 GetDbIndex 클래스라거나 이런거를 , 이렇게, 자동으로 만들어주지 못해서 일부러 , 이렇게, 손수 한땀한땀 만들었는데 이 부분을 파싱해가지고 요 아이를 자동으로 생성해줄 수 있다고 하면은 더 편하게 되겠죠 그러면 진짜로 이 클래스를 생성하는 부담까지 우리가 생각할 필요 없이 자동적으로 얘가 지금 몇 개의 인자를 받아주고 있는지 그 다음에 여기 뭐 인서트 인투 라거나 셀렉트 라거나 이런 문구를 분석해가지고 여기에 인자를 몇 개를 뱉어주는지를 봐가지고 요런 숫자들이라거나 아니면 아웃이나 인 같은 파라미터랑 컬럼을 바인딩하는 그런 부분까지 자동 생성을 해준다고 하면은 진짜로 이제 완전체가 되는 겁니다 그러면은 이제 더욱더 작업하기가 편하고 실수의 여유도 줄일 수가 있겠죠 , 이렇게, 해가지고 오늘 얘기한 내용이 , 사실, DB라거나 이 쿼리에 대한 개념이 없다고 하면 좀 이해하기 어렵고 당장은 이게 왜 엄청 대단한지 이해하기 힘들 수도 있겠지만 언젠가는 이런 버전 관리에 대해서 이제 뭔가 고민을 할 일이 생기게 되실 겁니다 그때라도 다시 두고두고 이런 내용에 대해서 잘 생각을 해보시면 되겠어요 , 이렇게, 해가지고 간략한 ORM을 만드는 그런 실습을 , 일단은, 마쳤습니다.