우리가 지난 시간까지 이런저런 Allocator를 만들어보면서 다양한 정책에 따라 가지고 메모리를 할당하고 해제하는 실습을 해봤는데요 이어서 이번 시간에 해볼 것은 메모리 풀링을 만들어 볼 겁니다 풀링이란 용어가 우리가 유니티나 얼렬이건 아니면 서버를 만들건 풀링이란 용어가 굉장히 자주 등장을 하는데 그 개념 자체는 , 사실, 어려운 게 아닙니다 말그대로 풀이라는 게 어떤 연못 같은 그런 공간이라고 생각하시면 돼요. 거기서 이제 우리가 지금까지는 메모리를 할당한 다음에 필요가 없어지면 바로 이런 식으로 해제를 해줬는데 해제를 완전히 , 이렇게, 해주는 게 아니라 그냥 어딘가에다가 보관을 했다가 나중에 다시 또 필요해지게 되면 그 임시보관 장소에 있던 거를 꺼내 가지고 다시 재사용하겠다 이겁니다. 말 그대로 쓰레기를 그냥 바로 버리는 게 아니라 우리가 뭔가 재활용을 해 가지고 그거를 다시 낭비하지 않고 사용할 수 있었던 그런 거랑 완전히 똑같은 개념이라고 생각하시면 돼요. 그래서 개념은 굉장히 단순한데 이제 이거를 막상 구현하려고 하면 조금 고민할 거리가 여러가지가 있습니다 가장 먼저 생각해볼 수 있는 풀링 방식은 일단 우리가 예를 들면 이런 나이트라는 개체를 만든다고 가정해봅시다 그런데 이 나이트가 우리가 만들 게임이 진짜 기사가 하도 많이 등장해가지고 얘가 진짜 진짜 진짜 많이 사용이 된다고 하면은 이런식으로 나이트를 동적으로 만들었다가 삭제를 할 때 어딘가에다가 그 나이트만을 모아놓는 그런 공간에다가 얘를 다시 , 일단은, 반환해준 다음에 다시 꺼냈으면 되긴 하겠죠 근데 그런 경우에는 , 사실, 뭐 정확히 말하면 이제 이거를 뭐 오브젝트 풀링이라고 하는게 어떤 오브젝트 단위로 우리가 풀링을 한다라고 해가지고 뭐 그렇게도 할 수 있기는 해요 근데 이제 그 다음으로 또 생각하는 문제가 뭐냐면은 뭐 나이트는 그렇게 한다고 칠 수 있겠지만 , 사실, 우리가 , 이렇게, C++ 코딩을 할 때 동적으로 할당하는 메모리가 꼭 이런 객체들만 있는 게 아니라는 문제가 있습니다 예를 들면 우리가 요런 식으로 벡터나 맵을 사용할 때도 이런식으로 우리가 나이트를 100개를 만들기 위해서 내부적으로 이 나이트 100개짜리를 담을 수 있는 배열을 내부적으로 만들죠 이게 동적 배열이다 보니까 마찬가지로 이 맵이란 애도 노드 단위로 , 이렇게, 노드를 만들어 가지고 걔네들을 막 트리 형태로 관리를 할 텐데 그런 경우도 , 사실, 여기서 내부적으로 다 동속할 땅이 되고 있는 겁니다 그러니까 이런 객체 단위로만 풀링을 할 수도 있겠지만 조금 더 일반적인 상황에 대해서 어떠한 크기도 상관없이 다 뭔가를 메모리를 재생할 수 있는 방법을 고민해야 된다는 얘기가 되는 거죠 크기가 항상 고정이지 않는다는 게 일단 첫 번째 전제입니다 그리고 굳이 왜 메모리 풀링을 해야 되느냐에 대해서는 여러가지 정답이 있을 수 있겠지만 , 일단은, 해제를 하고 그 다음에 다시 할당하고 해제하고 할당하고 하는 걸 반복할 때 이걸 너무 많이 반복하다 보면 역시나 컨택스 스위치 일어난다거나 하는 그런 커널 레벨까지 가 가지고 메모리를 다시 요청한다거나 하는 부분이 조금 아쉬울 수도 있고 게다가 심지어 제가 메모리 파편화, 즉 용어까지는 설명 안 드렸지만 이런 저런 메모리 들을 막 칼당하고 해제하고 하다보면 분명히 여기 있는 메모리가 해제되었는데 여기 있는 메모리 들끼리 너무 사이즈가 작아 가지고 중간 중간에 구멍이 뚫린 것 마냥 얘네들을 재사용할 수 없는 그런 상황도 생길 수가 있겠습니다 근데 물론 요즘 할당기는 이제 이런 걸 잘 처리해 줘 가지고 , 사실, 그 메모리 파편화까지 신경을 쓰면서 우리가 작업을 해야 되는지는 , 사실, 조금 의문이긴 해요 그래서 요즘 서버 프로젝트에 대해서 제가 수소문을 해본 결과 굳이 메모리 풀링까지 하지 않는다라고 답변을 주신 분들도 꽤 있었습니다 그러니까 이건 이제 약간 선택의 영역이 되었다고 보시면 되겠어요 하지만 늘 그렇지만 공부할 때는 뭐 어떤 거든 다 , 이렇게, 실습을 해보면서 만들면은 도움이 되니까 오늘은 이제 메모리 풀링을 간단하게 실습을 해볼 건데요 , 자, 일단은, 메모리 쪽에 가서 오늘 사용할 메모리 풀이라는 클래스를 , 일단은, 하나를 만들어 주시면 되겠습니다 , 자, 이렇게, 메모리 풀이 만들어졌구요 그 다음에 cpp는 오른쪽으로 그 다음에 헤더는 왼쪽에서 , 이렇게, 관리를 하도록 할게요 , 일단은, 메모리 풀을 사용할 때 우리 정책은 요런 겁니다 메모리 풀을 여러 개를 할당을 해줄 거에요 여러 개를 만들어 줄 건데 각각의 메모리 풀은 자기가 담당하고 있는 크기를 갖고 있을 겁니다 예를 들면 얘는 32 바이트 이하의 객체들을 얘가 이 메모리 풀이 담당할 것이고 그 다음에 32에서 64바이트 사이에 들어가는 크기의 그런 데이터들은 그 다음 메모리 풀이 관리하는 등등 이제 다양한 크기를 담을 수 있는 이런 풀들을 만들어 줄 거예요 근데 여기서 이제 선택을 해야 되는 건 뭐냐면 이거 메모리 풀에 대한 기본적인 이론이긴 한데 메모리 풀을 우리가 , 이렇게, 크게 할당해줘서 어떤 메모리 공간을 할당해준 다음에 이거를 크기에 따라가지고 , 일단은, 쪼갰을 수 있는 방법이 있습니다 얘는 100바이트는 한이한테 넘겨주고 그 다음 200바이트는 딴이한테 넘겨주고 이런 식으로 막 할 수가 있고 두 번째 방법은 아까 제가 처음부터 말씀을 드린 대로 이 메모리 풀은 , 일단은, 무조건 같은 크기의 데이터만 , 일단은, 담아줄 것이다 라고 해가지고 무조건 32바이트 이하의 데이터만 얘는 , 이렇게, 담아줄 수 있는 방식으로 만들어주는 이런 방법이 있어요 메모리 풀을 사용할 때 동일한 데이터끼리만 모아줄 것이냐 아니면 이걸 좀 유동적으로 관리해줄 것이냐 두 가지 초이스가 있는데 대부분 전자가 훨씬 더 관리하기가 쉽습니다 그래야지 동일한 크기끼리 얘를 관리하면은 중간에 있는 애가 이제 하나가 반환이 되면 걔를 그대로 재생할 수 있게 되기 때문에 이 방법이 또 쉽다고 보시면 되겠어요 , 자, 근데 이제 뭐 처음부터 코드를 하기 전에 말부터 , 이렇게, 막 하면은 잘 이해가 안 가실 확률이 높으니까 이제 뭐 코드를 작업을 하면서 조금 진행을 해보도록 하겠습니다 , 자, 일단은, 그래가지고 우리가 오늘 만들 방법은 예를 들면은 특정 크기 범위에 들어가는 애들끼리 모아가지고 하나의 메모리 풀에서 우리가 그걸 관리해주게 될 텐데 근데 그 객체들마다 뭔가 사이즈가 다 다를 수 있으니까 우리가 어떤 메모리를 할당할 때 거기다가 나중에 디버깅을 도와주기 위한 이런 메모리 헤더를 하나를 붙여 놓을 겁니다 그래가지고 실질적으로 데이터를 할당할 때는 이 메모리 헤더를 앞에다가 붙인 다음에 그 다음에 실질적으로 우리가 사용할 이 데이터를 같이 낑겨가지고 원플러스 원으로 만들어 준다고 생각하시면 되겠습니다 근데 , 사실, 우리가 사용하는 그런 표준 얼로케이터 같은 경우도 비슷하게 이런 메모리 헤더를 끼워 넣습니다 왜냐하면 우리가 예를 들면 이런 식으로 , 자, 나이트를 동적할당을 한 다음에 딜리트K를 해가지고 요 나이트를 우리가 삭제한다고 했을 때 요 부분에 대해서 생각해보신 적이 있는지 모르겠지만 이 딜리트라는 것 자체가 애당초 요 아이의 크기가 얼마인지를 알고 얘를 지울까요? 그게 굉장히 궁금하죠? 근데 사실상 얘를 이제 메모리를 까보면 이 나이트라는 걸 만들 때 요 나이트라는 메모리를 요렇게 할당해서 만들 때 요 앞에다가 실질적으로 요 객체의 사이즈는 얼마인지 그리고 다음 이 다음에 있는 힙에 할당된 다음 메모리 주소는 어디인지 등등 이런저런 정보들을 여기다가 이제 기입을 하고 있어요 그래서 우리도 비슷하게 나이트 객체를 할당할 때 이 앞에다가 이런저런 정보를 같이 낑겨넣는다라고 보시면 되겠습니다 , 일단은, 뭐 딱히 많은 정보를 입력하진 않을 거고 그냥 allocation size 즉 이 데이터 자체가 이제 얼마짜리 크기에 해당하는지 등등을 이제 여기다가 같이 기입을 해 주도록 하겠습니다 , 자, 그 다음에 메모리 헤더 같은 경우에 , 이렇게, 얘 사이즈를 받아가지고 일단 이 얼룩 사이즈에다가 , 이렇게, 넣어줄 거고요 , 자, 그 다음에 두 가지만 함수를 만들어 줄 건데 이건 attach header라는 함수가 있어가지고 우리가 메모리를 받아준 다음에 이 헤더를 기입해주는 그런 함수 역할을 하게 될 거고요. 그 다음에 거꾸로 이 메모리를 다 사용했으면 이제 이걸 반납해야 되는데 그때 이 헤더를 추출하는 그런 두 가지 함수를 만들어 주도록 하겠습니다. 이 attach 헤더는 처음에 이제 우리가 메모리를 할당한 다음에 아직까지 데이터는 사용하지 않은 상태이고 그냥 이 데이터가 할당된 상태에서 이 첫 번째 주소를 지금 , 이렇게, 넘겨준 상태입니다. 그래서 여기서 우리가 지난 시간에 배웠던 placement new 문법을 이용해가지고 , 자, 요런 식으로 placement new를 해가지고 여기에다가 이 얼룩사이즈를 , 일단은, 기입을 해주도록 하겠습니다 그 다음에 실질적으로 사용하는 쪽에서는 이 헤더에 대한 존재를 모르고 이건 우리가 내부적으로 관리하는 거기 때문에 그 다음에 그 다음으로 넘어가 가지고 이 데이터가 시작하는 주소를 반환해 줄 거예요 애당초 요 포인터 자체가 메모리 헤더 타입으로 우리가 받아줬으니까 실질적으로 여기다가 이런식으로 어... 뿔뿔을 해 줘 가지고 1을 더해 주게 되면은 포인터 연산 특성상, C++ 포인터 연산 특성상 메모리 헤더만큼을 건너뛰게 되기 때문에 정확히 이 데이터의 시작 위치로 이제 반환을 해 주게 될 겁니다. 그러면 사용하는 쪽에서는 그냥 이 데이터를 그냥 자기가 사용하면 된다는 얘기가 되는 거죠. 우린 이거는 여기서 내부적으로 관리하는 그런 헤더고요. 거꾸로 디테치 헤더는 이 데이터의 시작 위치를 반환해 줄 건데 우리는 이제 여기서 하고 싶은 거는 거꾸로 이 메모리 헤더를 추출해 가지고 얘를 이제 건네 주고 싶습니다. 그러니까 이제 거꾸로 헤더를 추출하기 위해서 , 일단은, 이 voidptr 이라는 것을 메모리 헤더 포인터로 캐스팅을 해준 다음에 여기다가 1을 빼주면 여기서 이제 한 칸 뒤로 갈 수가 있겠죠 그래가지고 이 주소를 , 일단은, 그냥 그대로 뱉어주도록 할 거예요 뭐 아직까지 얘는 그냥 어마무시하게 복잡한 그런 기능은 하는 건 아니고 나중에 가가지고 여기서 뭐 필요한 디버그 정보를 넣어주고 싶다고 하면 여기다가 이제 추가를 해주고 뭐 잘 설정을 해주면 되겠죠 , 자, 이렇게, 가지고 메모리 헤더는 완성이 되었구요 음 아 그리고 제가 늘상 하는 약간 부두술에 가까운 딱히 의미는 없지만 왠지 마음이 편해지는 요런 주석도 한번 달아보도록 하겠습니다 , 자, 그래가지고 요렇게 , 일단은, 달아보도록 할 거구요 , 자, 그 다음에 이제 이어가지고 아래쪽에는 본격적으로 이제 메모리 풀 클래스를 요기다가 이제 만들어 줄 것인데요 , 자, 일단 오른쪽 왼쪽 같이 보도록 하겠습니다 , 자, 그래가지고 요기서는 어 퍼블릭 프라이벳 일단 프라이벳 쪽에서는 알로케이션 사이즈를 들고 있을 건데요 아까 얘기한 대로 메모리 풀이 여러 개가 있다고 했었죠 여러 개가 있는데 각각의 자신이 담당하고 있는 그 메모리 사이즈가 있을 텐데 그거를 일단 여기다가 일단 들고 있을 거고요 그 다음에 알로케이션 카운트 뭐 , 일단은, 어토믹으로 하지 않아도 되는데 나중에 혹시 변할 수 있으니까 이걸 어토믹으로 만들어 주도록 하고 얘는 말 그대로 이 메모리 풀에서 얘가 뱉어준 그 메모리의 개수를 얘기하고 있는 겁니다. 이것도 순전히 디버그 용도죠. 결국에는 나중에 우리가 까봤을 때 지금 실질적으로 해당하는 메모리 사이즈에 해당하는 그런 메모리가 지금 몇 개가 할당이 되었는지를 이걸로 추적을 해주게 될 겁니다. , 자, 그 다음에 뭐 이번 단계에서는 그냥 락을 사용하는 그런 굉장히 단순한 방식으로 , 일단은, 만들어 보도록 할게요 다음 시간에는 이걸 좀 고쳐 볼 건데 , 일단은, 뭐 큐라거나 스택 아니면 벡터 뭐든 상관없이 이거를 뭐 잠시 들고 있다가 다시 뱉어줄 수 있는 형태면 무엇이든 상관이 없습니다 , 자, 이렇게, 일단은, 메모리 풀을 만들어 보도록 하겠습니다 그래서 , 일단은, 처음에는 allocation size를 얘는 받아 줄 거고요 소멸제도 일단 만들어 줄 것이고 그 다음에 push랑 pop을 각각 만들어 주도록 하겠습니다 메모리 헤더를 받아줄 것이고 메모리 헤더를 뱉어줄 것이고 푸시팝 그래서 이제 재사용하고 싶을 때는 다 사용했는데 그거를 이제 당장 삭제하지 않고 풀에다가 반납을 할 때는 푸시를 할 것이고 실질적으로 메모리가 필요해서 사용하고 싶을 때는 팝을 호출해줘가지고 사용한다라는 정책이 되는 거죠 , 자, 그 다음에 오른쪽에다가 메모리 풀을 이제 본격적으로 만들어 보도록 할 건데 어 , 자, 여기서 단축키를 이용해 가지고 컨트롤 점점 엔터 구현부를 다 만들어 보도록 합시다 나머지들도 컨트롤 점점 엔터 , 이렇게, 일단은, 구현부를 만들어 주도록 할건데 생성자 같은 경우에는 딱히 별걸 해주고는 아닐거고 얼로케이션 사이즈만 그대로 받아주도록 하겠습니다 이제부터 이 메모리 풀은 기본적으로 이 Allocation Size에 해당하는 메모리를 관리하겠다라는 얘기가 되는 거구요 그 다음에 소멸자 같은 경우에는 뭐 지금 미리 만들어도 되고 나중에 만들어도 되지만 얘는 그냥 정리하는 단계니까 그냥 Q에 있는 모든 메모리들을 꺼내가지고 , 일단은, 삭제를 해주도록 하겠습니다 그래가지고 Q.front를 꺼내가지고 Q.pop을 해서 , 이렇게, 일단은, Free로 해주도록 할게요 C스타일의 할당기를 이용해가지고 , 일단은, 여기다가 메모리를 딸려주도록 하겠습니다 , 자, 그러면 이제 어.. 푸쉬랑 팝을 만들어줘야 되는데 , 일단은, 팝부터 만들어주도록 할게요 그게 조금 생각하기 쉬워가지고 팝부터 만들어줄건데 얘는 , 일단은, 어.. 이제 메모리를 이 풀에 메모리가 있는지 없는지를 체크를 해줄겁니다 그래가지고 여기다가 영역을 잡아가지고 락을 잡아준 다음에 Q에 MT를 먼저 체크를 해줄거에요 그래서 여기서 체크하고 싶은 거는 우리가 사용하는 이 메모리 풀에 여분 데이터가 있는지를 먼저 체크하는 거죠 그래가지고 만약에 여분이 있습니까 Q가 MT가 아니라고 한다면 , 일단은, 여분이 있다는 얘기가 되는 거니까 있으면 그냥 하나를 꺼내 오면 되겠습니다 그래가지고 그렇게 되면은 이 헤더는 Q.front를 꺼내 주고 그 다음에 꺼내 줬으니까 하나를 팝 해주면 되겠죠 이걸 뭐 스택이나 벡터로 했으면 그게 맞게끔 이제 구현을 해주시면 되고 그래서 여기서 , 일단은, 데이터를 뿅 하나 꺼내왔는데 만약에 여기서 데이터가 처음에는 없을 수 있겠죠? 없으면 일단 새로 데이터를 할당을 해줘야 됩니다 그래서 만약에 이제 헤더를 박아주고 없다고 하면은 여기서 , 자, 이런식으로 메모리 헤더를 캐스팅을 해줌과 동시에 멀록을 이용해가지고 기본 힙 할당 함수를 이용해가지고 요렇게 메모리에다가 이제 할당해서 받아주도록 할게요 물론 이거를 , 이렇게, 매번마다 없으면은 새로 만들어도 되고 아니면 그냥 시작할 때 시작 단계에서 그냥 우리가 필요한 만큼 막 만 개든 십만 개건 미리 할당하는 방법도 있고 이건 여러가지 방법이 있어요 근데 지금은 팝을 할 때 없으면 그냥 , 이렇게, 실시간으로 새로 만드는 방식으로 새로 데이터를 만들어 데이터를 할당해 달라고 요구하는 식으로 만들어 보도록 하겠습니다 그리고 만약에 여기 들어왔다고 하면은 데이터가 이미 여분이 있어가지고 이 큐에 있던 걸로 우리가 꺼내왔다는 얘기가 되는 거죠 , 자, 그 경우에는 뭐 딱히 할 주권 없지만 그냥 혹시 모르니까 그냥 디버그 하기 위해서 이 Allocation Size가 0이 아닌지만 , 일단은, 체크를 해보도록 하겠습니다 그 다음에 결국에는 이 Allocount 같은 경우에 우리가 데이터를 하나를 꺼내왔으니까 이 개수를 하나를 늘려주도록 할게요 그리고 최종적으로 이 헤더를 뱉어주면 되겠습니다 그래서 결국에는 이 메모리 풀이라는 데다가 우리가 공용 데이터를 관리할 것인데 그 데이터를 하나를 꺼내가지고 뱉어준다라는 로직이 실행이 되는 거고 혹시라도 데이터가 더 이상 없다고 하면은 고갈되었으면은 실시간으로 , 이렇게, 하나를 만들어준다라고 볼 수가 있는 거죠 그럼 거꾸로 여기서 팝을 해가지고 신나게 이 메모리를 사용하다가 더 이상 필요 없어지면은 이제 거꾸로 푸쉬를 해가지고 풀에다가 메모리를 반납을 해주면 되겠죠? 풀에 메모리 반납 그래서 큐에다가 푸취를 해줘가지고 요렇게 넣어주고 그 다음에 얼로케이션 카운트도 어.. 패치 서브를 해가지고 이제는 거꾸로 반납이 되었으니까 얘는 이제 1을 줄여주면 되겠습니다 그래서 실시간으로 지금 팝이 된 카운트라고 볼 수가 있는 거죠 이 얼러카운트는 그 다음에 뭐 이거는 옵션이긴 한데 이 얼러케이션 사이즈를 , 일단은, 0으로 밀어가지고 얘가 0이면 더 이상 사용하지 않는 상태라고 , 일단은, 간주를 하도록 하겠습니다 , 자, 이렇게, 해가지고 일단 간략하게 메모리 풀을 , 일단은, 만들어 봤고요 이제 이거를 하나만 딱 , 이렇게, 만들어 가지고 사용하는 게 아니라 크기별로 굉장히 여러 개를 들고 있다고 했었죠 , 자, 그래가지고 이거는 뭐 그냥 메모리 헤더 cpp를 켜 가지고 어쨌든 요 파일 자체가 메모리 랑 관련된 애니까 이제 이거를 좀 총괄하는 메모리 매니저 같은 애를 여기 내부에 만들어 주도록 할게요 , 자, 그래가지고 이쪽에다가 , 일단은, 메모리 풀 전방선언을 해준 다음에 그 다음에 클래스는 메모리라고 지어도 되고 메모리 매니저라고 지어도 되고 이거는 이름을 마음이 드시는 대로 , 일단은, 만들어주시면 되겠습니다 , 자, 그래가지고 여기다가 메모리와 관련된 메모리를 관리하는 코드들을 여기서 넣어줄 거고요 얘가 한마디로 메모리 풀을 총괄하는 그런 아이라고 보시면 되겠습니다 , 자, 근데 이제 여기부터 좀 정책이 여러분들이 선택을 하셔야 되는 게 있는데 그래서 풀을 몇 개를 만들어 줄 것인가가 또 굉장히 고민이 되죠 근데 일반적으로는 조금 메모리가 좀 작은 사이즈 애들을 굉장히 많이 사용하게 되고 이게 커지면 커질수록 , 사실, 그렇게 겹칠 확률이 좀 낮기 때문에 메모리가 작은 애들은 좀 촘촘하게 많이 만들어 줄 것이고 메모리가 커지면 커질수록 메모리 풀 개수를 조금 유동적으로 줄여 보도록 할게요 그래가지고 지금 하려는 건 뭐냐면은 대충 1024 바이트 까지는 32 바이트 단위로 우리가 풀을 만들어 줄 것이고 그 다음에 1024 에서 2048 까지는 뭐 대충 128 단위로 만들어 줄 것이고 4096 최종적으로 4096 까지는 256 바이트 단위로 이제 풀을 늘려 주도록 하겠습니다 그래서 이거를 다시 풀카운트로 정리를 해보면 최종 풀카운트는 몇 개냐면은 1024 나누기 32 더하기 1024 나누기 128 더하기 2048 나누기 256 이라고 , 일단은, 볼 수가 있겠어요 요 단위별로 , 일단은, 카운트를 얘가 1024 바이트까지는 꽤 촘촘하게 만들어 줄 것이고 얘는 조금 더 느슨하게 얘는 점점점점 느슨하게 , 이렇게, 카운트를 조절한다고 보시면 되겠습니다 그리고 최종적으로 맥스 얼로케이션 사이즈 같은 경우는 4096 즉 4KB까지 우리가 이 풀을 만들어 줄 것이고 얘를 초과하는 애라고 하면은 꽤 큰 사이즈의 데이터이다 보니까 걔 같은 경우는 굳이 풀링을 할 필요가 없고 어차피 큰 데이터다 보니까 그냥 생으로 기본 힙 할당기를 이용을 해 주도록 하겠습니다 뭐 요런 정책으로 만들어 볼 것이고 그 다음에 메모리 어... 생성자 소멸자를 만들어 줄 것이고 그 다음에 Allocate라고 해가지고 메모리를 할당하는 함수 그 다음에 Release라고 해가지고 메모리를 날려주는 함수를 만들어 주도록 할게요 그 다음에 이어가지고 요 메모리 풀을 이제 관리를 어... 이 메모리 풀을 우리가 여기서 만든 이 메모리 풀을 여러 개를 들고 있을 거니까 걔를 , 이렇게, 100도로 , 일단은, 이렇게, 들고 있도록 하겠습니다 그 다음에 최종적으로 메모리 크기에 따라 가지고 메모리 풀을 빠르게 찾을 수 있도록 즉 시간 복잡도를 상수 안에 빠르게 찾기 위한 헬퍼 테이블을 또 추가로 만들어 주도록 할게요 메모리 풀을 빠르게 찾기 위한 풀 테이블입니다 최대 바이트가 4096 이니까 1을 더해 줘 가지고 0 바이트에서 4096 사이에 바이트를 우리가 딱 입력을 하면은 그러면 너는 해당 메모리 풀을 이용하면 되라는 걸 이제 입력을 해주는 겁니다. 얘를 사용하는 이유는 예를 들면 우리가 첫 번째가 32 바이트 이하의 그런 메모리를 관리하는 메모리 풀이기 때문에 0에서 32바이트 사이로 만약에 우리가 메모리가 필요하다고 하면 무조건 첫번째 애로 가야되기 때문에 0번, 1번, 2번, 3번에서 32까지 이 풀테이블이 같은 애를 가리키게 될겁니다. 그래서 그런 용도로 활용을 한다고 보시면 되는거고 , 자, 그래서 이 메모리를 이제 오른쪽에 가가지고 이어가지고 만들어 보도록 하겠습니다. , 자, 그 다음에 메모리 풀을 전방선언 해준거를 이제 여기다가 include 메모리 풀을 추가해줘가지고 사용을 해주시면 되겠고 그 다음에 생성자 만들어주고 소멸자도 만들어주고 그 다음에 얼로케이트도 만들어주고 릴리스도 만들어주도록 하겠습니다 그 다음에 좀 줄을 이쁘게 맞춰 보도록 할게요 딱히 의미는 없지만 그래서 , 일단은, 시작을 할 때는 이 메모리가 만들어질 때 얘가 사실상 매니저입니다 메모리 매니저여 가지고 여기서 우리가 지금 들고 있을 이 메모리 풀들을 그냥 싸그리 다 만들어주도록 할 거예요 , 자, 만드는건 어떻게 하냐면요 , 자, 이렇게, 일단은, 두개의 변수가 있는데 포문을 돌건데 사이즈가 32부터 시작을 해가지고 사이즈가 1024가 될 때까지는 우리가 단위를 32 바이트씩 올린다고 했었죠 꽤 촘촘하게 올리고 있는 겁니다 그러니까 이거를 이제 만들어 줄 거고 그때 그때마다 메모리 풀을 그냥 , 이렇게, 새로 만들어 줄 거에요 New Memory Pool 사이즈 짜리로 만들어 줄 것이고 그 다음에 요 풀에다가 Push Back을 해가지고 요 풀을 , 일단은, 넣어 주면 되겠습니다 그 다음에 요 헬퍼 테이블을 이제 채워줄 것인데 얘같은 경우는 테이블 인덱스를 요렇게 뺑뺑이를 돌면서 0번에서 지금 0번을 세팅했는데 0번에서 32바이트까지는 요 메모리 풀을 참조해라 라고 우리가 세팅을 해줘야 되니까 그냥 이런식으로 무한루프 무한루프는 아니고 와일문을 돌면서 풀테이블을 , 이렇게, 채워주면 되겠습니다 그 다음에 테이블 인덱스를 1 늘려주면 되겠죠 , 이렇게, 되면은 이제 첫턴에서는 0번에서 32번에 해당하는 바이트까지는 무조건 요 아이를 참조할 것이고 그 다음에 33 바이트부터 64 바이트는 두번째 메모리 풀을 참조할 것이고 이런 식으로 쫙 만들어지게 되겠죠 , 자, 그 다음에 이거를 복붙해가지고 한 번, 두 번 더 만들어준 다음에 어, 두 번째 턴 같은 경우에는 이거입니다 이제 1024에서 2048까지는 우리가 128 단위로 뺑뺑이를 돌린다고 했으니까 그래서 얘를 , 이렇게, 늘려주면 되겠고요 초기화 칸은 뭐 딱히 안 만들어줘도 됩니다 그냥 비워줘도 되고요 굳이 만들고 싶다고 하면은 뭐 얘가 1024부터 시작하게끔 유도를 해주시면 되겠고 그 다음에 얘는 2048까지겠죠. 1024부터 2048까지는 128 단위로 이제 늘리게 됩니다. 근데 여기 나머지 코드들은 뭐 딱히 바꿔줄 필요가 없구요. 그 다음에 마찬가지로 맨 마지막에는 얘가 이제 4096까지는 256 바이트 단위로 늘린다고 했으니까 요렇게 또 만들어주면 되겠죠. 그럼 이제 3번에 걸쳐가지고 매우 촘촘하게 조금 더 느슨하게 매우 느슨하게 이런 식으로 풀카운트가 만들어질 것이고 최종 풀카운트는 여기 보면은 48개가 이제 만들어지게 될 겁니다 이거는 여러분들이 이제 유동적으로 계산을 해가지고 더 촘촘하게 만들고 싶다 그러면 이런 공식을 좀 바꿔주면 되겠죠 , 이렇게, 해가지고 , 일단은, 메모리 풀을 싸그리 다 만들어 줘 가지고 이 크기에 따라 가지고 알맞는 메모리 풀을 찾아가게끔 이 풀테이블도 채워준 상태가 되겠습니다 , 자, 그 다음에 메모리 풀이 더 이상 필요 없어진다. 이건 , 사실, 프로그램이 끝나는 거니까 , 사실, 뭐 굳이 해제를 안 해줘도 딱히 상관은 없긴 한데 그래도 뭔가 좀 해제를 안 해주면 찝찝하니까 풀을 이제 하나씩 하나씩 돌면서 딜리트를 해주고 그 다음에 풀점 클리어를 그냥 같이 꼼꼼하게 해주도록 할게요. 그냥 메모리를 다 날려준 거죠. 동적할당돼서 얘가 동적할당된 걸 다 날려줄 것이고 , 자, 그 다음에 allocate를 해가지고 이 allocate는 헤더를 포함하지 않은 실제로 얘가 사용하고 싶어하는 그 메모리 사이즈를 지금 얘기를 하고 있는 겁니다. 그렇기 때문에 여기서 이제 이 메모리 헤더를 찾아 줄 것인데 이 Allocation Size는 기본적으로 얘가 요청한 사이즈에다가 메모리 헤더의 사이즈를 더한 만큼이겠죠 지금은 메모리 헤더가 딱히 내부적으로 인트 32만 추가되었으니까 4바이트가 추가가 되겠네요 그래가지고 이 헤더까지 추가할 수 있는 공간만큼을 우리가 이제 할당을 해줄 겁니다 근데 만약에 이 얼룩 사이즈가 최대 얼룩 사이즈를 넘어갔다고 하면은 얘는 이제 메모리 풀링을 하지 않고 그냥 기본 할당을 할 겁니다 어차피 , 이렇게, 큰 데이터는 굳이 풀링할 이유가 없어요 메모리 풀링 최대 크기를 벗어나면 그냥 일반 할당을 해주도록 하겠습니다 그래가지고 , 이렇게, 리인터펫 캐스트를 해준 다음에 요렇게 메모리 헤더를 바꿔준과 동시에 멀록을 이용해가지고 요 얼룩사이즈 만큼을 그냥 할당에서 뱉어줄 것이고 그게 아니라고 한다면 이제 작은 메모리 같은 경우에는 풀링을 하는게 의외로 많은 성능 향상을 볼 수 있고 그리고 메모리 파펴나 문제도 해결할 수 있기 때문에 이런 경우에는 메모리 풀에서 꺼내 오도록 하겠습니다 꺼내 오기 위해서는 풀 테이블에 해당 얼록 사이즈에 해당하는 메모리 풀을 찾아가지고 그냥 그대로 팝을 해주면 되겠죠 그럼 여기까지 왔으면 , 일단은, 메모리까지는 꺼내 왔는데 이제 그 다음에 해야 되는 거는 우리가 이 메모리 헤더라는 거를 , 이렇게, 기입을 해주는 부분이 들어가야 되겠죠 내가 여기다가 메모리를 꺼내 왔으니까 내가 음, 지금 할당하는 요 메모리는 얼마짜리 크기로 사용할 것이야라고 요거를 이제 적어주도록 할거에요. 이거는 뭐 디버그 용도라고 보시면 되겠습니다. 메모리 헤더에 어테치 헤더를 해가지고 헤더와 얼록사이즈를 각각 입력을 해주도록 하겠습니다. 그래서 여기에 입력된 얼록사이즈는 결국에는 이 헤더랑 데이터가 포함된 버전으로 지금 만들고 있는거죠. 그래서 몇 바이트를 지금 할당했다라고 여기다가 일단 정보를 뿅 기입을 해주는 셈이 되겠습니다. 그리고 거꾸로 이제 릴리즈를 할 때는 이제 거꾸로 메모리 헤더를 추출을 해줄건데 메모리 헤더에다가 디테치 헤더를 통해가지고 PTR을 받아오겠죠 , 자, 요 PTR이라는 거는 지금 사실상 이 유저 레벨에서 나중에 사용할 때는 요 포인터를 이용해가지고 요 데이터를 지금 활용하고 있었으니까 여기서 우리가 한 칸 뒤로 가가지고 요 메모리 헤더만큼을 이동해서 이 메모리 헤더에 해당하는 주소를 우리가 꺼내놓을 수 있으니까 이제 이 헤더를 참고하면 되겠죠 그래가지고 너는 얼마짜리 크기였냐라는 걸 한번 살펴볼건데 헤더에 얼록 사이즈를 체크해가지고 혹시 모르니까 얘가 만약에 0이었다고 하면 뭔가 문제가 있는 거니까 그냥 잡아주도록 할 거고 그 다음에 얼록 사이즈가 만약에 맥스 얼록 사이즈보다 크면은 이제 대칭적인 거죠 여기서 만약에 우리가 멀록으로 만들어놨다고 하면은 얘는 메모리 풀링 최대 크기를 벗어난 거니까 그러면 그냥 일반적인 해제 방식으로 그냥 프리를 , 이렇게, 해주도록 하겠습니다. 프리 헤더를 할 것이고 그게 아니라고 한다면 이미 충분히 작은 크기라고 볼 수 있는 거니까 메모리 풀에 우리가 해당 메모리를 이제 반납하면 되겠습니다. 반납한다. 그래가지고 역시나 풀 테이블을 이용해가지고 이 해당 얼룩 사이즈에 해당하는 메모리 풀이 어떤 건지 찾은 다음에 그대로 다시 푸쉬를 , 이렇게, 넣어주면 되겠어요. , 자, 여기까지는 참고로 요 부분에서 우리가 락을 잡지 않는다거나 하는 거는 결국에는 공용 데이터를 우리가 건드리지 않기 때문이죠 얘네들은 이미 잘 사용하고 있는 이 포인터는 나만 지금 릴리즈를 할 테니까 여기서 그냥 쿨하게 내가 얘를 날리기 위한 작업을 해줄 것이고 어차피 여기 내부적으로 메모리 풀에다가 넣는 작업에서 락을 잡아줘가지고 일단 동기화를 해주고 있습니다 그래가지고 이제 요 코드를 한번 분석을 해보시면 되겠어요. , 자, 이렇게, 굉장히 단순한 방법으로 , 일단은, 메모리 풀링을 구현을 해봤구요 결국은 이제는 무조건 이 메모리 얼러케이트랑 릴리즈를 통해 가지고 메모리를 할당해제를 받게 되면 얘가 알아서 풀링을 할 대상인지 아니면 그냥 쌩으로 만들어 줄 대상인지를 선택해 준다고 보시면 되겠습니다 참고로 하나 말씀드리자면 여기다가 왜 멀록을 써줬냐 우리가 이전에 만든 얼로케이터 중에서 이런 스톰퍼 얼로케이터를 쓰면 안되냐 라고 생각할 수도 있겠지만 이건 조금 애매해지는게 , 사실, 메모리 풀링이랑 우리가 이전에 만든 스톰퍼 얼로케이터랑은 궁합이 조금 안맞습니다 왜냐면 요 스톰퍼 얼로케이터의 기본 개념은 메모리가 필요 없어지면은 무조건 아주 그냥 확실하게 우리가 운영체제까지한테 부탁해가지고 그 메모리를 완전히 날려가지고 더 이상 접근을 못하게 한다가 우리 정책이었는데 이 메모리 풀링 정책이라는 것 자체는 어떤가요? 재사용하기 위해서 필요가 없으면 진짜로 그 메모리를 날리는 게 아니라 우리가 잠시 어딘가에다가 보관을 한다라는 개념이죠 사실은 이제 둘 중 하나를 선택해야 된다는 좀 슬픈 상황이 온 겁니다 그래가지고 메모리 풀링이랑 스톰풀은 조금 안맞는다라는 얘기를 하고 있는거구요 요 부분을 유심히 분석을 해주시면 되겠습니다 allocate 나는 메모리를 할당할것인데 이 메모리풀에서 꺼내오고 필요없어지면 메모리풀에 반납한다 라는 코드가 , 이렇게, 들어갔다고 보시면 되겠어요 그러면 이거를 실질적으로 적용을 시켜볼건데 일단 Allocator 이쪽에 돌아가가지고 우리가 이 풀링과 관련된 애를 사용하고 싶으면은 여기다가 풀 얼로케이터라는 걸 사용하도록 유도를 해봅시다 일단 여기서 여기까지 코드를 긁어가지고 여기까지 복붙을 한 다음에 풀 얼로케이터라고 해가지고 말 그대로 메모리 풀링을 하는 요런 할당기를 만들어 주도록 하겠습니다 얼록이랑 릴리즈는 똑같이 냅두도록 하고 그 다음에 이쪽에다가 음.. 여기서 여기까지 , 일단은, 긁어가지고 스톰퍼 얼로케이터 코드를 복붙한 다음에 얘를 풀 얼로케이터로 바꿔치기 해주고 , 자, 그 다음에 요 부분은 뭐 사실은 어.. 우리가 만들어준 메모리 그 매니저를 통해 가지고 객체를 만들어주게끔 이제 유도를 해주면 되겠죠 , 자, 이거는 뭐 여러가지 방법을 만들어줄 수 있겠지만 우리가 지금까지 전역으로 사용하는 그런 객체들은 요 코어 글로벌에서 만들어주고 있으니까 요 코드에 돌아가가지고 extern class memory gmemory라는 이름으로 글로벌 객체를 하나를 만들어주도록 합시다 조금 줄을 나열해줬고요 그 다음에 CPP에 돌아가가지고 이쪽에다가 메모리 G 메모리를 활용을 해주도록 하겠습니다. 널피티알 그리고 줄을 좀 맞춰주도록 할게요. 그 다음에 인클루드를 해가지고 전방선원 안내를 사용할 수 있게 이 메모리를 추가를 해줄 것이고 여기서 G 메모리는 New G 메모리 유 메모리를 만들어주고 삭제할때는 대충 이쯤에다가 삭제를 해주도록 하겠습니다 지금까지는 뭐 , 사실, 얘네들끼리 딱히 순서가 뭐 딱히 없기 때문에 뭐 어디간에 넣어도 상관이 없기는 해요 , 자, 이렇게, 해가지고 , 일단은, 만들어놨구요 그 다음에 오늘 뭐 할 거를 테스트 해보기 위해서 이 메모리에서 xalloc 이라는 것 자체가 core macro에 지금 저장이 되어 있을 텐데 core macro에 있는 거를 , 일단은, 얘를 full allocator로 일단 바꿔치기를 해주도록 할게요 이제부터는 스톰프가 사용되는 게 아니라 무조건 이 메모리 재활당이 들어가 가지고 이 메모리 풀에다가 개체를 다시 집어넣고 그 다음에 재활당을 하고 하는 부분이 들어간다고 일단 볼 수가 있겠습니다 , 자, 여기까지 , 일단은, 만들어봤고 서버코어을 일단 한번 빌드해서 에러가 없는지 한번 잡아보도록 하겠습니다 , 자, 여기서 반환.. 아 이 부분 아직 안 만들어놨네요 , 자, 얼로케이터에 돌아가가지고 그러면 얘는 이제 무엇을 해야 되느냐 리턴 글로벌로 만들어준 요 메모리에서 얼로케이트를 해가지고 요 사이즈만큼 , 이렇게, 넣어줘서 메모리를 할당한 다음에 뱉어주면 되고 얘는 거꾸로 릴리즈를 해서 요 포인터를 , 이렇게, 넣어주면 되겠죠 그 다음에 에러가 나는 거는 이 메모리를 지금 얘가 어떤 타입인지 몰라가지고 그런 거니까 위에 올려가지고 include 메모리 헤더를 추가를 해주면 되겠어요. 그럼 이제 진짜로 이 풀 얼로케이터에 따라가지고 얘를 사용해주면은 우리가 전역으로 만들어준 이 객체에 의해가지고 객체가 할당이 될 것이고 그때 이 코드가 실행이 되면서 알아서 메모리 풀을 이용해가지고 만들어주고 삭제를 하는 부분이 이제 동작을 하게 될 겁니다. 굉장히 단순하게 만들었는데 이게 , 사실, 메모리 풀의 기본 개념이라고 볼 수가 있겠어요 여기서 중요했던 건 결국에는 어떤 특정 크기에 해당하는 객체끼리 모아서 관리한다는 거죠 무조건 같은 클래스만 같은 풀에 들어가는 게 아니라 서로 다른 클래스라고 하더라도 크기가 어느 정도 비슷하다고 하면 같은 풀에 우리가 개를 관리한다고 , 일단은, 볼 수가 있는 겁니다 그래가지고 결국 여기서 뉴 딜리트를 당장 하지 않은거는 얘는 그냥 메모리만 , 일단은, 할당을 해준 다음에 그 다음에 사실상 우리가 여기 메모리 코드에서 요 부분에서 우리가 플레이스멘트 뉴 를 이용해가지고 생성자료를 호출해줬었죠 여기도 소멸제를 직접 호출해주고 그렇기 때문에 요 부분에서는 뉴 딜리트가 아니라 그냥 메모리만 할당하는 함수들을 이용해 준겁니다 , 자, 이렇게, 해가지고 , 일단은, 대충 코드가 만들어졌구요 그 다음 이제 게임 서버 쪽에 돌아가가지고 어... 요걸 뭐 간단하게 실습을 하기 위해서는 이게 멀티스레드 환경에서 그냥 뭐 문제없이 잘 동작하는지만 살펴보면 되겠죠 예를 들면은 뭐 요렇게 스레드를 한 5개 정도 만들어줄건데 G스레드 매니저에 런치를 해줄것이고 런치를 해줄것인데 , 자, 요기다가 람다로 받아가지고 무한 루프를 돌면서 대충 뭐 요런 코드들을 막 안에다가 넣어주도록 하겠습니다 어 벡터를 만들어주면서 요 나이트들을 만들어주고 그 다음에 얘네들을 만들어주고 그 다음에 너무 반복하긴 좀 싫으니까 디스스레드 슬립을 넣어줘가지고 좀 기다리면서 슬립4 한 10ms마다 요 벡터를 만들어주고 맵도 만들어주고 삭제라는 뭐 그런 코드들을 한번 여기다가 넣어주도록 할게요 , 자, 요렇게 그 다음에 G-thread 매니저에 조인을 해주게 되면은 무한대기를 타겠죠 , 자, 이렇게, 해가지고 간단하게 테스트를 해볼건데 어... , 일단은, 이 부분을 F4로 실행하면은 , 일단은, 뭐 크래쉬가 안나고 잘 동작한다는걸 일단 볼 수가 있구요 엄청 많이 막 객체를 생성하고 소멸하고 막 난리를 치고 있네요 , 자, 그 다음에 요기서 이제 궁금하니까 살짝 디버그를 해가지고 살펴보면은 여기서 Allocate 하는 부분과 그 다음에 Release 하는 부분이 이제 딱 잡힐 거라는 걸 알 수가 있습니다 여기서 딱 메모리를 잡으면은 여기서 Size라는 걸 16바이트를 요청을 했는데 얘는 어디서 온 건가 보면은 STL Allocator 즉 우리가 뭐 벡터나 맵 같은 걸 사용할 때 만들어진 애로 예상이 되고 16바이트가 만약에 왔으면은 실질적으로 4바이트를 추가한 이 Alloc Size 즉 20바이트만큼을 사용할 것인데 메모리 풀에서 얘를 지금 , 이렇게, 꺼내올 것이고 여기서 여분이 있는지 없는지에 따라가지고 다른 스레드가 잡혔네요 여분이 있는지 없는지에 따라가지고 만약에 여분이 있었다 이미 다른 애가 다시 반납한 애가 있다고 하면은 걔를 지금 , 이렇게, 있으면 하나 꺼내오는 부분이 실행이 될 겁니다 멀티스레드 환경이어가지고 자꾸 딴 애가 얘 스레드를 잡고 있는데 결국에는 이 부분을 살펴보면요 내가 없으면 새로 만들 것이고 그게 아니라 이미 다른 애가 반납한 애가 있어가지고 충분한 공간이 있다고 하면 여기에 여분이 있으면 하나를 꺼내와 가지고 걔를 그대로 재사용한다는 걸 , 일단은, 알 수가 있습니다 그래가지고 이게 , 사실, 메모리 풀의 기본이라고 볼 수가 있겠어요 , 이렇게, 해가지고 굉장히 단순하게 메모리 풀을 만들어 봤는데 이제 이거를 좀 다음 시간에 이런 저런 방법으로 개선하는 그런 내용에 대해서 알아보도록 하겠습니다.