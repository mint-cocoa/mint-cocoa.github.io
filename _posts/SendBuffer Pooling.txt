우리가 지난 시간까지 샌드 버퍼라는 개념을 도입을 해 가지고 샌드를 할 때마다 데이터를 막 복사하지 않고 샌드 버퍼라는 애를 , 이렇게, 한 번만 만들어 준 다음에 실질적으로 데이터를 보는 일이 없을 때는 샌드를 할 때 샌드 버퍼 자체를 넘겨 줘 가지고 걔네들을 , 이렇게, 물고 있는 형태로 작업을 해 봤습니다 그래가지고 실질적으로 데이터를 보낼 때는 여기 큐에다가 샌드 큐에 들어가 있는 애들을 모아가지고 스케터 개더라고 했었죠. 그거를 이제 한 번에 , 이렇게, 빵! 보내는 부분까지 , 일단은, 작업을 해봤고 이제 앞으로 이런 식으로 활용을 하게 될 겁니다. 굉장히 우아한 방법이죠. , 자, 그런데 여기서 이제 뭐 굳이 조금 아쉬운 부분, 개선할 만한 부분을 찾아보자면 매번마다 데이터를 보낼 때마다 이런 식으로 메이크셰드를 해가지고 샌드 버퍼를 만들어 준 다음에 채워주고, 뭐 채워주는건 그렇다 치더라도 요걸 매번마다 만들어주는게 조금 뭐 아쉽기는 하죠 물론 애당초 우리가 메이크시어드를 타고 들어가면은 결국에는 우리가 메모리 풀링을 뭐 릴리스 모드에선 적용시켜가지고 활용하고 있긴 있으니까 뭐 이정도로도 충분하지 않을까 싶을 수도 있지만 그럼에도 불구하고 우리 메모리 풀이 너무 메모리 양이 커지면 풀링을 하지 않고 그냥 뉴 딜리트 방식으로 동작하게 했죠. 그리고 심지어 또 하나의 문제는 렌스를 우리가 이런 식으로 데이터를 복사를 지금 , 이렇게, 하고 있죠 내가 사용할 데이터 자체를 크기를 미리 알면은 그 크기만큼을 정확하게 할당해서 사용을 해도 되기는 해요 근데 , 이렇게, 하지 않고 굳이 훨씬 더 큰 영역을 잡아준 이유는 뭐냐면은 나중에 가면은 이게 케바케로 좀 다르긴 한데 경우에 따라서는 미리 내가 보낼 바이트를 미리 예측할 수 없는 상황이 생깁니다 그럼 이건 약간 패킷 설계와 관련된 부분이긴 한데 먼저 버퍼를 크게 할당을 받은 다음에 이리저리 데이터를 채워주고 그제서야 내가 지금까지 채워준 사이즈가 계산이 되는 식으로도 동작하는 경우도 있고 아니면 먼저 내가 보낼 데이터를 다 만들어 준 다음에 계산을 먼저 해주고 , 이렇게, 만들어 주는 경우 있어 가지고 양쪽을 다 커버하기 위해서는 결국엔 , 이렇게, 처음부터 데이터를 좀 큼지막하게 할당을 해준 다음에 그 중에서 내가 일부만 사용하겠다라고 이 렌스를 따로 전달해주는 형태로 우리는 일단 작업을 해놨어요 근데 이렇다 보니까 처음에 메모리를 할당할 때 내가 사실상 1바이트만 보내야 되는 상황임에도 불구하고 , 이렇게, 4096이라는 굉장히 어마어마한 큰 크기를 잡는 게 조금 마음에 안 듭니다 그래서 오늘 주제는 이 샌드버퍼를 매번마다 만들지 않도록 풀링을 하는 그런 방법에 대해서 실습을 해볼 건데 그냥 간단하게 생각을 하면은 최대 크기의 버퍼로 만들어 가지고 걔를 그냥 재사용하게끔 만들면 되지 않을까 라는 생각이 듭니다 그것도 , 일단은, 괜찮다기 보다는 , 일단은, 합리적인 방법이긴 한데 메모리가 조금 아깝기는 하죠 당장 사용 1 바이트만 보내야 되는데도 막 어마어마하게 큰 사이즈를 잡는다는 것 자체가 조금 아까우니까 이거를 그러면 어떻게 조금 더 효율적으로 바꿀 수 있을지에 대해서 고민을 해보도록 합시다 근데 물론 이대로 그냥 사용을 해도 뭐 크게 무방하긴 해요 요즘 워낙 컴퓨터 성능이 좋아가지고 , 자, 그런데 일단 여러가지 기법들에 대해서 공부하는 것도 굉장히 뭐 좋은 도움이 되다 보니까 오늘 해볼 거는 제가 이전에 일하던 프로젝트에서 비슷하게 사용하던 방식을 한번 모방을 해볼 건데요 , 자, 일단은, 샌드버퍼 쪽부터 작업을 해보도록 할게요 , 자, 오늘 , 일단은, 이 샌드버퍼라는거에다가 두가지 클래스가 더 추가가 될건데 하나는 샌드버퍼 chunk라는 이름으로 지어줄것이고 두번째는 샌드버퍼 매니저라는애로 이름을 지어줄겁니다 , 자, 매니저는 말그대로 전역으로 사용하는 그런 매니저구요 이 샌드버퍼 chunk는 말그대로 버퍼들을 우리가 필요할 때마다 , 이렇게, 하나 만드는 게 아니라 굉장히 큰 덩어리를 하나를 , 일단은, 한번 할당을 받은 다음에 그거를 쪼개 가지고 샌드퍼퍼로 사용하겠다는 정책입니다 오늘 할 내용을 요약해보자면 어마어마하게 큰 요런 샌드퍼퍼 청크라는 걸 , 이렇게, 할당을 받은 다음에 거기서 우리가 , 이렇게, 잘라 쓰는 식으로 이 부분까지 쓰고 샌드 퍼퍼를 만들어주고 그 다음 부분 쓰고 샌드 퍼퍼를 만들어주고 필요한 만큼만 계속 , 이렇게, 잘라먹는 식으로 작업을 하게 될 거에요 그게 , 일단은, 포인트입니다 , 자, 그래서 일단 설계를 해보면서 설명을 드리도록 할게요 샌드 퍼퍼 청크라는 클래스를 일단 만들어주고 아래는 Sandbuffer Manager로 , 이렇게, 만들어 주도록 하겠습니다. 어느 쪽이 이해하기 더 쉬운지 모르겠어서 , 일단은, 좀 이해하기 쉽게 Sandbuffer Manager부터 간단하게 작업을 해볼 건데요. 이건 좀 큼지막하게 보여드리는 게 나을 것 같네요 , 자, 일단은, 락을 사용할 것이고 그 다음에 벡터로 샌드 버퍼 청크에 스마트 포인터를 , 이렇게, 들고 있을 예정입니다 샌드 버퍼 청크 , 자, 스마트 포인터 요거 아직 정의가 되지 않았으니까 우리가 타입에다가 얘네들을 지금 정의해서 사용하고 있었죠 그러니까 이쪽에 가가지고 여기 아래다가 복붙한 다음에 SandBufferChunkReference라는 애를 하나를 또 만들어주도록 하겠습니다. 요렇게 추가를 해주면 되겠죠. , 자, 하는 김에 줄 정리도 다시 , 이렇게, 정렬을 시켜주도록 하구요. 오케이, 저장. , 자, 그 다음에 다시 돌아와가지고 샌드 버퍼 매니저에서는 , 일단은, 기본적으로 샌드 버퍼 랩프를 뱉어주는 오픈이라는 함수가 하나 있을 거고요 이게 3개의 클래스가 맞물려서 동작을 하기 때문에 지금 당장 이해가 좀 하기 힘들 것 같은데 , 일단은, 따라 치면서 천천히 설명을 해보도록 할게요 샌드 버퍼 청크 랩프를 팝 해주고 얘는 푸쉬하는 기능도 같이 있을 겁니다. 얘가 , 일단은, 샌드 버퍼 풀의 개념이라고 보시면 되는 거죠. 샌드 버퍼 청크 랩. 그래서 얘를 버퍼라고 하고 마지막으로 이유는 곧 설명을 하겠지만 스태틱 보이드로 푸쉬 글로벌이라는 함수를 , 이렇게, 만들어주도록 할게요. 샌드 버퍼 청크의 포인터를 얘는 받아줄 겁니다. , 이렇게, 일단은, 함수 모양만 만들어 주고 이거를 바로 작업을 시작해 보도록 하겠습니다. open pop 그 다음에 push 마지막으로 Push Global 이라고 해가지고 얘네들을 이제 사용할 건데 Open 이라 하면 무엇을 Open 한다는 거냐면은 우리가 아까 얘기한 그 큼지막한 샌드 버퍼 덩어리에서 우리가 사용할 만큼을 쪼개서 이제 사용을 하겠다라고 얘가 그거를 뜯어가는 개념입니다. 버퍼가 이따만큼 큰데 어마어마하게 큰데 근육에서 내가 일부를 이제 사용하겠다라고 , 일단은, 열어주게 됩니다. 그래서 Open 이라는 용어를 사용하고 이걸 열어준 다음에 내가 열어준 영역만큼을 꼭 다 사용해야 되는 건 아니고 내가 데이터를 이리저리 쳐준 다음에 클로즈를 나중에 해주게 될텐데 그 클로즈한 영역이 실질적으로 내가 사용하는 영역이 될겁니다 그래서 얘는 먼저 이정도 예약을 한 다음에 예약한 것 중에서 일부를 사용해가지고 진짜로 사용할 데이터를 나중에 또 따로 클로즈를 해주게 된다 약간 이런식으로 동작을 하게 될거에요 , 자, 근데 그거는 뭐 지금 딱히 이해가 안가도 상관이 없구요 어... , 일단은, 팝을 오픈을 해가지고 사용하는 건 사용하는 건데 이 팝이랑 푸시부터 먼저 작업을 해볼게요 그 편이 조금 더 나을 것 같네요 얘네들은 뭘 하는 거냐면 이 샌드버퍼 청크라는 거를 다 소진해가지고 내가 다 썼다 더 이상 메모리가 없다고 하면 그걸 이제 풀에다가 반납을 해주게 될 겁니다 그래서 그거 푸시랑 팝이라는 이름으로 , 일단은, 받아주는 거예요 그래서 먼저 락을 잡아가지고 샌드버퍼 청크에다가 푸시백을 해가지고 , 일단은, 이런 식으로 다시 반납을 할 것이고 그 다음에 팝을 한다는 것은 내가 거꾸로 하나를 이제 이 샌드버퍼 청크라는 걸 꺼내 쓰겠다는 얘기니까 거꾸로 먼저 락을 걸어준 다음에 먼저 체크를 해줄 겁니다 샌드버퍼 청크가 MT 이냐 MT가 아니라고 하면은 우리 풀에 이 매니저가 들고 있는 큼지막한 샌드버퍼 청크가 하나 있다는 얘기니까 걔를 바로 반환을 해줄 거예요 그래서 SandbufferChunkRef를 , 이렇게, 꺼내가지고 SandbufferChunk에 Back을 해가지고 하나를 꺼내 준 다음에 SandbufferChunk에 PopBack을 해가지고 꺼내주고 그 다음에 얘를 바로 Return을 해주도록 하겠습니다 근데 만약에 여기 라이트 락을 해서 체크했는데 얘가 엠티라고 하면은 내가 지금 여유분이 하나도 없다는 얘기니까 여유분이 없으면 그제서야 얘를 빌려서 그냥 새로 만들어 주도록 할 거예요. 새로 만들어 줄 때는 이런 식으로 Sand Buffer Chunk라는 걸 , 이렇게, 만들어 준 다음에 그 다음에 Push Global로 , 이렇게, 두 번째를 설정해 주도록 하겠습니다 , 자, 이 부분이 살짝 헷갈릴 수 있는데요 우리가 일반적으로 스마트 포인터를 만들 때 그냥 지금까지는 Make Shared 이걸 이용했었죠 그리고 얘를 이용하게 되면은 Xnew라는 거로 우리 메모리 풀을 이용해가지고 만들어 준 다음에 더 이상 레퍼런스 카운팅이 0이 되어서 더 이상 사용 안 할 때는 우리가 소멸자에 해당하는 딜리트를 넣어 줬기 때문에 요 아이가 호출이 되어서 삭제가 되었습니다. 근데 지금 요 아이 같은 경우는 이 샌드버퍼 청크라는 애는 레퍼런스 카운트가 0이 되어서 더 이상 사용하지 않는다고 하면은 메모리를 날리는 게 아니라 다시 한번 요 푸쉬 글로벌로 들어와 가지고 다시 우리 샌드버퍼 청크 모임에다가 여기다가 다시 넣어 놓게 될 거예요 재사용을 계속 계속 무한정으로 한다는 얘기가 되는 거죠 이 메모리를 더 이상 사용하지 않는다고 해도 안 된다고 해도 걔를 날리는 게 아니라 재사용할 수 있게끔 다시 요 풀에다가 넣어주고 그 다음에 누군가가 팝을 해서 다시 필요해지면은 그 애를 다시 꺼내 쓰겠다라는 뭐 그런 마인드입니다 그래서 얘는 굉장히 특이하게도 처음에 만들어줄 때 스마트 포인트를 , 이렇게, 만들어주고 있는 거죠 얘가 실질적으로 레퍼런스 컴퓨터가 0이 될 때 그 딜리터를 얘기하고 있는 겁니다 그래서 요 함수가 이제 호출이 될 거고 그래서 얘가 유일하게 스태틱이 붙은 거예요 멤버 함수로 , 일단은, 전달해줄 수 없기 때문에 이런 식으로 스태틱 함수를 전달을 해준 거고요 얘 같은 경우는 그럼 이제 어떻게 해야 되느냐 우리가 이제 이 샌드버퍼 매니저를 글로벌하게 그냥 하나만 갖고 있을 겁니다 그래가지고 , 일단은, 코어 글로벌 쪽에 가가지고 , 자, 요 부분에다가 엑스턴 클래스 샌드 버퍼 매니저를 하나를 만들어 주도록 할게요 샌드 버퍼 매니저 앞으로 컨텐츠 쪽에서는 다 요 샌드 버퍼 매니저를 통해 가지고 샌드 버퍼를 할당을 받을 겁니다 , 자, 그 다음에 오른쪽에 가가지고 복붙 한 다음에 한 이쯤에다가 넣어 주도록 할게요 이런 식으로 초기는 널피티알 그리고 include sandbuffer 를 추가를 해주도록 하겠습니다 줄 맞춰주고 그 다음에 sandbuffer 를 이쪽에서 매니저를 만들어 주도록 하겠습니다 sandbuffer 매니저를 만들어 주고 더 이상 필요 없을 때 여기서 삭제를 해주게 되겠죠 물론 이게 딱히 일어날 일은 없을 테지만 이런 식으로 생성 삭제를 같이 넣어 주도록 하고 그러면은 이제 나중에 돌고 돌아 가지고 요기 다시 샌드버퍼 매니저에서 푸쉬 글로벌로 들어왔으면은 요 글로벌 샌드버퍼 매니저에 푸쉬를 다시 해준다라는 얘기가 되는 거죠 근데 이때는 요 샌드버퍼 청크 스마트 포인터를 만들어 줄 때 요 버퍼를 다시 재사용할 수 있게끔 요렇게 만들어 주게 될 겁니다 , 자, 이런 식으로 그래가지고 처음에 만들 때만 실질적으로 메모리에서 뉴를 해줘가지고 할당을 하고 그 다음부터는 반납한 거를 그대로 재사용을 계속 해주게 될 겁니다 그래서 이런 코드가 만들어진다고 볼 수 있겠어요 , 자, 그러면 , 일단은, 이 버퍼 매니저 역할은 결국에는 푸시팝을 해가지고 계속 뭔가 꺼내 쓰고 반납하고 꺼내 쓰고 반납하고 하는 역할인데 실질적으로 컨텐츠에서 사용을 할 때는 이 Open이라는 걸 이용해가지고 이제 사용을 하게 될 겁니다 어느 정도 메모리를 할당해줘 라는 걸 오픈이라고 하는 거죠 근데 이거를 매번 마다 뭐 여기 전역에 있는 거를 뭐 하나 꺼내 쓰고 하기보다는 , 일단은, 이거를 Thread Local로 자신만의 샌드 버퍼를 하나씩 갖고 있을 거예요 , 자, 이게 조금 달라지는 부분인데 TLS를 최대한 활용해가지고 락을 대부분의 상황에서는 걸지 않고 사용할 수 있게끔 유도를 해주는 방법이라고 보시면 되겠어요 이것도 , 일단은, 만들어보면서 설명을 해볼 건데 여기서 ThreadLocal로 SandBufferChunkRef를 하나를 , 이렇게, 정의를 해주도록 하겠습니다 SandBufferChunk SandBuffer를 큰 덩어리로 관리하는 거를 Chunk라고 하는데 그 아이를 지금 , 이렇게, ThreadLocal로 일단 만들어가지고 스레드별로 자신만의 버퍼 청크를 , 일단은, 하나 물고 있겠다 라는 얘기가 되는 거죠 , 자, 그 다음에 다시 샌드 버퍼 쪽으로 돌아가 가지고 여기서 오픈을 할 때는 맨 먼저 얘를 체크를 해볼 거에요 샌드 버퍼 청크가 있는지 없는지를 먼저 체크를 해 봐 가지고 만약에 샌드 버퍼 청크가 널이라고 하면은 팝을 하나를 해주게 될 겁니다 팝을 할 때는 여기서 라이트락을 걸어주죠 라이트락을 걸어주고 있는 겁니다 이 L 시리즈, 스레드로컬 같은 경우에는 스레드마다 고유하게 갖고 있기 때문에 경합이 없어가지고 얘를 접근할 때는 굳이 락을 걸어줄 필요가 없는 거죠 근데 만약에 얘가 널이라고 하면은 뭐 아직 할당받지 않았거나 지난번에 사용했던 게 다 사용한 그런 상황일 텐데 그때는 이런 식으로 팝을 해줘가지고 여기 풀에 있는 것 중에서 여유분을 하나를 꺼내려고 시도를 할거에요 만약에 여유분이 없으면 뭐 그제서야 실시간으로 , 이렇게, 만들어주게 될겁니다 , 자, 그 다음에 뭐 여기서 어 서치크래쉬를 해가지고 이 엘 샌드 버퍼가 , 일단은, 오픈 상태인지만 간단하게 체크를 해볼건데 혹시라도 오픈을 연속해서 여러번 할까봐 얘를 체크를 해주는 겁니다 요 부분은 , 일단은, 아직 안만들었는데 , 일단은, 그냥 , 이렇게, 냅두고 나중에 채운 식으로 작업을 해보도록 할게요 , 자, 그 다음에 이어가지고 해야 되는거는 다 썼으면 버리고 새거로 교체하는 코드가 이제 들어가게 될 겁니다 그러니까 이 L-Sand 버퍼라는 것 자체가 버퍼 청크라는 게 어마어마하게 큰 사이즈의 메모리를 먼저 할당을 받은 다음에 왼쪽부터 쭉 쓴다고 했었죠 근데 만약에 내가 여기서 여기까지 썼다고 하면은 걔는 두 번 다시 재사용을 하지 않고 그냥 앞으로만 쭉 진행을 하게 됩니다 그래서 언젠가는 언젠가는 막 사용하다 보면은 끝까지 도달해가지고 다 사용을 하게 되겠죠 다 사용을 했으면 이 전체의 버퍼 청크를 그냥 싸그리 날리고 다른 애를 다시 할당을 받아서 사용을 하게 될 거예요 그럼 요 아이는 어떻게 되느냐 언젠가는 더 이상 얘를 참조하는 애가 없어가지고 레퍼런스 카운트가 0이 되면은 아까 우리가 연결해준 요 푸쉬 글로벌로 들어오게 되면서 다시 존재가 잊혀질 때쯤 다시 요 풀에 들어오게 될 겁니다 그런 식으로 계속 재사용을 지금 하고 있는 거예요 그래가지고 다 썼으면 이제 버리고 새거로 교체하는 코드가 이제 여기서 들어가게 될건데 엘 샌드 버퍼 청크에 나중에 만들 프리 사이즈를 체크해가지고 여유 공간이 있는지를 체크하는데 그 여유 공간이 우리가 당장 할당해야 되는 요 사이즈보다 작다라고 하면은 더이상 자리가 없다는 얘기니까 그러면은 팝을 해가지고 다른 애로 교체를 해주게 될 겁니다. 다시 팝을 해가지고 요 코드가 실행되면서 여유분을 다시 한번 꺼내가지고 사용하지 않는 애를 하나 꺼내서 사용을 하겠다라는 얘기가 되는 거죠. 물론 역시나 여유분이 없으면 다시 만든다는 것도 이제 똑같습니다. 그 다음에 여기서 뭐 새로 만들었으면 , 자, 이런 식으로 리셋 한번을 시켜줘가지고 초기화 코드를 한번 실행을 해줄게요. 참고로 이거는 여기서도 들어가긴 해야되겠네요. , 자, 여기랑 여기랑 이 코드는 아직 뭐 어떤 의미인지 완벽하게 이해는 안가지만 이런식으로 처음, 그러니까 한번 초기화를 해줄것이고 그 다음에 여기까지 넘어왔다고 하면 결국에는 뭐 어떤 코드로 간에 내가 필요한 그런 버퍼 청크가 준비됐다고 가정을 할 수 있으니까 lsandbuffer.chunk에다가 open을 실행해가지고 내가 원하는 크기만큼을 이제 뜯었을 준비를 해주게 될 겁니다. 요런 느낌으로 이제 코드가 진행이 될 거예요. , 자, 근데 지금 여기까지만 보면은 아직 뭐 이게 정확히 어떻게 돌아가는지 이해가 잘 안 가실 테니까 바로 이어가지고 요 sandbuffer.chunk란 애도 이어서 만들어 보도록 할게요. 순서를 뭐부터 하는 게 좀 좋을지 모르겠는데 뭐 일단 , 이렇게, 해보도록 하겠습니다 , 자, 그 다음에 여기서 얘 같은 경우에 이제 enable shared from this를 , 일단은, 상속을 받을 거고요 레퍼런스 컨팅 관리를 해서 shared from this를 사용하기 때문이죠 아 그리고 참고로 제가 뭐 보다 보니까 느꼈는데 여기서 제가 까먹고 public을 누락을 했는데 이러면은 안 됩니다 public을 누락을 하게 되면은 실질적으로 shared from this를 할 때 에러가 나게 될 거에요 왜냐면 이걸 이제 퍼블릭으로 하지 않으면은 처음에 자신의 위급 포인터를 채워주는 부분이 실행이 되지 않기 때문에 원래 , 이렇게, 하면 안되고 항상 퍼블릭을 , 이렇게, 붙여주셔야 됩니다 근데 뭐 지금 당장은 샌드버퍼에서는 필요가 없기 때문에 잠시 날려주도록 하고 이 샌드버퍼 청크부터 일단 작업을 해주도록 할게요 , 자, 먼저 인원값으로 이 샌드버퍼 청크에 샌드버퍼 chunk 사이즈라고 해가지고 얘를 일단 하나를 , 이렇게, 일단은, 정리를 해놓도록 하겠습니다 이건 나중에 우리가 숫자를 바꿔줄거지만 기본적으로는 그냥 간단하게 아무 값이나 , 이렇게, 입력을 하고 이게 좀 큰 덩어리의 공간이라고 , 일단은, 가정을 해보도록 할게요 , 자, 그 다음에 생성자 그리고 소멸자도 만들어주고 샌드버퍼 chunk , 자, 그 다음에 reset 이라는 함수 아까 있었죠 그리고 샌드버퍼래프를 뱉어주는 open 이라는 함수를 먼저 만들어 주도록 하겠습니다 allocation size 얼마만큼 할당이 필요한가 그 다음에 클로즈 함수도 만들어 줄 것이고 얘가 실질적으로 우리가 사용한 크기를 요렇게 뱉어 주도록 할 거에요 , 이렇게, 닫아준, 열어준 다음에 닫아주는데 열어줄 때는 할당할 공간을 먼저 입력을 해주고 실질적으로 사용한 공간을 클로즈에 건네주게 될 겁니다 그 다음에 오픈 여부를 확인하는 함수를 만들어 줄 것이고 멤버면서부터 미리 만들어 보자면 , 일단은, open, false, gap 그 다음에 지금까지 사용한 Used Size라고 해가지고 내가 할당한 이 공간 중에서 얼마만큼을 지금 사용했느냐를 계속 추적을 해줄 겁니다. 그 다음에 마지막으로 정보 자체를 데이터를 Vector라거나 아니면 Array라거나 하는 식으로 들고 있으면 되는데 이번에는 그냥 Array로 , 이렇게, 일단 들고 있어 보도록 할게요. Byte에다가 SandBufferChunkSize만큼의 배열을 하나를 , 이렇게, 할당을 해주도록 하겠습니다. 네, 우리가 벡터까지는 만들어 놨는데 여기 컨테이너 쪽 가보면은 어레이는 아직 안 만들어 놓은 것 같네요. 이것도 겸사겸사 추가를 해주도록 하겠습니다. 어레이를 추가를 해주고 그 다음에 맨 앞에다가 template.typename.type.uint32.size라고 해가지고 usingArray는 array.type.size를 각각 , 이렇게, 입력을 해주도록 할게요. 그럼 이제 Array를 사용할 준비가 끝났고 뭐 이걸 벡터로 해도 상관없습니다. 그냥 이번에는 왠지 그냥 고정 크기인 어레이를 사용하고 싶어서 , 이렇게, 일단은, 만들어 봤고요. , 자, 그 다음에 다시 샌드버퍼로 돌아와가지고 줄을 좀 맞춰주도록 할게요. 얘네들을 좀 당겨가지고. buffer-open-used-size 일단 3개가 , 이렇게, 들어가게 됩니다. 그래서 isopen은 그냥 내가 오픈 여부인지 지금 사용 중인지 누군가가 나를 열어가지고 데이터를 기입하고 있는지만 추적을 할 것이고요. 혹시라도 오픈을 하고 클로즈를 하지 않았다거나 하는 그런 상황을 예방하기 위해서 , 일단은, 간단하게 얘를 추가한 겁니다. 그 다음에 실질적으로 buffer 이게 굉장히 중요한데 내가 사용하는 그 buffer 포인터를 달라 이거죠. 어마어마하게 큰 공간이 있는데 내가 지금까지 여기까지는 사용했다는 걸 Used Size로 추정할 것이고 그렇다는 것은 내가 다음으로 사용할 공간은 이 Cursor 위치가 가리키고 있는 이 위치죠. 그렇기 때문에 걔를 어떻게 뱉어줄 거냐면은 그냥 간단하게 이런 식으로 Used Size에 접근을 해가지고 그 주소를 일단 뱉어주도록 하겠습니다. 여기까지 사용했으니까 그 다음부터 사용하세요라고 그 주소를 , 이렇게, Buffer라는 거로 뱉어주도록 할 것이고 그 다음에 Free Size 지금 여유 공간이 얼마인가에서는 버퍼의 사이즈에서 Used Size만큼을 , 이렇게, 빼준거를 리턴을 해주면 되겠죠 근데 에러가 날 수 있으니까 스테이지 캐스트를 해줘가지고 뭐 유닛 32로 , 일단은, 간단하게 캐스팅을 해서 혹시라도 뭐 경고창이 뜨는걸 예방을 해주도록 합시다 , 자, 이렇게, 해가지고 뭐 이 버퍼의 크기에서 내가 사용한 거를 뺀 게 여유분이다 라는 지금 얘기를 하고 있는 겁니다 그래서 , 이렇게, 프리사이즈까지 만들어 줬고 뭐 여기까지 , 일단은, 만들어 놨으면 대충 필요한 기능은 다 있으니까 , 자, 하나씩 , 일단은, 생성자 그 다음에 소멸자 그리고 리셋 그 다음에 오픈 클로즈까지 다 , 일단은, 만들어 주도록 할게요 , 이렇게, 만들어주고 하는김에 좀 정렬도 해보도록 합시다 저는 , 일단은, 회사에서는 정렬을 잘 안하는 편인데 개인으로 프로젝트 할 때는 왠지 좀 정리를 하곤 합니다 좀 모순적이긴 한데 , 자, 그래가지고 뭐 , 이렇게, 일단은, 만들어 볼 것이고 , 자, 우리가 만드는 샌드 버퍼 청크가 좀 아래쪽에 만들어졌네요 이게 좀 마음에 안드니까 다시 복붙 해가지고 이쪽 영역에다가 다시 한번 , 이렇게, 집어넣고 작업을 시작을 해보도록 할게요 , 자, 여기까지 일단 생성전 소멸자에서는 뭐 딱히 뭐 뭐 하진 않을 거고 나중에 브레이크 포인트를 잡는 용도로만 활용할 것이고 리셋을 할 때는 open은 false로 다시 리셋하고 used size를 0으로 다시 초기화를 해줄 겁니다 , 사실, 요 부분이 중요한 거예요 어, 지금까지 기존에 사용하던 애가 이거를 막 이리저리 더럽혔을 수도 있으니까 만약에 리셋을 한다고 하면은 요 유즈드 사이즈를 0으로 시작해가지고 다시 여기부터 처음부터 쓰겠다라는 얘기를 하고 있는 겁니다 그 다음에 오픈을 할 때는 어, 말 그대로 지금 내가 어디까지 사용을 했을 텐데 그 다음부터 여기 어딘가까지를 할당을 하겠다라는 게 이제 오픈의 개념이구요 그렇기 때문에 뭐 , 일단은, 체크를 몇 개를 해보도록 합시다 이 얼록 사이즈가 진짜 충분한 이게 말이 되는건지 이 버퍼 크기보다 더 많은 공간을 할당해달라고 하는거는 , 사실, 말이 안되니까 , 이렇게, 일단은, 어서트 크래쉬를 한번 때리고 그 다음에 이중으로 오픈을 하지 않도록 오픈 체크를 한번 더 해주도록 할게요 참고로 우리가 지금 샌드버퍼 매니저에서 이런 식으로 TLS를 사용해가지고 버퍼 청크를 끄집어온 다음에 사용을 하고 있기 때문에 사실상 이 샌드버퍼 청크에 있는 코드들은 다 멀티스레드 환경이 아니라 싱글스레드 환경에서 동작을 한다고 가정을 하고 만들어도 됩니다 굳이 락을 걸 필요가 없다는 얘기가 되는 거죠 어차피 TLS 영역에서 지금 실행이 되는 것이기 때문에 , 자, 그래가지고 여기서 , 일단은, 두 번 체크를 해줬고 만약에 얼룩 사이즈가 여유분, 프리사이즈보다 크다라고 하면은 뭔가가 문제있는 상황이니까 널 PTR로 그냥 없다고 뱉어줄 것이고 그게 아니라고 하면은 오픈을 트롤로 해가지고 이제 지금 이 버퍼를 까먹는 준비를, 그니까 열어가지고 사용을 하겠다라고 하는거죠 그래가지고 여기서 이제 샌드버퍼를 만들어주면 되는데 뭐, 오브젝트 풀을 이왕이면 사용을 해보도록 합시다 이런식으로 샌드버퍼에 메이크쉐어드를 해가지고 이제 이 샌드 버퍼를 뜯어가지고 샌드 버퍼 포인터로 뱉어주게 될 거에요. 스마트 포인터로. 근데 여기서 먼저 Shared from this를 먼저 전달을 해줄 거고요. 이것도 아직 안 만들어졌는데 자기 자신과 버퍼 그리고 Allocation Size를 각각 전달을 해주면서 , 이렇게, 일단은, 만들어주게 될 겁니다. 이런 식으로 내 자신과 버퍼와 allocation size 그래서 이게 무슨 말이냐면 결국에는 이제 최종적으로 샌드버퍼 chunk를 잘라가지고 사용을 하는게 이 샌드버퍼의 역할인데 샌드버퍼 chunk가 이정도 활당이 되어있었고 어느정도 공간을 찝어줄거에요 여기서 여기까지 사용해도 돼 그러면 그거를 다시 우리가 샌드버퍼로 관리를 해주게 될겁니다 요 영역에서 여기까지를 사용하는 것을 샌드버퍼라고 하는 거죠 그런데 요 샌드 버퍼 청크라는 애가 누군가가 이 영역을 사용하고 있을 때까지는 절대로 이 영역이 삭제가 되면 안되겠죠 샌드 버퍼 청크를 날리면 안되기 때문에 얘도 내부적으로 레퍼런스 카운팅을 해주긴 해야됩니다 그래가지고 결국에는 요만큼 잘라가지고 누군가가 사용할 것이고 또 나머지를 요만큼 사용해서 사용할 것이고 이런식으로 각자 자기 영역을 쪼개가지고 사용을 할텐데 그 애들을 레퍼런스 카운팅을 하기 위해서 샌드 버퍼가 자신을 포함하고 있는 이 샌드 버퍼 청크를 알아야 된다는 얘기가 되는 거죠 , 자, 이게 말로 하니까 너무 어려운데 그래서 결론적으로 어떻게 하느냐 이 샌드 버퍼라는 애에서는 이제 얘가 직접적으로 , 이렇게, 영역을 만들어가지고 관리를 해주지 않고 그냥 포인터만 덩그러니 들고 있을 겁니다 이게 이제 달라지는 부분이에요 요런 식으로 , 자, 그 다음에 얼록 사이즈 그리고 라이트 사이즈는 똑같이 있는데 , 일단은, 다 통일해서 유인트32로 만들어 주도록 하겠습니다. 그 다음에 중요한게 Shared Pointer로 Sandbuffer Chunk , 사실, Sandbuffer Chunk를 F로 들고 있어도 똑같죠. 자신의 Owner가 누구인지를 , 이렇게, 들고 있을겁니다. , 자, 요런 느낌으로 그래서 결국에는 이 샌드버퍼라는 애가 어떤 메모리 공간을 똑같이 가리키고 있는 형태인데 그 메모리 공간을 제공한 owner는 누구이냐를 따로 , 이렇게, 멤버명수 들고 있어가지고 레퍼런스 카운팅을 유지를 시켜준다는 얘기가 되는거죠 내가 참조할 때까지는 너는 절대로 사라지면 안되니까 그렇게 해가지고 요렇게 해가지고 , 일단은, 얘도 레퍼런스 카운팅을 들어간다 라고 볼 수가 있겠구요 , 자, 그 다음에 요기서 이제 버퍼라는 애는 버퍼의 데이터가 아니라 이제는 그냥 포인터 형태로만 들고 있으니까 얘를 그대로 뱉어주면 되구요 라이트 사이즈는 얘를 그대로 뱉어주면 되고 캐페시티는 더 이상 활용하지 않을 거고 얘는 삭제하고 , 자, 카피 데이터도 삭제를 해주고 그냥 클로즈를 하고 요렇게 , 일단은, 요 함수만 만들어 주도록 할게요 그리고 여기 인자에서는 샌드 버퍼 chunk를 첫 인자로 받아줘서 owner가 누구인지를 채워줄 것이고 그 다음에 이 버퍼의 시작 주소는 어딘지를 또 요렇게 전달을 받고 마지막은 Allocation Size라고 할게요 버퍼 사이즈라고 하면 실질적으로 우리가 사용하고 있는 공간으로 오해할 수 있으니까 Allocation Size라고 하고 실제로 우리가 사용하는 데이터 공간을 Right Size라고 그냥 이 이름을 그대로 사용하도록 할게요 그래서 버퍼랑 Right Size랑 Close , 이렇게, 삼총사가 , 일단은, 들어간다고 보시면 되겠습니다 그래서 이 부분을 복붙해가지고 여기다가 , 일단은, 채워준 다음에 생성자를 다시 만들어주게 될 것인데 요 부분은 일단 날라가구요 , 자, 그 다음에 요기서 Owner는 그대로 멤버 면수로 들고 있을 것이고 Buffer도 그대로 전달을 받았고 Allocation Size도 각각 그냥 전달을 받아서 그냥 저장을 해주도록 하겠습니다. 그럼 , 이렇게, 되면은 이제는 내가 나의 Owner는 누구인지를 , 이렇게, 들고있게 되니까 이 포인터 주소가 내가 살아있을 때까지는 무조건 유효한다는 걸 보장할 수 있는 거죠. 그게 , 일단은, 쉐도우 포인트의 장점이라고 볼 수 있겠습니다. 근데 여기 순서가 샌드 버퍼 아래 지금 샌드 버퍼 청크가 등장하기 때문에 여기서 전방선언을 한 번 해주도록 하겠습니다. 샌드 버퍼 청크를 , 이렇게, 전방선언 한 번을 해주도록 할게요. , 자, 그 다음에 Copy Data는 원래는 원래 용도는 이런식으로 맴 카피를 해주고 라이트 렌스를 채워주고 하는 부분이었는데 이제 맴 카피는 외부에서 그냥 직접 이 버퍼를 꺼내 가지고 하도록 하고 얘가 해줄 거는 일단 이 Capacity가 사실상 이 Allocation Size죠 얘는 일단 , 이렇게, 교체를 해줄 것이고 그 다음에 이 함수가 close로 대체가 되어야 되겠죠 내가 지금 열어가지고 사용한 이 chunk를 다 사용했으니까 이 중에서 일부만 사용하겠다라고 내가 확정을 시켜주는 거죠 그래서 close라고 해가지고 write size를 , 이렇게, 건네받으면 write size를 저장해준 다음에 그럼 얘도 write size로 바꿔치게 돼가고 그 다음에 owner의 close를 , 이렇게, 호출해주게 될 겁니다 , 자, 요렇게 , 일단은, Owner의 Close를 호출해주게 되면은 내가 , 일단은, 까서 열심히 열심히 사용을 한 다음에 그 다음에 Open한 영역에서 내가 일부만을 사용했다고 지금 확정을 준 셈이 되는 거니까 이제 이 Close를 이어서 작업을 하면 되겠죠 , 자, 마침 이 부분을 안 했으니까 이어서 좀 해보자면 먼저 Assert Crash를 체크해가지고 Open이 True인지를 확인하도록 할게요 혹시라도 Open을 안 했는데 먼저 Close하는 건 말이 안 되는 겁니다 먼저 사용하려면은 Open을 먼저 해야 돼요 그러니까 클로즈를 했으면 체크를 하고 Open을 First로 키운 다음에 Used Size를 , 이렇게, Right Size만큼을 증가시켜 주도록 할 거예요 그럼 이게 결국에는 , 이렇게, 되는 거죠 큰 영역을 할당을 받은 다음에 이런 식으로 이 매니저를 통해 가지고 Open을 해가지고 내가 원하는 Allocation Size를 할당을 받아서 요 영역까지 , 일단은, 내가 작업을 하겠다라고 해서 신나게 작업을 하다가 아 이 중에서 이만큼만 쓸래 라고 했으면은 이제 Close 함수를 빵 때리게 되면은 걔가 요 부분으로 들어와 가지고 결국에 자신의 Owner의 Close를 같이 , 이렇게, 호출해 주게 될 거니까 그제서야 이 Sandbuffer Chunk 입장에서는 아 얘가 이만큼을 썼구나라는 걸 인지해 가지고 지금까지 사용했던 Used Size라는 Cursor가 , 이렇게, 깜빡깜빡거리고 있는 걸 이제 앞으로 당겨주는 게 되는 거죠 그럼 이 다음 턴에서는 이제부터는 요 부분부터 사용을 하게 될 겁니다 이런 식으로 Open Close 그 다음에 Cursor 옮기고 Open Close Cursor 옮기고 이런식으로 가다가 결국에는 자리가 부족해가지고 다 사용했다고 하면은 배터리처럼 그냥 교체를 해버리고 얘는 그냥 버려버리고 얘를 이제 버려버린다는 것 자체가 결국 이 의미죠 지금 여기서 보면은 사용을 하려고 하는데 다 썼으면 버리고 새거로 교체하는 겁니다. 그럼 새거로 교체했으면 이전에 있던 애는 이제 어떻게 되는 것인가 굉장히 궁금한데 이미 레퍼런스 카운팅이 다 이리저리 걸려있는 상태일 겁니다. 우리가 Session에서 여기서 SSand를 걸어줄 때 이 Sand Buffer라는 애를 이 샌드 버퍼라는 애들을 , 이렇게, 물려 있게끔 우리가 다 유도를 해주고 있었죠 이 샌드 이벤트에 지금 물고 있게끔 해주기 때문에 얘가 이 샌드 버퍼를 지금 가리키고 있는 상태이기 때문에 샌드가 완료가 되지 않으면은 이전에 보냈던 데이터들이 날아가지 않고 계속 유지가 되다가 어느 순간에 샌드도 다 완료되고 더 이상 소모가 될 필요가 없다고 하면은 얘가 알아서 레퍼런스 카운팅이 0이 되면서 결국에는 0이 되다보면 아까 이 Push Global로 들어오게 되가지고 다시 자동 반납이 된다고 보시면 되겠습니다 이 부분이 조금 이해하기가 어려울 수도 있는데 코드를 뭐 찬찬히 보시면 될 것 같고요 , 이렇게, 해가지고 샌드버퍼를 풀링하는 식으로 살짝 수정을 해봤어요 , 이렇게, 일단 만들어보고 , 일단은, 서버 코어를 빌드해가지고 제가 누락한 부분이 없는지를 간단하게 , 일단은, 체크를 해보도록 하겠습니다. 지금 한가지 문제가 있는데 여기 랩프가 빠져서 그런거네요. 스마트 포인터로 받아줘야 되니까 랩프를 , 이렇게, 받아주도록 할게요. , 자, 그 다음에 빌드를 해서 , 일단은, 오케이 통과시켰고요. 그러면은 이제 위에 얘를 사용하는 걸 이제 어떻게 해야 될지를 살펴보면은 게임 서버에서 어... 아 게임 세션에서 우리가 원래 사용하던 부분을 고쳐주면 되겠죠? 원래 , 이렇게, 사용하던 게 이제는 어떻게 되는 거냐면은 G Sandbuffer 매니저를 통해 가지고 오픈을 먼저 해가지고 우리가 원하는 만큼을 , 일단은, 오픈을 시켜준 다음에 그 다음에 데이터를 여기다가 이제 맴커피를 통해서 직접적으로 우리가 넣어주게 될 겁니다. Sandbuffer에 버퍼 조소는 어디이냐 그 다음에 내가 원래 사용하던 데이터를 여기다가 복붙 해준 다음에 다 썼으면은 그제서야 샌드 버퍼를 클로즈 해준다 라고 해주는 거죠 그리고 여기서 클로즈 할 때는 내가 사용한 용량을 다시 , 이렇게, 기입을 해가지고 뚜껑을 닫아주는 겁니다 열어주고 닫아주고 이런 식으로 버퍼를 만들어 준 다음에 기존과 마찬가지로 어 브로드 캐스팅을 한다거나 아니면은 뭐 샌드를 한다거나 할 때는 요 샌드 버퍼 자체를 그대로 넘겨준다 라고 보시면 되겠어요 , 자, 요렇게 , 일단은, 빌드 통과를 시켜주고 마찬가지로 더미 클라이언트도 얘도 어딘가에서 지금 활용하고 있는 부분이 있을텐데 걔를 이제 똑같이 고쳐주면 되겠습니다 , 자, 이거를 , 일단은, 복붙 해가지고 위쪽에다가 Connected to Server 바로 아래다가 , 이렇게, 복붙을 한 다음에 send data랑 size of send data로 얘를 바꿔치기 해주도록 할게요 , 자, 이런식으로 size of send data 아래도 그 다음에 복붙 해가지고 이쪽 아래에서도 똑같이 요렇게 만들어 보도록 하겠습니다 그래서 빌드를 하면은 , 일단은, 아무런 문제 없이 , 이렇게, 통과가 되겠죠 , 자, 그러면 이제는 아까와는 조금 다르게 4096 사이즈만큼을 오픈을 하려고 할 때 이 버퍼에다가 우리가 , 사실, 요 부분이 좀 중요한데 버퍼 사이즈를 얼마로 할지가 살짝 중요하긴 하죠 이게 지금 몇 사이즈로 되는데 지금은 하필이면 딱 똑같은 크기를 되어 있으니까 얘를 그냥 잠시 뭐 한 6000 정도로 , 일단은, 버퍼 사이즈를 조금 늘려 주도록 할게요 나중에 가면 엄청 큰 값이 될 겁니다 , 자, 그 다음에 지금 사용하고 있는 공간이 야금야금 잘 소모가 되고 있는지가 굉장히 궁금하니까 여기 샌드버퍼에다가 오픈을 할 때 로그를 찍어 주도록 합시다 여기서 잠시 cout을 통해 가지고 현재 프리 영역은 얼마인지를 찍어 주도록 할게요 lsandbuffer chunk에서 free size를 잠시 로그로 찍어 보도록 하겠습니다 , 이렇게, 해서 다시 빌드를 한 다음에 실행을 해보면 , 사실, 기능상으로는 아까랑 지난번이랑 별다른 차이가 없이 정상적으로 실행이 된다는 걸 일단 확인할 수가 있을 것이고요 그래서 이런 식으로 정상적으로 잘 활용하고 있고 프리사이즈 로그를 유심히 보면 야금야금 조금씩 줄어든다는 걸 볼 수가 있습니다 이게 지금 스레드가 여러 개가 동작하면 이게 약간 늘어나는 것처럼 보일 수 있는데 그건 아니고 그냥 여러 개가 지금 사용하면서 전체적으로 자기만의 버퍼 청크를 사용하고 있다고 볼 수가 있는 거죠 그래서 여기서 유심히 봐야 될 부분은 뭐냐면 결국에는 우리가 샌드 버퍼라는 애를 실시간으로 메모리를 할당을 받아서 사용하는 건 아니고 큰 덩어리인 샌드 버퍼 청크를 한 번만 할당해준 다음에 거기서 우리가 샌드 버퍼라는 애로 쪼개서 사용한다는 게 가장 핵심적인 부분이고요 그 다음에 실질적으로 샌드가 다 완료가 되었으면 이런 식으로 샌드 버퍼 소멸자가 호출이 되면서 얘가 소멸이 되면은 자신의 오너도 여기서 레퍼런스 카운트를 들고 있던 걸 하나를 내려놓게 되겠죠. 그러다 보니까 이런 식으로 샌드 버퍼 청크에 레퍼런스 카운트도 언젠가는 다 사용하게 되면 0이 될 겁니다. 그래가지고 결국에는 요 부분을 이제 진짜 잘 이해하셔야 되는데 내가 더 이상 사용하지 않는 애였다고 하면은 버리고 새거로 교체를 하게 될 것이고 여기서 바꿔치기가 되겠죠 그럼 바꿔치기가 됐으면은 이전에 있던 애는 레퍼런스 카운트가 샌드를 걸린 애들만큼 유지가 되다가 언젠가는 0이 되면서 0이 되었다고 하면은 다시 어... 우리가 요 소멸할 때 요 함수를 호출하려고 했으니까 레퍼런스 카운트가 0이 될 때는 푸쉬 글로벌로 들어와가지고 어떻게 된다? 요기 푸쉬로 다시 들어와서 얌전히 다시 버퍼 청크 풀에 들어가게 된다는 얘기가 되는 거죠 그래서 이 흐름이 굉장히 재미있는 흐름인데 다 사용을 하다가 다 사용했으면 날라가고 날라가다가 레퍼런스 카운팅이 0이 됐으면 다시 풀에 들어간다라고 볼 수가 있는 거죠 그래서 결국에는 사실은 요 공간 자체를 어마어마하게 크게 해도 딱히 상관이 없는 게 처음에 할당할 때 한 번만 할당이 될 것이고 그 다음부터는 메모리 개입이 없지 우리가 계속 무한정으로 재사용을 하게 된다는 그런 엄청난 장점이 생기게 될 겁니다 그래서 실질적으로 이런식으로 언젠가는 프리사이즈가 다 고괄이 되어서 내가 할당받으려는 크기보다 작아지게 되면 그제서야 이 샌드 버퍼 청크를 버리고 교체를 하게 될 것이라는 얘기가 되는거죠 , 이렇게, 해서 간단하게 샌드 버퍼 풀링을 하는 방식으로 수정을 해봤는데 잘 이해가 가실지는 모르겠지만 제가 개인적으로 생각할 때는 굉장히 단순하면서도 좋은 방법이라고 생각합니다 그리고 이런식으로 TLS 영역을 최대한 활용해가지고 락의 경합을 없앤다는 것도 굉장히 중요하죠. 왜냐면 , 사실, 우리가 MMO 기준으로 패킷을 주고받는 그런 샌들을 우리가 사용할 일이 굉장히 많을텐데 그때마다 락을 걸어가지고 경합해서 꺼내오는 것도 약간 뭐 마음이 찝찝할 수 밖에 없습니다 근데 이런 식으로 TLS 영역을 사용하게 되면은 남들이랑 경합을 하지 않고 어지간해서는 이제 이 Thread Buffer Chunk를 교체를 하는 이 팝이 실행되기 이전까지는 그냥 싱글스레드인 것 마냥 락을 걸지 않고 그냥 그대로 모든 코드가 잘 안전하게 실행이 된다는 장점이 생기게 되는 거죠 , 자, 이렇게, 가지고 굉장히 좀 반복해서 말씀을 드리는 건 이게 처음에 이해할 땐 좀 제 기준으로는 좀 어렵기 때문에 반복해서 말씀을 드린 거고 요런 기법도 있다는 걸 참고해서 한번 알아주시면 되겠습니다.